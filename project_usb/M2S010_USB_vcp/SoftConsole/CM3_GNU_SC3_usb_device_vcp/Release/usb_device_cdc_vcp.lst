
usb_device_cdc_vcp:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  00000000  00000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000330  00000190  00000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00008ab0  000004c0  000004c0  000084c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         000005d0  20000000  00008f70  00018000  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000006a0  200005d0  00009540  000185d0  2**4
                  ALLOC
  5 .heap         0000e390  20000c70  00009540  00018c70  2**4
                  ALLOC
  6 .stack        00001000  2000f000  00009540  0001f000  2**4
                  ALLOC
  7 .comment      00000408  00000000  00000000  000185d0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000280  00000000  00000000  000189d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00001de8  00000000  00000000  00018c58  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00017916  00000000  00000000  0001aa40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000032a5  00000000  00000000  00032356  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00006849  00000000  00000000  000355fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001d64  00000000  00000000  0003be44  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000716d  00000000  00000000  0003dba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00007785  00000000  00000000  00044d15  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 000cca2d  00000000  00000000  0004c49a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  00118ec7  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00002a18  00000000  00000000  00118eec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .vector_table:

00000000 <__vector_table_start>:
   0:	20010000 	.word	0x20010000
   4:	00000191 	.word	0x00000191
   8:	0000037f 	.word	0x0000037f
   c:	00000381 	.word	0x00000381
  10:	00000383 	.word	0x00000383
  14:	00000385 	.word	0x00000385
  18:	00000387 	.word	0x00000387
	...
  2c:	00000389 	.word	0x00000389
  30:	0000038b 	.word	0x0000038b
  34:	00000000 	.word	0x00000000
  38:	0000038d 	.word	0x0000038d
  3c:	0000038f 	.word	0x0000038f
  40:	00000391 	.word	0x00000391
  44:	00000393 	.word	0x00000393
  48:	00000395 	.word	0x00000395
  4c:	00000397 	.word	0x00000397
  50:	00000399 	.word	0x00000399
  54:	0000039b 	.word	0x0000039b
  58:	0000039d 	.word	0x0000039d
  5c:	0000039f 	.word	0x0000039f
  60:	000003a1 	.word	0x000003a1
  64:	000003a3 	.word	0x000003a3
  68:	00005141 	.word	0x00005141
  6c:	00005121 	.word	0x00005121
  70:	000003a9 	.word	0x000003a9
  74:	000003ab 	.word	0x000003ab
  78:	000003ad 	.word	0x000003ad
  7c:	000003af 	.word	0x000003af
  80:	000003b1 	.word	0x000003b1
  84:	000003b3 	.word	0x000003b3
  88:	000003b5 	.word	0x000003b5
  8c:	00005b5d 	.word	0x00005b5d
  90:	0000099d 	.word	0x0000099d
  94:	00000d35 	.word	0x00000d35
  98:	000003bd 	.word	0x000003bd
  9c:	000003bf 	.word	0x000003bf
  a0:	000003c1 	.word	0x000003c1
  a4:	000003c3 	.word	0x000003c3
  a8:	000003c5 	.word	0x000003c5
  ac:	000085e9 	.word	0x000085e9
  b0:	0000870d 	.word	0x0000870d
  b4:	000003cb 	.word	0x000003cb
  b8:	000003cd 	.word	0x000003cd
  bc:	000003cf 	.word	0x000003cf
  c0:	000003d1 	.word	0x000003d1
  c4:	000003d3 	.word	0x000003d3
  c8:	000003d5 	.word	0x000003d5
  cc:	000003d7 	.word	0x000003d7
  d0:	000003d9 	.word	0x000003d9
  d4:	000003db 	.word	0x000003db
  d8:	000003dd 	.word	0x000003dd
  dc:	000003df 	.word	0x000003df
  e0:	000003e1 	.word	0x000003e1
  e4:	000003e3 	.word	0x000003e3
  e8:	000003e5 	.word	0x000003e5
  ec:	000003e7 	.word	0x000003e7
  f0:	000003e9 	.word	0x000003e9
  f4:	000003eb 	.word	0x000003eb
  f8:	000003ed 	.word	0x000003ed
  fc:	000003ef 	.word	0x000003ef
 100:	000003f1 	.word	0x000003f1
 104:	000003f3 	.word	0x000003f3
 108:	000003f5 	.word	0x000003f5
 10c:	000003f7 	.word	0x000003f7
 110:	000003f9 	.word	0x000003f9
 114:	000003fb 	.word	0x000003fb
 118:	000003fd 	.word	0x000003fd
 11c:	000003ff 	.word	0x000003ff
 120:	00000401 	.word	0x00000401
 124:	00000403 	.word	0x00000403
 128:	00000405 	.word	0x00000405
 12c:	00000407 	.word	0x00000407
 130:	00000409 	.word	0x00000409
 134:	0000040b 	.word	0x0000040b
 138:	0000040d 	.word	0x0000040d
 13c:	0000040f 	.word	0x0000040f
 140:	00000411 	.word	0x00000411
 144:	00000413 	.word	0x00000413
 148:	00000415 	.word	0x00000415
 14c:	00000417 	.word	0x00000417
 150:	00000419 	.word	0x00000419
 154:	0000041b 	.word	0x0000041b
 158:	0000041d 	.word	0x0000041d
 15c:	0000041f 	.word	0x0000041f
 160:	00000421 	.word	0x00000421
 164:	00000423 	.word	0x00000423
 168:	00000425 	.word	0x00000425
 16c:	00000427 	.word	0x00000427
 170:	00000429 	.word	0x00000429
 174:	0000042b 	.word	0x0000042b
 178:	0000042d 	.word	0x0000042d
 17c:	0000042f 	.word	0x0000042f
 180:	00000431 	.word	0x00000431
 184:	00000433 	.word	0x00000433
	...

Disassembly of section .boot_code:

00000190 <Reset_Handler>:
 190:	f04f 0b00 	mov.w	fp, #0
 194:	f8df 02be 	ldr.w	r0, [pc, #702]	; 456 <SF2_MDDR_MODE_CR>
 198:	6800      	ldr	r0, [r0, #0]
 19a:	f8df 12b6 	ldr.w	r1, [pc, #694]	; 452 <SF2_EDAC_CR>
 19e:	6809      	ldr	r1, [r1, #0]
 1a0:	f001 0103 	and.w	r1, r1, #3
 1a4:	f000 001c 	and.w	r0, r0, #28
 1a8:	2814      	cmp	r0, #20
 1aa:	d101      	bne.n	1b0 <check_esram_edac>
 1ac:	f04b 0b02 	orr.w	fp, fp, #2

000001b0 <check_esram_edac>:
 1b0:	2900      	cmp	r1, #0
 1b2:	d001      	beq.n	1b8 <check_stack_init>
 1b4:	f04b 0b01 	orr.w	fp, fp, #1

000001b8 <check_stack_init>:
 1b8:	f1bb 0f00 	cmp.w	fp, #0
 1bc:	d005      	beq.n	1ca <system_init>

000001be <clear_stack>:
 1be:	48a7      	ldr	r0, [pc, #668]	; (45c <SF2_MDDR_MODE_CR+0x6>)
 1c0:	49a7      	ldr	r1, [pc, #668]	; (460 <SF2_MDDR_MODE_CR+0xa>)
 1c2:	f8df 2272 	ldr.w	r2, [pc, #626]	; 436 <RAM_INIT_PATTERN>
 1c6:	f000 f89f 	bl	308 <fill_memory>

000001ca <system_init>:
 1ca:	48a6      	ldr	r0, [pc, #664]	; (464 <SF2_MDDR_MODE_CR+0xe>)
 1cc:	4780      	blx	r0
 1ce:	f00b 0a02 	and.w	sl, fp, #2
 1d2:	f1ba 0f00 	cmp.w	sl, #0
 1d6:	d00c      	beq.n	1f2 <remap_memory>
 1d8:	f8df 026e 	ldr.w	r0, [pc, #622]	; 44a <SF2_DDRB_NB_SIZE>
 1dc:	f8df 126e 	ldr.w	r1, [pc, #622]	; 44e <SF2_DDRB_CR>
 1e0:	6802      	ldr	r2, [r0, #0]
 1e2:	680b      	ldr	r3, [r1, #0]
 1e4:	b40f      	push	{r0, r1, r2, r3}
 1e6:	f04f 0200 	mov.w	r2, #0
 1ea:	f04f 03ff 	mov.w	r3, #255	; 0xff
 1ee:	6002      	str	r2, [r0, #0]
 1f0:	600b      	str	r3, [r1, #0]

000001f2 <remap_memory>:
 1f2:	489d      	ldr	r0, [pc, #628]	; (468 <SF2_MDDR_MODE_CR+0x12>)
 1f4:	4a9d      	ldr	r2, [pc, #628]	; (46c <SF2_MDDR_MODE_CR+0x16>)
 1f6:	4b9e      	ldr	r3, [pc, #632]	; (470 <SF2_MDDR_MODE_CR+0x1a>)
 1f8:	2802      	cmp	r0, #2
 1fa:	d108      	bne.n	20e <check_esram_remap>
 1fc:	f8df 123e 	ldr.w	r1, [pc, #574]	; 43e <SF2_ESRAM_CR>
 200:	600a      	str	r2, [r1, #0]
 202:	f8df 1242 	ldr.w	r1, [pc, #578]	; 446 <SF2_ENVM_REMAP_CR>
 206:	600a      	str	r2, [r1, #0]
 208:	f8df 1236 	ldr.w	r1, [pc, #566]	; 442 <SF2_DDR_CR>
 20c:	600b      	str	r3, [r1, #0]

0000020e <check_esram_remap>:
 20e:	2801      	cmp	r0, #1
 210:	d108      	bne.n	224 <check_mirrored_nvm>
 212:	f8df 122e 	ldr.w	r1, [pc, #558]	; 442 <SF2_DDR_CR>
 216:	600a      	str	r2, [r1, #0]
 218:	f8df 122a 	ldr.w	r1, [pc, #554]	; 446 <SF2_ENVM_REMAP_CR>
 21c:	600a      	str	r2, [r1, #0]
 21e:	f8df 121e 	ldr.w	r1, [pc, #542]	; 43e <SF2_ESRAM_CR>
 222:	600b      	str	r3, [r1, #0]

00000224 <check_mirrored_nvm>:
 224:	4893      	ldr	r0, [pc, #588]	; (474 <SF2_MDDR_MODE_CR+0x1e>)
 226:	2800      	cmp	r0, #0
 228:	d109      	bne.n	23e <copy_data>
 22a:	4893      	ldr	r0, [pc, #588]	; (478 <SF2_MDDR_MODE_CR+0x22>)
 22c:	4993      	ldr	r1, [pc, #588]	; (47c <SF2_MDDR_MODE_CR+0x26>)
 22e:	4a94      	ldr	r2, [pc, #592]	; (480 <SF2_MDDR_MODE_CR+0x2a>)
 230:	f000 f832 	bl	298 <block_copy>

00000234 <copy_text>:
 234:	4893      	ldr	r0, [pc, #588]	; (484 <SF2_MDDR_MODE_CR+0x2e>)
 236:	4994      	ldr	r1, [pc, #592]	; (488 <SF2_MDDR_MODE_CR+0x32>)
 238:	4a94      	ldr	r2, [pc, #592]	; (48c <SF2_MDDR_MODE_CR+0x36>)
 23a:	f000 f82d 	bl	298 <block_copy>

0000023e <copy_data>:
 23e:	4894      	ldr	r0, [pc, #592]	; (490 <SF2_MDDR_MODE_CR+0x3a>)
 240:	4994      	ldr	r1, [pc, #592]	; (494 <SF2_MDDR_MODE_CR+0x3e>)
 242:	4a95      	ldr	r2, [pc, #596]	; (498 <SF2_MDDR_MODE_CR+0x42>)
 244:	f000 f828 	bl	298 <block_copy>

00000248 <clear_bss>:
 248:	4894      	ldr	r0, [pc, #592]	; (49c <SF2_MDDR_MODE_CR+0x46>)
 24a:	4995      	ldr	r1, [pc, #596]	; (4a0 <SF2_MDDR_MODE_CR+0x4a>)
 24c:	f8df 21e6 	ldr.w	r2, [pc, #486]	; 436 <RAM_INIT_PATTERN>
 250:	f000 f85a 	bl	308 <fill_memory>

00000254 <clear_heap>:
 254:	f1bb 0f00 	cmp.w	fp, #0
 258:	d012      	beq.n	280 <call_glob_ctor>
 25a:	4892      	ldr	r0, [pc, #584]	; (4a4 <SF2_MDDR_MODE_CR+0x4e>)
 25c:	4992      	ldr	r1, [pc, #584]	; (4a8 <SF2_MDDR_MODE_CR+0x52>)
 25e:	f8df 21da 	ldr.w	r2, [pc, #474]	; 43a <HEAP_INIT_PATTERN>
 262:	f000 f851 	bl	308 <fill_memory>
 266:	f00b 0a02 	and.w	sl, fp, #2
 26a:	f1ba 0f00 	cmp.w	sl, #0
 26e:	d007      	beq.n	280 <call_glob_ctor>
 270:	bc0f      	pop	{r0, r1, r2, r3}
 272:	6002      	str	r2, [r0, #0]
 274:	600b      	str	r3, [r1, #0]
 276:	bf00      	nop
 278:	f3af 8000 	nop.w
 27c:	f3af 8000 	nop.w

00000280 <call_glob_ctor>:
 280:	f8df 0228 	ldr.w	r0, [pc, #552]	; 4ac <SF2_MDDR_MODE_CR+0x56>
 284:	f20f 0e03 	addw	lr, pc, #3
 288:	4700      	bx	r0

0000028a <branch_to_main>:
 28a:	f04f 0000 	mov.w	r0, #0
 28e:	f04f 0100 	mov.w	r1, #0
 292:	f8df f21c 	ldr.w	pc, [pc, #540]	; 4b0 <SF2_MDDR_MODE_CR+0x5a>

00000296 <ExitLoop>:
 296:	e7fe      	b.n	296 <ExitLoop>

00000298 <block_copy>:
 298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
 29c:	4288      	cmp	r0, r1
 29e:	d025      	beq.n	2ec <block_copy_exit>
 2a0:	ebb2 0201 	subs.w	r2, r2, r1
 2a4:	d500      	bpl.n	2a8 <block_copy_address_ok>
 2a6:	e7fe      	b.n	2a6 <block_copy+0xe>

000002a8 <block_copy_address_ok>:
 2a8:	ea40 0301 	orr.w	r3, r0, r1
 2ac:	f013 0303 	ands.w	r3, r3, #3
 2b0:	d002      	beq.n	2b8 <block_copy_continue>

000002b2 <block_copy_byte_copy>:
 2b2:	f000 f81d 	bl	2f0 <block_copy_byte>
 2b6:	e019      	b.n	2ec <block_copy_exit>

000002b8 <block_copy_continue>:
 2b8:	f04f 0300 	mov.w	r3, #0
 2bc:	4690      	mov	r8, r2
 2be:	1112      	asrs	r2, r2, #4
 2c0:	d0f7      	beq.n	2b2 <block_copy_byte_copy>

000002c2 <block_copy_loop>:
 2c2:	429a      	cmp	r2, r3
 2c4:	bf1c      	itt	ne
 2c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
 2c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
 2ca:	f103 0301 	add.w	r3, r3, #1
 2ce:	d1f8      	bne.n	2c2 <block_copy_loop>
 2d0:	f008 080f 	and.w	r8, r8, #15
 2d4:	f1b8 0f00 	cmp.w	r8, #0
 2d8:	d008      	beq.n	2ec <block_copy_exit>

000002da <copy_spare_bytes>:
 2da:	7804      	ldrb	r4, [r0, #0]
 2dc:	700c      	strb	r4, [r1, #0]
 2de:	f100 0001 	add.w	r0, r0, #1
 2e2:	f101 0101 	add.w	r1, r1, #1
 2e6:	f1b8 0801 	subs.w	r8, r8, #1
 2ea:	d1f6      	bne.n	2da <copy_spare_bytes>

000002ec <block_copy_exit>:
 2ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

000002f0 <block_copy_byte>:
 2f0:	b508      	push	{r3, lr}
 2f2:	f04f 0300 	mov.w	r3, #0

000002f6 <block_copy_byte_loop>:
 2f6:	7803      	ldrb	r3, [r0, #0]
 2f8:	700b      	strb	r3, [r1, #0]
 2fa:	f100 0001 	add.w	r0, r0, #1
 2fe:	f101 0101 	add.w	r1, r1, #1
 302:	3a01      	subs	r2, #1
 304:	d1f7      	bne.n	2f6 <block_copy_byte_loop>
 306:	bd08      	pop	{r3, pc}

00000308 <fill_memory>:
 308:	4288      	cmp	r0, r1
 30a:	d037      	beq.n	37c <fill_memory_exit>
 30c:	f000 0603 	and.w	r6, r0, #3
 310:	2e00      	cmp	r6, #0
 312:	d014      	beq.n	33e <fill_memory_end_start>
 314:	f04f 0504 	mov.w	r5, #4
 318:	eba5 0406 	sub.w	r4, r5, r6
 31c:	f04f 0708 	mov.w	r7, #8
 320:	fb07 f806 	mul.w	r8, r7, r6
 324:	4691      	mov	r9, r2
 326:	fa69 f908 	ror.w	r9, r9, r8

0000032a <fill_memory_spare_bytes_start>:
 32a:	2c00      	cmp	r4, #0
 32c:	d007      	beq.n	33e <fill_memory_end_start>
 32e:	f880 9000 	strb.w	r9, [r0]
 332:	fa69 f907 	ror.w	r9, r9, r7
 336:	f100 0001 	add.w	r0, r0, #1
 33a:	3c01      	subs	r4, #1
 33c:	e7f5      	b.n	32a <fill_memory_spare_bytes_start>

0000033e <fill_memory_end_start>:
 33e:	f04f 0600 	mov.w	r6, #0
 342:	460f      	mov	r7, r1
 344:	1a09      	subs	r1, r1, r0
 346:	4688      	mov	r8, r1
 348:	1109      	asrs	r1, r1, #4
 34a:	4691      	mov	r9, r2
 34c:	4614      	mov	r4, r2
 34e:	4615      	mov	r5, r2
 350:	42b1      	cmp	r1, r6
 352:	d006      	beq.n	362 <fill_memory_spare_bytes_end>

00000354 <fill_memory_loop>:
 354:	bf18      	it	ne
 356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
 35a:	f106 0601 	add.w	r6, r6, #1
 35e:	42b1      	cmp	r1, r6
 360:	d1f8      	bne.n	354 <fill_memory_loop>

00000362 <fill_memory_spare_bytes_end>:
 362:	f008 080f 	and.w	r8, r8, #15

00000366 <fill_memory_spare_end_loop>:
 366:	f1b8 0f00 	cmp.w	r8, #0
 36a:	d007      	beq.n	37c <fill_memory_exit>
 36c:	7002      	strb	r2, [r0, #0]
 36e:	ea4f 2232 	mov.w	r2, r2, ror #8
 372:	f100 0001 	add.w	r0, r0, #1
 376:	f1b8 0801 	subs.w	r8, r8, #1
 37a:	e7f4      	b.n	366 <fill_memory_spare_end_loop>

0000037c <fill_memory_exit>:
 37c:	4770      	bx	lr

0000037e <NMI_Handler>:
 37e:	e7fe      	b.n	37e <NMI_Handler>

00000380 <HardFault_Handler>:
 380:	e7fe      	b.n	380 <HardFault_Handler>

00000382 <MemManage_Handler>:
 382:	e7fe      	b.n	382 <MemManage_Handler>

00000384 <BusFault_Handler>:
 384:	e7fe      	b.n	384 <BusFault_Handler>

00000386 <UsageFault_Handler>:
 386:	e7fe      	b.n	386 <UsageFault_Handler>

00000388 <SVC_Handler>:
 388:	e7fe      	b.n	388 <SVC_Handler>

0000038a <DebugMon_Handler>:
 38a:	e7fe      	b.n	38a <DebugMon_Handler>

0000038c <PendSV_Handler>:
 38c:	e7fe      	b.n	38c <PendSV_Handler>

0000038e <SysTick_Handler>:
 38e:	e7fe      	b.n	38e <SysTick_Handler>

00000390 <WdogWakeup_IRQHandler>:
 390:	e7fe      	b.n	390 <WdogWakeup_IRQHandler>

00000392 <RTC_Wakeup_IRQHandler>:
 392:	e7fe      	b.n	392 <RTC_Wakeup_IRQHandler>

00000394 <SPI0_IRQHandler>:
 394:	e7fe      	b.n	394 <SPI0_IRQHandler>

00000396 <SPI1_IRQHandler>:
 396:	e7fe      	b.n	396 <SPI1_IRQHandler>

00000398 <I2C0_IRQHandler>:
 398:	e7fe      	b.n	398 <I2C0_IRQHandler>

0000039a <I2C0_SMBAlert_IRQHandler>:
 39a:	e7fe      	b.n	39a <I2C0_SMBAlert_IRQHandler>

0000039c <I2C0_SMBus_IRQHandler>:
 39c:	e7fe      	b.n	39c <I2C0_SMBus_IRQHandler>

0000039e <I2C1_IRQHandler>:
 39e:	e7fe      	b.n	39e <I2C1_IRQHandler>

000003a0 <I2C1_SMBAlert_IRQHandler>:
 3a0:	e7fe      	b.n	3a0 <I2C1_SMBAlert_IRQHandler>

000003a2 <I2C1_SMBus_IRQHandler>:
 3a2:	e7fe      	b.n	3a2 <I2C1_SMBus_IRQHandler>
 3a4:	e7fe      	b.n	3a4 <I2C1_SMBus_IRQHandler+0x2>
 3a6:	e7fe      	b.n	3a6 <I2C1_SMBus_IRQHandler+0x4>

000003a8 <EthernetMAC_IRQHandler>:
 3a8:	e7fe      	b.n	3a8 <EthernetMAC_IRQHandler>

000003aa <DMA_IRQHandler>:
 3aa:	e7fe      	b.n	3aa <DMA_IRQHandler>

000003ac <Timer1_IRQHandler>:
 3ac:	e7fe      	b.n	3ac <Timer1_IRQHandler>

000003ae <Timer2_IRQHandler>:
 3ae:	e7fe      	b.n	3ae <Timer2_IRQHandler>

000003b0 <CAN_IRQHandler>:
 3b0:	e7fe      	b.n	3b0 <CAN_IRQHandler>

000003b2 <ENVM0_IRQHandler>:
 3b2:	e7fe      	b.n	3b2 <ENVM0_IRQHandler>

000003b4 <ENVM1_IRQHandler>:
 3b4:	e7fe      	b.n	3b4 <ENVM1_IRQHandler>
 3b6:	e7fe      	b.n	3b6 <ENVM1_IRQHandler+0x2>
 3b8:	e7fe      	b.n	3b8 <ENVM1_IRQHandler+0x4>
 3ba:	e7fe      	b.n	3ba <ENVM1_IRQHandler+0x6>

000003bc <PLL_Lock_IRQHandler>:
 3bc:	e7fe      	b.n	3bc <PLL_Lock_IRQHandler>

000003be <PLL_LockLost_IRQHandler>:
 3be:	e7fe      	b.n	3be <PLL_LockLost_IRQHandler>

000003c0 <CommSwitchError_IRQHandler>:
 3c0:	e7fe      	b.n	3c0 <CommSwitchError_IRQHandler>

000003c2 <CacheError_IRQHandler>:
 3c2:	e7fe      	b.n	3c2 <CacheError_IRQHandler>

000003c4 <DDR_IRQHandler>:
 3c4:	e7fe      	b.n	3c4 <DDR_IRQHandler>
 3c6:	e7fe      	b.n	3c6 <DDR_IRQHandler+0x2>
 3c8:	e7fe      	b.n	3c8 <DDR_IRQHandler+0x4>

000003ca <ECC_Error_IRQHandler>:
 3ca:	e7fe      	b.n	3ca <ECC_Error_IRQHandler>

000003cc <MDDR_IOCalib_IRQHandler>:
 3cc:	e7fe      	b.n	3cc <MDDR_IOCalib_IRQHandler>

000003ce <FAB_PLL_Lock_IRQHandler>:
 3ce:	e7fe      	b.n	3ce <FAB_PLL_Lock_IRQHandler>

000003d0 <FAB_PLL_LockLost_IRQHandler>:
 3d0:	e7fe      	b.n	3d0 <FAB_PLL_LockLost_IRQHandler>

000003d2 <FIC64_IRQHandler>:
 3d2:	e7fe      	b.n	3d2 <FIC64_IRQHandler>

000003d4 <FabricIrq0_IRQHandler>:
 3d4:	e7fe      	b.n	3d4 <FabricIrq0_IRQHandler>

000003d6 <FabricIrq1_IRQHandler>:
 3d6:	e7fe      	b.n	3d6 <FabricIrq1_IRQHandler>

000003d8 <FabricIrq2_IRQHandler>:
 3d8:	e7fe      	b.n	3d8 <FabricIrq2_IRQHandler>

000003da <FabricIrq3_IRQHandler>:
 3da:	e7fe      	b.n	3da <FabricIrq3_IRQHandler>

000003dc <FabricIrq4_IRQHandler>:
 3dc:	e7fe      	b.n	3dc <FabricIrq4_IRQHandler>

000003de <FabricIrq5_IRQHandler>:
 3de:	e7fe      	b.n	3de <FabricIrq5_IRQHandler>

000003e0 <FabricIrq6_IRQHandler>:
 3e0:	e7fe      	b.n	3e0 <FabricIrq6_IRQHandler>

000003e2 <FabricIrq7_IRQHandler>:
 3e2:	e7fe      	b.n	3e2 <FabricIrq7_IRQHandler>

000003e4 <FabricIrq8_IRQHandler>:
 3e4:	e7fe      	b.n	3e4 <FabricIrq8_IRQHandler>

000003e6 <FabricIrq9_IRQHandler>:
 3e6:	e7fe      	b.n	3e6 <FabricIrq9_IRQHandler>

000003e8 <FabricIrq10_IRQHandler>:
 3e8:	e7fe      	b.n	3e8 <FabricIrq10_IRQHandler>

000003ea <FabricIrq11_IRQHandler>:
 3ea:	e7fe      	b.n	3ea <FabricIrq11_IRQHandler>

000003ec <FabricIrq12_IRQHandler>:
 3ec:	e7fe      	b.n	3ec <FabricIrq12_IRQHandler>

000003ee <FabricIrq13_IRQHandler>:
 3ee:	e7fe      	b.n	3ee <FabricIrq13_IRQHandler>

000003f0 <FabricIrq14_IRQHandler>:
 3f0:	e7fe      	b.n	3f0 <FabricIrq14_IRQHandler>

000003f2 <FabricIrq15_IRQHandler>:
 3f2:	e7fe      	b.n	3f2 <FabricIrq15_IRQHandler>

000003f4 <GPIO0_IRQHandler>:
 3f4:	e7fe      	b.n	3f4 <GPIO0_IRQHandler>

000003f6 <GPIO1_IRQHandler>:
 3f6:	e7fe      	b.n	3f6 <GPIO1_IRQHandler>

000003f8 <GPIO2_IRQHandler>:
 3f8:	e7fe      	b.n	3f8 <GPIO2_IRQHandler>

000003fa <GPIO3_IRQHandler>:
 3fa:	e7fe      	b.n	3fa <GPIO3_IRQHandler>

000003fc <GPIO4_IRQHandler>:
 3fc:	e7fe      	b.n	3fc <GPIO4_IRQHandler>

000003fe <GPIO5_IRQHandler>:
 3fe:	e7fe      	b.n	3fe <GPIO5_IRQHandler>

00000400 <GPIO6_IRQHandler>:
 400:	e7fe      	b.n	400 <GPIO6_IRQHandler>

00000402 <GPIO7_IRQHandler>:
 402:	e7fe      	b.n	402 <GPIO7_IRQHandler>

00000404 <GPIO8_IRQHandler>:
 404:	e7fe      	b.n	404 <GPIO8_IRQHandler>

00000406 <GPIO9_IRQHandler>:
 406:	e7fe      	b.n	406 <GPIO9_IRQHandler>

00000408 <GPIO10_IRQHandler>:
 408:	e7fe      	b.n	408 <GPIO10_IRQHandler>

0000040a <GPIO11_IRQHandler>:
 40a:	e7fe      	b.n	40a <GPIO11_IRQHandler>

0000040c <GPIO12_IRQHandler>:
 40c:	e7fe      	b.n	40c <GPIO12_IRQHandler>

0000040e <GPIO13_IRQHandler>:
 40e:	e7fe      	b.n	40e <GPIO13_IRQHandler>

00000410 <GPIO14_IRQHandler>:
 410:	e7fe      	b.n	410 <GPIO14_IRQHandler>

00000412 <GPIO15_IRQHandler>:
 412:	e7fe      	b.n	412 <GPIO15_IRQHandler>

00000414 <GPIO16_IRQHandler>:
 414:	e7fe      	b.n	414 <GPIO16_IRQHandler>

00000416 <GPIO17_IRQHandler>:
 416:	e7fe      	b.n	416 <GPIO17_IRQHandler>

00000418 <GPIO18_IRQHandler>:
 418:	e7fe      	b.n	418 <GPIO18_IRQHandler>

0000041a <GPIO19_IRQHandler>:
 41a:	e7fe      	b.n	41a <GPIO19_IRQHandler>

0000041c <GPIO20_IRQHandler>:
 41c:	e7fe      	b.n	41c <GPIO20_IRQHandler>

0000041e <GPIO21_IRQHandler>:
 41e:	e7fe      	b.n	41e <GPIO21_IRQHandler>

00000420 <GPIO22_IRQHandler>:
 420:	e7fe      	b.n	420 <GPIO22_IRQHandler>

00000422 <GPIO23_IRQHandler>:
 422:	e7fe      	b.n	422 <GPIO23_IRQHandler>

00000424 <GPIO24_IRQHandler>:
 424:	e7fe      	b.n	424 <GPIO24_IRQHandler>

00000426 <GPIO25_IRQHandler>:
 426:	e7fe      	b.n	426 <GPIO25_IRQHandler>

00000428 <GPIO26_IRQHandler>:
 428:	e7fe      	b.n	428 <GPIO26_IRQHandler>

0000042a <GPIO27_IRQHandler>:
 42a:	e7fe      	b.n	42a <GPIO27_IRQHandler>

0000042c <GPIO28_IRQHandler>:
 42c:	e7fe      	b.n	42c <GPIO28_IRQHandler>

0000042e <GPIO29_IRQHandler>:
 42e:	e7fe      	b.n	42e <GPIO29_IRQHandler>

00000430 <GPIO30_IRQHandler>:
 430:	e7fe      	b.n	430 <GPIO30_IRQHandler>

00000432 <GPIO31_IRQHandler>:
 432:	e7fe      	b.n	432 <GPIO31_IRQHandler>

00000434 <mscc_post_hw_cfg_init>:
 434:	4770      	bx	lr

00000436 <RAM_INIT_PATTERN>:
 436:	0000      	.short	0x0000
	...

0000043a <HEAP_INIT_PATTERN>:
 43a:	a2a2      	.short	0xa2a2
 43c:	a2a2      	.short	0xa2a2

0000043e <SF2_ESRAM_CR>:
 43e:	8000      	.short	0x8000
 440:	4003      	.short	0x4003

00000442 <SF2_DDR_CR>:
 442:	8008      	.short	0x8008
 444:	4003      	.short	0x4003

00000446 <SF2_ENVM_REMAP_CR>:
 446:	8010      	.short	0x8010
 448:	4003      	.short	0x4003

0000044a <SF2_DDRB_NB_SIZE>:
 44a:	8030      	.short	0x8030
 44c:	4003      	.short	0x4003

0000044e <SF2_DDRB_CR>:
 44e:	8034      	.short	0x8034
 450:	4003      	.short	0x4003

00000452 <SF2_EDAC_CR>:
 452:	8038      	.short	0x8038
 454:	4003      	.short	0x4003

00000456 <SF2_MDDR_MODE_CR>:
 456:	0818      	.short	0x0818
 458:	00004002 	.word	0x00004002
 45c:	2000f000 	.word	0x2000f000
 460:	20010000 	.word	0x20010000
 464:	00008a65 	.word	0x00008a65
	...
 470:	00000001 	.word	0x00000001
	...
 480:	00000190 	.word	0x00000190
 484:	000004c0 	.word	0x000004c0
 488:	000004c0 	.word	0x000004c0
 48c:	00008f70 	.word	0x00008f70
 490:	00008f70 	.word	0x00008f70
 494:	20000000 	.word	0x20000000
 498:	200005d0 	.word	0x200005d0
 49c:	200005d0 	.word	0x200005d0
 4a0:	20000c70 	.word	0x20000c70
 4a4:	20000c70 	.word	0x20000c70
 4a8:	2000f000 	.word	0x2000f000
 4ac:	00008b99 	.word	0x00008b99
 4b0:	0000050d 	.word	0x0000050d
 4b4:	f3af 8000 	nop.w
 4b8:	f3af 8000 	nop.w
 4bc:	f3af 8000 	nop.w

Disassembly of section .text:

000004c0 <__do_global_dtors_aux>:
     4c0:	f240 53d0 	movw	r3, #1488	; 0x5d0
     4c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     4c8:	781a      	ldrb	r2, [r3, #0]
     4ca:	b90a      	cbnz	r2, 4d0 <__do_global_dtors_aux+0x10>
     4cc:	2001      	movs	r0, #1
     4ce:	7018      	strb	r0, [r3, #0]
     4d0:	4770      	bx	lr
     4d2:	bf00      	nop

000004d4 <frame_dummy>:
     4d4:	f240 0000 	movw	r0, #0
     4d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
     4dc:	b508      	push	{r3, lr}
     4de:	6803      	ldr	r3, [r0, #0]
     4e0:	b12b      	cbz	r3, 4ee <frame_dummy+0x1a>
     4e2:	f240 0300 	movw	r3, #0
     4e6:	f2c0 0300 	movt	r3, #0
     4ea:	b103      	cbz	r3, 4ee <frame_dummy+0x1a>
     4ec:	4798      	blx	r3
     4ee:	bd08      	pop	{r3, pc}

000004f0 <receive_data_handler>:
(
    uint32_t rx_count,
    uint32_t rx_err_status
)
{
    if(rx_err_status == 0)
     4f0:	b929      	cbnz	r1, 4fe <receive_data_handler+0xe>
    {
        if(rx_count)
     4f2:	b928      	cbnz	r0, 500 <receive_data_handler+0x10>
        {
            g_rx_count = rx_count;
        }
        else
        {
            g_rx_count = 0;
     4f4:	f240 51d4 	movw	r1, #1492	; 0x5d4
     4f8:	f2c2 0100 	movt	r1, #8192	; 0x2000
     4fc:	6008      	str	r0, [r1, #0]
     4fe:	4770      	bx	lr
{
    if(rx_err_status == 0)
    {
        if(rx_count)
        {
            g_rx_count = rx_count;
     500:	f240 53d4 	movw	r3, #1492	; 0x5d4
     504:	f2c2 0300 	movt	r3, #8192	; 0x2000
     508:	6018      	str	r0, [r3, #0]
     50a:	4770      	bx	lr

0000050c <main>:
volatile uint32_t g_tx_count=0;

void receive_data_handler( uint32_t rx_count, uint32_t rx_err_status );

int main()
{
     50c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    VCP_init(MSS_USB_VCP_9600_BAUD, MSS_USB_VCP_ONE_STOP_BIT,
     510:	2100      	movs	r1, #0
     512:	460a      	mov	r2, r1
     514:	f44f 5016 	mov.w	r0, #9600	; 0x2580
volatile uint32_t g_tx_count=0;

void receive_data_handler( uint32_t rx_count, uint32_t rx_err_status );

int main()
{
     518:	b082      	sub	sp, #8
    VCP_init(MSS_USB_VCP_9600_BAUD, MSS_USB_VCP_ONE_STOP_BIT,
     51a:	2308      	movs	r3, #8
     51c:	f000 f9b0 	bl	880 <VCP_init>
             MSS_USB_VCP_NO_PARITY, MSS_USB_VCP_DATA_8_BITS);

	MSS_UART_init	(&g_mss_uart0, MSS_UART_115200_BAUD,
     520:	f640 4024 	movw	r0, #3108	; 0xc24
     524:	f2c2 0000 	movt	r0, #8192	; 0x2000
     528:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
     52c:	2203      	movs	r2, #3
     52e:	f005 f8d3 	bl	56d8 <MSS_UART_init>
			MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT );

    while(VCP_HOST_APP_READY != VCP_configuration_state());
     532:	f000 f8ff 	bl	734 <VCP_configuration_state>
     536:	2802      	cmp	r0, #2
     538:	d1fb      	bne.n	532 <main+0x26>

    VCP_rx_prepare(receive_buf, sizeof(receive_buf), receive_data_handler);
     53a:	f240 56d4 	movw	r6, #1492	; 0x5d4
     53e:	f2c2 0600 	movt	r6, #8192	; 0x2000
     542:	f240 42f1 	movw	r2, #1265	; 0x4f1
     546:	f2c0 0200 	movt	r2, #0
     54a:	f44f 7100 	mov.w	r1, #512	; 0x200
     54e:	1d30      	adds	r0, r6, #4
     550:	f000 f962 	bl	818 <VCP_rx_prepare>
    VCP_tx(g_greeting, sizeof(g_greeting));
     554:	f240 0008 	movw	r0, #8
     558:	2170      	movs	r1, #112	; 0x70
     55a:	f2c2 0000 	movt	r0, #8192	; 0x2000
     55e:	f000 f97b 	bl	858 <VCP_tx>
    MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)MMUART_0_greeting);
     562:	f640 4024 	movw	r0, #3108	; 0xc24
     566:	f2c2 0000 	movt	r0, #8192	; 0x2000
     56a:	4926      	ldr	r1, [pc, #152]	; (604 <main+0xf8>)
     56c:	f003 fef6 	bl	435c <MSS_UART_polled_tx_string>
     570:	ac01      	add	r4, sp, #4

    size_t rx_size;
    uint8_t rx_buff[3];
    for(;;)
    {
        if(g_rx_count)
     572:	4637      	mov	r7, r6
        {
            VCP_tx(receive_buf, g_rx_count);
            MSS_UART_polled_tx(&g_mss_uart0, receive_buf, g_rx_count);
            g_rx_count=0;
     574:	f04f 0800 	mov.w	r8, #0
     578:	e00d      	b.n	596 <main+0x8a>
        }
        if((1 == VCP_tx_done()))
     57a:	f000 f8d5 	bl	728 <VCP_tx_done>
     57e:	2801      	cmp	r0, #1
     580:	d01e      	beq.n	5c0 <main+0xb4>
        {
            VCP_rx_prepare(receive_buf, sizeof(receive_buf), receive_data_handler);
        }
        rx_size = MSS_UART_get_rx(&g_mss_uart0, rx_buff, sizeof(rx_buff));
     582:	f640 4024 	movw	r0, #3108	; 0xc24
     586:	f2c2 0000 	movt	r0, #8192	; 0x2000
     58a:	4621      	mov	r1, r4
     58c:	2203      	movs	r2, #3
     58e:	f003 ff89 	bl	44a4 <MSS_UART_get_rx>
        if( rx_size > 0 )
     592:	4605      	mov	r5, r0
     594:	bb40      	cbnz	r0, 5e8 <main+0xdc>

    size_t rx_size;
    uint8_t rx_buff[3];
    for(;;)
    {
        if(g_rx_count)
     596:	6833      	ldr	r3, [r6, #0]
     598:	2b00      	cmp	r3, #0
     59a:	d0ee      	beq.n	57a <main+0x6e>
        {
            VCP_tx(receive_buf, g_rx_count);
     59c:	6839      	ldr	r1, [r7, #0]
     59e:	481a      	ldr	r0, [pc, #104]	; (608 <main+0xfc>)
     5a0:	f000 f95a 	bl	858 <VCP_tx>
            MSS_UART_polled_tx(&g_mss_uart0, receive_buf, g_rx_count);
     5a4:	f640 4024 	movw	r0, #3108	; 0xc24
     5a8:	683a      	ldr	r2, [r7, #0]
     5aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
     5ae:	4916      	ldr	r1, [pc, #88]	; (608 <main+0xfc>)
     5b0:	f003 fe7e 	bl	42b0 <MSS_UART_polled_tx>
            g_rx_count=0;
     5b4:	f8c7 8000 	str.w	r8, [r7]
        }
        if((1 == VCP_tx_done()))
     5b8:	f000 f8b6 	bl	728 <VCP_tx_done>
     5bc:	2801      	cmp	r0, #1
     5be:	d1e0      	bne.n	582 <main+0x76>
        {
            VCP_rx_prepare(receive_buf, sizeof(receive_buf), receive_data_handler);
     5c0:	f240 42f1 	movw	r2, #1265	; 0x4f1
     5c4:	f2c0 0200 	movt	r2, #0
     5c8:	f44f 7100 	mov.w	r1, #512	; 0x200
     5cc:	480e      	ldr	r0, [pc, #56]	; (608 <main+0xfc>)
     5ce:	f000 f923 	bl	818 <VCP_rx_prepare>
        }
        rx_size = MSS_UART_get_rx(&g_mss_uart0, rx_buff, sizeof(rx_buff));
     5d2:	f640 4024 	movw	r0, #3108	; 0xc24
     5d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
     5da:	4621      	mov	r1, r4
     5dc:	2203      	movs	r2, #3
     5de:	f003 ff61 	bl	44a4 <MSS_UART_get_rx>
        if( rx_size > 0 )
     5e2:	4605      	mov	r5, r0
     5e4:	2800      	cmp	r0, #0
     5e6:	d0d6      	beq.n	596 <main+0x8a>
        {
           	MSS_UART_polled_tx(&g_mss_uart0, rx_buff, sizeof(rx_buff));
     5e8:	f640 4024 	movw	r0, #3108	; 0xc24
     5ec:	4621      	mov	r1, r4
     5ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
     5f2:	2203      	movs	r2, #3
     5f4:	f003 fe5c 	bl	42b0 <MSS_UART_polled_tx>
           	VCP_tx(rx_buff, rx_size);
     5f8:	4620      	mov	r0, r4
     5fa:	4629      	mov	r1, r5
     5fc:	f000 f92c 	bl	858 <VCP_tx>
     600:	e7c9      	b.n	596 <main+0x8a>
     602:	bf00      	nop
     604:	20000078 	.word	0x20000078
     608:	200005d8 	.word	0x200005d8

0000060c <vcp_device_descriptor>:
vcp_device_descriptor
(
    uint32_t* length
)
{
   *length = sizeof(device_descriptor);
     60c:	2312      	movs	r3, #18
     60e:	6003      	str	r3, [r0, #0]
   return(device_descriptor);
}
     610:	f240 00e8 	movw	r0, #232	; 0xe8
     614:	f2c2 0000 	movt	r0, #8192	; 0x2000
     618:	4770      	bx	lr
     61a:	bf00      	nop

0000061c <vcp_device_qual_descriptor>:
(
    mss_usb_device_speed_t speed,
    uint32_t* length
)
{
    if(speed == MSS_USB_DEVICE_HS)
     61c:	b118      	cbz	r0, 626 <vcp_device_qual_descriptor+0xa>
        *length = sizeof(fs_dev_qualifier_descriptor);
         return(fs_dev_qualifier_descriptor);
    }
    else
    {
        *length = sizeof(hs_dev_qualifier_descriptor);
     61e:	220a      	movs	r2, #10
     620:	4803      	ldr	r0, [pc, #12]	; (630 <vcp_device_qual_descriptor+0x14>)
     622:	600a      	str	r2, [r1, #0]
         return(hs_dev_qualifier_descriptor);
    }
}
     624:	4770      	bx	lr
    uint32_t* length
)
{
    if(speed == MSS_USB_DEVICE_HS)
    {
        *length = sizeof(fs_dev_qualifier_descriptor);
     626:	230a      	movs	r3, #10
     628:	600b      	str	r3, [r1, #0]
     62a:	4802      	ldr	r0, [pc, #8]	; (634 <vcp_device_qual_descriptor+0x18>)
         return(fs_dev_qualifier_descriptor);
     62c:	4770      	bx	lr
     62e:	bf00      	nop
     630:	20000108 	.word	0x20000108
     634:	200000fc 	.word	0x200000fc

00000638 <vcp_get_string>:
    const uint8_t *idx = string ;
    uint8_t *cp_dest;

    cp_dest = dest;

    if((dest != 0) && (string != 0))
     638:	1e03      	subs	r3, r0, #0
     63a:	bf18      	it	ne
     63c:	2301      	movne	r3, #1
     63e:	2900      	cmp	r1, #0
     640:	bf0c      	ite	eq
     642:	2300      	moveq	r3, #0
     644:	f003 0301 	andne.w	r3, r3, #1
vcp_get_string
(
    uint8_t* string,
    uint8_t* dest
)
{
     648:	b410      	push	{r4}
    const uint8_t *idx = string ;
    uint8_t *cp_dest;

    cp_dest = dest;

    if((dest != 0) && (string != 0))
     64a:	b1bb      	cbz	r3, 67c <vcp_get_string+0x44>
    {
        for (; *(idx); ++idx)
     64c:	7802      	ldrb	r2, [r0, #0]
     64e:	b1ba      	cbz	r2, 680 <vcp_get_string+0x48>
     650:	460b      	mov	r3, r1
     652:	4604      	mov	r4, r0
        {
            *(dest + 2) = *(idx);
            dest++;
            *(dest + 2) = 0x00;
     654:	f04f 0c00 	mov.w	ip, #0

    if((dest != 0) && (string != 0))
    {
        for (; *(idx); ++idx)
        {
            *(dest + 2) = *(idx);
     658:	709a      	strb	r2, [r3, #2]
            dest++;
            *(dest + 2) = 0x00;
     65a:	f883 c003 	strb.w	ip, [r3, #3]

    cp_dest = dest;

    if((dest != 0) && (string != 0))
    {
        for (; *(idx); ++idx)
     65e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
        return(g_string_descriptor);
    }
}

uint8_t
vcp_get_string
     662:	3302      	adds	r3, #2

    cp_dest = dest;

    if((dest != 0) && (string != 0))
    {
        for (; *(idx); ++idx)
     664:	2a00      	cmp	r2, #0
     666:	d1f7      	bne.n	658 <vcp_get_string+0x20>
            *(dest + 2) = *(idx);
            dest++;
            *(dest + 2) = 0x00;
            dest++;
        }
        *cp_dest = ((idx - string) * 2) + 2;                /*bLength*/
     668:	f1c0 0201 	rsb	r2, r0, #1
     66c:	1913      	adds	r3, r2, r4
     66e:	0058      	lsls	r0, r3, #1
     670:	b2c0      	uxtb	r0, r0
        *(cp_dest + 1) = USB_STRING_DESCRIPTOR_TYPE;        /*bDesriptorType*/
     672:	2203      	movs	r2, #3
     674:	704a      	strb	r2, [r1, #1]
            *(dest + 2) = *(idx);
            dest++;
            *(dest + 2) = 0x00;
            dest++;
        }
        *cp_dest = ((idx - string) * 2) + 2;                /*bLength*/
     676:	7008      	strb	r0, [r1, #0]
        *(cp_dest + 1) = USB_STRING_DESCRIPTOR_TYPE;        /*bDesriptorType*/
    }

    return(((idx - string) * 2) + 2);
}
     678:	bc10      	pop	{r4}
     67a:	4770      	bx	lr
    const uint8_t *idx = string ;
    uint8_t *cp_dest;

    cp_dest = dest;

    if((dest != 0) && (string != 0))
     67c:	2002      	movs	r0, #2
     67e:	e7fb      	b.n	678 <vcp_get_string+0x40>
    {
        for (; *(idx); ++idx)
     680:	4604      	mov	r4, r0
     682:	e7f1      	b.n	668 <vcp_get_string+0x30>

00000684 <vcp_string_descriptor>:
vcp_string_descriptor
(
    uint8_t index,
    uint32_t* length
)
{
     684:	b510      	push	{r4, lr}
     686:	460c      	mov	r4, r1
    switch(index)
     688:	2805      	cmp	r0, #5
     68a:	d815      	bhi.n	6b8 <vcp_string_descriptor+0x34>
     68c:	e8df f000 	tbb	[pc, r0]
     690:	332c2520 	.word	0x332c2520
     694:	033a      	.short	0x033a
            *length = vcp_get_string((uint8_t*)USB_STRING_CONFIG,
                                     g_string_descriptor);
        break;

        case USB_STRING_DESCRIPTOR_IDX_INTERFACE:
            *length = vcp_get_string((uint8_t*)USB_STRING_INTERFACE,
     696:	f648 50b0 	movw	r0, #36272	; 0x8db0
     69a:	f640 315c 	movw	r1, #2908	; 0xb5c
     69e:	f2c0 0000 	movt	r0, #0
            *length = vcp_get_string((uint8_t*)USB_STRING_SERIAL,
                                     g_string_descriptor);
        break;

        case USB_STRING_DESCRIPTOR_IDX_CONFIG:
            *length = vcp_get_string((uint8_t*)USB_STRING_CONFIG,
     6a2:	f2c2 0100 	movt	r1, #8192	; 0x2000
     6a6:	f7ff ffc7 	bl	638 <vcp_get_string>
     6aa:	f640 335c 	movw	r3, #2908	; 0xb5c
     6ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
     6b2:	6020      	str	r0, [r4, #0]
        return(lang_string_descriptor);
    }
    {
        return(g_string_descriptor);
    }
}
     6b4:	4618      	mov	r0, r3
     6b6:	bd10      	pop	{r4, pc}
           /*Raise error*/
          *length = 0u;
        break;
    }

    if(USB_STRING_DESCRIPTOR_IDX_LANGID == index)
     6b8:	4a16      	ldr	r2, [pc, #88]	; (714 <vcp_string_descriptor+0x90>)
     6ba:	f640 335c 	movw	r3, #2908	; 0xb5c
     6be:	f2c2 0300 	movt	r3, #8192	; 0x2000
                                     g_string_descriptor);
        break;

        default:
           /*Raise error*/
          *length = 0u;
     6c2:	2100      	movs	r1, #0
        break;
    }

    if(USB_STRING_DESCRIPTOR_IDX_LANGID == index)
     6c4:	2800      	cmp	r0, #0
     6c6:	bf08      	it	eq
     6c8:	4613      	moveq	r3, r2
                                     g_string_descriptor);
        break;

        default:
           /*Raise error*/
          *length = 0u;
     6ca:	6021      	str	r1, [r4, #0]
        return(lang_string_descriptor);
    }
    {
        return(g_string_descriptor);
    }
}
     6cc:	4618      	mov	r0, r3
     6ce:	bd10      	pop	{r4, pc}
)
{
    switch(index)
    {
        case USB_STRING_DESCRIPTOR_IDX_LANGID:
            *length = sizeof(lang_string_descriptor);
     6d0:	2304      	movs	r3, #4
     6d2:	600b      	str	r3, [r1, #0]
     6d4:	4b0f      	ldr	r3, [pc, #60]	; (714 <vcp_string_descriptor+0x90>)
        return(lang_string_descriptor);
    }
    {
        return(g_string_descriptor);
    }
}
     6d6:	4618      	mov	r0, r3
     6d8:	bd10      	pop	{r4, pc}
        case USB_STRING_DESCRIPTOR_IDX_LANGID:
            *length = sizeof(lang_string_descriptor);
        break;

        case USB_STRING_DESCRIPTOR_IDX_MANUFACTURER:
            *length = vcp_get_string((uint8_t*)USB_STRING_MANUFACTURER,
     6da:	f648 5078 	movw	r0, #36216	; 0x8d78
     6de:	f640 315c 	movw	r1, #2908	; 0xb5c
     6e2:	f2c0 0000 	movt	r0, #0
     6e6:	e7dc      	b.n	6a2 <vcp_string_descriptor+0x1e>
                                     g_string_descriptor);
        break;

        case USB_STRING_DESCRIPTOR_IDX_PRODUCT:
            *length = vcp_get_string((uint8_t*)USB_STRING_PRODUCT,
     6e8:	f648 5088 	movw	r0, #36232	; 0x8d88
     6ec:	f640 315c 	movw	r1, #2908	; 0xb5c
     6f0:	f2c0 0000 	movt	r0, #0
     6f4:	e7d5      	b.n	6a2 <vcp_string_descriptor+0x1e>
                                     g_string_descriptor);
        break;

        case USB_STRING_DESCRIPTOR_IDX_SERIAL:
            *length = vcp_get_string((uint8_t*)USB_STRING_SERIAL,
     6f6:	f648 50a0 	movw	r0, #36256	; 0x8da0
     6fa:	f640 315c 	movw	r1, #2908	; 0xb5c
     6fe:	f2c0 0000 	movt	r0, #0
     702:	e7ce      	b.n	6a2 <vcp_string_descriptor+0x1e>
                                     g_string_descriptor);
        break;

        case USB_STRING_DESCRIPTOR_IDX_CONFIG:
            *length = vcp_get_string((uint8_t*)USB_STRING_CONFIG,
     704:	f648 50a8 	movw	r0, #36264	; 0x8da8
     708:	f640 315c 	movw	r1, #2908	; 0xb5c
     70c:	f2c0 0000 	movt	r0, #0
     710:	e7c7      	b.n	6a2 <vcp_string_descriptor+0x1e>
     712:	bf00      	nop
     714:	20000114 	.word	0x20000114

00000718 <VCP_tx_wait_complete>:
VCP_tx_wait_complete
(
    void
)
{
    while (!g_vcptx_complete_status);
     718:	f240 1024 	movw	r0, #292	; 0x124
     71c:	f2c2 0000 	movt	r0, #8192	; 0x2000
     720:	7803      	ldrb	r3, [r0, #0]
     722:	b103      	cbz	r3, 726 <VCP_tx_wait_complete+0xe>
     724:	4770      	bx	lr
     726:	e7fe      	b.n	726 <VCP_tx_wait_complete+0xe>

00000728 <VCP_tx_done>:
uint32_t
VCP_tx_done
(
    void
)
{
     728:	f240 1324 	movw	r3, #292	; 0x124
     72c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    return (g_vcptx_complete_status);
}
     730:	7818      	ldrb	r0, [r3, #0]
     732:	4770      	bx	lr

00000734 <VCP_configuration_state>:
VCP_configuration_state
(
    void
)
{
    return (g_vcp_config_state);
     734:	f240 73dc 	movw	r3, #2012	; 0x7dc
     738:	f2c2 0300 	movt	r3, #8192	; 0x2000
     73c:	7818      	ldrb	r0, [r3, #0]
}
     73e:	4770      	bx	lr

00000740 <VCP_init_cb>:
VCP_init_cb
(
    void
)
{
    g_vcptx_complete_status = 1u;
     740:	f240 1324 	movw	r3, #292	; 0x124
    g_vcprx_complete_status = 1u;
    g_vcp_config_state = VCP_CONFIGURED;
     744:	f240 71dc 	movw	r1, #2012	; 0x7dc
VCP_init_cb
(
    void
)
{
    g_vcptx_complete_status = 1u;
     748:	2201      	movs	r2, #1
     74a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_vcprx_complete_status = 1u;
    g_vcp_config_state = VCP_CONFIGURED;
     74e:	f2c2 0100 	movt	r1, #8192	; 0x2000
     752:	700a      	strb	r2, [r1, #0]
(
    void
)
{
    g_vcptx_complete_status = 1u;
    g_vcprx_complete_status = 1u;
     754:	705a      	strb	r2, [r3, #1]
VCP_init_cb
(
    void
)
{
    g_vcptx_complete_status = 1u;
     756:	701a      	strb	r2, [r3, #0]
    g_vcprx_complete_status = 1u;
    g_vcp_config_state = VCP_CONFIGURED;
}
     758:	4770      	bx	lr
     75a:	bf00      	nop

0000075c <VCP_release_cb>:
VCP_release_cb
(
    uint8_t cfgidx
)
{
    g_vcp_config_state = VCP_NOT_CONFIGURED;
     75c:	f240 73dc 	movw	r3, #2012	; 0x7dc
     760:	f2c2 0300 	movt	r3, #8192	; 0x2000
     764:	2200      	movs	r2, #0
     766:	701a      	strb	r2, [r3, #0]
}
     768:	4770      	bx	lr
     76a:	bf00      	nop

0000076c <VCP_process_request_cb>:
    uint8_t** buf,
    uint32_t* length
)
{
    uint8_t result = USB_FAIL;
    switch(setup_pkt->request)
     76c:	7843      	ldrb	r3, [r0, #1]
     76e:	2b21      	cmp	r3, #33	; 0x21
     770:	d01c      	beq.n	7ac <VCP_process_request_cb+0x40>
     772:	2b22      	cmp	r3, #34	; 0x22
     774:	d010      	beq.n	798 <VCP_process_request_cb+0x2c>
     776:	2b20      	cmp	r3, #32
     778:	d001      	beq.n	77e <VCP_process_request_cb+0x12>
     77a:	2000      	movs	r0, #0
     77c:	4770      	bx	lr
    case USB_CDC_CLEAR_COMM_FEATURE:
        result = USB_FAIL;
    break;

    case USB_CDC_SET_LINE_CODING:
        *buf = (uint8_t*)&g_linecoding_params;
     77e:	480e      	ldr	r0, [pc, #56]	; (7b8 <VCP_process_request_cb+0x4c>)
        *length = 7u;
        host_detected++;
     780:	f240 73dc 	movw	r3, #2012	; 0x7dc
    case USB_CDC_CLEAR_COMM_FEATURE:
        result = USB_FAIL;
    break;

    case USB_CDC_SET_LINE_CODING:
        *buf = (uint8_t*)&g_linecoding_params;
     784:	6008      	str	r0, [r1, #0]
        *length = 7u;
     786:	2007      	movs	r0, #7
     788:	6010      	str	r0, [r2, #0]
        host_detected++;
     78a:	f2c2 0300 	movt	r3, #8192	; 0x2000
     78e:	7859      	ldrb	r1, [r3, #1]
     790:	2001      	movs	r0, #1
     792:	180a      	adds	r2, r1, r0
     794:	705a      	strb	r2, [r3, #1]
        result = USB_SUCCESS;
        break;
     796:	4770      	bx	lr
        *length = 7u;
        result = USB_SUCCESS;
    break;

    case USB_CDC_SET_CONTROL_LINE_STATE:
        g_vcp_serial_state = (uint8_t)setup_pkt->value;
     798:	f8b0 c002 	ldrh.w	ip, [r0, #2]
     79c:	f240 72dc 	movw	r2, #2012	; 0x7dc
     7a0:	f2c2 0200 	movt	r2, #8192	; 0x2000
     7a4:	f882 c002 	strb.w	ip, [r2, #2]
     7a8:	2001      	movs	r0, #1
    default:
        result = USB_FAIL;
    break;
    }
    return result;
}
     7aa:	4770      	bx	lr
        host_detected++;
        result = USB_SUCCESS;
        break;

    case USB_CDC_GET_LINE_CODING:
        *buf = (uint8_t*)&g_linecoding_params;
     7ac:	4802      	ldr	r0, [pc, #8]	; (7b8 <VCP_process_request_cb+0x4c>)
        *length = 7u;
     7ae:	2307      	movs	r3, #7
        host_detected++;
        result = USB_SUCCESS;
        break;

    case USB_CDC_GET_LINE_CODING:
        *buf = (uint8_t*)&g_linecoding_params;
     7b0:	6008      	str	r0, [r1, #0]
        *length = 7u;
     7b2:	6013      	str	r3, [r2, #0]
     7b4:	2001      	movs	r0, #1
        result = USB_SUCCESS;
    break;
     7b6:	4770      	bx	lr
     7b8:	20000128 	.word	0x20000128

000007bc <VCP_tx_cb>:
VCP_tx_cb
(
    uint8_t status
)
{
    if(status < 2 ) /*Ignore underrun error*/
     7bc:	2801      	cmp	r0, #1
     7be:	d805      	bhi.n	7cc <VCP_tx_cb+0x10>
    {
        g_vcptx_complete_status = 1u;
     7c0:	f240 1324 	movw	r3, #292	; 0x124
     7c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     7c8:	2201      	movs	r2, #1
     7ca:	701a      	strb	r2, [r3, #0]
    {
        ASSERT(0);
    }
    return 1;

}
     7cc:	2001      	movs	r0, #1
     7ce:	4770      	bx	lr

000007d0 <VCP_rx_cb>:
    uint8_t status,
    uint32_t rx_count
)
{

    g_vcprx_complete_status = 1u;
     7d0:	f240 1324 	movw	r3, #292	; 0x124
VCP_rx_cb
(
    uint8_t status,
    uint32_t rx_count
)
{
     7d4:	b510      	push	{r4, lr}
     7d6:	4602      	mov	r2, r0

    g_vcprx_complete_status = 1u;
     7d8:	2401      	movs	r4, #1
     7da:	f2c2 0300 	movt	r3, #8192	; 0x2000

    /*Call the Handler function provided by user with VCP_rx_prepare() function*/
    g_rx_complete_handler(rx_count, status);
     7de:	4608      	mov	r0, r1
    uint8_t status,
    uint32_t rx_count
)
{

    g_vcprx_complete_status = 1u;
     7e0:	705c      	strb	r4, [r3, #1]

    /*Call the Handler function provided by user with VCP_rx_prepare() function*/
    g_rx_complete_handler(rx_count, status);
     7e2:	4611      	mov	r1, r2
     7e4:	68db      	ldr	r3, [r3, #12]
     7e6:	4798      	blx	r3

    return 1;
}
     7e8:	4620      	mov	r0, r4
     7ea:	bd10      	pop	{r4, pc}

000007ec <VCP_cep_tx_cb>:
(
    uint8_t status
)
{
    return 1;
}
     7ec:	2001      	movs	r0, #1
     7ee:	4770      	bx	lr

000007f0 <VCP_cep_rx_cb>:
VCP_cep_rx_cb
(
    uint8_t status
)
{
    if(host_detected == 1)
     7f0:	f240 73dc 	movw	r3, #2012	; 0x7dc
     7f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
     7f8:	785a      	ldrb	r2, [r3, #1]
     7fa:	2a01      	cmp	r2, #1
     7fc:	d103      	bne.n	806 <VCP_cep_rx_cb+0x16>
    {
        g_vcp_config_state = VCP_HOST_APP_READY;
        host_detected =0;
     7fe:	2100      	movs	r1, #0
    uint8_t status
)
{
    if(host_detected == 1)
    {
        g_vcp_config_state = VCP_HOST_APP_READY;
     800:	2002      	movs	r0, #2
        host_detected =0;
     802:	7059      	strb	r1, [r3, #1]
    uint8_t status
)
{
    if(host_detected == 1)
    {
        g_vcp_config_state = VCP_HOST_APP_READY;
     804:	7018      	strb	r0, [r3, #0]
        host_detected =0;
    }
    return 1;
}
     806:	2001      	movs	r0, #1
     808:	4770      	bx	lr
     80a:	bf00      	nop

0000080c <VCP_notification_cb>:
(
    uint8_t** buf_p,
    uint32_t* len_p
)
{
    *buf_p = (uint8_t*)0;
     80c:	2300      	movs	r3, #0
    *len_p = 0;
     80e:	600b      	str	r3, [r1, #0]
(
    uint8_t** buf_p,
    uint32_t* len_p
)
{
    *buf_p = (uint8_t*)0;
     810:	6003      	str	r3, [r0, #0]
    *len_p = 0;
}
     812:	4770      	bx	lr

00000814 <VCP_default_rx_complete_handler>:
    uint32_t rx_err_status
)
{
    /*No User handler function assigned.*/
    ASSERT(0);
}
     814:	4770      	bx	lr
     816:	bf00      	nop

00000818 <VCP_rx_prepare>:
(
    uint8_t* buf,
    uint32_t length,
    vcp_rx_complete_handler_t rx_handler_func
)
{
     818:	b508      	push	{r3, lr}
    if((g_vcp_config_state >= VCP_CONFIGURED) &&
     81a:	f240 73dc 	movw	r3, #2012	; 0x7dc
     81e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     822:	781b      	ldrb	r3, [r3, #0]
     824:	b153      	cbz	r3, 83c <VCP_rx_prepare+0x24>
     826:	f1b0 0c00 	subs.w	ip, r0, #0
     82a:	bf18      	it	ne
     82c:	f04f 0c01 	movne.w	ip, #1
     830:	2a00      	cmp	r2, #0
     832:	bf0c      	ite	eq
     834:	2300      	moveq	r3, #0
     836:	f00c 0301 	andne.w	r3, ip, #1
     83a:	b90b      	cbnz	r3, 840 <VCP_rx_prepare+0x28>
        (buf != (uint8_t*)0))
    {
        g_vcprx_complete_status = 0u;
        g_rx_complete_handler = rx_handler_func;
        MSS_USBD_CDC_rx_prepare(buf, length);
        return 1u;
     83c:	2000      	movs	r0, #0
    }
    else
    {
        return 0u;
    }
}
     83e:	bd08      	pop	{r3, pc}
{
    if((g_vcp_config_state >= VCP_CONFIGURED) &&
        (rx_handler_func != (vcp_rx_complete_handler_t)0) &&
        (buf != (uint8_t*)0))
    {
        g_vcprx_complete_status = 0u;
     840:	f240 1324 	movw	r3, #292	; 0x124
     844:	f2c2 0300 	movt	r3, #8192	; 0x2000
        g_rx_complete_handler = rx_handler_func;
     848:	60da      	str	r2, [r3, #12]
{
    if((g_vcp_config_state >= VCP_CONFIGURED) &&
        (rx_handler_func != (vcp_rx_complete_handler_t)0) &&
        (buf != (uint8_t*)0))
    {
        g_vcprx_complete_status = 0u;
     84a:	2200      	movs	r2, #0
     84c:	705a      	strb	r2, [r3, #1]
        g_rx_complete_handler = rx_handler_func;
        MSS_USBD_CDC_rx_prepare(buf, length);
     84e:	f002 f9ab 	bl	2ba8 <MSS_USBD_CDC_rx_prepare>
     852:	2001      	movs	r0, #1
        return 1u;
     854:	bd08      	pop	{r3, pc}
     856:	bf00      	nop

00000858 <VCP_tx>:
(
    uint8_t* buf,
    uint32_t length
)
{
    if((g_vcp_config_state >= VCP_CONFIGURED) && (buf != (uint8_t*)0))
     858:	f240 72dc 	movw	r2, #2012	; 0x7dc
     85c:	f2c2 0200 	movt	r2, #8192	; 0x2000
VCP_tx
(
    uint8_t* buf,
    uint32_t length
)
{
     860:	b508      	push	{r3, lr}
    if((g_vcp_config_state >= VCP_CONFIGURED) && (buf != (uint8_t*)0))
     862:	7813      	ldrb	r3, [r2, #0]
     864:	b153      	cbz	r3, 87c <VCP_tx+0x24>
     866:	b148      	cbz	r0, 87c <VCP_tx+0x24>
    {
        g_vcptx_complete_status = 0u;
     868:	f240 1324 	movw	r3, #292	; 0x124
     86c:	f2c2 0300 	movt	r3, #8192	; 0x2000
     870:	2200      	movs	r2, #0
     872:	701a      	strb	r2, [r3, #0]
        MSS_USBD_CDC_tx(buf, length);
     874:	f002 f94c 	bl	2b10 <MSS_USBD_CDC_tx>
     878:	2001      	movs	r0, #1
        return 1u;
     87a:	bd08      	pop	{r3, pc}
     87c:	2000      	movs	r0, #0
    }
    else
    {
        return 0u;
    }
}
     87e:	bd08      	pop	{r3, pc}

00000880 <VCP_init>:
    uint32_t baud_rate,
    uint8_t stop_bits,
    uint8_t parity,
    uint8_t data_bits
)
{
     880:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    SYSREG->WDOG_CR = 0x0000;        /*Disable Watch-dog*/
     884:	f248 0500 	movw	r5, #32768	; 0x8000
     888:	2400      	movs	r4, #0
     88a:	f2c4 0503 	movt	r5, #16387	; 0x4003
     88e:	66ec      	str	r4, [r5, #108]	; 0x6c
    uint32_t baud_rate,
    uint8_t stop_bits,
    uint8_t parity,
    uint8_t data_bits
)
{
     890:	461e      	mov	r6, r3
     892:	4615      	mov	r5, r2
     894:	460f      	mov	r7, r1
     896:	4680      	mov	r8, r0
    SYSREG->WDOG_CR = 0x0000;        /*Disable Watch-dog*/

    MSS_GPIO_init();
     898:	f007 ff96 	bl	87c8 <MSS_GPIO_init>
    MSS_GPIO_config(MSS_GPIO_0 , MSS_GPIO_OUTPUT_MODE);
     89c:	4620      	mov	r0, r4
     89e:	2105      	movs	r1, #5
     8a0:	f007 ffde 	bl	8860 <MSS_GPIO_config>

    /*Keep USB PHY out of Reset*/
    MSS_GPIO_set_output(MSS_GPIO_0 , 0);
     8a4:	4621      	mov	r1, r4
     8a6:	4620      	mov	r0, r4
     8a8:	f007 ffe6 	bl	8878 <MSS_GPIO_set_output>

    g_linecoding_params.bitrate = baud_rate;
     8ac:	f240 1a24 	movw	sl, #292	; 0x124
    g_linecoding_params.datatype = data_bits;

    /*
    Assign call-back function handler structure needed by USB Device Core driver
    */
    MSS_USBD_set_descr_cb_handler(&vcp_descriptors_cb);
     8b0:	f240 1018 	movw	r0, #280	; 0x118
    MSS_GPIO_config(MSS_GPIO_0 , MSS_GPIO_OUTPUT_MODE);

    /*Keep USB PHY out of Reset*/
    MSS_GPIO_set_output(MSS_GPIO_0 , 0);

    g_linecoding_params.bitrate = baud_rate;
     8b4:	f2c2 0a00 	movt	sl, #8192	; 0x2000
    g_linecoding_params.datatype = data_bits;

    /*
    Assign call-back function handler structure needed by USB Device Core driver
    */
    MSS_USBD_set_descr_cb_handler(&vcp_descriptors_cb);
     8b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    MSS_GPIO_config(MSS_GPIO_0 , MSS_GPIO_OUTPUT_MODE);

    /*Keep USB PHY out of Reset*/
    MSS_GPIO_set_output(MSS_GPIO_0 , 0);

    g_linecoding_params.bitrate = baud_rate;
     8bc:	f8ca 8004 	str.w	r8, [sl, #4]
    g_linecoding_params.format = stop_bits;
     8c0:	f88a 7008 	strb.w	r7, [sl, #8]
    g_linecoding_params.paritytype = parity;
     8c4:	f88a 5009 	strb.w	r5, [sl, #9]
    g_linecoding_params.datatype = data_bits;
     8c8:	f88a 600a 	strb.w	r6, [sl, #10]

    /*
    Assign call-back function handler structure needed by USB Device Core driver
    */
    MSS_USBD_set_descr_cb_handler(&vcp_descriptors_cb);
     8cc:	f000 fdec 	bl	14a8 <MSS_USBD_set_descr_cb_handler>

    /*Assign call-back function handler structure needed by USBD-CDC driver.*/
    MSS_USBD_CDC_init(&g_vcp_app_cb, MSS_USB_DEVICE_HS);
     8d0:	f10a 0010 	add.w	r0, sl, #16
     8d4:	4621      	mov	r1, r4
     8d6:	f002 f96d 	bl	2bb4 <MSS_USBD_CDC_init>

    /*Initialize USBD driver driver */
    MSS_USBD_init(MSS_USB_DEVICE_HS);
     8da:	4620      	mov	r0, r4
}
     8dc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    /*Assign call-back function handler structure needed by USBD-CDC driver.*/
    MSS_USBD_CDC_init(&g_vcp_app_cb, MSS_USB_DEVICE_HS);

    /*Initialize USBD driver driver */
    MSS_USBD_init(MSS_USB_DEVICE_HS);
     8e0:	f002 b840 	b.w	2964 <MSS_USBD_init>

000008e4 <NVIC_init>:
     * functions is obsolete on SmartFusion2 devices.
     *
     * Simply remove the call to NVIC_init() from your application code.
     */
    ASSERT(0);
}
     8e4:	4770      	bx	lr
     8e6:	bf00      	nop

000008e8 <NVIC_set_handler>:
     * The function to implement depends on which MSS_INT_F2M[n] signal is used
     * in your Libero design to connect the interrupt signal of the peripheral
     * generating the interrupt.
     */
    ASSERT(0);
}
     8e8:	4770      	bx	lr
     8ea:	bf00      	nop

000008ec <NVIC_set_priority>:
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
}
     8ec:	4770      	bx	lr
     8ee:	bf00      	nop

000008f0 <NVIC_enable_interrupt>:
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
}
     8f0:	4770      	bx	lr
     8f2:	bf00      	nop

000008f4 <NVIC_disable_interrupt>:
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
}
     8f4:	4770      	bx	lr
     8f6:	bf00      	nop

000008f8 <NVIC_clear_interrupt>:
     *      - FabricIrq13_IRQn
     *      - FabricIrq14_IRQn
     *      - FabricIrq15_IRQn
     */
    ASSERT(0);
}
     8f8:	4770      	bx	lr
     8fa:	bf00      	nop

000008fc <HAL_disable_interrupts>:
     8fc:	f3ef 8010 	mrs	r0, PRIMASK
     900:	b672      	cpsid	i
     902:	4770      	bx	lr

00000904 <HAL_restore_interrupts>:
     904:	f380 8810 	msr	PRIMASK, r0
     908:	4770      	bx	lr

0000090a <HW_set_32bit_reg>:
     90a:	6001      	str	r1, [r0, #0]
     90c:	4770      	bx	lr

0000090e <HW_get_32bit_reg>:
     90e:	6800      	ldr	r0, [r0, #0]
     910:	4770      	bx	lr

00000912 <HW_set_32bit_reg_field>:
     912:	b50e      	push	{r1, r2, r3, lr}
     914:	fa03 f301 	lsl.w	r3, r3, r1
     918:	ea03 0302 	and.w	r3, r3, r2
     91c:	6801      	ldr	r1, [r0, #0]
     91e:	ea6f 0202 	mvn.w	r2, r2
     922:	ea01 0102 	and.w	r1, r1, r2
     926:	ea41 0103 	orr.w	r1, r1, r3
     92a:	6001      	str	r1, [r0, #0]
     92c:	bd0e      	pop	{r1, r2, r3, pc}

0000092e <HW_get_32bit_reg_field>:
     92e:	6800      	ldr	r0, [r0, #0]
     930:	ea00 0002 	and.w	r0, r0, r2
     934:	fa20 f001 	lsr.w	r0, r0, r1
     938:	4770      	bx	lr

0000093a <HW_set_16bit_reg>:
     93a:	8001      	strh	r1, [r0, #0]
     93c:	4770      	bx	lr

0000093e <HW_get_16bit_reg>:
     93e:	8800      	ldrh	r0, [r0, #0]
     940:	4770      	bx	lr

00000942 <HW_set_16bit_reg_field>:
     942:	b50e      	push	{r1, r2, r3, lr}
     944:	fa03 f301 	lsl.w	r3, r3, r1
     948:	ea03 0302 	and.w	r3, r3, r2
     94c:	8801      	ldrh	r1, [r0, #0]
     94e:	ea6f 0202 	mvn.w	r2, r2
     952:	ea01 0102 	and.w	r1, r1, r2
     956:	ea41 0103 	orr.w	r1, r1, r3
     95a:	8001      	strh	r1, [r0, #0]
     95c:	bd0e      	pop	{r1, r2, r3, pc}

0000095e <HW_get_16bit_reg_field>:
     95e:	8800      	ldrh	r0, [r0, #0]
     960:	ea00 0002 	and.w	r0, r0, r2
     964:	fa20 f001 	lsr.w	r0, r0, r1
     968:	4770      	bx	lr

0000096a <HW_set_8bit_reg>:
     96a:	7001      	strb	r1, [r0, #0]
     96c:	4770      	bx	lr

0000096e <HW_get_8bit_reg>:
     96e:	7800      	ldrb	r0, [r0, #0]
     970:	4770      	bx	lr

00000972 <HW_set_8bit_reg_field>:
     972:	b50e      	push	{r1, r2, r3, lr}
     974:	fa03 f301 	lsl.w	r3, r3, r1
     978:	ea03 0302 	and.w	r3, r3, r2
     97c:	7801      	ldrb	r1, [r0, #0]
     97e:	ea6f 0202 	mvn.w	r2, r2
     982:	ea01 0102 	and.w	r1, r1, r2
     986:	ea41 0103 	orr.w	r1, r1, r3
     98a:	7001      	strb	r1, [r0, #0]
     98c:	bd0e      	pop	{r1, r2, r3, pc}

0000098e <HW_get_8bit_reg_field>:
     98e:	7800      	ldrb	r0, [r0, #0]
     990:	ea00 0002 	and.w	r0, r0, r2
     994:	fa20 f001 	lsr.w	r0, r0, r1
     998:	4770      	bx	lr
	...

0000099c <USB_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void USB_IRQHandler(void)
#else
void USB_IRQHandler(void)
#endif
{
     99c:	466b      	mov	r3, sp
     99e:	f023 0107 	bic.w	r1, r3, #7
     9a2:	468d      	mov	sp, r1
     9a4:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
MSS_USB_CIF_read_irq_reg
(
    void
)
{
    return (USB->USB_IRQ);
     9a8:	f243 0300 	movw	r3, #12288	; 0x3000
     9ac:	f2c4 0304 	movt	r3, #16388	; 0x4004
     9b0:	7a98      	ldrb	r0, [r3, #10]
     9b2:	b082      	sub	sp, #8
    volatile uint8_t usb_irq;
    volatile uint16_t tx_ep_irq;
    volatile uint16_t rx_ep_irq;
    volatile uint8_t role;

    usb_irq = MSS_USB_CIF_read_irq_reg();
     9b4:	f88d 0007 	strb.w	r0, [sp, #7]
MSS_USB_CIF_read_tx_ep_irq_reg
(
    void
)
{
    return (USB->TX_IRQ);
     9b8:	885a      	ldrh	r2, [r3, #2]
     9ba:	fa1f fc82 	uxth.w	ip, r2
    tx_ep_irq = MSS_USB_CIF_read_tx_ep_irq_reg();
     9be:	f8ad c004 	strh.w	ip, [sp, #4]
MSS_USB_CIF_read_rx_ep_irq_reg
(
    void
)
{
    return (USB->RX_IRQ);
     9c2:	8899      	ldrh	r1, [r3, #4]
     9c4:	b288      	uxth	r0, r1
    rx_ep_irq = MSS_USB_CIF_read_rx_ep_irq_reg();
     9c6:	f8ad 0002 	strh.w	r0, [sp, #2]
     Interrupt occurs but the HostMode bit in DevCtl is also cleared.
     Hence moving Disconnect handling out of get_mode condition.
     In the event of Disconnection, The decision is made based on the B-Device
     bit(DevCtl-D7).
     */
    if(usb_irq & DISCONNECT_IRQ_MASK)
     9ca:	f89d 2007 	ldrb.w	r2, [sp, #7]
     9ce:	f012 0f20 	tst.w	r2, #32
     9d2:	d00a      	beq.n	9ea <USB_IRQHandler+0x4e>
(
    void
)
{
    /*TODO:only valid when session bit is set*/
    return (((USB->DEV_CTRL & DEV_CTRL_B_DEVICE_MASK) ?
     9d4:	f893 0060 	ldrb.w	r0, [r3, #96]	; 0x60
     9d8:	09c2      	lsrs	r2, r0, #7
    {
        role = MSS_USB_CIF_get_role();
     9da:	f88d 2006 	strb.w	r2, [sp, #6]

#ifdef MSS_USB_DEVICE_ENABLED
        if(MSS_USB_DEVICE_ROLE_DEVICE_B == role)
     9de:	f89d c006 	ldrb.w	ip, [sp, #6]
     9e2:	f1bc 0f01 	cmp.w	ip, #1
     9e6:	f000 8152 	beq.w	c8e <USB_IRQHandler+0x2f2>
MSS_USB_CIF_get_mode
(
    void
)
{
    return (((USB->DEV_CTRL & DEV_CTRL_HOST_MODE_MASK) ?
     9ea:	f243 0000 	movw	r0, #12288	; 0x3000
     9ee:	f2c4 0004 	movt	r0, #16388	; 0x4004
     9f2:	f890 c060 	ldrb.w	ip, [r0, #96]	; 0x60
        }
#endif //MSS_USB_HOST_ENABLED
    }

#ifdef MSS_USB_DEVICE_ENABLED
    if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
     9f6:	f01c 0f04 	tst.w	ip, #4
     9fa:	d111      	bne.n	a20 <USB_IRQHandler+0x84>
    {
      if(usb_irq & RESUME_IRQ_MASK)
     9fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
     a00:	f013 0f02 	tst.w	r3, #2
     a04:	f040 8105 	bne.w	c12 <USB_IRQHandler+0x276>
        {
            g_mss_usbd_cb.usbd_resume();
        }
        if(usb_irq & SUSPEND_IRQ_MASK)
     a08:	f89d c007 	ldrb.w	ip, [sp, #7]
     a0c:	f01c 0f01 	tst.w	ip, #1
     a10:	f040 810b 	bne.w	c2a <USB_IRQHandler+0x28e>
        {
            g_mss_usbd_cb.usbd_suspend();
        }
        if(usb_irq & RESET_IRQ_MASK)
     a14:	f89d 2007 	ldrb.w	r2, [sp, #7]
     a18:	f012 0f04 	tst.w	r2, #4
     a1c:	f040 8111 	bne.w	c42 <USB_IRQHandler+0x2a6>
#endif /*SOF interrupt is not processed*/

    }
#endif    //MSS_USB_HOST_ENABLED

    if(tx_ep_irq & 0x0001u)
     a20:	f8bd 3004 	ldrh.w	r3, [sp, #4]
     a24:	f013 0f01 	tst.w	r3, #1
     a28:	f040 80d5 	bne.w	bd6 <USB_IRQHandler+0x23a>
    {
        /*handle EP0 IRQ*/
        MSS_USB_CIF_handle_cep_irq();
    }

    if(tx_ep_irq & 0xFFFEu)    /*EP0 is handled above*/
     a2c:	f8bd c004 	ldrh.w	ip, [sp, #4]
     a30:	f02c 0301 	bic.w	r3, ip, #1
     a34:	0419      	lsls	r1, r3, #16
     a36:	0c08      	lsrs	r0, r1, #16
     a38:	2800      	cmp	r0, #0
     a3a:	d05d      	beq.n	af8 <USB_IRQHandler+0x15c>
    {
        /*Handle TX EP here, pass on the EP numbers.Mask EP0 bit*/
        tx_ep_irq &= 0xFFFEu;
     a3c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
     a40:	f023 0101 	bic.w	r1, r3, #1
     a44:	0408      	lsls	r0, r1, #16
     a46:	0c02      	lsrs	r2, r0, #16
     a48:	f8ad 2004 	strh.w	r2, [sp, #4]
        MSS_USB_CIF_handle_tx_ep_irq(tx_ep_irq);
     a4c:	f8bd 4004 	ldrh.w	r4, [sp, #4]
     a50:	b2a4      	uxth	r4, r4
)
{
    mss_usb_ep_num_t ep_num = MSS_USB_TX_EP_1;
    uint8_t status = 0u;

    while(irq_num)
     a52:	2c00      	cmp	r4, #0
     a54:	d050      	beq.n	af8 <USB_IRQHandler+0x15c>
     a56:	2501      	movs	r5, #1
MSS_USB_CIF_tx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
     a58:	f243 0600 	movw	r6, #12288	; 0x3000
            MSS_USB_CIF_tx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
            {
                status = MSS_USB_CIF_device_tx_errchk(ep_num);
                g_mss_usbd_cb.usbd_ep_tx_complete(ep_num,status);
     a5c:	f240 1a60 	movw	sl, #352	; 0x160
     a60:	f2c4 0604 	movt	r6, #16388	; 0x4004
     a64:	f2c2 0a00 	movt	sl, #8192	; 0x2000
     a68:	46a8      	mov	r8, r5
     a6a:	e03f      	b.n	aec <USB_IRQHandler+0x150>
     a6c:	fa08 f705 	lsl.w	r7, r8, r5
     a70:	88f1      	ldrh	r1, [r6, #6]
     a72:	b2bf      	uxth	r7, r7
     a74:	b288      	uxth	r0, r1
     a76:	ea20 0207 	bic.w	r2, r0, r7
     a7a:	80f2      	strh	r2, [r6, #6]
MSS_USB_CIF_get_mode
(
    void
)
{
    return (((USB->DEV_CTRL & DEV_CTRL_HOST_MODE_MASK) ?
     a7c:	f896 c060 	ldrb.w	ip, [r6, #96]	; 0x60

        if(irq_num & MSS_USB_WORD_BIT_0_MASK)
        {
            MSS_USB_CIF_tx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
     a80:	f01c 0f04 	tst.w	ip, #4
     a84:	d12a      	bne.n	adc <USB_IRQHandler+0x140>
MSS_USB_CIF_tx_ep_is_underrun
(
    mss_usb_ep_num_t ep_num
)
{
   return (((USB->ENDPOINT[ep_num].TX_CSR & TxCSRL_REG_EPN_UNDERRUN_MASK) ?
     a86:	f105 0310 	add.w	r3, r5, #16
     a8a:	011a      	lsls	r2, r3, #4
     a8c:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
     a90:	f50c 2286 	add.w	r2, ip, #274432	; 0x43000
     a94:	f8b2 e002 	ldrh.w	lr, [r2, #2]
     a98:	f01e 0104 	ands.w	r1, lr, #4
     a9c:	d007      	beq.n	aae <USB_IRQHandler+0x112>
MSS_USB_CIF_tx_ep_clr_underrun
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_UNDERRUN_MASK;
     a9e:	f8b2 e002 	ldrh.w	lr, [r2, #2]
     aa2:	2101      	movs	r1, #1
     aa4:	f02e 0004 	bic.w	r0, lr, #4
     aa8:	0400      	lsls	r0, r0, #16
     aaa:	0c00      	lsrs	r0, r0, #16
     aac:	8050      	strh	r0, [r2, #2]
MSS_USB_CIF_tx_ep_is_stall_sent_bit
(
    mss_usb_ep_num_t ep_num
)
{
    return (uint8_t)(((USB->ENDPOINT[ep_num].TX_CSR & TxCSRL_REG_EPN_STALL_SENT_MASK) ?
     aae:	011a      	lsls	r2, r3, #4
     ab0:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
     ab4:	f503 2386 	add.w	r3, r3, #274432	; 0x43000
     ab8:	f8b3 c002 	ldrh.w	ip, [r3, #2]
     abc:	f01c 0f20 	tst.w	ip, #32
     ac0:	d008      	beq.n	ad4 <USB_IRQHandler+0x138>
MSS_USB_CIF_tx_ep_clr_stall_sent_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_STALL_SENT_MASK;
     ac2:	f8b3 e002 	ldrh.w	lr, [r3, #2]
        status |= TX_EP_UNDER_RUN_ERROR;
        MSS_USB_CIF_tx_ep_clr_underrun(ep_num);
    }
    if(MSS_USB_CIF_tx_ep_is_stall_sent_bit(ep_num))
    {
        status |= TX_EP_STALL_ERROR;
     ac6:	f041 0102 	orr.w	r1, r1, #2
     aca:	f02e 0020 	bic.w	r0, lr, #32
     ace:	0402      	lsls	r2, r0, #16
     ad0:	0c10      	lsrs	r0, r2, #16
     ad2:	8058      	strh	r0, [r3, #2]
            MSS_USB_CIF_tx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
            {
                status = MSS_USB_CIF_device_tx_errchk(ep_num);
                g_mss_usbd_cb.usbd_ep_tx_complete(ep_num,status);
     ad4:	f8da 3004 	ldr.w	r3, [sl, #4]
     ad8:	4628      	mov	r0, r5
     ada:	4798      	blx	r3
MSS_USB_CIF_tx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
     adc:	f8b6 c006 	ldrh.w	ip, [r6, #6]
     ae0:	fa1f f18c 	uxth.w	r1, ip
     ae4:	430f      	orrs	r7, r1
     ae6:	80f7      	strh	r7, [r6, #6]
#endif  //MSS_USB_HOST_ENABLED

            MSS_USB_CIF_tx_ep_enable_irq(ep_num);
        }
        status = 0u; /*resetting for next EP status*/
        ++ep_num;
     ae8:	3501      	adds	r5, #1
     aea:	b2ed      	uxtb	r5, r5
    mss_usb_ep_num_t ep_num = MSS_USB_TX_EP_1;
    uint8_t status = 0u;

    while(irq_num)
    {
        irq_num >>= 1u;                                  /*EP1 starts from D1*/
     aec:	0864      	lsrs	r4, r4, #1

        if(irq_num & MSS_USB_WORD_BIT_0_MASK)
     aee:	f014 0f01 	tst.w	r4, #1
     af2:	d1bb      	bne.n	a6c <USB_IRQHandler+0xd0>
)
{
    mss_usb_ep_num_t ep_num = MSS_USB_TX_EP_1;
    uint8_t status = 0u;

    while(irq_num)
     af4:	2c00      	cmp	r4, #0
     af6:	d1f7      	bne.n	ae8 <USB_IRQHandler+0x14c>
        /*Handle TX EP here, pass on the EP numbers.Mask EP0 bit*/
        tx_ep_irq &= 0xFFFEu;
        MSS_USB_CIF_handle_tx_ep_irq(tx_ep_irq);
    }

    if(rx_ep_irq & 0xFFFEu)    /*bit0 is not defined*/
     af8:	f8bd 1002 	ldrh.w	r1, [sp, #2]
     afc:	f021 0301 	bic.w	r3, r1, #1
     b00:	0418      	lsls	r0, r3, #16
     b02:	0c02      	lsrs	r2, r0, #16
     b04:	2a00      	cmp	r2, #0
     b06:	d061      	beq.n	bcc <USB_IRQHandler+0x230>
    {
        /*Handle RX EP here, pass on the EP numbers*/
        MSS_USB_CIF_handle_rx_ep_irq(rx_ep_irq);
     b08:	f8bd 4002 	ldrh.w	r4, [sp, #2]
     b0c:	b2a4      	uxth	r4, r4
{
    mss_usb_ep_num_t ep_num = MSS_USB_RX_EP_1;
    uint8_t status = 0u;


    while(irq_num)
     b0e:	2c00      	cmp	r4, #0
     b10:	d05c      	beq.n	bcc <USB_IRQHandler+0x230>
     b12:	2501      	movs	r5, #1
MSS_USB_CIF_rx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
     b14:	f243 0600 	movw	r6, #12288	; 0x3000
            MSS_USB_CIF_rx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
            {
                status = MSS_USB_CIF_device_rx_errchk(ep_num);
                g_mss_usbd_cb.usbd_ep_rx(ep_num, status);
     b18:	f240 1a60 	movw	sl, #352	; 0x160
     b1c:	f2c4 0604 	movt	r6, #16388	; 0x4004
     b20:	f2c2 0a00 	movt	sl, #8192	; 0x2000
     b24:	46a8      	mov	r8, r5
     b26:	e04b      	b.n	bc0 <USB_IRQHandler+0x224>
     b28:	fa08 f705 	lsl.w	r7, r8, r5
     b2c:	8933      	ldrh	r3, [r6, #8]
     b2e:	b2bf      	uxth	r7, r7
     b30:	b298      	uxth	r0, r3
     b32:	ea20 0207 	bic.w	r2, r0, r7
     b36:	8132      	strh	r2, [r6, #8]
MSS_USB_CIF_get_mode
(
    void
)
{
    return (((USB->DEV_CTRL & DEV_CTRL_HOST_MODE_MASK) ?
     b38:	f896 c060 	ldrb.w	ip, [r6, #96]	; 0x60

        if(irq_num & MSS_USB_WORD_BIT_0_MASK)
        {
            MSS_USB_CIF_rx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
     b3c:	f01c 0f04 	tst.w	ip, #4
     b40:	d136      	bne.n	bb0 <USB_IRQHandler+0x214>
MSS_USB_CIF_rx_ep_is_overrun
(
    mss_usb_ep_num_t ep_num
)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_OVERRUN_MASK) ?
     b42:	f105 0210 	add.w	r2, r5, #16
     b46:	0110      	lsls	r0, r2, #4
     b48:	f100 4180 	add.w	r1, r0, #1073741824	; 0x40000000
     b4c:	f501 2386 	add.w	r3, r1, #274432	; 0x43000
     b50:	f8b3 e006 	ldrh.w	lr, [r3, #6]
     b54:	f01e 0104 	ands.w	r1, lr, #4
     b58:	d007      	beq.n	b6a <USB_IRQHandler+0x1ce>
MSS_USB_CIF_rx_ep_clr_overrun
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_OVERRUN_MASK;
     b5a:	f8b3 c006 	ldrh.w	ip, [r3, #6]
     b5e:	2101      	movs	r1, #1
     b60:	f02c 0004 	bic.w	r0, ip, #4
     b64:	0400      	lsls	r0, r0, #16
     b66:	0c00      	lsrs	r0, r0, #16
     b68:	80d8      	strh	r0, [r3, #6]
MSS_USB_CIF_rx_ep_is_stall_sent_bit
(
    mss_usb_ep_num_t ep_num
)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_STALL_SENT_MASK) ?
     b6a:	0110      	lsls	r0, r2, #4
     b6c:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
     b70:	f503 2386 	add.w	r3, r3, #274432	; 0x43000
     b74:	f8b3 e006 	ldrh.w	lr, [r3, #6]
     b78:	f01e 0f40 	tst.w	lr, #64	; 0x40
     b7c:	d008      	beq.n	b90 <USB_IRQHandler+0x1f4>
MSS_USB_CIF_rx_ep_clr_stall_sent_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_STALL_SENT_MASK;
     b7e:	f8b3 c006 	ldrh.w	ip, [r3, #6]
        status |= RX_EP_OVER_RUN_ERROR;
        MSS_USB_CIF_rx_ep_clr_overrun(ep_num);
    }
    if(MSS_USB_CIF_rx_ep_is_stall_sent_bit(ep_num))
    {
        status |= RX_EP_STALL_ERROR;
     b82:	f041 0102 	orr.w	r1, r1, #2
     b86:	f02c 0040 	bic.w	r0, ip, #64	; 0x40
     b8a:	0400      	lsls	r0, r0, #16
     b8c:	0c00      	lsrs	r0, r0, #16
     b8e:	80d8      	strh	r0, [r3, #6]
MSS_USB_CIF_rx_ep_is_dataerr
(
    mss_usb_ep_num_t ep_num
)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_DATA_ERR_MASK) ?
     b90:	0113      	lsls	r3, r2, #4
     b92:	f103 4080 	add.w	r0, r3, #1073741824	; 0x40000000
     b96:	f500 2386 	add.w	r3, r0, #274432	; 0x43000
     b9a:	f8b3 e006 	ldrh.w	lr, [r3, #6]
            MSS_USB_CIF_rx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
            {
                status = MSS_USB_CIF_device_rx_errchk(ep_num);
                g_mss_usbd_cb.usbd_ep_rx(ep_num, status);
     b9e:	f8da 2000 	ldr.w	r2, [sl]
     ba2:	f01e 0f08 	tst.w	lr, #8
        MSS_USB_CIF_rx_ep_clr_stall_sent_bit(ep_num);
    }
    if(MSS_USB_CIF_rx_ep_is_dataerr(ep_num))
    {
        /*This error will be cleared when RxPktRdy bit is cleared.*/
        status |= RX_EP_DATA_ERROR;
     ba6:	bf18      	it	ne
     ba8:	f041 0104 	orrne.w	r1, r1, #4
            MSS_USB_CIF_rx_ep_disable_irq(ep_num);
#ifdef MSS_USB_DEVICE_ENABLED
            if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
            {
                status = MSS_USB_CIF_device_rx_errchk(ep_num);
                g_mss_usbd_cb.usbd_ep_rx(ep_num, status);
     bac:	4628      	mov	r0, r5
     bae:	4790      	blx	r2
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
     bb0:	f8b6 c008 	ldrh.w	ip, [r6, #8]
     bb4:	fa1f f18c 	uxth.w	r1, ip
     bb8:	430f      	orrs	r7, r1
     bba:	8137      	strh	r7, [r6, #8]
            }
#endif //MSS_USB_HOST_ENABLED
            MSS_USB_CIF_rx_ep_enable_irq(ep_num);
        }
        status = 0u; /*resetting for next EP status*/
        ++ep_num;
     bbc:	3501      	adds	r5, #1
     bbe:	b2ed      	uxtb	r5, r5
    uint8_t status = 0u;


    while(irq_num)
    {
        irq_num >>= 1u;  /*EP1 starts from D1*/
     bc0:	0864      	lsrs	r4, r4, #1

        if(irq_num & MSS_USB_WORD_BIT_0_MASK)
     bc2:	f014 0f01 	tst.w	r4, #1
     bc6:	d1af      	bne.n	b28 <USB_IRQHandler+0x18c>
{
    mss_usb_ep_num_t ep_num = MSS_USB_RX_EP_1;
    uint8_t status = 0u;


    while(irq_num)
     bc8:	2c00      	cmp	r4, #0
     bca:	d1f7      	bne.n	bbc <USB_IRQHandler+0x220>
    if(rx_ep_irq & 0xFFFEu)    /*bit0 is not defined*/
    {
        /*Handle RX EP here, pass on the EP numbers*/
        MSS_USB_CIF_handle_rx_ep_irq(rx_ep_irq);
    }
}
     bcc:	b002      	add	sp, #8
     bce:	e8bd 45f1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, r8, sl, lr}
     bd2:	4685      	mov	sp, r0
     bd4:	4770      	bx	lr
MSS_USB_CIF_set_index_reg
(
    uint8_t index
)
{
    USB->INDEX = index;
     bd6:	f243 0300 	movw	r3, #12288	; 0x3000
     bda:	f2c4 0304 	movt	r3, #16388	; 0x4004
     bde:	2200      	movs	r2, #0
     be0:	739a      	strb	r2, [r3, #14]
MSS_USB_CIF_get_mode
(
    void
)
{
    return (((USB->DEV_CTRL & DEV_CTRL_HOST_MODE_MASK) ?
     be2:	f893 0060 	ldrb.w	r0, [r3, #96]	; 0x60
    uint8_t status = 0u;

    MSS_USB_CIF_set_index_reg(MSS_USB_CEP);

#ifdef MSS_USB_DEVICE_ENABLED
    if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
     be6:	f010 0f04 	tst.w	r0, #4
     bea:	f47f af1f 	bne.w	a2c <USB_IRQHandler+0x90>
MSS_USB_CIF_cep_is_stall_sent
(
    void
)
{
    return (((USB->INDEXED_CSR.DEVICE_EP0.CSR0 & CSR0L_DEV_STALL_SENT_MASK) ?
     bee:	8a59      	ldrh	r1, [r3, #18]
MSS_USB_CIF_cep_clr_stall_sent
(
    void
)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 &= ~CSR0L_DEV_STALL_SENT_MASK;
     bf0:	8a5a      	ldrh	r2, [r3, #18]
MSS_USB_CIF_cep_is_stall_sent
(
    void
)
{
    return (((USB->INDEXED_CSR.DEVICE_EP0.CSR0 & CSR0L_DEV_STALL_SENT_MASK) ?
     bf2:	f011 0f04 	tst.w	r1, #4
     bf6:	d056      	beq.n	ca6 <USB_IRQHandler+0x30a>
MSS_USB_CIF_cep_clr_stall_sent
(
    void
)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 &= ~CSR0L_DEV_STALL_SENT_MASK;
     bf8:	f022 0204 	bic.w	r2, r2, #4
     bfc:	0411      	lsls	r1, r2, #16
     bfe:	0c0a      	lsrs	r2, r1, #16
    {
        if(MSS_USB_CIF_cep_is_stall_sent())
        {
            status |= CTRL_EP_STALL_ERROR;
            MSS_USB_CIF_cep_clr_stall_sent();
            g_mss_usbd_cb.usbd_cep_setup(status);
     c00:	f240 1060 	movw	r0, #352	; 0x160
     c04:	825a      	strh	r2, [r3, #18]
     c06:	f2c2 0000 	movt	r0, #8192	; 0x2000
     c0a:	6883      	ldr	r3, [r0, #8]
     c0c:	2002      	movs	r0, #2
     c0e:	4798      	blx	r3
     c10:	e70c      	b.n	a2c <USB_IRQHandler+0x90>
#ifdef MSS_USB_DEVICE_ENABLED
    if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
    {
      if(usb_irq & RESUME_IRQ_MASK)
        {
            g_mss_usbd_cb.usbd_resume();
     c12:	f240 1160 	movw	r1, #352	; 0x160
     c16:	f2c2 0100 	movt	r1, #8192	; 0x2000
     c1a:	6a0a      	ldr	r2, [r1, #32]
     c1c:	4790      	blx	r2
        }
        if(usb_irq & SUSPEND_IRQ_MASK)
     c1e:	f89d c007 	ldrb.w	ip, [sp, #7]
     c22:	f01c 0f01 	tst.w	ip, #1
     c26:	f43f aef5 	beq.w	a14 <USB_IRQHandler+0x78>
        {
            g_mss_usbd_cb.usbd_suspend();
     c2a:	f240 1360 	movw	r3, #352	; 0x160
     c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
     c32:	69d8      	ldr	r0, [r3, #28]
     c34:	4780      	blx	r0
        }
        if(usb_irq & RESET_IRQ_MASK)
     c36:	f89d 2007 	ldrb.w	r2, [sp, #7]
     c3a:	f012 0f04 	tst.w	r2, #4
     c3e:	f43f aeef 	beq.w	a20 <USB_IRQHandler+0x84>
     c42:	f243 0300 	movw	r3, #12288	; 0x3000
     c46:	f2c4 0304 	movt	r3, #16388	; 0x4004
     c4a:	2200      	movs	r2, #0
     c4c:	739a      	strb	r2, [r3, #14]
/*******************************************************************************
 * Enables USB interrupts.
 */
static __INLINE void MSS_USB_CIF_enable_usbirq(uint8_t irq_mask)
{
    USB->USB_ENABLE |= (irq_mask);
     c4e:	f893 c00b 	ldrb.w	ip, [r3, #11]
        {
            MSS_USB_CIF_set_index_reg(MSS_USB_CEP);
            MSS_USB_CIF_enable_usbirq(DISCONNECT_IRQ_MASK | SUSPEND_IRQ_MASK);
            cep_state = MSS_USB_CTRL_EP_IDLE;
     c52:	f640 31ac 	movw	r1, #2988	; 0xbac
     c56:	f04c 0e21 	orr.w	lr, ip, #33	; 0x21
     c5a:	f2c2 0100 	movt	r1, #8192	; 0x2000
     c5e:	f883 e00b 	strb.w	lr, [r3, #11]
     c62:	700a      	strb	r2, [r1, #0]
MSS_USB_CIF_clr_usb_irq_reg
(
    void
)
{
    USB->USB_IRQ = 0u;
     c64:	729a      	strb	r2, [r3, #10]
(
    void
)
{
    /*Setting SERVICED_SETUP_END bit clears SetupEnd bit*/
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 |= CSR0L_DEV_SERVICED_SETUP_END_MASK;
     c66:	8a5a      	ldrh	r2, [r3, #18]
            MSS_USB_CIF_clr_usb_irq_reg();
            MSS_USB_CIF_cep_clr_setupend();
            MSS_USB_CIF_cep_clr_stall_sent();
            g_mss_usbd_cb.usbd_reset();
     c68:	f240 1160 	movw	r1, #352	; 0x160
     c6c:	b290      	uxth	r0, r2
     c6e:	f040 0c80 	orr.w	ip, r0, #128	; 0x80
     c72:	f8a3 c012 	strh.w	ip, [r3, #18]
MSS_USB_CIF_cep_clr_stall_sent
(
    void
)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 &= ~CSR0L_DEV_STALL_SENT_MASK;
     c76:	f8b3 e012 	ldrh.w	lr, [r3, #18]
     c7a:	f2c2 0100 	movt	r1, #8192	; 0x2000
     c7e:	f02e 0204 	bic.w	r2, lr, #4
     c82:	0410      	lsls	r0, r2, #16
     c84:	0c02      	lsrs	r2, r0, #16
     c86:	825a      	strh	r2, [r3, #18]
     c88:	6988      	ldr	r0, [r1, #24]
     c8a:	4780      	blx	r0
     c8c:	e6c8      	b.n	a20 <USB_IRQHandler+0x84>
     c8e:	7ad9      	ldrb	r1, [r3, #11]

#ifdef MSS_USB_DEVICE_ENABLED
        if(MSS_USB_DEVICE_ROLE_DEVICE_B == role)
        {
            MSS_USB_CIF_enable_usbirq(RESET_IRQ_MASK);
            g_mss_usbd_cb.usbd_disconnect();
     c90:	f240 1260 	movw	r2, #352	; 0x160
     c94:	f041 0e04 	orr.w	lr, r1, #4
     c98:	f883 e00b 	strb.w	lr, [r3, #11]
     c9c:	f2c2 0200 	movt	r2, #8192	; 0x2000
     ca0:	6a53      	ldr	r3, [r2, #36]	; 0x24
     ca2:	4798      	blx	r3
     ca4:	e6a1      	b.n	9ea <USB_IRQHandler+0x4e>
MSS_USB_CIF_cep_is_setupend
(
    void
)
{
    return (((USB->INDEXED_CSR.DEVICE_EP0.CSR0 & CSR0L_DEV_SETUP_END_MASK) ?
     ca6:	f012 0010 	ands.w	r0, r2, #16
     caa:	d011      	beq.n	cd0 <USB_IRQHandler+0x334>
(
    void
)
{
    /*Setting SERVICED_SETUP_END bit clears SetupEnd bit*/
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 |= CSR0L_DEV_SERVICED_SETUP_END_MASK;
     cac:	8a58      	ldrh	r0, [r3, #18]
                else
                {
                    status &= ~CTRL_EP_SETUP_END_ERROR;
                }

                g_mss_usbd_cb.usbd_cep_setup(status);
     cae:	f240 1260 	movw	r2, #352	; 0x160
     cb2:	fa1f fc80 	uxth.w	ip, r0
     cb6:	f04c 0e80 	orr.w	lr, ip, #128	; 0x80
     cba:	f8a3 e012 	strh.w	lr, [r3, #18]
MSS_USB_CIF_cep_is_rxpktrdy
(
    void
)
{
    return (((USB->INDEXED_CSR.DEVICE_EP0.CSR0 & CSR0L_DEV_RX_PKT_RDY_MASK) ?
     cbe:	8a59      	ldrh	r1, [r3, #18]
     cc0:	f2c2 0200 	movt	r2, #8192	; 0x2000
     cc4:	43c8      	mvns	r0, r1
     cc6:	6893      	ldr	r3, [r2, #8]
     cc8:	f000 0001 	and.w	r0, r0, #1
     ccc:	4798      	blx	r3
     cce:	e6ad      	b.n	a2c <USB_IRQHandler+0x90>
            }
            else
            {
                if(cep_state == MSS_USB_CTRL_EP_IDLE)
     cd0:	f640 32ac 	movw	r2, #2988	; 0xbac
     cd4:	f2c2 0200 	movt	r2, #8192	; 0x2000
     cd8:	7811      	ldrb	r1, [r2, #0]
     cda:	468c      	mov	ip, r1
     cdc:	b1a9      	cbz	r1, d0a <USB_IRQHandler+0x36e>
                    if(MSS_USB_CIF_cep_is_rxpktrdy())
                    {
                        g_mss_usbd_cb.usbd_cep_setup(status);
                    }
                }
                else if (cep_state == MSS_USB_CTRL_EP_TX)
     cde:	f892 c000 	ldrb.w	ip, [r2]
     ce2:	f1bc 0f01 	cmp.w	ip, #1
     ce6:	d01d      	beq.n	d24 <USB_IRQHandler+0x388>
                {
                    g_mss_usbd_cb.usbd_cep_tx_complete(status);
                }
                else if(cep_state == MSS_USB_CTRL_EP_RX)
     ce8:	7811      	ldrb	r1, [r2, #0]
     cea:	2902      	cmp	r1, #2
     cec:	f47f ae9e 	bne.w	a2c <USB_IRQHandler+0x90>
     cf0:	f8b3 c012 	ldrh.w	ip, [r3, #18]
     cf4:	f01c 0f01 	tst.w	ip, #1
     cf8:	f43f ae98 	beq.w	a2c <USB_IRQHandler+0x90>
                {
                    if(MSS_USB_CIF_cep_is_rxpktrdy())
                    {
                        g_mss_usbd_cb.usbd_cep_rx(status);
     cfc:	f240 1260 	movw	r2, #352	; 0x160
     d00:	f2c2 0200 	movt	r2, #8192	; 0x2000
     d04:	68d3      	ldr	r3, [r2, #12]
     d06:	4798      	blx	r3
     d08:	e690      	b.n	a2c <USB_IRQHandler+0x90>
     d0a:	8a5b      	ldrh	r3, [r3, #18]
     d0c:	f013 0f01 	tst.w	r3, #1
     d10:	f43f ae8c 	beq.w	a2c <USB_IRQHandler+0x90>
            {
                if(cep_state == MSS_USB_CTRL_EP_IDLE)
                {
                    if(MSS_USB_CIF_cep_is_rxpktrdy())
                    {
                        g_mss_usbd_cb.usbd_cep_setup(status);
     d14:	f240 1160 	movw	r1, #352	; 0x160
     d18:	f2c2 0100 	movt	r1, #8192	; 0x2000
     d1c:	688a      	ldr	r2, [r1, #8]
     d1e:	4660      	mov	r0, ip
     d20:	4790      	blx	r2
     d22:	e683      	b.n	a2c <USB_IRQHandler+0x90>
                    }
                }
                else if (cep_state == MSS_USB_CTRL_EP_TX)
                {
                    g_mss_usbd_cb.usbd_cep_tx_complete(status);
     d24:	f240 1260 	movw	r2, #352	; 0x160
     d28:	f2c2 0200 	movt	r2, #8192	; 0x2000
     d2c:	6913      	ldr	r3, [r2, #16]
     d2e:	4798      	blx	r3
     d30:	e67c      	b.n	a2c <USB_IRQHandler+0x90>
     d32:	bf00      	nop

00000d34 <USB_DMA_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void USB_DMA_IRQHandler(void)
#else
void USB_DMA_IRQHandler(void)
#endif
{
     d34:	4668      	mov	r0, sp
     d36:	f020 0107 	bic.w	r1, r0, #7
     d3a:	468d      	mov	sp, r1
     d3c:	e92d 45f1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, sl, lr}
MSS_USB_CIF_dma_read_irq
(
    void
)
{
    return (USB->DMA_CHANNEL[0].IRQ);   /*IRQ is valid only for DMA chan0*/
     d40:	f243 0300 	movw	r3, #12288	; 0x3000
     d44:	f2c4 0304 	movt	r3, #16388	; 0x4004
     d48:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
     d4c:	b082      	sub	sp, #8
    mss_usb_dma_dir_t dma_dir;
    mss_usb_ep_num_t ep_num;
    uint8_t dma_irq;
    uint32_t increamented_addr=0;

    dma_irq = MSS_USB_CIF_dma_read_irq();
     d4e:	b2e4      	uxtb	r4, r4

    while(dma_irq)
     d50:	2c00      	cmp	r4, #0
     d52:	d040      	beq.n	dd6 <USB_DMA_IRQHandler+0xa2>
     d54:	2600      	movs	r6, #0
#endif //MSS_USB_HOST_ENABLED
#ifdef MSS_USB_DEVICE_ENABLED
                if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
                {
                    /*Call the device mode logical layer driver callback function*/
                    g_mss_usbd_cb.usbd_dma_handler(ep_num, dma_dir, status,increamented_addr);
     d56:	f240 1860 	movw	r8, #352	; 0x160
MSS_USB_CIF_dma_stop_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL &= ~DMA_CNTL_REG_START_XFR_MASK;
     d5a:	469a      	mov	sl, r3
     d5c:	f2c2 0800 	movt	r8, #8192	; 0x2000
    uint8_t dma_irq;
    uint32_t increamented_addr=0;

    dma_irq = MSS_USB_CIF_dma_read_irq();

    while(dma_irq)
     d60:	4635      	mov	r5, r6
     d62:	e009      	b.n	d78 <USB_DMA_IRQHandler+0x44>
MSS_USB_CIF_dma_clr_bus_err
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL  &= ~DMA_CNTL_REG_DMA_BUS_ERR_MASK;
     d64:	685a      	ldr	r2, [r3, #4]
            ep_num = (mss_usb_ep_num_t)MSS_USB_CIF_dma_get_epnum(dma_channel);
            dma_dir = (mss_usb_dma_dir_t)MSS_USB_CIF_dma_get_dir(dma_channel);

            if(MSS_USB_CIF_dma_is_bus_err(dma_channel))
            {
                status |=DMA_XFR_ERROR;
     d66:	f046 0640 	orr.w	r6, r6, #64	; 0x40
     d6a:	f422 7180 	bic.w	r1, r2, #256	; 0x100
     d6e:	6059      	str	r1, [r3, #4]
    uint8_t dma_irq;
    uint32_t increamented_addr=0;

    dma_irq = MSS_USB_CIF_dma_read_irq();

    while(dma_irq)
     d70:	0864      	lsrs	r4, r4, #1
     d72:	d030      	beq.n	dd6 <USB_DMA_IRQHandler+0xa2>
                }
#endif //MSS_USB_DEVICE_ENABLED

            }
        }
        dma_channel++;
     d74:	3501      	adds	r5, #1
     d76:	b2ed      	uxtb	r5, r5

    dma_irq = MSS_USB_CIF_dma_read_irq();

    while(dma_irq)
    {
        if(dma_irq & MSS_USB_BYTE_BIT_0_MASK)
     d78:	f014 0f01 	tst.w	r4, #1
     d7c:	d0f8      	beq.n	d70 <USB_DMA_IRQHandler+0x3c>
MSS_USB_CIF_dma_stop_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL &= ~DMA_CNTL_REG_START_XFR_MASK;
     d7e:	f243 2300 	movw	r3, #12800	; 0x3200
     d82:	0128      	lsls	r0, r5, #4
     d84:	f2c4 0304 	movt	r3, #16388	; 0x4004
     d88:	18c3      	adds	r3, r0, r3
     d8a:	685a      	ldr	r2, [r3, #4]
     d8c:	f022 0101 	bic.w	r1, r2, #1
     d90:	6059      	str	r1, [r3, #4]
    This API will return numbers from 0 to 15, mss_usb_ep_num_t maps it to TX_EP 
    numbers. Using DMA DIR, CIF driver should correctly map it as TX EP or RX EP.
    */
    volatile uint8_t ep_num;

    ep_num = (USB->DMA_CHANNEL[dma_channel].CNTL  & DMA_CNTL_REG_DMA_EP_NUM_MASK);
     d92:	6858      	ldr	r0, [r3, #4]
     d94:	f000 0cf0 	and.w	ip, r0, #240	; 0xf0
     d98:	f88d c007 	strb.w	ip, [sp, #7]
    return (mss_usb_ep_num_t)(ep_num >> DMA_CNTL_REG_DMA_EP_NUM_SHIFT);
     d9c:	f89d 0007 	ldrb.w	r0, [sp, #7]
MSS_USB_CIF_dma_get_dir
(
    mss_usb_dma_channel_t dma_channel
)
{
    return(((USB->DMA_CHANNEL[dma_channel].CNTL & DMA_CNTL_REG_DMA_DIR_MASK) ?
     da0:	6859      	ldr	r1, [r3, #4]
MSS_USB_CIF_dma_is_bus_err
(
    mss_usb_dma_channel_t dma_channel
)
{
    return (((USB->DMA_CHANNEL[dma_channel].CNTL  & DMA_CNTL_REG_DMA_BUS_ERR_MASK) ?
     da2:	685a      	ldr	r2, [r3, #4]
     da4:	f412 7f80 	tst.w	r2, #256	; 0x100
     da8:	d1dc      	bne.n	d64 <USB_DMA_IRQHandler+0x30>
MSS_USB_CIF_dma_read_addr
(
    mss_usb_dma_channel_t dma_channel
)
{
    return (USB->DMA_CHANNEL[dma_channel].ADDR);
     daa:	012a      	lsls	r2, r5, #4
     dac:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
     db0:	f50c 2386 	add.w	r3, ip, #274432	; 0x43000
MSS_USB_CIF_dma_get_dir
(
    mss_usb_dma_channel_t dma_channel
)
{
    return(((USB->DMA_CHANNEL[dma_channel].CNTL & DMA_CNTL_REG_DMA_DIR_MASK) ?
     db4:	f3c1 0140 	ubfx	r1, r1, #1, #1
    numbers. Using DMA DIR, CIF driver should correctly map it as TX EP or RX EP.
    */
    volatile uint8_t ep_num;

    ep_num = (USB->DMA_CHANNEL[dma_channel].CNTL  & DMA_CNTL_REG_DMA_EP_NUM_MASK);
    return (mss_usb_ep_num_t)(ep_num >> DMA_CNTL_REG_DMA_EP_NUM_SHIFT);
     db8:	0900      	lsrs	r0, r0, #4
MSS_USB_CIF_dma_read_addr
(
    mss_usb_dma_channel_t dma_channel
)
{
    return (USB->DMA_CHANNEL[dma_channel].ADDR);
     dba:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
                MSS_USB_CIF_dma_clr_bus_err(dma_channel);
            }
            else
            {
                increamented_addr = MSS_USB_CIF_dma_read_addr(dma_channel);
                if(MSS_USB_DMA_READ == dma_dir)    /*TX EP*/
     dbe:	b979      	cbnz	r1, de0 <USB_DMA_IRQHandler+0xac>
MSS_USB_CIF_get_mode
(
    void
)
{
    return (((USB->DEV_CTRL & DEV_CTRL_HOST_MODE_MASK) ?
     dc0:	f89a 2060 	ldrb.w	r2, [sl, #96]	; 0x60
                    /*Call the host mode logical layer driver callback function*/
                    g_mss_usbh_cb.usbh_dma_handler(ep_num, dma_dir, status,increamented_addr);
                }
#endif //MSS_USB_HOST_ENABLED
#ifdef MSS_USB_DEVICE_ENABLED
                if(MSS_USB_CORE_MODE_DEVICE == MSS_USB_CIF_get_mode())
     dc4:	f012 0f04 	tst.w	r2, #4
     dc8:	d1d2      	bne.n	d70 <USB_DMA_IRQHandler+0x3c>
                {
                    /*Call the device mode logical layer driver callback function*/
                    g_mss_usbd_cb.usbd_dma_handler(ep_num, dma_dir, status,increamented_addr);
     dca:	f8d8 7028 	ldr.w	r7, [r8, #40]	; 0x28
     dce:	4632      	mov	r2, r6
     dd0:	47b8      	blx	r7
    uint8_t dma_irq;
    uint32_t increamented_addr=0;

    dma_irq = MSS_USB_CIF_dma_read_irq();

    while(dma_irq)
     dd2:	0864      	lsrs	r4, r4, #1
     dd4:	d1ce      	bne.n	d74 <USB_DMA_IRQHandler+0x40>
            }
        }
        dma_channel++;
        dma_irq >>= 1u;
    }
}
     dd6:	b002      	add	sp, #8
     dd8:	e8bd 45f1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, r8, sl, lr}
     ddc:	4685      	mov	sp, r0
     dde:	4770      	bx	lr
MSS_USB_CIF_tx_ep_is_dma_enabled
(
    mss_usb_ep_num_t ep_num
)
{
    return (((USB->ENDPOINT[ep_num].TX_CSR & TxCSRH_REG_EPN_ENABLE_DMA_MASK) ?
     de0:	f243 1200 	movw	r2, #12544	; 0x3100
     de4:	ea4f 1c00 	mov.w	ip, r0, lsl #4
     de8:	f2c4 0204 	movt	r2, #16388	; 0x4004
     dec:	4462      	add	r2, ip
     dee:	f8b2 c002 	ldrh.w	ip, [r2, #2]
     df2:	f41c 5f80 	tst.w	ip, #4096	; 0x1000
MSS_USB_CIF_tx_ep_disable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRH_REG_EPN_ENABLE_DMA_MASK;
     df6:	bf1f      	itttt	ne
     df8:	f8b2 c002 	ldrhne.w	ip, [r2, #2]
     dfc:	f42c 5c80 	bicne.w	ip, ip, #4096	; 0x1000
     e00:	ea4f 4c0c 	movne.w	ip, ip, lsl #16
     e04:	ea4f 4c1c 	movne.w	ip, ip, lsr #16
     e08:	bf18      	it	ne
     e0a:	f8a2 c002 	strhne.w	ip, [r2, #2]
     e0e:	e7d7      	b.n	dc0 <USB_DMA_IRQHandler+0x8c>

00000e10 <MSS_USB_CIF_rx_ep_read_prepare>:
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t xfr_length
)
{
     e10:	b410      	push	{r4}
    /*Fixed Buffer overwriting issue found with printer driver and
      issue with interrupt transfer with DMA by moving the location
      of interrupt enable function*/
    if(DMA_ENABLE == dma_enable)
     e12:	2a01      	cmp	r2, #1
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t xfr_length
)
{
     e14:	9c02      	ldr	r4, [sp, #8]
     e16:	f89d c004 	ldrb.w	ip, [sp, #4]
    /*Fixed Buffer overwriting issue found with printer driver and
      issue with interrupt transfer with DMA by moving the location
      of interrupt enable function*/
    if(DMA_ENABLE == dma_enable)
     e1a:	d001      	beq.n	e20 <MSS_USB_CIF_rx_ep_read_prepare+0x10>

            /*MUSB section 17.4.1*/
            MSS_USB_CIF_rx_ep_disable_dma(ep_num);
        }
    }
}
     e1c:	bc10      	pop	{r4}
     e1e:	4770      	bx	lr
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
     e20:	011a      	lsls	r2, r3, #4
     e22:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     e26:	f502 2286 	add.w	r2, r2, #274432	; 0x43000
        /*
         DMA Count register will be loaded after receive interrupt occurs.
         Mode need to be set every time since M1 to M0 transition might have
         happened for "short packet".
         */
         if(MSS_USB_XFR_BULK == xfr_type)
     e2a:	f1bc 0f02 	cmp.w	ip, #2
     e2e:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
     e32:	d018      	beq.n	e66 <MSS_USB_CIF_rx_ep_read_prepare+0x56>
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
     e34:	f243 1300 	movw	r3, #12544	; 0x3100
     e38:	0100      	lsls	r0, r0, #4
     e3a:	f2c4 0304 	movt	r3, #16388	; 0x4004
     e3e:	18c1      	adds	r1, r0, r3
     e40:	88ca      	ldrh	r2, [r1, #6]
     e42:	0450      	lsls	r0, r2, #17
     e44:	0c42      	lsrs	r2, r0, #17
     e46:	80ca      	strh	r2, [r1, #6]
MSS_USB_CIF_rx_ep_set_dma_mode0
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_DMA_MODE_MASK;
     e48:	f8b1 c006 	ldrh.w	ip, [r1, #6]
     e4c:	f42c 6000 	bic.w	r0, ip, #2048	; 0x800
     e50:	0402      	lsls	r2, r0, #16
     e52:	0c10      	lsrs	r0, r2, #16
     e54:	80c8      	strh	r0, [r1, #6]
MSS_USB_CIF_rx_ep_disable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_DMA_MASK;
     e56:	f8b1 c006 	ldrh.w	ip, [r1, #6]
     e5a:	f42c 5200 	bic.w	r2, ip, #8192	; 0x2000
     e5e:	0410      	lsls	r0, r2, #16
     e60:	0c02      	lsrs	r2, r0, #16
     e62:	80ca      	strh	r2, [r1, #6]
     e64:	e7da      	b.n	e1c <MSS_USB_CIF_rx_ep_read_prepare+0xc>
MSS_USB_CIF_rx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_DMA_MODE_MASK;
     e66:	f243 1100 	movw	r1, #12544	; 0x3100
     e6a:	0100      	lsls	r0, r0, #4
     e6c:	f2c4 0104 	movt	r1, #16388	; 0x4004
     e70:	1841      	adds	r1, r0, r1
     e72:	88c8      	ldrh	r0, [r1, #6]
     e74:	fa1f fc80 	uxth.w	ip, r0
     e78:	f44c 6000 	orr.w	r0, ip, #2048	; 0x800
     e7c:	80c8      	strh	r0, [r1, #6]
MSS_USB_CIF_rx_ep_set_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
     e7e:	f8b1 c006 	ldrh.w	ip, [r1, #6]
     e82:	fa1f f08c 	uxth.w	r0, ip
     e86:	f440 4c00 	orr.w	ip, r0, #32768	; 0x8000
     e8a:	f8a1 c006 	strh.w	ip, [r1, #6]
MSS_USB_CIF_rx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_DMA_MASK;
     e8e:	88c8      	ldrh	r0, [r1, #6]
     e90:	fa1f fc80 	uxth.w	ip, r0
     e94:	f44c 5000 	orr.w	r0, ip, #8192	; 0x2000
     e98:	80c8      	strh	r0, [r1, #6]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
     e9a:	f8c2 420c 	str.w	r4, [r2, #524]	; 0x20c

            MSS_USB_CIF_dma_write_count(dma_channel,
                                        xfr_length);

            /*Handling single NULL packet reception*/
            if(0u != xfr_length )
     e9e:	2c00      	cmp	r4, #0
     ea0:	d0bc      	beq.n	e1c <MSS_USB_CIF_rx_ep_read_prepare+0xc>
MSS_USB_CIF_dma_start_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_START_XFR_MASK;
     ea2:	f243 2000 	movw	r0, #12800	; 0x3200
     ea6:	011b      	lsls	r3, r3, #4
     ea8:	f2c4 0004 	movt	r0, #16388	; 0x4004
     eac:	181a      	adds	r2, r3, r0
     eae:	6851      	ldr	r1, [r2, #4]
     eb0:	f041 0301 	orr.w	r3, r1, #1
     eb4:	6053      	str	r3, [r2, #4]
     eb6:	e7b1      	b.n	e1c <MSS_USB_CIF_rx_ep_read_prepare+0xc>

00000eb8 <MSS_USB_CIF_ep_write_pkt>:
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t xfr_length,
    uint32_t txn_length
)
{
     eb8:	b470      	push	{r4, r5, r6}
    if(ep_num && (buf_addr != 0))
     eba:	1e04      	subs	r4, r0, #0
     ebc:	bf18      	it	ne
     ebe:	2401      	movne	r4, #1
     ec0:	2900      	cmp	r1, #0
     ec2:	bf0c      	ite	eq
     ec4:	2400      	moveq	r4, #0
     ec6:	f004 0401 	andne.w	r4, r4, #1
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t xfr_length,
    uint32_t txn_length
)
{
     eca:	9d05      	ldr	r5, [sp, #20]
     ecc:	f89d c00c 	ldrb.w	ip, [sp, #12]
    if(ep_num && (buf_addr != 0))
     ed0:	2c00      	cmp	r4, #0
     ed2:	d05c      	beq.n	f8e <MSS_USB_CIF_ep_write_pkt+0xd6>
    {
        if(DMA_ENABLE == dma_enable)
     ed4:	2a01      	cmp	r2, #1
     ed6:	d05c      	beq.n	f92 <MSS_USB_CIF_ep_write_pkt+0xda>

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     ed8:	f3c5 048f 	ubfx	r4, r5, #2, #16
     edc:	b30c      	cbz	r4, f22 <MSS_USB_CIF_ep_write_pkt+0x6a>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
     ede:	680e      	ldr	r6, [r1, #0]
     ee0:	f243 0200 	movw	r2, #12288	; 0x3000
     ee4:	1e63      	subs	r3, r4, #1
     ee6:	f2c4 0204 	movt	r2, #16388	; 0x4004
     eea:	f100 0c08 	add.w	ip, r0, #8
     eee:	f842 602c 	str.w	r6, [r2, ip, lsl #2]
     ef2:	f003 0601 	and.w	r6, r3, #1

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     ef6:	2301      	movs	r3, #1
     ef8:	429c      	cmp	r4, r3
     efa:	d912      	bls.n	f22 <MSS_USB_CIF_ep_write_pkt+0x6a>
     efc:	b12e      	cbz	r6, f0a <MSS_USB_CIF_ep_write_pkt+0x52>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
     efe:	684e      	ldr	r6, [r1, #4]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     f00:	2302      	movs	r3, #2
     f02:	429c      	cmp	r4, r3
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
     f04:	f842 602c 	str.w	r6, [r2, ip, lsl #2]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     f08:	d90b      	bls.n	f22 <MSS_USB_CIF_ep_write_pkt+0x6a>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
     f0a:	f851 6023 	ldr.w	r6, [r1, r3, lsl #2]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     f0e:	3301      	adds	r3, #1
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
     f10:	f842 602c 	str.w	r6, [r2, ip, lsl #2]
     f14:	f851 6023 	ldr.w	r6, [r1, r3, lsl #2]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     f18:	3301      	adds	r3, #1
     f1a:	429c      	cmp	r4, r3
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
     f1c:	f842 602c 	str.w	r6, [r2, ip, lsl #2]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
     f20:	d8f3      	bhi.n	f0a <MSS_USB_CIF_ep_write_pkt+0x52>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f22:	f025 0303 	bic.w	r3, r5, #3
     f26:	429d      	cmp	r5, r3
     f28:	d925      	bls.n	f76 <MSS_USB_CIF_ep_write_pkt+0xbe>
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f2a:	18c9      	adds	r1, r1, r3
     f2c:	43da      	mvns	r2, r3
     f2e:	f243 0400 	movw	r4, #12288	; 0x3000
     f32:	f811 6b01 	ldrb.w	r6, [r1], #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f36:	3301      	adds	r3, #1
     f38:	1952      	adds	r2, r2, r5
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f3a:	f2c4 0404 	movt	r4, #16388	; 0x4004
     f3e:	f100 0c08 	add.w	ip, r0, #8
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f42:	429d      	cmp	r5, r3
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f44:	f804 602c 	strb.w	r6, [r4, ip, lsl #2]
     f48:	f002 0201 	and.w	r2, r2, #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f4c:	d913      	bls.n	f76 <MSS_USB_CIF_ep_write_pkt+0xbe>
     f4e:	b132      	cbz	r2, f5e <MSS_USB_CIF_ep_write_pkt+0xa6>
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f50:	f811 2b01 	ldrb.w	r2, [r1], #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f54:	3301      	adds	r3, #1
     f56:	429d      	cmp	r5, r3
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f58:	f804 202c 	strb.w	r2, [r4, ip, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f5c:	d90b      	bls.n	f76 <MSS_USB_CIF_ep_write_pkt+0xbe>
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f5e:	460a      	mov	r2, r1
     f60:	f812 6b01 	ldrb.w	r6, [r2], #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f64:	3302      	adds	r3, #2
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f66:	f804 602c 	strb.w	r6, [r4, ip, lsl #2]
     f6a:	784e      	ldrb	r6, [r1, #1]
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f6c:	1c51      	adds	r1, r2, #1
     f6e:	429d      	cmp	r5, r3
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
     f70:	f804 602c 	strb.w	r6, [r4, ip, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
     f74:	d8f3      	bhi.n	f5e <MSS_USB_CIF_ep_write_pkt+0xa6>
MSS_USB_CIF_tx_ep_set_txpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_TX_PKT_RDY_MASK;
     f76:	f243 1300 	movw	r3, #12544	; 0x3100
     f7a:	0100      	lsls	r0, r0, #4
     f7c:	f2c4 0304 	movt	r3, #16388	; 0x4004
     f80:	18c1      	adds	r1, r0, r3
     f82:	884a      	ldrh	r2, [r1, #2]
     f84:	b290      	uxth	r0, r2
     f86:	f040 0c01 	orr.w	ip, r0, #1
     f8a:	f8a1 c002 	strh.w	ip, [r1, #2]
                                     buf_addr,
                                     txn_length);
            MSS_USB_CIF_tx_ep_set_txpktrdy(ep_num);
        }
    }
}
     f8e:	bc70      	pop	{r4, r5, r6}
     f90:	4770      	bx	lr
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
     f92:	011a      	lsls	r2, r3, #4
     f94:	f102 4480 	add.w	r4, r2, #1073741824	; 0x40000000
     f98:	f504 2486 	add.w	r4, r4, #274432	; 0x43000
            /*Make sure that address is Modulo-4.Bits D0-D1 are read only.*/
            ASSERT(!(((uint32_t)buf_addr) & 0x00000002));

            MSS_USB_CIF_dma_write_addr(dma_channel,(uint32_t)(buf_addr));

            if(MSS_USB_XFR_BULK == xfr_type)
     f9c:	f1bc 0f02 	cmp.w	ip, #2
     fa0:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
MSS_USB_CIF_tx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_ENABLE_DMA_MASK;
     fa4:	f243 1200 	movw	r2, #12544	; 0x3100
     fa8:	d017      	beq.n	fda <MSS_USB_CIF_ep_write_pkt+0x122>
MSS_USB_CIF_tx_ep_disable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRH_REG_EPN_ENABLE_DMA_MASK;
     faa:	0101      	lsls	r1, r0, #4
     fac:	f2c4 0204 	movt	r2, #16388	; 0x4004
     fb0:	188a      	adds	r2, r1, r2
     fb2:	f8b2 c002 	ldrh.w	ip, [r2, #2]
     fb6:	f42c 5080 	bic.w	r0, ip, #4096	; 0x1000
     fba:	0401      	lsls	r1, r0, #16
     fbc:	0c08      	lsrs	r0, r1, #16
     fbe:	8050      	strh	r0, [r2, #2]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
     fc0:	f8c4 520c 	str.w	r5, [r4, #524]	; 0x20c
MSS_USB_CIF_dma_start_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_START_XFR_MASK;
     fc4:	f243 2100 	movw	r1, #12800	; 0x3200
     fc8:	011b      	lsls	r3, r3, #4
     fca:	f2c4 0104 	movt	r1, #16388	; 0x4004
     fce:	185a      	adds	r2, r3, r1
     fd0:	6850      	ldr	r0, [r2, #4]
     fd2:	f040 0301 	orr.w	r3, r0, #1
     fd6:	6053      	str	r3, [r2, #4]
     fd8:	e7d9      	b.n	f8e <MSS_USB_CIF_ep_write_pkt+0xd6>
MSS_USB_CIF_tx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_ENABLE_DMA_MASK;
     fda:	0101      	lsls	r1, r0, #4
     fdc:	f2c4 0204 	movt	r2, #16388	; 0x4004
     fe0:	188a      	adds	r2, r1, r2
     fe2:	8850      	ldrh	r0, [r2, #2]
     fe4:	fa1f fc80 	uxth.w	ip, r0
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
     fe8:	9804      	ldr	r0, [sp, #16]
MSS_USB_CIF_tx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_ENABLE_DMA_MASK;
     fea:	f44c 5180 	orr.w	r1, ip, #4096	; 0x1000
     fee:	8051      	strh	r1, [r2, #2]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
     ff0:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
     ff4:	e7e6      	b.n	fc4 <MSS_USB_CIF_ep_write_pkt+0x10c>
     ff6:	bf00      	nop

00000ff8 <MSS_USB_CIF_configure_ep_dma>:
    mss_usb_dma_mode_t dma_mode,
    mss_usb_dma_burst_mode_t burst_mode,
    mss_usb_ep_num_t ep_num,
    uint32_t buf_addr
)
{
     ff8:	b470      	push	{r4, r5, r6}
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_ep_num_t ep_num
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
     ffa:	f243 0c00 	movw	ip, #12288	; 0x3000
     ffe:	f2c4 0c04 	movt	ip, #16388	; 0x4004
    1002:	f89d 600c 	ldrb.w	r6, [sp, #12]
    1006:	f100 0420 	add.w	r4, r0, #32
    100a:	eb0c 1404 	add.w	r4, ip, r4, lsl #4
    100e:	0135      	lsls	r5, r6, #4
    1010:	6866      	ldr	r6, [r4, #4]
    1012:	f005 05ff 	and.w	r5, r5, #255	; 0xff
    1016:	4335      	orrs	r5, r6
    1018:	6065      	str	r5, [r4, #4]
{
    /*
    dir = 1 => DMA read (TX EP)
    dir = 0 => DMA write (RX EP)
    */
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dir << DMA_CNTL_REG_DMA_DIR_SHIFT);
    101a:	6865      	ldr	r5, [r4, #4]
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    101c:	025b      	lsls	r3, r3, #9
{
    /*
    dir = 1 => DMA read (TX EP)
    dir = 0 => DMA write (RX EP)
    */
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dir << DMA_CNTL_REG_DMA_DIR_SHIFT);
    101e:	ea45 0141 	orr.w	r1, r5, r1, lsl #1
    1022:	6061      	str	r1, [r4, #4]
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_mode_t dma_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dma_mode << DMA_CNTL_REG_DMA_MODE_SHIFT);
    1024:	6861      	ldr	r1, [r4, #4]
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    1026:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_mode_t dma_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dma_mode << DMA_CNTL_REG_DMA_MODE_SHIFT);
    102a:	ea41 0282 	orr.w	r2, r1, r2, lsl #2
    102e:	6062      	str	r2, [r4, #4]
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    1030:	6862      	ldr	r2, [r4, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    1032:	eb0c 1100 	add.w	r1, ip, r0, lsl #4
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    1036:	4313      	orrs	r3, r2
    1038:	6063      	str	r3, [r4, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    103a:	9a04      	ldr	r2, [sp, #16]
    103c:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208
MSS_USB_CIF_dma_enable_irq
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_ENABLE_DMA_IRQ_MASK;
    1040:	6860      	ldr	r0, [r4, #4]
    1042:	f040 0308 	orr.w	r3, r0, #8
    1046:	6063      	str	r3, [r4, #4]
    MSS_USB_CIF_dma_set_dir(dma_channel, dma_dir);
    MSS_USB_CIF_dma_set_mode(dma_channel, dma_mode);
    MSS_USB_CIF_dma_set_burst_mode(dma_channel, burst_mode);
    MSS_USB_CIF_dma_write_addr(dma_channel, buf_addr);
    MSS_USB_CIF_dma_enable_irq(dma_channel);
}
    1048:	bc70      	pop	{r4, r5, r6}
    104a:	4770      	bx	lr

0000104c <MSS_USB_CIF_tx_ep_configure>:
MSS_USB_CIF_tx_ep_configure

(
    mss_usb_ep_t* core_ep
)
{
    104c:	b470      	push	{r4, r5, r6}
    uint8_t dpb = 1u;
    mss_usb_dma_mode_t mode;

    if(DPB_ENABLE == core_ep->dpb_enable)
    104e:	7844      	ldrb	r4, [r0, #1]
    {
        dpb = 2u;
    }

    MSS_USB_CIF_tx_ep_set_fifo_size(core_ep->num,
    1050:	8845      	ldrh	r5, [r0, #2]
    1052:	7801      	ldrb	r1, [r0, #0]
)
{
    uint8_t dpb = 1u;
    mss_usb_dma_mode_t mode;

    if(DPB_ENABLE == core_ep->dpb_enable)
    1054:	2c01      	cmp	r4, #1
    1056:	bf14      	ite	ne
    1058:	2301      	movne	r3, #1
    105a:	2302      	moveq	r3, #2
    {
        dpb = 2u;
    }

    MSS_USB_CIF_tx_ep_set_fifo_size(core_ep->num,
    105c:	fb95 f3f3 	sdiv	r3, r5, r3
{
    uint16_t temp;
    uint8_t i = 0;

    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    1060:	1e0d      	subs	r5, r1, #0
    1062:	bf18      	it	ne
    1064:	2501      	movne	r5, #1
    1066:	2b07      	cmp	r3, #7
    1068:	bf94      	ite	ls
    106a:	2200      	movls	r2, #0
    106c:	f005 0201 	andhi.w	r2, r5, #1
    1070:	2a00      	cmp	r2, #0
    1072:	d054      	beq.n	111e <MSS_USB_CIF_tx_ep_configure+0xd2>
    {
        USB->INDEX = ep_num;
    1074:	f243 0200 	movw	r2, #12288	; 0x3000
    1078:	f2c4 0204 	movt	r2, #16388	; 0x4004
        temp = (fifo_size / MIN_EP_FIFO_SZ);
    107c:	08db      	lsrs	r3, r3, #3
    uint8_t i = 0;

    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
    107e:	7391      	strb	r1, [r2, #14]
        temp = (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    1080:	f013 0201 	ands.w	r2, r3, #1
    1084:	f040 80d1 	bne.w	122a <MSS_USB_CIF_tx_ep_configure+0x1de>
        {
            temp >>= 1u;
    1088:	085b      	lsrs	r3, r3, #1
            i++;
    108a:	3201      	adds	r2, #1
    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
        temp = (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    108c:	f013 0f01 	tst.w	r3, #1
        {
            temp >>= 1u;
            i++;
    1090:	b2d2      	uxtb	r2, r2
    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
        temp = (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    1092:	d0f9      	beq.n	1088 <MSS_USB_CIF_tx_ep_configure+0x3c>
        {
            temp >>= 1u;
            i++;
        }
        USB->TX_FIFO_SIZE = ((dpb << TXFIFOSZ_REG_DPB_SHIFT) | i);
    1094:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
    1098:	f243 0300 	movw	r3, #12288	; 0x3000
    109c:	fa5f fc82 	uxtb.w	ip, r2
    10a0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    10a4:	f883 c062 	strb.w	ip, [r3, #98]	; 0x62
                                    ((core_ep->fifo_size) / dpb),
                                    core_ep->dpb_enable);

    MSS_USB_CIF_tx_ep_set_fifo_addr(core_ep->num, core_ep->fifo_addr);
    10a8:	8882      	ldrh	r2, [r0, #4]
)
{
    /*Valid address values are from 0 to FFF8 in steps of 8*/
    if(ep_num > MSS_USB_CEP)
    {
        USB->INDEX = ep_num;
    10aa:	f243 0300 	movw	r3, #12288	; 0x3000
    10ae:	f2c4 0304 	movt	r3, #16388	; 0x4004
        USB->TX_FIFO_ADDR = (addr / EP_FIFO_ADDR_STEP);
    10b2:	08d2      	lsrs	r2, r2, #3

    if(DPB_ENABLE == core_ep->dpb_enable)
    10b4:	2c01      	cmp	r4, #1
)
{
    /*Valid address values are from 0 to FFF8 in steps of 8*/
    if(ep_num > MSS_USB_CEP)
    {
        USB->INDEX = ep_num;
    10b6:	7399      	strb	r1, [r3, #14]
        USB->TX_FIFO_ADDR = (addr / EP_FIFO_ADDR_STEP);
    10b8:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
    10bc:	d034      	beq.n	1128 <MSS_USB_CIF_tx_ep_configure+0xdc>
    {
        MSS_USB_enable_tx_ep_dpb(core_ep->num);
    }
    else if(DPB_DISABLE == core_ep->dpb_enable)
    10be:	2c00      	cmp	r4, #0
    10c0:	d040      	beq.n	1144 <MSS_USB_CIF_tx_ep_configure+0xf8>
    else
    {
        ASSERT(0);
    }

    MSS_USB_CIF_tx_ep_set_max_pkt(core_ep->num,
    10c2:	8902      	ldrh	r2, [r0, #8]
    10c4:	7d03      	ldrb	r3, [r0, #20]
    uint16_t max_pkt_size,
    uint8_t num_usb_pkt
)
{
    /*TODO:make sure that there is no data in FIFO before writing into the maxP reg*/
    if((ep_num > MSS_USB_CEP) && ((max_pkt_size % 8) == 0) && (num_usb_pkt > 0))
    10c6:	b15d      	cbz	r5, 10e0 <MSS_USB_CIF_tx_ep_configure+0x94>
    10c8:	f012 0f07 	tst.w	r2, #7
    10cc:	bf14      	ite	ne
    10ce:	2400      	movne	r4, #0
    10d0:	2401      	moveq	r4, #1
    10d2:	2b00      	cmp	r3, #0
    10d4:	bf0c      	ite	eq
    10d6:	2400      	moveq	r4, #0
    10d8:	f004 0401 	andne.w	r4, r4, #1
    10dc:	2c00      	cmp	r4, #0
    10de:	d141      	bne.n	1164 <MSS_USB_CIF_tx_ep_configure+0x118>
    10e0:	f101 0310 	add.w	r3, r1, #16
MSS_USB_CIF_tx_ep_clr_data_tog
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_CLR_DATA_TOG_MASK;
    10e4:	011a      	lsls	r2, r3, #4
    10e6:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    10ea:	f503 2386 	add.w	r3, r3, #274432	; 0x43000
    10ee:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    10f2:	fa1f f28c 	uxth.w	r2, ip
    10f6:	f042 0c40 	orr.w	ip, r2, #64	; 0x40
    10fa:	f8a3 c002 	strh.w	ip, [r3, #2]
                                  core_ep->max_pkt_size,
                                  core_ep->num_usb_pkt);

    MSS_USB_CIF_tx_ep_clr_data_tog(core_ep->num);

    if(DMA_ENABLE == core_ep->dma_enable)
    10fe:	7982      	ldrb	r2, [r0, #6]
    1100:	2a01      	cmp	r2, #1
    1102:	d04f      	beq.n	11a4 <MSS_USB_CIF_tx_ep_configure+0x158>
MSS_USB_CIF_tx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    1104:	2301      	movs	r3, #1
    1106:	fa13 f001 	lsls.w	r0, r3, r1
    110a:	f243 0300 	movw	r3, #12288	; 0x3000
    110e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1112:	88da      	ldrh	r2, [r3, #6]
    1114:	4310      	orrs	r0, r2
    1116:	b281      	uxth	r1, r0
    1118:	80d9      	strh	r1, [r3, #6]
                                     core_ep->num,
                                     (uint32_t)(core_ep->buf_addr));
    }

    MSS_USB_CIF_tx_ep_enable_irq(core_ep->num);
}
    111a:	bc70      	pop	{r4, r5, r6}
    111c:	4770      	bx	lr

    MSS_USB_CIF_tx_ep_set_fifo_size(core_ep->num,
                                    ((core_ep->fifo_size) / dpb),
                                    core_ep->dpb_enable);

    MSS_USB_CIF_tx_ep_set_fifo_addr(core_ep->num, core_ep->fifo_addr);
    111e:	8882      	ldrh	r2, [r0, #4]
    mss_usb_ep_num_t ep_num,
    uint16_t addr
)
{
    /*Valid address values are from 0 to FFF8 in steps of 8*/
    if(ep_num > MSS_USB_CEP)
    1120:	2d00      	cmp	r5, #0
    1122:	d1c2      	bne.n	10aa <MSS_USB_CIF_tx_ep_configure+0x5e>

    if(DPB_ENABLE == core_ep->dpb_enable)
    1124:	2c01      	cmp	r4, #1
    1126:	d1ca      	bne.n	10be <MSS_USB_CIF_tx_ep_configure+0x72>
MSS_USB_enable_tx_ep_dpb
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_DPBUF_DIS &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << ep_num));
    1128:	408c      	lsls	r4, r1
    112a:	f243 0300 	movw	r3, #12288	; 0x3000
    112e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1132:	f8b3 2342 	ldrh.w	r2, [r3, #834]	; 0x342
    1136:	fa1f fc82 	uxth.w	ip, r2
    113a:	ea2c 0404 	bic.w	r4, ip, r4
    113e:	f8a3 4342 	strh.w	r4, [r3, #834]	; 0x342
    1142:	e7be      	b.n	10c2 <MSS_USB_CIF_tx_ep_configure+0x76>
MSS_USB_disable_tx_ep_dpb
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_DPBUF_DIS |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << ep_num);
    1144:	2301      	movs	r3, #1
    1146:	fa13 f201 	lsls.w	r2, r3, r1
    114a:	f243 0300 	movw	r3, #12288	; 0x3000
    114e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1152:	f8b3 c342 	ldrh.w	ip, [r3, #834]	; 0x342
    1156:	ea42 020c 	orr.w	r2, r2, ip
    115a:	fa1f fc82 	uxth.w	ip, r2
    115e:	f8a3 c342 	strh.w	ip, [r3, #834]	; 0x342
    1162:	e7ae      	b.n	10c2 <MSS_USB_CIF_tx_ep_configure+0x76>
)
{
    /*TODO:make sure that there is no data in FIFO before writing into the maxP reg*/
    if((ep_num > MSS_USB_CEP) && ((max_pkt_size % 8) == 0) && (num_usb_pkt > 0))
    {
        if((num_usb_pkt > 31u))
    1164:	2b1f      	cmp	r3, #31
    1166:	d8bb      	bhi.n	10e0 <MSS_USB_CIF_tx_ep_configure+0x94>
            /*not allowed*/
        }
        else
        {
            USB->ENDPOINT[ep_num].TX_MAX_P = 0u;
            USB->ENDPOINT[ep_num].TX_MAX_P = num_usb_pkt - 1u;
    1168:	1e5e      	subs	r6, r3, #1
        {
            /*not allowed*/
        }
        else
        {
            USB->ENDPOINT[ep_num].TX_MAX_P = 0u;
    116a:	f243 0c00 	movw	ip, #12288	; 0x3000
    116e:	f101 0310 	add.w	r3, r1, #16
    1172:	f2c4 0c04 	movt	ip, #16388	; 0x4004
    1176:	011c      	lsls	r4, r3, #4
            USB->ENDPOINT[ep_num].TX_MAX_P = num_usb_pkt - 1u;
    1178:	b2b5      	uxth	r5, r6
        {
            /*not allowed*/
        }
        else
        {
            USB->ENDPOINT[ep_num].TX_MAX_P = 0u;
    117a:	f04f 0600 	mov.w	r6, #0
    117e:	f824 600c 	strh.w	r6, [r4, ip]
            USB->ENDPOINT[ep_num].TX_MAX_P = num_usb_pkt - 1u;
    1182:	f824 500c 	strh.w	r5, [r4, ip]
            USB->ENDPOINT[ep_num].TX_MAX_P <<= TX_MAX_P_REG_NUM_USB_PKT_SHIFT;
    1186:	f834 500c 	ldrh.w	r5, [r4, ip]
    118a:	02ed      	lsls	r5, r5, #11
    118c:	f405 4578 	and.w	r5, r5, #63488	; 0xf800
    1190:	f824 500c 	strh.w	r5, [r4, ip]
            USB->ENDPOINT[ep_num].TX_MAX_P |= (max_pkt_size);
    1194:	f834 500c 	ldrh.w	r5, [r4, ip]
    1198:	b2ad      	uxth	r5, r5
    119a:	ea45 0202 	orr.w	r2, r5, r2
    119e:	f824 200c 	strh.w	r2, [r4, ip]
    11a2:	e79f      	b.n	10e4 <MSS_USB_CIF_tx_ep_configure+0x98>

    MSS_USB_CIF_tx_ep_clr_data_tog(core_ep->num);

    if(DMA_ENABLE == core_ep->dma_enable)
    {
        if(MSS_USB_XFR_BULK == core_ep->xfr_type )
    11a4:	7b04      	ldrb	r4, [r0, #12]
MSS_USB_CIF_tx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_DMA_MODE_MASK;
    11a6:	885a      	ldrh	r2, [r3, #2]
    11a8:	2c02      	cmp	r4, #2
    11aa:	d032      	beq.n	1212 <MSS_USB_CIF_tx_ep_configure+0x1c6>
MSS_USB_CIF_tx_ep_set_dma_mode0
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRH_REG_EPN_DMA_MODE_MASK;
    11ac:	f422 6480 	bic.w	r4, r2, #1024	; 0x400
    11b0:	0422      	lsls	r2, r4, #16
    11b2:	0c15      	lsrs	r5, r2, #16
    11b4:	805d      	strh	r5, [r3, #2]
MSS_USB_CIF_tx_ep_disable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRH_REG_EPN_ENABLE_DMA_MASK;
    11b6:	885c      	ldrh	r4, [r3, #2]
    11b8:	f04f 0c00 	mov.w	ip, #0
    11bc:	f424 5280 	bic.w	r2, r4, #4096	; 0x1000
    11c0:	0415      	lsls	r5, r2, #16
    11c2:	0c2c      	lsrs	r4, r5, #16
    11c4:	805c      	strh	r4, [r3, #2]
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_ep_num_t ep_num
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    11c6:	79c2      	ldrb	r2, [r0, #7]
    11c8:	f243 2500 	movw	r5, #12800	; 0x3200
    11cc:	0114      	lsls	r4, r2, #4
    11ce:	f2c4 0504 	movt	r5, #16388	; 0x4004
    11d2:	1963      	adds	r3, r4, r5
    11d4:	685d      	ldr	r5, [r3, #4]
    11d6:	010c      	lsls	r4, r1, #4
    11d8:	f004 04ff 	and.w	r4, r4, #255	; 0xff
    11dc:	432c      	orrs	r4, r5
    11de:	605c      	str	r4, [r3, #4]
{
    /*
    dir = 1 => DMA read (TX EP)
    dir = 0 => DMA write (RX EP)
    */
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dir << DMA_CNTL_REG_DMA_DIR_SHIFT);
    11e0:	685c      	ldr	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    11e2:	0112      	lsls	r2, r2, #4
{
    /*
    dir = 1 => DMA read (TX EP)
    dir = 0 => DMA write (RX EP)
    */
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dir << DMA_CNTL_REG_DMA_DIR_SHIFT);
    11e4:	f044 0402 	orr.w	r4, r4, #2
    11e8:	605c      	str	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_mode_t dma_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dma_mode << DMA_CNTL_REG_DMA_MODE_SHIFT);
    11ea:	685c      	ldr	r4, [r3, #4]
            MSS_USB_CIF_tx_ep_set_dma_mode0(core_ep->num);
            MSS_USB_CIF_tx_ep_disable_dma(core_ep->num);
            mode = MSS_USB_DMA_MODE0;
        }

        MSS_USB_CIF_configure_ep_dma(core_ep->dma_channel,
    11ec:	6980      	ldr	r0, [r0, #24]
    11ee:	ea4c 0404 	orr.w	r4, ip, r4
    11f2:	605c      	str	r4, [r3, #4]
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    11f4:	685c      	ldr	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    11f6:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    11fa:	f502 2286 	add.w	r2, r2, #274432	; 0x43000
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    11fe:	f444 64c0 	orr.w	r4, r4, #1536	; 0x600
    1202:	605c      	str	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    1204:	f8c2 0208 	str.w	r0, [r2, #520]	; 0x208
MSS_USB_CIF_dma_enable_irq
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_ENABLE_DMA_IRQ_MASK;
    1208:	685a      	ldr	r2, [r3, #4]
    120a:	f042 0008 	orr.w	r0, r2, #8
    120e:	6058      	str	r0, [r3, #4]
    1210:	e778      	b.n	1104 <MSS_USB_CIF_tx_ep_configure+0xb8>
MSS_USB_CIF_tx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_DMA_MODE_MASK;
    1212:	b292      	uxth	r2, r2
    1214:	f442 6580 	orr.w	r5, r2, #1024	; 0x400
    1218:	805d      	strh	r5, [r3, #2]
MSS_USB_CIF_tx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_ENABLE_DMA_MASK;
    121a:	885c      	ldrh	r4, [r3, #2]
    121c:	f04f 0c04 	mov.w	ip, #4
    1220:	b2a2      	uxth	r2, r4
    1222:	f442 5580 	orr.w	r5, r2, #4096	; 0x1000
    1226:	805d      	strh	r5, [r3, #2]
    1228:	e7cd      	b.n	11c6 <MSS_USB_CIF_tx_ep_configure+0x17a>
    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
        temp = (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    122a:	2200      	movs	r2, #0
    122c:	e732      	b.n	1094 <MSS_USB_CIF_tx_ep_configure+0x48>
    122e:	bf00      	nop

00001230 <MSS_USB_CIF_rx_ep_configure>:
MSS_USB_CIF_rx_ep_configure

(
    mss_usb_ep_t* core_ep
)
{
    1230:	b430      	push	{r4, r5}
    uint8_t dpb = 1u;
    mss_usb_dma_mode_t mode;
    if(DPB_ENABLE == core_ep->dpb_enable)
    1232:	7844      	ldrb	r4, [r0, #1]
    {
        dpb = 2u;
    }

    MSS_USB_CIF_rx_ep_set_fifo_size(core_ep->num,
    1234:	8845      	ldrh	r5, [r0, #2]
    1236:	7801      	ldrb	r1, [r0, #0]
    mss_usb_ep_t* core_ep
)
{
    uint8_t dpb = 1u;
    mss_usb_dma_mode_t mode;
    if(DPB_ENABLE == core_ep->dpb_enable)
    1238:	2c01      	cmp	r4, #1
    123a:	bf14      	ite	ne
    123c:	2301      	movne	r3, #1
    123e:	2302      	moveq	r3, #2
    {
        dpb = 2u;
    }

    MSS_USB_CIF_rx_ep_set_fifo_size(core_ep->num,
    1240:	fb95 f3f3 	sdiv	r3, r5, r3
    /*fifo_size is the size in terms of number of bytes.*/
    uint16_t temp;
    uint8_t i = 0u;

    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    1244:	1e0d      	subs	r5, r1, #0
    1246:	bf18      	it	ne
    1248:	2501      	movne	r5, #1
    124a:	2b07      	cmp	r3, #7
    124c:	bf94      	ite	ls
    124e:	2200      	movls	r2, #0
    1250:	f005 0201 	andhi.w	r2, r5, #1
    1254:	2a00      	cmp	r2, #0
    1256:	d056      	beq.n	1306 <MSS_USB_CIF_rx_ep_configure+0xd6>
    {
        USB->INDEX = ep_num;
    1258:	f243 0200 	movw	r2, #12288	; 0x3000
    125c:	f2c4 0204 	movt	r2, #16388	; 0x4004
        temp= (fifo_size / MIN_EP_FIFO_SZ);
    1260:	08db      	lsrs	r3, r3, #3
    uint8_t i = 0u;

    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
    1262:	7391      	strb	r1, [r2, #14]
        temp= (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    1264:	f013 0201 	ands.w	r2, r3, #1
    1268:	f040 80d2 	bne.w	1410 <MSS_USB_CIF_rx_ep_configure+0x1e0>
        {
            temp >>= 1u;
    126c:	085b      	lsrs	r3, r3, #1
            i++;
    126e:	3201      	adds	r2, #1
    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
        temp= (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    1270:	f013 0f01 	tst.w	r3, #1
        {
            temp >>= 1u;
            i++;
    1274:	b2d2      	uxtb	r2, r2
    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
        temp= (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    1276:	d0f9      	beq.n	126c <MSS_USB_CIF_rx_ep_configure+0x3c>
        {
            temp >>= 1u;
            i++;
        }
        USB->RX_FIFO_SIZE = ((dpb << RXFIFOSZ_REG_DPB_SHIFT) | i);
    1278:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
    127c:	f243 0300 	movw	r3, #12288	; 0x3000
    1280:	fa5f fc82 	uxtb.w	ip, r2
    1284:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1288:	f883 c063 	strb.w	ip, [r3, #99]	; 0x63
                                     ((core_ep->fifo_size) / dpb),
                                     core_ep->dpb_enable);

    MSS_USB_CIF_rx_ep_set_fifo_addr(core_ep->num,
    128c:	8882      	ldrh	r2, [r0, #4]
)
{
    /*Valid address values are from 0 to FFF8 in steps of 8*/
    if(ep_num > MSS_USB_CEP)
    {
        USB->INDEX = ep_num;
    128e:	f243 0300 	movw	r3, #12288	; 0x3000
    1292:	f2c4 0304 	movt	r3, #16388	; 0x4004
        USB->RX_FIFO_ADDR = (addr / EP_FIFO_ADDR_STEP);
    1296:	08d2      	lsrs	r2, r2, #3
                                     core_ep->fifo_addr);

    if(DPB_ENABLE == core_ep->dpb_enable)
    1298:	2c01      	cmp	r4, #1
)
{
    /*Valid address values are from 0 to FFF8 in steps of 8*/
    if(ep_num > MSS_USB_CEP)
    {
        USB->INDEX = ep_num;
    129a:	7399      	strb	r1, [r3, #14]
        USB->RX_FIFO_ADDR = (addr / EP_FIFO_ADDR_STEP);
    129c:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    12a0:	d036      	beq.n	1310 <MSS_USB_CIF_rx_ep_configure+0xe0>
    {
        MSS_USB_CIF_enable_rx_ep_dpb(core_ep->num);
    }
    else if(DPB_DISABLE == core_ep->dpb_enable)
    12a2:	2c00      	cmp	r4, #0
    12a4:	d042      	beq.n	132c <MSS_USB_CIF_rx_ep_configure+0xfc>
    else
    {
        ASSERT(0);
    }

    MSS_USB_CIF_rx_ep_set_max_pkt(core_ep->num,
    12a6:	8902      	ldrh	r2, [r0, #8]
    12a8:	f890 c014 	ldrb.w	ip, [r0, #20]
    uint16_t max_pkt_size,
    uint8_t num_usb_pkt
)
{
    /*TODO:make sure that there is no data in FIFO before writing into the maxP reg*/
    if((ep_num > MSS_USB_CEP) && (max_pkt_size > 0) && ((max_pkt_size % 8) == 0))
    12ac:	2a00      	cmp	r2, #0
    12ae:	bf0c      	ite	eq
    12b0:	2500      	moveq	r5, #0
    12b2:	f005 0501 	andne.w	r5, r5, #1
    12b6:	b115      	cbz	r5, 12be <MSS_USB_CIF_rx_ep_configure+0x8e>
    12b8:	f012 0507 	ands.w	r5, r2, #7
    12bc:	d046      	beq.n	134c <MSS_USB_CIF_rx_ep_configure+0x11c>
    12be:	f101 0310 	add.w	r3, r1, #16
(
    mss_usb_ep_num_t ep_num
)
{
    /*setting CLR_DAT_TOG bit clears USB Data toggle bit*/
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_CLR_DAT_TOG_MASK;
    12c2:	011a      	lsls	r2, r3, #4
    12c4:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    12c8:	f503 2386 	add.w	r3, r3, #274432	; 0x43000
    12cc:	88da      	ldrh	r2, [r3, #6]
    12ce:	fa1f fc82 	uxth.w	ip, r2
    12d2:	f04c 0280 	orr.w	r2, ip, #128	; 0x80
    12d6:	80da      	strh	r2, [r3, #6]
MSS_USB_CIF_rx_ep_clr_rxpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_RX_PKT_RDY_MASK;
    12d8:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    12dc:	f02c 0201 	bic.w	r2, ip, #1
    12e0:	0412      	lsls	r2, r2, #16
    12e2:	0c12      	lsrs	r2, r2, #16
    12e4:	80da      	strh	r2, [r3, #6]
                                  core_ep->num_usb_pkt);

    MSS_USB_CIF_rx_ep_clr_data_tog(core_ep->num);
    MSS_USB_CIF_rx_ep_clr_rxpktrdy(core_ep->num);

    if(DMA_ENABLE == core_ep->dma_enable)
    12e6:	7982      	ldrb	r2, [r0, #6]
    12e8:	2a01      	cmp	r2, #1
    12ea:	d050      	beq.n	138e <MSS_USB_CIF_rx_ep_configure+0x15e>
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    12ec:	2301      	movs	r3, #1
    12ee:	fa13 f001 	lsls.w	r0, r3, r1
    12f2:	f243 0300 	movw	r3, #12288	; 0x3000
    12f6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    12fa:	891a      	ldrh	r2, [r3, #8]
    12fc:	4310      	orrs	r0, r2
    12fe:	b281      	uxth	r1, r0
    1300:	8119      	strh	r1, [r3, #8]
                                     core_ep->num,
                                     (uint32_t)(core_ep->buf_addr));
    }

    MSS_USB_CIF_rx_ep_enable_irq(core_ep->num);
}
    1302:	bc30      	pop	{r4, r5}
    1304:	4770      	bx	lr

    MSS_USB_CIF_rx_ep_set_fifo_size(core_ep->num,
                                     ((core_ep->fifo_size) / dpb),
                                     core_ep->dpb_enable);

    MSS_USB_CIF_rx_ep_set_fifo_addr(core_ep->num,
    1306:	8882      	ldrh	r2, [r0, #4]
    mss_usb_ep_num_t ep_num,
    uint16_t addr
)
{
    /*Valid address values are from 0 to FFF8 in steps of 8*/
    if(ep_num > MSS_USB_CEP)
    1308:	2d00      	cmp	r5, #0
    130a:	d1c0      	bne.n	128e <MSS_USB_CIF_rx_ep_configure+0x5e>
                                     core_ep->fifo_addr);

    if(DPB_ENABLE == core_ep->dpb_enable)
    130c:	2c01      	cmp	r4, #1
    130e:	d1c8      	bne.n	12a2 <MSS_USB_CIF_rx_ep_configure+0x72>
MSS_USB_CIF_enable_rx_ep_dpb
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_DPBUF_DIS &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << ep_num));
    1310:	408c      	lsls	r4, r1
    1312:	f243 0300 	movw	r3, #12288	; 0x3000
    1316:	f2c4 0304 	movt	r3, #16388	; 0x4004
    131a:	f8b3 2340 	ldrh.w	r2, [r3, #832]	; 0x340
    131e:	fa1f fc82 	uxth.w	ip, r2
    1322:	ea2c 0404 	bic.w	r4, ip, r4
    1326:	f8a3 4340 	strh.w	r4, [r3, #832]	; 0x340
    132a:	e7bc      	b.n	12a6 <MSS_USB_CIF_rx_ep_configure+0x76>
MSS_USB_CIF_disable_rx_ep_dpb
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_DPBUF_DIS |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << ep_num);
    132c:	2301      	movs	r3, #1
    132e:	fa13 f201 	lsls.w	r2, r3, r1
    1332:	f243 0300 	movw	r3, #12288	; 0x3000
    1336:	f2c4 0304 	movt	r3, #16388	; 0x4004
    133a:	f8b3 c340 	ldrh.w	ip, [r3, #832]	; 0x340
    133e:	ea42 020c 	orr.w	r2, r2, ip
    1342:	fa1f fc82 	uxth.w	ip, r2
    1346:	f8a3 c340 	strh.w	ip, [r3, #832]	; 0x340
    134a:	e7ac      	b.n	12a6 <MSS_USB_CIF_rx_ep_configure+0x76>
)
{
    /*TODO:make sure that there is no data in FIFO before writing into the maxP reg*/
    if((ep_num > MSS_USB_CEP) && (max_pkt_size > 0) && ((max_pkt_size % 8) == 0))
    {
        if((num_usb_pkt > 31))
    134c:	f1bc 0f1f 	cmp.w	ip, #31
    1350:	d8b5      	bhi.n	12be <MSS_USB_CIF_rx_ep_configure+0x8e>
        {
            /*not allowed*/
        }
        else
        {
            USB->ENDPOINT[ep_num].RX_MAX_P = 0u;
    1352:	f101 0310 	add.w	r3, r1, #16
    1356:	011c      	lsls	r4, r3, #4
    1358:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
            USB->ENDPOINT[ep_num].RX_MAX_P = num_usb_pkt - 1u;
    135c:	f10c 3cff 	add.w	ip, ip, #4294967295
        {
            /*not allowed*/
        }
        else
        {
            USB->ENDPOINT[ep_num].RX_MAX_P = 0u;
    1360:	f504 2486 	add.w	r4, r4, #274432	; 0x43000
            USB->ENDPOINT[ep_num].RX_MAX_P = num_usb_pkt - 1u;
    1364:	fa1f fc8c 	uxth.w	ip, ip
        {
            /*not allowed*/
        }
        else
        {
            USB->ENDPOINT[ep_num].RX_MAX_P = 0u;
    1368:	80a5      	strh	r5, [r4, #4]
            USB->ENDPOINT[ep_num].RX_MAX_P = num_usb_pkt - 1u;
    136a:	f8a4 c004 	strh.w	ip, [r4, #4]
            USB->ENDPOINT[ep_num].RX_MAX_P <<= RX_MAX_P_REG_NUM_USB_PKT_SHIFT;
    136e:	f8b4 c004 	ldrh.w	ip, [r4, #4]
    1372:	ea4f 2ccc 	mov.w	ip, ip, lsl #11
    1376:	f40c 4c78 	and.w	ip, ip, #63488	; 0xf800
    137a:	f8a4 c004 	strh.w	ip, [r4, #4]
            USB->ENDPOINT[ep_num].RX_MAX_P |= (max_pkt_size);
    137e:	f8b4 c004 	ldrh.w	ip, [r4, #4]
    1382:	fa1f fc8c 	uxth.w	ip, ip
    1386:	ea4c 0202 	orr.w	r2, ip, r2
    138a:	80a2      	strh	r2, [r4, #4]
    138c:	e799      	b.n	12c2 <MSS_USB_CIF_rx_ep_configure+0x92>
    MSS_USB_CIF_rx_ep_clr_data_tog(core_ep->num);
    MSS_USB_CIF_rx_ep_clr_rxpktrdy(core_ep->num);

    if(DMA_ENABLE == core_ep->dma_enable)
    {
        if(MSS_USB_XFR_BULK == core_ep->xfr_type)
    138e:	7b05      	ldrb	r5, [r0, #12]
MSS_USB_CIF_rx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_DMA_MODE_MASK;
    1390:	88da      	ldrh	r2, [r3, #6]
    1392:	2d02      	cmp	r5, #2
    1394:	d030      	beq.n	13f8 <MSS_USB_CIF_rx_ep_configure+0x1c8>
MSS_USB_CIF_rx_ep_set_dma_mode0
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_DMA_MODE_MASK;
    1396:	f422 6500 	bic.w	r5, r2, #2048	; 0x800
    139a:	042a      	lsls	r2, r5, #16
    139c:	0c14      	lsrs	r4, r2, #16
    139e:	80dc      	strh	r4, [r3, #6]
MSS_USB_CIF_rx_ep_disable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_DMA_MASK;
    13a0:	88dd      	ldrh	r5, [r3, #6]
    13a2:	f04f 0c00 	mov.w	ip, #0
    13a6:	f425 5200 	bic.w	r2, r5, #8192	; 0x2000
    13aa:	0414      	lsls	r4, r2, #16
    13ac:	0c25      	lsrs	r5, r4, #16
    13ae:	80dd      	strh	r5, [r3, #6]
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_ep_num_t ep_num
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    13b0:	79c2      	ldrb	r2, [r0, #7]
    13b2:	f243 2500 	movw	r5, #12800	; 0x3200
    13b6:	0114      	lsls	r4, r2, #4
    13b8:	f2c4 0504 	movt	r5, #16388	; 0x4004
    13bc:	1963      	adds	r3, r4, r5
    13be:	685d      	ldr	r5, [r3, #4]
    13c0:	010c      	lsls	r4, r1, #4
    13c2:	f004 04ff 	and.w	r4, r4, #255	; 0xff
    13c6:	432c      	orrs	r4, r5
    13c8:	605c      	str	r4, [r3, #4]
{
    /*
    dir = 1 => DMA read (TX EP)
    dir = 0 => DMA write (RX EP)
    */
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dir << DMA_CNTL_REG_DMA_DIR_SHIFT);
    13ca:	685c      	ldr	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    13cc:	0112      	lsls	r2, r2, #4
{
    /*
    dir = 1 => DMA read (TX EP)
    dir = 0 => DMA write (RX EP)
    */
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dir << DMA_CNTL_REG_DMA_DIR_SHIFT);
    13ce:	605c      	str	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_mode_t dma_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= (dma_mode << DMA_CNTL_REG_DMA_MODE_SHIFT);
    13d0:	685c      	ldr	r4, [r3, #4]
            MSS_USB_CIF_rx_ep_set_dma_mode0(core_ep->num);
            MSS_USB_CIF_rx_ep_disable_dma(core_ep->num);
            mode = MSS_USB_DMA_MODE0;
        }

        MSS_USB_CIF_configure_ep_dma(core_ep->dma_channel,
    13d2:	6980      	ldr	r0, [r0, #24]
    13d4:	ea4c 0404 	orr.w	r4, ip, r4
    13d8:	605c      	str	r4, [r3, #4]
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    13da:	685c      	ldr	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    13dc:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    13e0:	f502 2286 	add.w	r2, r2, #274432	; 0x43000
    mss_usb_dma_channel_t dma_channel,
    mss_usb_dma_burst_mode_t
    burst_mode
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |=
    13e4:	f444 64c0 	orr.w	r4, r4, #1536	; 0x600
    13e8:	605c      	str	r4, [r3, #4]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    13ea:	f8c2 0208 	str.w	r0, [r2, #520]	; 0x208
MSS_USB_CIF_dma_enable_irq
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_ENABLE_DMA_IRQ_MASK;
    13ee:	685a      	ldr	r2, [r3, #4]
    13f0:	f042 0008 	orr.w	r0, r2, #8
    13f4:	6058      	str	r0, [r3, #4]
    13f6:	e779      	b.n	12ec <MSS_USB_CIF_rx_ep_configure+0xbc>
MSS_USB_CIF_rx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_DMA_MODE_MASK;
    13f8:	b292      	uxth	r2, r2
    13fa:	f442 6400 	orr.w	r4, r2, #2048	; 0x800
    13fe:	80dc      	strh	r4, [r3, #6]
MSS_USB_CIF_rx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_DMA_MASK;
    1400:	88dd      	ldrh	r5, [r3, #6]
    1402:	f04f 0c04 	mov.w	ip, #4
    1406:	b2aa      	uxth	r2, r5
    1408:	f442 5400 	orr.w	r4, r2, #8192	; 0x2000
    140c:	80dc      	strh	r4, [r3, #6]
    140e:	e7cf      	b.n	13b0 <MSS_USB_CIF_rx_ep_configure+0x180>
    /*Valid FIFO sizes are 8,16,32,64,128,512,1024,2048,4096*/
    if((ep_num > MSS_USB_CEP) && (fifo_size >= MIN_EP_FIFO_SZ))
    {
        USB->INDEX = ep_num;
        temp= (fifo_size / MIN_EP_FIFO_SZ);
        while(!(temp & MSS_USB_WORD_BIT_0_MASK))
    1410:	2200      	movs	r2, #0
    1412:	e731      	b.n	1278 <MSS_USB_CIF_rx_ep_configure+0x48>

00001414 <MSS_USB_CIF_start_testpacket>:
/***************************************************************************//**
 Starts sending Test packet as specified in the USB2.0
 This is USB-IF certification requirement.
 */
void MSS_USB_CIF_start_testpacket(void)
{
    1414:	b430      	push	{r4, r5}
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xEE,
    0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFC,
    0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0x7E
    };
    1416:	f648 5cc0 	movw	ip, #36288	; 0x8dc0
/***************************************************************************//**
 Starts sending Test packet as specified in the USB2.0
 This is USB-IF certification requirement.
 */
void MSS_USB_CIF_start_testpacket(void)
{
    141a:	b08e      	sub	sp, #56	; 0x38
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xEE,
    0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFC,
    0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0x7E
    };
    141c:	f2c0 0c00 	movt	ip, #0
    1420:	466d      	mov	r5, sp
    1422:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    1426:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1428:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    142c:	462c      	mov	r4, r5
    142e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1430:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    1434:	4625      	mov	r5, r4
    1436:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1438:	e89c 0003 	ldmia.w	ip, {r0, r1}
    143c:	6028      	str	r0, [r5, #0]
    143e:	7521      	strb	r1, [r4, #20]
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    1440:	9800      	ldr	r0, [sp, #0]
    1442:	f243 0300 	movw	r3, #12288	; 0x3000
    1446:	f2c4 0304 	movt	r3, #16388	; 0x4004
    144a:	6218      	str	r0, [r3, #32]
    144c:	9a01      	ldr	r2, [sp, #4]
    144e:	621a      	str	r2, [r3, #32]
    1450:	9902      	ldr	r1, [sp, #8]
    1452:	6219      	str	r1, [r3, #32]
    1454:	9803      	ldr	r0, [sp, #12]
    1456:	6218      	str	r0, [r3, #32]
    1458:	9a04      	ldr	r2, [sp, #16]
    145a:	621a      	str	r2, [r3, #32]
    145c:	9905      	ldr	r1, [sp, #20]
    145e:	6219      	str	r1, [r3, #32]
    1460:	9806      	ldr	r0, [sp, #24]
    1462:	6218      	str	r0, [r3, #32]
    1464:	9a07      	ldr	r2, [sp, #28]
    1466:	621a      	str	r2, [r3, #32]
    1468:	9908      	ldr	r1, [sp, #32]
    146a:	6219      	str	r1, [r3, #32]
    146c:	9809      	ldr	r0, [sp, #36]	; 0x24
    146e:	6218      	str	r0, [r3, #32]
    1470:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    1472:	621a      	str	r2, [r3, #32]
    1474:	990b      	ldr	r1, [sp, #44]	; 0x2c
    USB->TEST_MODE = TESTMODE_TESTK_MASK;
}

static __INLINE void MSS_USB_CIF_start_testpacket_bit(void)
{
    USB->TEST_MODE = TESTMODE_TESTPACKET_MASK;
    1476:	2208      	movs	r2, #8
    1478:	6219      	str	r1, [r3, #32]
    147a:	980c      	ldr	r0, [sp, #48]	; 0x30
    147c:	6218      	str	r0, [r3, #32]
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    147e:	f89d c034 	ldrb.w	ip, [sp, #52]	; 0x34
    1482:	f883 c020 	strb.w	ip, [r3, #32]
    1486:	73da      	strb	r2, [r3, #15]
MSS_USB_CIF_cep_set_txpktrdy
(
    void
)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 |= CSR0L_DEV_TX_PKT_RDY_MASK;
    1488:	8a59      	ldrh	r1, [r3, #18]
    148a:	b288      	uxth	r0, r1
    148c:	f040 0202 	orr.w	r2, r0, #2
    1490:	825a      	strh	r2, [r3, #18]
MSS_USB_CIF_cep_disable_irq
(
    void
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~TX_IRQ_ENABLE_REG_CEP_MASK);
    1492:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    1496:	f02c 0101 	bic.w	r1, ip, #1
    149a:	0408      	lsls	r0, r1, #16
    149c:	0c02      	lsrs	r2, r0, #16
    149e:	80da      	strh	r2, [r3, #6]
    MSS_USB_CIF_load_tx_fifo (MSS_USB_CEP, test_pkt, 53u);
    MSS_USB_CIF_start_testpacket_bit();
    MSS_USB_CIF_cep_set_txpktrdy();
    MSS_USB_CIF_cep_disable_irq();
}
    14a0:	b00e      	add	sp, #56	; 0x38
    14a2:	bc30      	pop	{r4, r5}
    14a4:	4770      	bx	lr
    14a6:	bf00      	nop

000014a8 <MSS_USBD_set_descr_cb_handler>:
MSS_USBD_set_descr_cb_handler
(
    mss_usbd_user_descr_cb_t* user_desc_cb
)
{
    g_usbd_user_descr_cb = user_desc_cb;
    14a8:	f640 33a0 	movw	r3, #2976	; 0xba0
    14ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14b0:	6018      	str	r0, [r3, #0]
}
    14b2:	4770      	bx	lr

000014b4 <MSS_USBD_set_class_cb_handler>:
MSS_USBD_set_class_cb_handler
(
    mss_usbd_class_cb_t* class_cb
)
{
    g_usbd_class_cb = class_cb;
    14b4:	f640 339c 	movw	r3, #2972	; 0xb9c
    14b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    14bc:	6018      	str	r0, [r3, #0]
}
    14be:	4770      	bx	lr

000014c0 <MSS_USBD_tx_ep_stall>:
MSS_USBD_tx_ep_stall
(
    mss_usb_ep_num_t ep_num
)
{
    gd_tx_ep[ep_num].stall = 1u;
    14c0:	f240 7ce0 	movw	ip, #2016	; 0x7e0
    14c4:	222c      	movs	r2, #44	; 0x2c
    14c6:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    14ca:	fb02 c300 	mla	r3, r2, r0, ip
MSS_USB_CIF_tx_ep_set_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_SEND_STALL_MASK;
    14ce:	f243 1200 	movw	r2, #12544	; 0x3100
    14d2:	0100      	lsls	r0, r0, #4
    14d4:	2101      	movs	r1, #1
    14d6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    14da:	7299      	strb	r1, [r3, #10]
    14dc:	1882      	adds	r2, r0, r2
    14de:	8851      	ldrh	r1, [r2, #2]
    14e0:	b288      	uxth	r0, r1
    14e2:	f040 0310 	orr.w	r3, r0, #16
    14e6:	8053      	strh	r3, [r2, #2]
    MSS_USBD_CIF_tx_ep_stall(ep_num);
}
    14e8:	4770      	bx	lr
    14ea:	bf00      	nop

000014ec <MSS_USBD_tx_ep_clr_stall>:
MSS_USB_CIF_tx_ep_clr_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_SEND_STALL_MASK;
    14ec:	f243 1300 	movw	r3, #12544	; 0x3100
    14f0:	0102      	lsls	r2, r0, #4
    14f2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    14f6:	18d3      	adds	r3, r2, r3
    14f8:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    14fc:	f02c 0110 	bic.w	r1, ip, #16
    1500:	0408      	lsls	r0, r1, #16
    1502:	0c02      	lsrs	r2, r0, #16
    1504:	805a      	strh	r2, [r3, #2]
MSS_USB_CIF_tx_ep_clr_data_tog
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_CLR_DATA_TOG_MASK;
    1506:	8859      	ldrh	r1, [r3, #2]
    1508:	b288      	uxth	r0, r1
    150a:	f040 0240 	orr.w	r2, r0, #64	; 0x40
    150e:	805a      	strh	r2, [r3, #2]
(
    mss_usb_ep_num_t ep_num
)
{
    MSS_USBD_CIF_tx_ep_clr_stall(ep_num);
}
    1510:	4770      	bx	lr
    1512:	bf00      	nop

00001514 <MSS_USBD_tx_ep_flush_fifo>:

/***************************************************************************//**
*/
static __INLINE void MSS_USB_CIF_tx_ep_flush_fifo(mss_usb_ep_num_t ep_num)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_FLUSH_FIFO_MASK;
    1514:	f243 1200 	movw	r2, #12544	; 0x3100
    1518:	0100      	lsls	r0, r0, #4
    151a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    151e:	1883      	adds	r3, r0, r2
    1520:	8859      	ldrh	r1, [r3, #2]
    1522:	b288      	uxth	r0, r1
    1524:	f040 0208 	orr.w	r2, r0, #8
    1528:	805a      	strh	r2, [r3, #2]
(
    mss_usb_ep_num_t ep_num
)
{
    MSS_USB_CIF_tx_ep_flush_fifo(ep_num);
}
    152a:	4770      	bx	lr

0000152c <MSS_USBD_rx_ep_stall>:
MSS_USBD_rx_ep_stall
(
    mss_usb_ep_num_t ep_num
)
{
    gd_rx_ep[ep_num].stall = 1u;
    152c:	f240 7ce0 	movw	ip, #2016	; 0x7e0
    1530:	222c      	movs	r2, #44	; 0x2c
    1532:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    1536:	fb02 c300 	mla	r3, r2, r0, ip
MSS_USB_CIF_rx_ep_set_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_SEND_STALL_MASK;
    153a:	f243 1200 	movw	r2, #12544	; 0x3100
    153e:	0100      	lsls	r0, r0, #4
    1540:	2101      	movs	r1, #1
    1542:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1546:	f883 10e6 	strb.w	r1, [r3, #230]	; 0xe6
    154a:	1882      	adds	r2, r0, r2
    154c:	88d1      	ldrh	r1, [r2, #6]
    154e:	b288      	uxth	r0, r1
    1550:	f040 0320 	orr.w	r3, r0, #32
    1554:	80d3      	strh	r3, [r2, #6]
    MSS_USBD_CIF_rx_ep_stall(ep_num);
}
    1556:	4770      	bx	lr

00001558 <MSS_USBD_rx_ep_clr_stall>:
MSS_USB_CIF_rx_ep_clr_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_SEND_STALL_MASK;
    1558:	f243 1300 	movw	r3, #12544	; 0x3100
    155c:	0102      	lsls	r2, r0, #4
    155e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1562:	18d3      	adds	r3, r2, r3
    1564:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    1568:	f02c 0120 	bic.w	r1, ip, #32
    156c:	0408      	lsls	r0, r1, #16
    156e:	0c02      	lsrs	r2, r0, #16
    1570:	80da      	strh	r2, [r3, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    /*setting CLR_DAT_TOG bit clears USB Data toggle bit*/
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_CLR_DAT_TOG_MASK;
    1572:	88d9      	ldrh	r1, [r3, #6]
    1574:	b288      	uxth	r0, r1
    1576:	f040 0280 	orr.w	r2, r0, #128	; 0x80
    157a:	80da      	strh	r2, [r3, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    MSS_USBD_CIF_rx_ep_clr_stall(ep_num);
}
    157c:	4770      	bx	lr
    157e:	bf00      	nop

00001580 <MSS_USBD_rx_ep_flush_fifo>:

/***************************************************************************//**
*/
static __INLINE void MSS_USB_CIF_rx_ep_flush_fifo(mss_usb_ep_num_t ep_num)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_FLUSH_FIFO_MASK;
    1580:	f243 1200 	movw	r2, #12544	; 0x3100
    1584:	0100      	lsls	r0, r0, #4
    1586:	f2c4 0204 	movt	r2, #16388	; 0x4004
    158a:	1883      	adds	r3, r0, r2
    158c:	88d9      	ldrh	r1, [r3, #6]
    158e:	b288      	uxth	r0, r1
    1590:	f040 0210 	orr.w	r2, r0, #16
    1594:	80da      	strh	r2, [r3, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    MSS_USB_CIF_rx_ep_flush_fifo(ep_num);
}
    1596:	4770      	bx	lr

00001598 <MSS_USBD_cep_flush_fifo>:
/*lint -e20 -e522 -e10 -e40 -e63 -e35 -e26 -e78*/
/***************************************************************************//**
*/
static __INLINE void MSS_USB_CIF_cep_flush_fifo(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 |= CSR0H_DEV_FLUSH_FIFO_MASK;
    1598:	f243 0300 	movw	r3, #12288	; 0x3000
    159c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    15a0:	8a59      	ldrh	r1, [r3, #18]
    15a2:	b288      	uxth	r0, r1
    15a4:	f440 7280 	orr.w	r2, r0, #256	; 0x100
    15a8:	825a      	strh	r2, [r3, #18]
(
    void
)
{
    MSS_USB_CIF_cep_flush_fifo();
}
    15aa:	4770      	bx	lr

000015ac <MSS_USBD_get_dev_address>:
    USB->FADDR = addr;
}

static __INLINE uint8_t MSS_USBD_CIF_get_dev_addr(void)
{
    return(USB->FADDR);
    15ac:	f243 0300 	movw	r3, #12288	; 0x3000
    15b0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    15b4:	7818      	ldrb	r0, [r3, #0]
(
    void
)
{
    return(MSS_USBD_CIF_get_dev_addr());
}
    15b6:	4770      	bx	lr

000015b8 <MSS_USBD_set_isoupdate>:
}

/*ISO INEP Will wait for SOF packet after TxPktRdy is set*/
static __INLINE void MSS_USBD_CIF_set_isoupdate(void)
{
    USB->POWER |= POWER_REG_ISO_UPDATE_MASK;
    15b8:	f243 0300 	movw	r3, #12288	; 0x3000
    15bc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    15c0:	7858      	ldrb	r0, [r3, #1]
    15c2:	f040 0280 	orr.w	r2, r0, #128	; 0x80
    15c6:	705a      	strb	r2, [r3, #1]
(
    void
)
{
    MSS_USBD_CIF_set_isoupdate();
}
    15c8:	4770      	bx	lr
    15ca:	bf00      	nop

000015cc <MSS_USBD_clr_isoupdate>:
}

/*ISO INEP Will NOT wait for SOF packet after TxPktRdy is set*/
static __INLINE void MSS_USBD_CIF_clr_isoupdate(void)
{
    USB->POWER &= ~POWER_REG_ISO_UPDATE_MASK;
    15cc:	f243 0300 	movw	r3, #12288	; 0x3000
    15d0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    15d4:	7858      	ldrb	r0, [r3, #1]
    15d6:	f000 027f 	and.w	r2, r0, #127	; 0x7f
    15da:	705a      	strb	r2, [r3, #1]
(
    void
)
{
    MSS_USBD_CIF_clr_isoupdate();
}
    15dc:	4770      	bx	lr
    15de:	bf00      	nop

000015e0 <MSS_USBD_tx_ep_is_fifo_notempty>:
 Indicates that there is at least one byte available to be transmitted from
 TX FIFO
 */
static __INLINE uint8_t MSS_USB_CIF_is_txepfifo_notempty(mss_usb_ep_num_t ep_num)
{
    return(((USB->ENDPOINT[ep_num].TX_CSR & TxCSRL_REG_EPN_TX_FIFO_NE_MASK)
    15e0:	f243 1100 	movw	r1, #12544	; 0x3100
    15e4:	0102      	lsls	r2, r0, #4
    15e6:	f2c4 0104 	movt	r1, #16388	; 0x4004
    15ea:	1853      	adds	r3, r2, r1
    15ec:	8858      	ldrh	r0, [r3, #2]
(
    mss_usb_ep_num_t epnum
)
{
    return(MSS_USB_CIF_is_txepfifo_notempty(epnum));
}
    15ee:	f3c0 0040 	ubfx	r0, r0, #1, #1
    15f2:	4770      	bx	lr

000015f4 <MSS_USBD_rx_ep_is_fifo_full>:

/***************************************************************************//**
*/
static __INLINE uint8_t MSS_USB_CIF_rx_ep_is_fifo_full(mss_usb_ep_num_t ep_num)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_RX_FIFO_FULL_MASK) ?
    15f4:	f243 1100 	movw	r1, #12544	; 0x3100
    15f8:	0102      	lsls	r2, r0, #4
    15fa:	f2c4 0104 	movt	r1, #16388	; 0x4004
    15fe:	1853      	adds	r3, r2, r1
    1600:	88d8      	ldrh	r0, [r3, #6]
(
    mss_usb_ep_num_t epnum
)
{
    return(MSS_USB_CIF_rx_ep_is_fifo_full(epnum));
}
    1602:	f3c0 0040 	ubfx	r0, r0, #1, #1
    1606:	4770      	bx	lr

00001608 <MSS_USBD_tx_ep_disable_irq>:
MSS_USB_CIF_tx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    1608:	2201      	movs	r2, #1
    160a:	fa12 f300 	lsls.w	r3, r2, r0
    160e:	f243 0200 	movw	r2, #12288	; 0x3000
    1612:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1616:	88d0      	ldrh	r0, [r2, #6]
    1618:	b281      	uxth	r1, r0
    161a:	ea21 0303 	bic.w	r3, r1, r3
    161e:	80d3      	strh	r3, [r2, #6]
(
    mss_usb_ep_num_t epnum
)
{
    MSS_USB_CIF_tx_ep_disable_irq(epnum);
}
    1620:	4770      	bx	lr
    1622:	bf00      	nop

00001624 <MSS_USBD_rx_ep_disable_irq>:
MSS_USB_CIF_rx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    1624:	2201      	movs	r2, #1
    1626:	fa12 f300 	lsls.w	r3, r2, r0
    162a:	f243 0200 	movw	r2, #12288	; 0x3000
    162e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1632:	8910      	ldrh	r0, [r2, #8]
    1634:	b281      	uxth	r1, r0
    1636:	ea21 0303 	bic.w	r3, r1, r3
    163a:	8113      	strh	r3, [r2, #8]
(
    mss_usb_ep_num_t epnum
)
{
    MSS_USB_CIF_rx_ep_disable_irq(epnum);
}
    163c:	4770      	bx	lr
    163e:	bf00      	nop

00001640 <MSS_USBD_tx_ep_enable_irq>:
MSS_USB_CIF_tx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    1640:	2201      	movs	r2, #1
    1642:	fa12 f300 	lsls.w	r3, r2, r0
    1646:	f243 0200 	movw	r2, #12288	; 0x3000
    164a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    164e:	88d1      	ldrh	r1, [r2, #6]
    1650:	430b      	orrs	r3, r1
    1652:	b29b      	uxth	r3, r3
    1654:	80d3      	strh	r3, [r2, #6]
(
    mss_usb_ep_num_t epnum
)
{
    MSS_USB_CIF_tx_ep_enable_irq(epnum);
}
    1656:	4770      	bx	lr

00001658 <MSS_USBD_rx_ep_enable_irq>:
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    1658:	2201      	movs	r2, #1
    165a:	fa12 f300 	lsls.w	r3, r2, r0
    165e:	f243 0200 	movw	r2, #12288	; 0x3000
    1662:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1666:	8911      	ldrh	r1, [r2, #8]
    1668:	430b      	orrs	r3, r1
    166a:	b29b      	uxth	r3, r3
    166c:	8113      	strh	r3, [r2, #8]
(
    mss_usb_ep_num_t epnum
)
{
    MSS_USB_CIF_rx_ep_enable_irq(epnum);
}
    166e:	4770      	bx	lr

00001670 <MSS_USBD_cep_enable_irq>:
MSS_USB_CIF_cep_enable_irq
(
    void
)
{
    USB->TX_IRQ_ENABLE |= (uint16_t)(TX_IRQ_ENABLE_REG_CEP_MASK);
    1670:	f243 0300 	movw	r3, #12288	; 0x3000
    1674:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1678:	88d9      	ldrh	r1, [r3, #6]
    167a:	b288      	uxth	r0, r1
    167c:	f040 0201 	orr.w	r2, r0, #1
    1680:	80da      	strh	r2, [r3, #6]
(
    void
)
{
    MSS_USB_CIF_cep_enable_irq();
}
    1682:	4770      	bx	lr

00001684 <MSS_USBD_cep_disable_irq>:
MSS_USB_CIF_cep_disable_irq
(
    void
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~TX_IRQ_ENABLE_REG_CEP_MASK);
    1684:	f243 0200 	movw	r2, #12288	; 0x3000
    1688:	f2c4 0204 	movt	r2, #16388	; 0x4004
    168c:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    1690:	f02c 0101 	bic.w	r1, ip, #1
    1694:	0408      	lsls	r0, r1, #16
    1696:	0c03      	lsrs	r3, r0, #16
    1698:	80d3      	strh	r3, [r2, #6]
(
    void
)
{
    MSS_USB_CIF_cep_disable_irq();
}
    169a:	4770      	bx	lr

0000169c <mss_usbd_sof_cb>:
#ifndef MSS_USB_DEVICE_TEST_MODE
#else
    usbd_test_cb.test_sof(status);
#endif

}
    169c:	4770      	bx	lr
    169e:	bf00      	nop

000016a0 <mss_usbd_suspend_cb>:
/*******************************************************************************
 * Enables USB interrupts.
 */
static __INLINE void MSS_USB_CIF_enable_usbirq(uint8_t irq_mask)
{
    USB->USB_ENABLE |= (irq_mask);
    16a0:	f243 0200 	movw	r2, #12288	; 0x3000
    16a4:	f2c4 0204 	movt	r2, #16388	; 0x4004
    16a8:	f892 c00b 	ldrb.w	ip, [r2, #11]
    void
)
{
    #ifndef MSS_USB_DEVICE_TEST_MODE
        MSS_USB_CIF_enable_usbirq(RESUME_IRQ_MASK);
        g_usbd_dev_conf.device_state_at_suspend = g_usbd_dev_conf.device_state;
    16ac:	f240 73e0 	movw	r3, #2016	; 0x7e0
    16b0:	f04c 0002 	orr.w	r0, ip, #2
    16b4:	72d0      	strb	r0, [r2, #11]
    16b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16ba:	f893 21bb 	ldrb.w	r2, [r3, #443]	; 0x1bb
        g_usbd_dev_conf.device_state = MSS_USB_SUSPENDED_STATE;
    16be:	2106      	movs	r1, #6
    16c0:	f883 11bb 	strb.w	r1, [r3, #443]	; 0x1bb
    void
)
{
    #ifndef MSS_USB_DEVICE_TEST_MODE
        MSS_USB_CIF_enable_usbirq(RESUME_IRQ_MASK);
        g_usbd_dev_conf.device_state_at_suspend = g_usbd_dev_conf.device_state;
    16c4:	f883 21bc 	strb.w	r2, [r3, #444]	; 0x1bc
        g_usbd_dev_conf.device_state = MSS_USB_SUSPENDED_STATE;
    #else
    /*usbd_test_cb.test_suspend();*/
    #endif
}
    16c8:	4770      	bx	lr
    16ca:	bf00      	nop

000016cc <mss_usbd_resume_cb>:
(
    void
)
{
    #ifndef MSS_USB_DEVICE_TEST_MODE
        g_usbd_dev_conf.device_state = g_usbd_dev_conf.device_state_at_suspend;
    16cc:	f240 73e0 	movw	r3, #2016	; 0x7e0
    16d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    16d4:	f893 21bc 	ldrb.w	r2, [r3, #444]	; 0x1bc
    16d8:	f883 21bb 	strb.w	r2, [r3, #443]	; 0x1bb
    #else
        usbd_test_cb.test_resume();
    #endif
}
    16dc:	4770      	bx	lr
    16de:	bf00      	nop

000016e0 <mss_usbd_disconnect_cb>:
MSS_USB_CIF_rx_ep_disable_irq_all
(
    void
)
{
    USB->RX_IRQ_ENABLE = 0u ;
    16e0:	f243 0200 	movw	r2, #12288	; 0x3000
    16e4:	f2c4 0204 	movt	r2, #16388	; 0x4004

static void mss_usbd_disconnect_cb(void)
{
    #ifndef MSS_USB_DEVICE_TEST_MODE
        g_usbd_dev_conf.device_state = MSS_USB_NOT_ATTACHED_STATE;
    16e8:	f04f 0c00 	mov.w	ip, #0
        MSS_USB_CIF_rx_ep_disable_irq_all();
        MSS_USB_CIF_tx_ep_disable_irq_all();
        NVIC_ClearPendingIRQ(USB_DMA_IRQn);
        NVIC_ClearPendingIRQ(USB_IRQn);
        if(0 != g_usbd_class_cb->usbd_class_release)
    16ec:	f640 319c 	movw	r1, #2972	; 0xb9c
    16f0:	f8a2 c008 	strh.w	ip, [r2, #8]
    16f4:	f2c2 0100 	movt	r1, #8192	; 0x2000
    16f8:	680b      	ldr	r3, [r1, #0]
        usbd_test_cb.test_resume();
    #endif
}

static void mss_usbd_disconnect_cb(void)
{
    16fa:	b510      	push	{r4, lr}
(
    void
)
{
    /*Keep D0, CEP interrupt bit unaltered.*/
    USB->TX_IRQ_ENABLE = (USB->TX_IRQ_ENABLE & TX_IRQ_ENABLE_REG_CEP_MASK);
    16fc:	88d4      	ldrh	r4, [r2, #6]
    #ifndef MSS_USB_DEVICE_TEST_MODE
        g_usbd_dev_conf.device_state = MSS_USB_NOT_ATTACHED_STATE;
    16fe:	f240 70e0 	movw	r0, #2016	; 0x7e0
    1702:	f2c2 0000 	movt	r0, #8192	; 0x2000

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    1706:	f24e 1100 	movw	r1, #57600	; 0xe100
    170a:	f004 0401 	and.w	r4, r4, #1
        MSS_USB_CIF_rx_ep_disable_irq_all();
        MSS_USB_CIF_tx_ep_disable_irq_all();
        NVIC_ClearPendingIRQ(USB_DMA_IRQn);
        NVIC_ClearPendingIRQ(USB_IRQn);
        if(0 != g_usbd_class_cb->usbd_class_release)
    170e:	685b      	ldr	r3, [r3, #4]
    1710:	80d4      	strh	r4, [r2, #6]
    1712:	f2ce 0100 	movt	r1, #57344	; 0xe000
}

static void mss_usbd_disconnect_cb(void)
{
    #ifndef MSS_USB_DEVICE_TEST_MODE
        g_usbd_dev_conf.device_state = MSS_USB_NOT_ATTACHED_STATE;
    1716:	f880 c1bb 	strb.w	ip, [r0, #443]	; 0x1bb
    171a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    171e:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
    1722:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
    1726:	f8c1 2180 	str.w	r2, [r1, #384]	; 0x180
        MSS_USB_CIF_rx_ep_disable_irq_all();
        MSS_USB_CIF_tx_ep_disable_irq_all();
        NVIC_ClearPendingIRQ(USB_DMA_IRQn);
        NVIC_ClearPendingIRQ(USB_IRQn);
        if(0 != g_usbd_class_cb->usbd_class_release)
    172a:	b10b      	cbz	r3, 1730 <mss_usbd_disconnect_cb+0x50>
        {
            g_usbd_class_cb->usbd_class_release(0xFF);
    172c:	20ff      	movs	r0, #255	; 0xff
    172e:	4798      	blx	r3
    1730:	bd10      	pop	{r4, pc}
    1732:	bf00      	nop

00001734 <mss_usbd_dma_handler_cb>:
    uint32_t dma_addr_val
)
{
    mss_usb_ep_t *ep_ptr = 0;

    if(DMA_XFR_ERROR == status)
    1734:	2a40      	cmp	r2, #64	; 0x40
    mss_usb_ep_num_t ep_num,
    mss_usb_dma_dir_t dma_dir,
    uint8_t status,
    uint32_t dma_addr_val
)
{
    1736:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    mss_usb_ep_t *ep_ptr = 0;

    if(DMA_XFR_ERROR == status)
    1738:	d02c      	beq.n	1794 <mss_usbd_dma_handler_cb+0x60>
        ASSERT(0);
    }
    else
    {

        if(MSS_USB_DMA_READ == dma_dir)    /*TX EP*/
    173a:	2901      	cmp	r1, #1
    173c:	d02b      	beq.n	1796 <mss_usbd_dma_handler_cb+0x62>
            else
            {
                MSS_USB_CIF_tx_ep_set_txpktrdy(ep_num);
            }
        }
        else if(MSS_USB_DMA_WRITE == dma_dir)/*RX EP*/
    173e:	bb49      	cbnz	r1, 1794 <mss_usbd_dma_handler_cb+0x60>
        {
            ep_ptr = &gd_rx_ep[ep_num];
    1740:	4c37      	ldr	r4, [pc, #220]	; (1820 <mss_usbd_dma_handler_cb+0xec>)
    1742:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
    1746:	fb0c 4100 	mla	r1, ip, r0, r4

            if((NO_ZLP_TO_XFR == ep_ptr->add_zlp) &&
    174a:	690c      	ldr	r4, [r1, #16]
    174c:	bb14      	cbnz	r4, 1794 <mss_usbd_dma_handler_cb+0x60>
               (ep_ptr->xfr_length) &&
    174e:	69cc      	ldr	r4, [r1, #28]
        }
        else if(MSS_USB_DMA_WRITE == dma_dir)/*RX EP*/
        {
            ep_ptr = &gd_rx_ep[ep_num];

            if((NO_ZLP_TO_XFR == ep_ptr->add_zlp) &&
    1750:	b304      	cbz	r4, 1794 <mss_usbd_dma_handler_cb+0x60>
               (ep_ptr->xfr_length) &&
               (!(ep_ptr->xfr_length % ep_ptr->max_pkt_size)))
    1752:	f8b1 c008 	ldrh.w	ip, [r1, #8]
    1756:	fbb4 f5fc 	udiv	r5, r4, ip
    175a:	fb0c 4415 	mls	r4, ip, r5, r4
    175e:	b9cc      	cbnz	r4, 1794 <mss_usbd_dma_handler_cb+0x60>
MSS_USB_CIF_rx_ep_get_dma_mode
(
    mss_usb_ep_num_t ep_num
)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_DMA_MODE_MASK) ?
    1760:	f243 1500 	movw	r5, #12544	; 0x3100
    1764:	ea4f 1c00 	mov.w	ip, r0, lsl #4
    1768:	f2c4 0504 	movt	r5, #16388	; 0x4004
    176c:	4465      	add	r5, ip
            {
                ep_ptr->xfr_count = dma_addr_val - (uint32_t)ep_ptr->buf_addr;
    176e:	698c      	ldr	r4, [r1, #24]
    1770:	f8b5 c006 	ldrh.w	ip, [r5, #6]
    1774:	1b1c      	subs	r4, r3, r4

                if(MSS_USB_DMA_MODE0 == (MSS_USB_CIF_rx_ep_get_dma_mode(ep_num)))
    1776:	f41c 6f00 	tst.w	ip, #2048	; 0x800

            if((NO_ZLP_TO_XFR == ep_ptr->add_zlp) &&
               (ep_ptr->xfr_length) &&
               (!(ep_ptr->xfr_length % ep_ptr->max_pkt_size)))
            {
                ep_ptr->xfr_count = dma_addr_val - (uint32_t)ep_ptr->buf_addr;
    177a:	620c      	str	r4, [r1, #32]

                if(MSS_USB_DMA_MODE0 == (MSS_USB_CIF_rx_ep_get_dma_mode(ep_num)))
    177c:	d047      	beq.n	180e <mss_usbd_dma_handler_cb+0xda>
                {
                    MSS_USB_CIF_rx_ep_clr_rxpktrdy(ep_num);
                }
                if(0 != g_usbd_class_cb->usbd_class_rx_done)
    177e:	f640 339c 	movw	r3, #2972	; 0xb9c
    1782:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1786:	6819      	ldr	r1, [r3, #0]
    1788:	694b      	ldr	r3, [r1, #20]
    178a:	b11b      	cbz	r3, 1794 <mss_usbd_dma_handler_cb+0x60>
                {
                    /* call-back class driver */
                    g_usbd_class_cb->usbd_class_rx_done(ep_num, status,
    178c:	4611      	mov	r1, r2
    178e:	4622      	mov	r2, r4
    1790:	4798      	blx	r3
    1792:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1794:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1796:	f100 0c10 	add.w	ip, r0, #16
    179a:	ea4f 140c 	mov.w	r4, ip, lsl #4
    179e:	f104 4180 	add.w	r1, r4, #1073741824	; 0x40000000
    17a2:	f501 2186 	add.w	r1, r1, #274432	; 0x43000
    17a6:	88cc      	ldrh	r4, [r1, #6]
        if(MSS_USB_DMA_READ == dma_dir)    /*TX EP*/
        {
            ep_ptr = &gd_tx_ep[ep_num];

            /*EP interrupt wont happen when */
            if((MSS_USB_DMA_MODE1 == (MSS_USB_CIF_rx_ep_get_dma_mode(ep_num))) &&
    17a8:	f414 6f00 	tst.w	r4, #2048	; 0x800
    17ac:	d023      	beq.n	17f6 <mss_usbd_dma_handler_cb+0xc2>
    else
    {

        if(MSS_USB_DMA_READ == dma_dir)    /*TX EP*/
        {
            ep_ptr = &gd_tx_ep[ep_num];
    17ae:	f240 74e0 	movw	r4, #2016	; 0x7e0
    17b2:	f2c2 0400 	movt	r4, #8192	; 0x2000
    17b6:	252c      	movs	r5, #44	; 0x2c
    17b8:	fb05 4500 	mla	r5, r5, r0, r4

            /*EP interrupt wont happen when */
            if((MSS_USB_DMA_MODE1 == (MSS_USB_CIF_rx_ep_get_dma_mode(ep_num))) &&
               (NO_ZLP_TO_XFR == ep_ptr->add_zlp) &&
    17bc:	692c      	ldr	r4, [r5, #16]
    17be:	b9d4      	cbnz	r4, 17f6 <mss_usbd_dma_handler_cb+0xc2>
               (ep_ptr->xfr_length) &&
    17c0:	69ec      	ldr	r4, [r5, #28]
        if(MSS_USB_DMA_READ == dma_dir)    /*TX EP*/
        {
            ep_ptr = &gd_tx_ep[ep_num];

            /*EP interrupt wont happen when */
            if((MSS_USB_DMA_MODE1 == (MSS_USB_CIF_rx_ep_get_dma_mode(ep_num))) &&
    17c2:	b1c4      	cbz	r4, 17f6 <mss_usbd_dma_handler_cb+0xc2>
               (NO_ZLP_TO_XFR == ep_ptr->add_zlp) &&
               (ep_ptr->xfr_length) &&
               (!(ep_ptr->xfr_length % ep_ptr->max_pkt_size)))
    17c4:	892e      	ldrh	r6, [r5, #8]
    17c6:	fbb4 f7f6 	udiv	r7, r4, r6
    17ca:	fb06 4417 	mls	r4, r6, r7, r4
    17ce:	b994      	cbnz	r4, 17f6 <mss_usbd_dma_handler_cb+0xc2>
MSS_USB_CIF_tx_ep_is_txpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    return (((USB->ENDPOINT[ep_num].TX_CSR & TxCSRL_REG_EPN_TX_PKT_RDY_MASK) ?
    17d0:	f8b1 c002 	ldrh.w	ip, [r1, #2]
    17d4:	f01c 0f01 	tst.w	ip, #1
    17d8:	d1fa      	bne.n	17d0 <mss_usbd_dma_handler_cb+0x9c>
            {
                /* wait till last TxMaxPkt size packet is sent.*/
                while(MSS_USB_CIF_tx_ep_is_txpktrdy(ep_num));
                ep_ptr->xfr_count = dma_addr_val - (uint32_t)ep_ptr->buf_addr;

                if(0 != g_usbd_class_cb->usbd_class_tx_done)
    17da:	f640 319c 	movw	r1, #2972	; 0xb9c
    17de:	f2c2 0100 	movt	r1, #8192	; 0x2000
    17e2:	680c      	ldr	r4, [r1, #0]
               (ep_ptr->xfr_length) &&
               (!(ep_ptr->xfr_length % ep_ptr->max_pkt_size)))
            {
                /* wait till last TxMaxPkt size packet is sent.*/
                while(MSS_USB_CIF_tx_ep_is_txpktrdy(ep_num));
                ep_ptr->xfr_count = dma_addr_val - (uint32_t)ep_ptr->buf_addr;
    17e4:	69a9      	ldr	r1, [r5, #24]

                if(0 != g_usbd_class_cb->usbd_class_tx_done)
    17e6:	6924      	ldr	r4, [r4, #16]
               (ep_ptr->xfr_length) &&
               (!(ep_ptr->xfr_length % ep_ptr->max_pkt_size)))
            {
                /* wait till last TxMaxPkt size packet is sent.*/
                while(MSS_USB_CIF_tx_ep_is_txpktrdy(ep_num));
                ep_ptr->xfr_count = dma_addr_val - (uint32_t)ep_ptr->buf_addr;
    17e8:	1a5b      	subs	r3, r3, r1
    17ea:	622b      	str	r3, [r5, #32]

                if(0 != g_usbd_class_cb->usbd_class_tx_done)
    17ec:	2c00      	cmp	r4, #0
    17ee:	d0d1      	beq.n	1794 <mss_usbd_dma_handler_cb+0x60>
                {
                    /* call-back class driver */
                    g_usbd_class_cb->usbd_class_tx_done(ep_num, status);
    17f0:	4611      	mov	r1, r2
    17f2:	47a0      	blx	r4
    17f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
MSS_USB_CIF_tx_ep_set_txpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_TX_PKT_RDY_MASK;
    17f6:	ea4f 120c 	mov.w	r2, ip, lsl #4
    17fa:	f102 4c80 	add.w	ip, r2, #1073741824	; 0x40000000
    17fe:	f50c 2386 	add.w	r3, ip, #274432	; 0x43000
    1802:	8859      	ldrh	r1, [r3, #2]
    1804:	b288      	uxth	r0, r1
    1806:	f040 0201 	orr.w	r2, r0, #1
    180a:	805a      	strh	r2, [r3, #2]
    180c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
MSS_USB_CIF_rx_ep_clr_rxpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_RX_PKT_RDY_MASK;
    180e:	f8b5 c006 	ldrh.w	ip, [r5, #6]
    1812:	f02c 0301 	bic.w	r3, ip, #1
    1816:	0419      	lsls	r1, r3, #16
    1818:	0c0b      	lsrs	r3, r1, #16
    181a:	80eb      	strh	r3, [r5, #6]
    181c:	e7af      	b.n	177e <mss_usbd_dma_handler_cb+0x4a>
    181e:	bf00      	nop
    1820:	200008bc 	.word	0x200008bc

00001824 <MSS_USBD_cep_write>:
MSS_USBD_cep_write
(
    uint8_t * addr,
    uint32_t length
)
{
    1824:	b410      	push	{r4}
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    1826:	f240 73e0 	movw	r3, #2016	; 0x7e0
    182a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cep_ptr->xfr_length = length;

    cep_ptr->xfr_count = 0u;
    cep_ptr->txn_count = 0u;

    if(cep_ptr->xfr_length > cep_ptr->max_pkt_size)
    182e:	891a      	ldrh	r2, [r3, #8]
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    cep_ptr->xfr_length = length;

    cep_ptr->xfr_count = 0u;
    1830:	2400      	movs	r4, #0
    uint32_t length
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    1832:	6198      	str	r0, [r3, #24]
    cep_ptr->xfr_count = 0u;
    cep_ptr->txn_count = 0u;

    if(cep_ptr->xfr_length > cep_ptr->max_pkt_size)
    {
        cep_ptr->txn_length = cep_ptr->max_pkt_size;
    1834:	428a      	cmp	r2, r1
    1836:	bf94      	ite	ls
    1838:	625a      	strls	r2, [r3, #36]	; 0x24
    183a:	6259      	strhi	r1, [r3, #36]	; 0x24
    else
    {
        cep_ptr->txn_length = length;
    }

    MSS_USBD_CIF_cep_write_pkt(&gd_tx_ep[MSS_USB_CEP]);
    183c:	4618      	mov	r0, r3

    cep_ptr->buf_addr = addr;
    cep_ptr->xfr_length = length;

    cep_ptr->xfr_count = 0u;
    cep_ptr->txn_count = 0u;
    183e:	629c      	str	r4, [r3, #40]	; 0x28
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    cep_ptr->xfr_length = length;
    1840:	61d9      	str	r1, [r3, #28]

    cep_ptr->xfr_count = 0u;
    1842:	621c      	str	r4, [r3, #32]
    {
        cep_ptr->txn_length = length;
    }

    MSS_USBD_CIF_cep_write_pkt(&gd_tx_ep[MSS_USB_CEP]);
}
    1844:	bc10      	pop	{r4}
    else
    {
        cep_ptr->txn_length = length;
    }

    MSS_USBD_CIF_cep_write_pkt(&gd_tx_ep[MSS_USB_CEP]);
    1846:	f001 bad9 	b.w	2dfc <MSS_USBD_CIF_cep_write_pkt>
    184a:	bf00      	nop

0000184c <mss_usbd_ep_tx_complete_cb>:
mss_usbd_ep_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    184c:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    uint8_t transfer_complete = 0u;
    uint32_t increamented_addr = 0u;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[num];

    if(status & TX_EP_STALL_ERROR)
    1850:	f011 0f02 	tst.w	r1, #2
mss_usbd_ep_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    1854:	b085      	sub	sp, #20
    1856:	4680      	mov	r8, r0
    uint8_t transfer_complete = 0u;
    uint32_t increamented_addr = 0u;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[num];

    if(status & TX_EP_STALL_ERROR)
    1858:	d114      	bne.n	1884 <mss_usbd_ep_tx_complete_cb+0x38>
    uint8_t status
)
{
    uint8_t transfer_complete = 0u;
    uint32_t increamented_addr = 0u;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[num];
    185a:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
    185e:	fb0c fc00 	mul.w	ip, ip, r0
    1862:	f240 73e0 	movw	r3, #2016	; 0x7e0
    1866:	f2c2 0300 	movt	r3, #8192	; 0x2000
    186a:	eb03 000c 	add.w	r0, r3, ip
         DMA Disabled:
         For multi-packet bulk transfers, control will reach here after every
         single packet is transferred. Provide next packet for transmission till
         the end of data.
         */
        if(DMA_ENABLE == txep_ptr->dma_enable)
    186e:	7982      	ldrb	r2, [r0, #6]
    1870:	2a01      	cmp	r2, #1
    1872:	d013      	beq.n	189c <mss_usbd_ep_tx_complete_cb+0x50>
            /*TODO: Move the decision to transmit ZLP from CIFL to here*/
            transfer_complete = 1u;
        }
        else    /*DMA_DISABLE*/
        {
            txep_ptr->txn_count = txep_ptr->txn_length;
    1874:	6a46      	ldr	r6, [r0, #36]	; 0x24
            txep_ptr->xfr_count += txep_ptr->txn_length;
    1876:	6a07      	ldr	r7, [r0, #32]

            if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
    1878:	7b04      	ldrb	r4, [r0, #12]
            transfer_complete = 1u;
        }
        else    /*DMA_DISABLE*/
        {
            txep_ptr->txn_count = txep_ptr->txn_length;
            txep_ptr->xfr_count += txep_ptr->txn_length;
    187a:	19f7      	adds	r7, r6, r7

            if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
    187c:	2c02      	cmp	r4, #2
            /*TODO: Move the decision to transmit ZLP from CIFL to here*/
            transfer_complete = 1u;
        }
        else    /*DMA_DISABLE*/
        {
            txep_ptr->txn_count = txep_ptr->txn_length;
    187e:	6286      	str	r6, [r0, #40]	; 0x28
            txep_ptr->xfr_count += txep_ptr->txn_length;
    1880:	6207      	str	r7, [r0, #32]

            if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
    1882:	d01f      	beq.n	18c4 <mss_usbd_ep_tx_complete_cb+0x78>
        }
    }
    if(1u == transfer_complete)
    {
        #ifndef MSS_USB_DEVICE_TEST_MODE
                if(0 != g_usbd_class_cb->usbd_class_tx_done)
    1884:	f640 329c 	movw	r2, #2972	; 0xb9c
    1888:	f2c2 0200 	movt	r2, #8192	; 0x2000
    188c:	6810      	ldr	r0, [r2, #0]
    188e:	6903      	ldr	r3, [r0, #16]
    1890:	b10b      	cbz	r3, 1896 <mss_usbd_ep_tx_complete_cb+0x4a>
                {
                    g_usbd_class_cb->usbd_class_tx_done(num, status);
    1892:	4640      	mov	r0, r8
    1894:	4798      	blx	r3
                                 txep_ptr->dma_channel,
                                 txep_ptr->xfr_type,
                                 txep_ptr->xfr_length,
                                 txep_ptr->txn_length);
    }
}
    1896:	b005      	add	sp, #20
    1898:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
MSS_USB_CIF_dma_read_addr
(
    mss_usb_dma_channel_t dma_channel
)
{
    return (USB->DMA_CHANNEL[dma_channel].ADDR);
    189c:	79c3      	ldrb	r3, [r0, #7]
         the end of data.
         */
        if(DMA_ENABLE == txep_ptr->dma_enable)
        {
            increamented_addr = MSS_USB_CIF_dma_read_addr(txep_ptr->dma_channel);
            txep_ptr->xfr_count = increamented_addr - ((uint32_t)txep_ptr->buf_addr);
    189e:	6982      	ldr	r2, [r0, #24]
    18a0:	011b      	lsls	r3, r3, #4
    18a2:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
    18a6:	f50c 2386 	add.w	r3, ip, #274432	; 0x43000
    18aa:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    18ae:	1a9b      	subs	r3, r3, r2
        }
    }
    if(1u == transfer_complete)
    {
        #ifndef MSS_USB_DEVICE_TEST_MODE
                if(0 != g_usbd_class_cb->usbd_class_tx_done)
    18b0:	f640 329c 	movw	r2, #2972	; 0xb9c
    18b4:	f2c2 0200 	movt	r2, #8192	; 0x2000
         the end of data.
         */
        if(DMA_ENABLE == txep_ptr->dma_enable)
        {
            increamented_addr = MSS_USB_CIF_dma_read_addr(txep_ptr->dma_channel);
            txep_ptr->xfr_count = increamented_addr - ((uint32_t)txep_ptr->buf_addr);
    18b8:	6203      	str	r3, [r0, #32]
        }
    }
    if(1u == transfer_complete)
    {
        #ifndef MSS_USB_DEVICE_TEST_MODE
                if(0 != g_usbd_class_cb->usbd_class_tx_done)
    18ba:	6810      	ldr	r0, [r2, #0]
    18bc:	6903      	ldr	r3, [r0, #16]
    18be:	2b00      	cmp	r3, #0
    18c0:	d1e7      	bne.n	1892 <mss_usbd_ep_tx_complete_cb+0x46>
    18c2:	e7e8      	b.n	1896 <mss_usbd_ep_tx_complete_cb+0x4a>
            txep_ptr->txn_count = txep_ptr->txn_length;
            txep_ptr->xfr_count += txep_ptr->txn_length;

            if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
            {
                if(txep_ptr->xfr_count < txep_ptr->xfr_length)
    18c4:	69c5      	ldr	r5, [r0, #28]
    18c6:	42af      	cmp	r7, r5
    18c8:	d300      	bcc.n	18cc <mss_usbd_ep_tx_complete_cb+0x80>
                {
                    transfer_complete = 0u;
                }
                else if(txep_ptr->xfr_count == txep_ptr->xfr_length)
    18ca:	d026      	beq.n	191a <mss_usbd_ep_tx_complete_cb+0xce>
    18cc:	f8b0 a008 	ldrh.w	sl, [r0, #8]
         is completed now
         */
        txep_ptr->txn_count = 0u;
        ASSERT(txep_ptr->xfr_length >= txep_ptr->xfr_count);

        if((txep_ptr->xfr_length - txep_ptr->xfr_count) >= txep_ptr->max_pkt_size)
    18d0:	1be9      	subs	r1, r5, r7
    18d2:	4656      	mov	r6, sl
    {
        /*
         Reset the txn_count since one transaction out of the transfer
         is completed now
         */
        txep_ptr->txn_count = 0u;
    18d4:	f04f 0e00 	mov.w	lr, #0
        ASSERT(txep_ptr->xfr_length >= txep_ptr->xfr_count);

        if((txep_ptr->xfr_length - txep_ptr->xfr_count) >= txep_ptr->max_pkt_size)
    18d8:	4551      	cmp	r1, sl
    {
        /*
         Reset the txn_count since one transaction out of the transfer
         is completed now
         */
        txep_ptr->txn_count = 0u;
    18da:	f8c0 e028 	str.w	lr, [r0, #40]	; 0x28
        ASSERT(txep_ptr->xfr_length >= txep_ptr->xfr_count);

        if((txep_ptr->xfr_length - txep_ptr->xfr_count) >= txep_ptr->max_pkt_size)
        {
            txep_ptr->txn_length = txep_ptr->max_pkt_size;
    18de:	bf28      	it	cs
    18e0:	6246      	strcs	r6, [r0, #36]	; 0x24
         is completed now
         */
        txep_ptr->txn_count = 0u;
        ASSERT(txep_ptr->xfr_length >= txep_ptr->xfr_count);

        if((txep_ptr->xfr_length - txep_ptr->xfr_count) >= txep_ptr->max_pkt_size)
    18e2:	d317      	bcc.n	1914 <mss_usbd_ep_tx_complete_cb+0xc8>
        {
            txep_ptr->txn_length = txep_ptr->max_pkt_size;
        }
        else
        {
            txep_ptr->txn_length = (txep_ptr->xfr_length - txep_ptr->xfr_count);
    18e4:	f813 c00c 	ldrb.w	ip, [r3, ip]
 Indicates that there is at least one byte available to be transmitted from
 TX FIFO
 */
static __INLINE uint8_t MSS_USB_CIF_is_txepfifo_notempty(mss_usb_ep_num_t ep_num)
{
    return(((USB->ENDPOINT[ep_num].TX_CSR & TxCSRL_REG_EPN_TX_FIFO_NE_MASK)
    18e8:	f243 1100 	movw	r1, #12544	; 0x3100
    18ec:	f2c4 0104 	movt	r1, #16388	; 0x4004
    18f0:	ea4f 130c 	mov.w	r3, ip, lsl #4
    18f4:	1859      	adds	r1, r3, r1
    18f6:	f8b1 e002 	ldrh.w	lr, [r1, #2]
    18fa:	f01e 0f02 	tst.w	lr, #2
    18fe:	d1fa      	bne.n	18f6 <mss_usbd_ep_tx_complete_cb+0xaa>
        }

        while(MSS_USB_CIF_is_txepfifo_notempty(txep_ptr->num));
        MSS_USB_CIF_ep_write_pkt(txep_ptr->num,
    1900:	6981      	ldr	r1, [r0, #24]
    1902:	79c3      	ldrb	r3, [r0, #7]
    1904:	1879      	adds	r1, r7, r1
    1906:	4660      	mov	r0, ip
    1908:	9400      	str	r4, [sp, #0]
    190a:	9501      	str	r5, [sp, #4]
    190c:	9602      	str	r6, [sp, #8]
    190e:	f7ff fad3 	bl	eb8 <MSS_USB_CIF_ep_write_pkt>
    1912:	e7c0      	b.n	1896 <mss_usbd_ep_tx_complete_cb+0x4a>
        {
            txep_ptr->txn_length = txep_ptr->max_pkt_size;
        }
        else
        {
            txep_ptr->txn_length = (txep_ptr->xfr_length - txep_ptr->xfr_count);
    1914:	6241      	str	r1, [r0, #36]	; 0x24
    1916:	460e      	mov	r6, r1
    1918:	e7e4      	b.n	18e4 <mss_usbd_ep_tx_complete_cb+0x98>
                {
                    transfer_complete = 0u;
                }
                else if(txep_ptr->xfr_count == txep_ptr->xfr_length)
                {
                    if(ADD_ZLP_TO_XFR == txep_ptr->add_zlp)
    191a:	f8d0 a010 	ldr.w	sl, [r0, #16]
    191e:	f1ba 0f01 	cmp.w	sl, #1
    1922:	d1af      	bne.n	1884 <mss_usbd_ep_tx_complete_cb+0x38>
                    {
                        if(0u == txep_ptr->txn_count)
    1924:	2e00      	cmp	r6, #0
    1926:	d0ad      	beq.n	1884 <mss_usbd_ep_tx_complete_cb+0x38>
                        {
                            transfer_complete = 1u;
                        }
                        else
                        {
                            if(txep_ptr->txn_count == txep_ptr->max_pkt_size)
    1928:	f8b0 a008 	ldrh.w	sl, [r0, #8]
    192c:	4556      	cmp	r6, sl
    192e:	d0cf      	beq.n	18d0 <mss_usbd_ep_tx_complete_cb+0x84>
                            {
                                transfer_complete = 0u;
                            }
                            else if(txep_ptr->txn_count < txep_ptr->max_pkt_size)
    1930:	d2ce      	bcs.n	18d0 <mss_usbd_ep_tx_complete_cb+0x84>
    1932:	e7a7      	b.n	1884 <mss_usbd_ep_tx_complete_cb+0x38>

00001934 <MSS_USBD_tx_ep_write>:
(
    mss_usb_ep_num_t ep_num,
    uint8_t * addr,
    uint32_t length
)
{
    1934:	b5f0      	push	{r4, r5, r6, r7, lr}

    /* assert if uneven value for BULK transfers */
    ASSERT(ep_num);
    ASSERT(addr != 0);

    if((ep_num) && (addr != 0))
    1936:	1e03      	subs	r3, r0, #0
    1938:	bf18      	it	ne
    193a:	2301      	movne	r3, #1
    193c:	2900      	cmp	r1, #0
    193e:	bf0c      	ite	eq
    1940:	2300      	moveq	r3, #0
    1942:	f003 0301 	andne.w	r3, r3, #1
(
    mss_usb_ep_num_t ep_num,
    uint8_t * addr,
    uint32_t length
)
{
    1946:	b085      	sub	sp, #20
    1948:	4614      	mov	r4, r2

    /* assert if uneven value for BULK transfers */
    ASSERT(ep_num);
    ASSERT(addr != 0);

    if((ep_num) && (addr != 0))
    194a:	b323      	cbz	r3, 1996 <MSS_USBD_tx_ep_write+0x62>
    uint8_t * addr,
    uint32_t length
)
{
    uint8_t dpb = 1u;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];
    194c:	222c      	movs	r2, #44	; 0x2c
    194e:	fb02 fc00 	mul.w	ip, r2, r0
    1952:	f240 7ee0 	movw	lr, #2016	; 0x7e0
    1956:	f2c2 0e00 	movt	lr, #8192	; 0x2000
    195a:	eb0e 020c 	add.w	r2, lr, ip
    ASSERT(ep_num);
    ASSERT(addr != 0);

    if((ep_num) && (addr != 0))
    {
        if(DPB_ENABLE == txep_ptr->dpb_enable)
    195e:	7856      	ldrb	r6, [r2, #1]
        txep_ptr->buf_addr = addr;
        txep_ptr->xfr_length = length;
        txep_ptr->xfr_count = 0u;
        txep_ptr->txn_count = 0u;

        if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
    1960:	7b15      	ldrb	r5, [r2, #12]
            dpb = 2u;
        }
        txep_ptr->num = ep_num;
        txep_ptr->buf_addr = addr;
        txep_ptr->xfr_length = length;
        txep_ptr->xfr_count = 0u;
    1962:	2700      	movs	r7, #0
    ASSERT(ep_num);
    ASSERT(addr != 0);

    if((ep_num) && (addr != 0))
    {
        if(DPB_ENABLE == txep_ptr->dpb_enable)
    1964:	2e01      	cmp	r6, #1
    1966:	bf14      	ite	ne
    1968:	2601      	movne	r6, #1
    196a:	2602      	moveq	r6, #2
        txep_ptr->buf_addr = addr;
        txep_ptr->xfr_length = length;
        txep_ptr->xfr_count = 0u;
        txep_ptr->txn_count = 0u;

        if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
    196c:	2d02      	cmp	r5, #2
    {
        if(DPB_ENABLE == txep_ptr->dpb_enable)
        {
            dpb = 2u;
        }
        txep_ptr->num = ep_num;
    196e:	f80e 000c 	strb.w	r0, [lr, ip]
        txep_ptr->buf_addr = addr;
        txep_ptr->xfr_length = length;
        txep_ptr->xfr_count = 0u;
        txep_ptr->txn_count = 0u;
    1972:	6297      	str	r7, [r2, #40]	; 0x28
        if(DPB_ENABLE == txep_ptr->dpb_enable)
        {
            dpb = 2u;
        }
        txep_ptr->num = ep_num;
        txep_ptr->buf_addr = addr;
    1974:	6191      	str	r1, [r2, #24]
        txep_ptr->xfr_length = length;
    1976:	61d4      	str	r4, [r2, #28]
        txep_ptr->xfr_count = 0u;
    1978:	6217      	str	r7, [r2, #32]
        txep_ptr->txn_count = 0u;

        if(MSS_USB_XFR_BULK == txep_ptr->xfr_type)
    197a:	d015      	beq.n	19a8 <MSS_USBD_tx_ep_write+0x74>

        /*
         section 8.4.2.3 -- No support for HB in Interrupt transfers.
         i.e. maximum one packet(num_usb_pkt=1)can be transferred in one frame.
         */
        else if(MSS_USB_XFR_INTERRUPT == txep_ptr->xfr_type)
    197c:	2d03      	cmp	r5, #3
    197e:	d00c      	beq.n	199a <MSS_USBD_tx_ep_write+0x66>
            else
            {
                txep_ptr->txn_length = length;
            }
        }
        else if(MSS_USB_XFR_ISO == txep_ptr->xfr_type)
    1980:	2d01      	cmp	r5, #1
    1982:	bf18      	it	ne
    1984:	6a56      	ldrne	r6, [r2, #36]	; 0x24
    1986:	d008      	beq.n	199a <MSS_USBD_tx_ep_write+0x66>
            {
                txep_ptr->txn_length = length;
            }
        }

        MSS_USB_CIF_ep_write_pkt(txep_ptr->num,
    1988:	79d3      	ldrb	r3, [r2, #7]
    198a:	7992      	ldrb	r2, [r2, #6]
    198c:	9500      	str	r5, [sp, #0]
    198e:	9401      	str	r4, [sp, #4]
    1990:	9602      	str	r6, [sp, #8]
    1992:	f7ff fa91 	bl	eb8 <MSS_USB_CIF_ep_write_pkt>
                                 txep_ptr->dma_channel,
                                 txep_ptr->xfr_type,
                                 txep_ptr->xfr_length,
                                 txep_ptr->txn_length);
    }
}
    1996:	b005      	add	sp, #20
    1998:	bdf0      	pop	{r4, r5, r6, r7, pc}
                txep_ptr->txn_length = length;
            }
        }
        else if(MSS_USB_XFR_ISO == txep_ptr->xfr_type)
        {
            if(length >= (txep_ptr->max_pkt_size * dpb))
    199a:	8913      	ldrh	r3, [r2, #8]
    199c:	fb03 f606 	mul.w	r6, r3, r6
    19a0:	42b4      	cmp	r4, r6
    19a2:	d304      	bcc.n	19ae <MSS_USBD_tx_ep_write+0x7a>
            {
                txep_ptr->txn_length = (txep_ptr->max_pkt_size * dpb);
    19a4:	6256      	str	r6, [r2, #36]	; 0x24
    19a6:	e7ef      	b.n	1988 <MSS_USBD_tx_ep_write+0x54>
            /*
            TODO: TxMaxP payload value MUST be an even number when dealing with
            Multi packet Bulk transaction for proper interrupt generation.
            This needs to be taken care.
            */
            if(length <= txep_ptr->fifo_size)
    19a8:	8856      	ldrh	r6, [r2, #2]
    19aa:	42b4      	cmp	r4, r6
    19ac:	d8fa      	bhi.n	19a4 <MSS_USBD_tx_ep_write+0x70>
            {
                txep_ptr->txn_length = (txep_ptr->max_pkt_size * dpb);
            }
            else
            {
                txep_ptr->txn_length = length;
    19ae:	6254      	str	r4, [r2, #36]	; 0x24
    19b0:	4626      	mov	r6, r4
    19b2:	e7e9      	b.n	1988 <MSS_USBD_tx_ep_write+0x54>

000019b4 <mss_usbd_ep_rx_cb>:
    mss_usb_ep_num_t ep_num,
    uint8_t status
)
{
    uint8_t transfer_complete = 0u;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    19b4:	222c      	movs	r2, #44	; 0x2c
mss_usbd_ep_rx_cb
(
    mss_usb_ep_num_t ep_num,
    uint8_t status
)
{
    19b6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t transfer_complete = 0u;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    19ba:	fb02 f200 	mul.w	r2, r2, r0
    19be:	4bb1      	ldr	r3, [pc, #708]	; (1c84 <mss_usbd_ep_rx_cb+0x2d0>)
mss_usbd_ep_rx_cb
(
    mss_usb_ep_num_t ep_num,
    uint8_t status
)
{
    19c0:	b089      	sub	sp, #36	; 0x24
    uint8_t transfer_complete = 0u;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    19c2:	189c      	adds	r4, r3, r2
     is concluded when xfr_count = xfr_length. No zlp is expected to be
     received for the case of xfr_length = n*maxpktsz.
     When DMA-m1 is enabled, the control will return here only once after
     completion of transfer.
     */
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
    19c4:	f011 0f0f 	tst.w	r1, #15
    19c8:	d00b      	beq.n	19e2 <mss_usbd_ep_rx_cb+0x2e>
                                       rxep_ptr->xfr_length);
    }
    else if(transfer_complete == 1)
    {
        #ifndef MSS_USB_DEVICE_TEST_MODE
        if(0 != g_usbd_class_cb->usbd_class_rx_done)
    19ca:	f640 339c 	movw	r3, #2972	; 0xb9c
    19ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    19d2:	681a      	ldr	r2, [r3, #0]
    19d4:	6953      	ldr	r3, [r2, #20]
    19d6:	b10b      	cbz	r3, 19dc <mss_usbd_ep_rx_cb+0x28>
        {
            g_usbd_class_cb->usbd_class_rx_done(ep_num, status, rxep_ptr->xfr_count);
    19d8:	6a22      	ldr	r2, [r4, #32]
    19da:	4798      	blx	r3
    else
    {
        /*Do Nothing. DMA m0 will be handled in DMA_Handler*/
    }

}
    19dc:	b009      	add	sp, #36	; 0x24
    19de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
MSS_USB_CIF_rx_ep_is_rxpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_RX_PKT_RDY_MASK) ?
    19e2:	f100 0b10 	add.w	fp, r0, #16
    19e6:	ea4f 150b 	mov.w	r5, fp, lsl #4
    19ea:	f105 4680 	add.w	r6, r5, #1073741824	; 0x40000000
    19ee:	f506 2686 	add.w	r6, r6, #274432	; 0x43000
    19f2:	f8b6 c006 	ldrh.w	ip, [r6, #6]
    19f6:	f01c 0f01 	tst.w	ip, #1
    19fa:	d116      	bne.n	1a2a <mss_usbd_ep_rx_cb+0x76>
                {
                    /*
                     For ISO and interrupt transfers, LB-expects only one packet in
                     one transaction HB expects at most 3 packets in one transaction
                     */
                    if(rxep_ptr->txn_count <= rxep_ptr->max_pkt_size)
    19fc:	69e5      	ldr	r5, [r4, #28]
    19fe:	6a26      	ldr	r6, [r4, #32]
    1a00:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    1a04:	7b27      	ldrb	r7, [r4, #12]
        /*
         Reset the txn_count since one transaction out of the
         transfer is completed.
         */
        rxep_ptr->txn_count = 0u;
        MSS_USB_CIF_rx_ep_read_prepare(rxep_ptr->num,
    1a06:	69a1      	ldr	r1, [r4, #24]
    1a08:	5c98      	ldrb	r0, [r3, r2]
    1a0a:	1989      	adds	r1, r1, r6

    if(transfer_complete == 0)
    {
        ASSERT(rxep_ptr->xfr_length >= rxep_ptr->xfr_count);

        if((rxep_ptr->xfr_length - rxep_ptr->xfr_count) >= rxep_ptr->max_pkt_size)
    1a0c:	1bae      	subs	r6, r5, r6
        {
            rxep_ptr->txn_length = rxep_ptr->max_pkt_size;
    1a0e:	45b4      	cmp	ip, r6
    1a10:	bf94      	ite	ls
    1a12:	f8c4 c024 	strls.w	ip, [r4, #36]	; 0x24
    1a16:	6266      	strhi	r6, [r4, #36]	; 0x24

        /*
         Reset the txn_count since one transaction out of the
         transfer is completed.
         */
        rxep_ptr->txn_count = 0u;
    1a18:	2600      	movs	r6, #0
        MSS_USB_CIF_rx_ep_read_prepare(rxep_ptr->num,
    1a1a:	79e3      	ldrb	r3, [r4, #7]
    1a1c:	79a2      	ldrb	r2, [r4, #6]

        /*
         Reset the txn_count since one transaction out of the
         transfer is completed.
         */
        rxep_ptr->txn_count = 0u;
    1a1e:	62a6      	str	r6, [r4, #40]	; 0x28
        MSS_USB_CIF_rx_ep_read_prepare(rxep_ptr->num,
    1a20:	9700      	str	r7, [sp, #0]
    1a22:	9501      	str	r5, [sp, #4]
    1a24:	f7ff f9f4 	bl	e10 <MSS_USB_CIF_rx_ep_read_prepare>
    1a28:	e7d8      	b.n	19dc <mss_usbd_ep_rx_cb+0x28>
(
    mss_usb_ep_num_t ep_num
)
{
    /*only valid when rxpktrdy is set*/
    return (USB->ENDPOINT[ep_num].RX_COUNT);
    1a2a:	0105      	lsls	r5, r0, #4
    1a2c:	f105 4c80 	add.w	ip, r5, #1073741824	; 0x40000000
    1a30:	f50c 2586 	add.w	r5, ip, #274432	; 0x43000
        {
            uint32_t increamented_addr;

            received_count = (uint32_t)MSS_USB_CIF_rx_ep_read_count(ep_num);

            if(DMA_ENABLE == rxep_ptr->dma_enable)
    1a34:	f894 c006 	ldrb.w	ip, [r4, #6]
    1a38:	f8b5 5108 	ldrh.w	r5, [r5, #264]	; 0x108
    1a3c:	f1bc 0f01 	cmp.w	ip, #1
    1a40:	b2ad      	uxth	r5, r5
    1a42:	f000 8093 	beq.w	1b6c <mss_usbd_ep_rx_cb+0x1b8>
                    /*Upper layer cb will be called from DMA ISR*/
                }
            }
            else // no dma
            {
                if(received_count)
    1a46:	2d00      	cmp	r5, #0
    1a48:	d076      	beq.n	1b38 <mss_usbd_ep_rx_cb+0x184>
                {
                    MSS_USB_CIF_read_rx_fifo(ep_num,
    1a4a:	69a7      	ldr	r7, [r4, #24]
    1a4c:	6a26      	ldr	r6, [r4, #32]
    1a4e:	19be      	adds	r6, r7, r6

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a50:	ea5f 0995 	movs.w	r9, r5, lsr #2
    1a54:	9605      	str	r6, [sp, #20]
    1a56:	d034      	beq.n	1ac2 <mss_usbd_ep_rx_cb+0x10e>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1a58:	f243 0600 	movw	r6, #12288	; 0x3000
    1a5c:	f2c4 0604 	movt	r6, #16388	; 0x4004
    1a60:	9603      	str	r6, [sp, #12]
    1a62:	f100 0a08 	add.w	sl, r0, #8
    1a66:	f856 702a 	ldr.w	r7, [r6, sl, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a6a:	f04f 0c01 	mov.w	ip, #1
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1a6e:	9e05      	ldr	r6, [sp, #20]
    1a70:	f109 38ff 	add.w	r8, r9, #4294967295

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a74:	45cc      	cmp	ip, r9
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1a76:	6037      	str	r7, [r6, #0]
    1a78:	ea08 080c 	and.w	r8, r8, ip

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a7c:	d221      	bcs.n	1ac2 <mss_usbd_ep_rx_cb+0x10e>
    1a7e:	f1b8 0f00 	cmp.w	r8, #0
    1a82:	d009      	beq.n	1a98 <mss_usbd_ep_rx_cb+0xe4>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1a84:	9f03      	ldr	r7, [sp, #12]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a86:	f04f 0c02 	mov.w	ip, #2
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1a8a:	f857 802a 	ldr.w	r8, [r7, sl, lsl #2]
    1a8e:	9e05      	ldr	r6, [sp, #20]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a90:	45cc      	cmp	ip, r9
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1a92:	f8c6 8004 	str.w	r8, [r6, #4]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1a96:	d214      	bcs.n	1ac2 <mss_usbd_ep_rx_cb+0x10e>
    1a98:	9e05      	ldr	r6, [sp, #20]
    1a9a:	9f03      	ldr	r7, [sp, #12]
    1a9c:	9507      	str	r5, [sp, #28]
    1a9e:	46a0      	mov	r8, r4
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1aa0:	f857 502a 	ldr.w	r5, [r7, sl, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1aa4:	f10c 0401 	add.w	r4, ip, #1
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1aa8:	f846 502c 	str.w	r5, [r6, ip, lsl #2]
    1aac:	f857 502a 	ldr.w	r5, [r7, sl, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1ab0:	f104 0c01 	add.w	ip, r4, #1
    1ab4:	45cc      	cmp	ip, r9
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1ab6:	f846 5024 	str.w	r5, [r6, r4, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1aba:	d3f1      	bcc.n	1aa0 <mss_usbd_ep_rx_cb+0xec>
    1abc:	9d07      	ldr	r5, [sp, #28]
    1abe:	9605      	str	r6, [sp, #20]
    1ac0:	4644      	mov	r4, r8
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1ac2:	f025 0c03 	bic.w	ip, r5, #3
    1ac6:	4565      	cmp	r5, ip
    1ac8:	d932      	bls.n	1b30 <mss_usbd_ep_rx_cb+0x17c>
    1aca:	ea6f 070c 	mvn.w	r7, ip
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1ace:	f243 0800 	movw	r8, #12288	; 0x3000
    1ad2:	197e      	adds	r6, r7, r5
    1ad4:	f2c4 0804 	movt	r8, #16388	; 0x4004
    1ad8:	9f05      	ldr	r7, [sp, #20]
    1ada:	f100 0a08 	add.w	sl, r0, #8
    1ade:	f818 902a 	ldrb.w	r9, [r8, sl, lsl #2]
    1ae2:	9607      	str	r6, [sp, #28]
    1ae4:	eb07 060c 	add.w	r6, r7, ip
    1ae8:	f806 9b01 	strb.w	r9, [r6], #1
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1aec:	f10c 0c01 	add.w	ip, ip, #1
    1af0:	f8dd 901c 	ldr.w	r9, [sp, #28]
    1af4:	4565      	cmp	r5, ip
    1af6:	f009 0701 	and.w	r7, r9, #1
    1afa:	d919      	bls.n	1b30 <mss_usbd_ep_rx_cb+0x17c>
    1afc:	b13f      	cbz	r7, 1b0e <mss_usbd_ep_rx_cb+0x15a>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1afe:	f818 702a 	ldrb.w	r7, [r8, sl, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1b02:	f10c 0c01 	add.w	ip, ip, #1
    1b06:	4565      	cmp	r5, ip
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1b08:	f806 7b01 	strb.w	r7, [r6], #1
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1b0c:	d910      	bls.n	1b30 <mss_usbd_ep_rx_cb+0x17c>
    1b0e:	46a1      	mov	r9, r4
    1b10:	4647      	mov	r7, r8
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1b12:	f817 802a 	ldrb.w	r8, [r7, sl, lsl #2]
    1b16:	4634      	mov	r4, r6
    1b18:	f804 8b01 	strb.w	r8, [r4], #1
    1b1c:	f817 802a 	ldrb.w	r8, [r7, sl, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1b20:	f10c 0c02 	add.w	ip, ip, #2
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1b24:	f886 8001 	strb.w	r8, [r6, #1]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1b28:	1c66      	adds	r6, r4, #1
    1b2a:	4565      	cmp	r5, ip
    1b2c:	d8f1      	bhi.n	1b12 <mss_usbd_ep_rx_cb+0x15e>
    1b2e:	464c      	mov	r4, r9
                                             (rxep_ptr->buf_addr+rxep_ptr->xfr_count),
                                             received_count);

                    rxep_ptr->txn_count = received_count;
                    rxep_ptr->xfr_count += received_count;
    1b30:	6a26      	ldr	r6, [r4, #32]
                {
                    MSS_USB_CIF_read_rx_fifo(ep_num,
                                             (rxep_ptr->buf_addr+rxep_ptr->xfr_count),
                                             received_count);

                    rxep_ptr->txn_count = received_count;
    1b32:	62a5      	str	r5, [r4, #40]	; 0x28
                    rxep_ptr->xfr_count += received_count;
    1b34:	1975      	adds	r5, r6, r5
    1b36:	6225      	str	r5, [r4, #32]
                }
                if(MSS_USB_XFR_BULK == rxep_ptr->xfr_type)
    1b38:	7b27      	ldrb	r7, [r4, #12]
    1b3a:	2f02      	cmp	r7, #2
    1b3c:	f000 80a4 	beq.w	1c88 <mss_usbd_ep_rx_cb+0x2d4>
                {
                    /*
                     For ISO and interrupt transfers, LB-expects only one packet in
                     one transaction HB expects at most 3 packets in one transaction
                     */
                    if(rxep_ptr->txn_count <= rxep_ptr->max_pkt_size)
    1b40:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    1b44:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    1b46:	4565      	cmp	r5, ip
    1b48:	f240 808d 	bls.w	1c66 <mss_usbd_ep_rx_cb+0x2b2>
    1b4c:	6a26      	ldr	r6, [r4, #32]
    1b4e:	69e5      	ldr	r5, [r4, #28]
MSS_USB_CIF_rx_ep_clr_rxpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_RX_PKT_RDY_MASK;
    1b50:	ea4f 1b0b 	mov.w	fp, fp, lsl #4
    1b54:	f10b 4080 	add.w	r0, fp, #1073741824	; 0x40000000
    1b58:	f500 2086 	add.w	r0, r0, #274432	; 0x43000
    1b5c:	f8b0 e006 	ldrh.w	lr, [r0, #6]
    1b60:	f02e 0101 	bic.w	r1, lr, #1
    1b64:	0409      	lsls	r1, r1, #16
    1b66:	0c09      	lsrs	r1, r1, #16
    1b68:	80c1      	strh	r1, [r0, #6]
    1b6a:	e74c      	b.n	1a06 <mss_usbd_ep_rx_cb+0x52>
MSS_USB_CIF_rx_ep_get_dma_mode
(
    mss_usb_ep_num_t ep_num
)
{
    return(((USB->ENDPOINT[ep_num].RX_CSR & RxCSRL_REG_EPN_DMA_MODE_MASK) ?
    1b6c:	88f3      	ldrh	r3, [r6, #6]

            received_count = (uint32_t)MSS_USB_CIF_rx_ep_read_count(ep_num);

            if(DMA_ENABLE == rxep_ptr->dma_enable)
            {
                if(MSS_USB_DMA_MODE1 == (MSS_USB_CIF_rx_ep_get_dma_mode(ep_num)))
    1b6e:	f413 6f00 	tst.w	r3, #2048	; 0x800
    1b72:	f000 8095 	beq.w	1ca0 <mss_usbd_ep_rx_cb+0x2ec>
MSS_USB_CIF_dma_stop_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL &= ~DMA_CNTL_REG_START_XFR_MASK;
    1b76:	79e2      	ldrb	r2, [r4, #7]
    1b78:	f243 2300 	movw	r3, #12800	; 0x3200
    1b7c:	0117      	lsls	r7, r2, #4
    1b7e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1b82:	18fb      	adds	r3, r7, r3
    1b84:	f8d3 8004 	ldr.w	r8, [r3, #4]
    1b88:	f028 0201 	bic.w	r2, r8, #1
    1b8c:	605a      	str	r2, [r3, #4]
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    1b8e:	88f2      	ldrh	r2, [r6, #6]
MSS_USB_CIF_dma_read_addr
(
    mss_usb_dma_channel_t dma_channel
)
{
    return (USB->DMA_CHANNEL[dma_channel].ADDR);
    1b90:	f107 4380 	add.w	r3, r7, #1073741824	; 0x40000000
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    1b94:	0452      	lsls	r2, r2, #17
    1b96:	0c52      	lsrs	r2, r2, #17
    1b98:	80f2      	strh	r2, [r6, #6]
MSS_USB_CIF_dma_read_addr
(
    mss_usb_dma_channel_t dma_channel
)
{
    return (USB->DMA_CHANNEL[dma_channel].ADDR);
    1b9a:	f503 2286 	add.w	r2, r3, #274432	; 0x43000
    1b9e:	f8d2 3208 	ldr.w	r3, [r2, #520]	; 0x208
                    MSS_USB_CIF_rx_ep_clr_autoclr(ep_num);

                    /*Count number of bytes read so far,since DMA was
                    operating in m1 with Autoclr.*/
                    increamented_addr = MSS_USB_CIF_dma_read_addr(rxep_ptr->dma_channel);
                    rxep_ptr->xfr_count = (increamented_addr - (uint32_t)(rxep_ptr->buf_addr));
    1ba2:	69a2      	ldr	r2, [r4, #24]
    1ba4:	1a9b      	subs	r3, r3, r2
    1ba6:	6223      	str	r3, [r4, #32]

                    if(received_count)
    1ba8:	2d00      	cmp	r5, #0
    1baa:	d05c      	beq.n	1c66 <mss_usbd_ep_rx_cb+0x2b2>
                    {
                        MSS_USB_CIF_read_rx_fifo(ep_num,
    1bac:	189b      	adds	r3, r3, r2

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1bae:	ea5f 0895 	movs.w	r8, r5, lsr #2
    1bb2:	d026      	beq.n	1c02 <mss_usbd_ep_rx_cb+0x24e>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1bb4:	f243 0200 	movw	r2, #12288	; 0x3000
    1bb8:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1bbc:	f100 0708 	add.w	r7, r0, #8
    1bc0:	f852 6027 	ldr.w	r6, [r2, r7, lsl #2]
    1bc4:	f108 3aff 	add.w	sl, r8, #4294967295

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1bc8:	45c4      	cmp	ip, r8
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1bca:	601e      	str	r6, [r3, #0]
    1bcc:	f00a 0601 	and.w	r6, sl, #1

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1bd0:	d217      	bcs.n	1c02 <mss_usbd_ep_rx_cb+0x24e>
    1bd2:	b136      	cbz	r6, 1be2 <mss_usbd_ep_rx_cb+0x22e>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1bd4:	f852 6027 	ldr.w	r6, [r2, r7, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1bd8:	f04f 0c02 	mov.w	ip, #2
    1bdc:	45c4      	cmp	ip, r8
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1bde:	605e      	str	r6, [r3, #4]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1be0:	d20f      	bcs.n	1c02 <mss_usbd_ep_rx_cb+0x24e>
    1be2:	468a      	mov	sl, r1
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1be4:	f852 1027 	ldr.w	r1, [r2, r7, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1be8:	f10c 0601 	add.w	r6, ip, #1
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1bec:	f843 102c 	str.w	r1, [r3, ip, lsl #2]
    1bf0:	f852 1027 	ldr.w	r1, [r2, r7, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1bf4:	f106 0c01 	add.w	ip, r6, #1
    1bf8:	45c4      	cmp	ip, r8
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    1bfa:	f843 1026 	str.w	r1, [r3, r6, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    1bfe:	d3f1      	bcc.n	1be4 <mss_usbd_ep_rx_cb+0x230>
    1c00:	4651      	mov	r1, sl
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c02:	f025 0c03 	bic.w	ip, r5, #3
    1c06:	4565      	cmp	r5, ip
    1c08:	d92a      	bls.n	1c60 <mss_usbd_ep_rx_cb+0x2ac>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1c0a:	f243 0600 	movw	r6, #12288	; 0x3000
    1c0e:	f2c4 0604 	movt	r6, #16388	; 0x4004
    1c12:	f100 0708 	add.w	r7, r0, #8
    1c16:	ea6f 020c 	mvn.w	r2, ip
    1c1a:	4463      	add	r3, ip
    1c1c:	f816 8027 	ldrb.w	r8, [r6, r7, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c20:	f10c 0c01 	add.w	ip, ip, #1
    1c24:	1952      	adds	r2, r2, r5
    1c26:	4565      	cmp	r5, ip
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1c28:	f803 8b01 	strb.w	r8, [r3], #1
    1c2c:	f002 0201 	and.w	r2, r2, #1
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c30:	d916      	bls.n	1c60 <mss_usbd_ep_rx_cb+0x2ac>
    1c32:	b13a      	cbz	r2, 1c44 <mss_usbd_ep_rx_cb+0x290>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1c34:	f816 2027 	ldrb.w	r2, [r6, r7, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c38:	f10c 0c01 	add.w	ip, ip, #1
    1c3c:	4565      	cmp	r5, ip
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1c3e:	f803 2b01 	strb.w	r2, [r3], #1
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c42:	d90d      	bls.n	1c60 <mss_usbd_ep_rx_cb+0x2ac>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1c44:	f816 8027 	ldrb.w	r8, [r6, r7, lsl #2]
    1c48:	461a      	mov	r2, r3
    1c4a:	f802 8b01 	strb.w	r8, [r2], #1
    1c4e:	f816 8027 	ldrb.w	r8, [r6, r7, lsl #2]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c52:	f10c 0c02 	add.w	ip, ip, #2
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    1c56:	f883 8001 	strb.w	r8, [r3, #1]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    1c5a:	1c53      	adds	r3, r2, #1
    1c5c:	4565      	cmp	r5, ip
    1c5e:	d8f1      	bhi.n	1c44 <mss_usbd_ep_rx_cb+0x290>
                                                 (rxep_ptr->buf_addr+rxep_ptr->xfr_count),
                                                 received_count);

                        rxep_ptr->xfr_count += received_count;
    1c60:	6a23      	ldr	r3, [r4, #32]
    1c62:	195d      	adds	r5, r3, r5
    1c64:	6225      	str	r5, [r4, #32]
MSS_USB_CIF_rx_ep_clr_rxpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_RX_PKT_RDY_MASK;
    1c66:	ea4f 1b0b 	mov.w	fp, fp, lsl #4
    1c6a:	f10b 4280 	add.w	r2, fp, #1073741824	; 0x40000000
    1c6e:	f502 2286 	add.w	r2, r2, #274432	; 0x43000
    1c72:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    1c76:	f02c 0301 	bic.w	r3, ip, #1
    1c7a:	041b      	lsls	r3, r3, #16
    1c7c:	0c1b      	lsrs	r3, r3, #16
    1c7e:	80d3      	strh	r3, [r2, #6]
    1c80:	e6a3      	b.n	19ca <mss_usbd_ep_rx_cb+0x16>
    1c82:	bf00      	nop
    1c84:	200008bc 	.word	0x200008bc
                    rxep_ptr->txn_count = received_count;
                    rxep_ptr->xfr_count += received_count;
                }
                if(MSS_USB_XFR_BULK == rxep_ptr->xfr_type)
                {
                    if(ADD_ZLP_TO_XFR == rxep_ptr->add_zlp)
    1c88:	6926      	ldr	r6, [r4, #16]
                    {
                        if(rxep_ptr->xfr_count < rxep_ptr->xfr_length)
    1c8a:	69e5      	ldr	r5, [r4, #28]
                    rxep_ptr->txn_count = received_count;
                    rxep_ptr->xfr_count += received_count;
                }
                if(MSS_USB_XFR_BULK == rxep_ptr->xfr_type)
                {
                    if(ADD_ZLP_TO_XFR == rxep_ptr->add_zlp)
    1c8c:	2e01      	cmp	r6, #1
                    {
                        if(rxep_ptr->xfr_count < rxep_ptr->xfr_length)
    1c8e:	6a26      	ldr	r6, [r4, #32]
                    rxep_ptr->txn_count = received_count;
                    rxep_ptr->xfr_count += received_count;
                }
                if(MSS_USB_XFR_BULK == rxep_ptr->xfr_type)
                {
                    if(ADD_ZLP_TO_XFR == rxep_ptr->add_zlp)
    1c90:	d020      	beq.n	1cd4 <mss_usbd_ep_rx_cb+0x320>
                            ASSERT(0);
                        }
                    }
                    else // no zlp
                    {
                        if(rxep_ptr->xfr_count == rxep_ptr->xfr_length)
    1c92:	42ae      	cmp	r6, r5
    1c94:	bf18      	it	ne
    1c96:	f8b4 c008 	ldrhne.w	ip, [r4, #8]
    1c9a:	f47f af59 	bne.w	1b50 <mss_usbd_ep_rx_cb+0x19c>
    1c9e:	e7e2      	b.n	1c66 <mss_usbd_ep_rx_cb+0x2b2>
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
    1ca0:	79e3      	ldrb	r3, [r4, #7]
MSS_USB_CIF_dma_start_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_START_XFR_MASK;
    1ca2:	f243 2000 	movw	r0, #12800	; 0x3200
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
    1ca6:	0119      	lsls	r1, r3, #4
    1ca8:	f101 4c80 	add.w	ip, r1, #1073741824	; 0x40000000
    1cac:	f50c 2286 	add.w	r2, ip, #274432	; 0x43000
MSS_USB_CIF_dma_start_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_START_XFR_MASK;
    1cb0:	0119      	lsls	r1, r3, #4
    1cb2:	f2c4 0004 	movt	r0, #16388	; 0x4004
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
    1cb6:	f8c2 520c 	str.w	r5, [r2, #524]	; 0x20c
MSS_USB_CIF_dma_start_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_START_XFR_MASK;
    1cba:	180b      	adds	r3, r1, r0
    1cbc:	6859      	ldr	r1, [r3, #4]
    1cbe:	f041 0001 	orr.w	r0, r1, #1
    1cc2:	6058      	str	r0, [r3, #4]
MSS_USB_CIF_rx_ep_clr_rxpktrdy
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_RX_PKT_RDY_MASK;
    1cc4:	f8b6 c006 	ldrh.w	ip, [r6, #6]
    1cc8:	f02c 0201 	bic.w	r2, ip, #1
    1ccc:	0411      	lsls	r1, r2, #16
    1cce:	0c08      	lsrs	r0, r1, #16
    1cd0:	80f0      	strh	r0, [r6, #6]
    1cd2:	e683      	b.n	19dc <mss_usbd_ep_rx_cb+0x28>
                }
                if(MSS_USB_XFR_BULK == rxep_ptr->xfr_type)
                {
                    if(ADD_ZLP_TO_XFR == rxep_ptr->add_zlp)
                    {
                        if(rxep_ptr->xfr_count < rxep_ptr->xfr_length)
    1cd4:	42ae      	cmp	r6, r5
    1cd6:	d2dd      	bcs.n	1c94 <mss_usbd_ep_rx_cb+0x2e0>
                        {
                            if(rxep_ptr->txn_count < rxep_ptr->max_pkt_size)
    1cd8:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    1cdc:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
    1ce0:	45e0      	cmp	r8, ip
    1ce2:	d3c0      	bcc.n	1c66 <mss_usbd_ep_rx_cb+0x2b2>
    1ce4:	e734      	b.n	1b50 <mss_usbd_ep_rx_cb+0x19c>
    1ce6:	bf00      	nop

00001ce8 <MSS_USBD_rx_ep_read_prepare>:
    mss_usb_ep_num_t ep_num,
    uint8_t * addr,
    uint32_t length
)
{
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    1ce8:	232c      	movs	r3, #44	; 0x2c
(
    mss_usb_ep_num_t ep_num,
    uint8_t * addr,
    uint32_t length
)
{
    1cea:	b530      	push	{r4, r5, lr}
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    1cec:	fb03 f300 	mul.w	r3, r3, r0
    1cf0:	480d      	ldr	r0, [pc, #52]	; (1d28 <MSS_USBD_rx_ep_read_prepare+0x40>)
(
    mss_usb_ep_num_t ep_num,
    uint8_t * addr,
    uint32_t length
)
{
    1cf2:	4614      	mov	r4, r2
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    1cf4:	18c5      	adds	r5, r0, r3
    ASSERT(ep_num);
    ASSERT(addr != 0);

    rxep_ptr->buf_addr = addr;
    rxep_ptr->xfr_length = length;
    rxep_ptr->xfr_count = 0u;
    1cf6:	2200      	movs	r2, #0
(
    mss_usb_ep_num_t ep_num,
    uint8_t * addr,
    uint32_t length
)
{
    1cf8:	b083      	sub	sp, #12
    ASSERT(addr != 0);

    rxep_ptr->buf_addr = addr;
    rxep_ptr->xfr_length = length;
    rxep_ptr->xfr_count = 0u;
    rxep_ptr->txn_count = 0u;
    1cfa:	62aa      	str	r2, [r5, #40]	; 0x28
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];

    ASSERT(ep_num);
    ASSERT(addr != 0);

    rxep_ptr->buf_addr = addr;
    1cfc:	61a9      	str	r1, [r5, #24]
    rxep_ptr->xfr_length = length;
    1cfe:	61ec      	str	r4, [r5, #28]
    rxep_ptr->xfr_count = 0u;
    1d00:	622a      	str	r2, [r5, #32]
    rxep_ptr->txn_count = 0u;

    /*ASSERT when length is 0, address is null or ep number is wrong*/
    if(length > 0u)
    1d02:	b134      	cbz	r4, 1d12 <MSS_USBD_rx_ep_read_prepare+0x2a>
        */
        /*
         section 8.4.2.3 -- No support for HB in Interrupt transfers.
         i.e. maximum one packet(num_usb_pkt=1)can be transferred in one frame.
        */
        if(length >= rxep_ptr->max_pkt_size)
    1d04:	f8b5 c008 	ldrh.w	ip, [r5, #8]
        {
            rxep_ptr->txn_length = rxep_ptr->max_pkt_size;
    1d08:	45a4      	cmp	ip, r4
    1d0a:	bf94      	ite	ls
    1d0c:	f8c5 c024 	strls.w	ip, [r5, #36]	; 0x24
    1d10:	626c      	strhi	r4, [r5, #36]	; 0x24
        {
            rxep_ptr->txn_length = length;
        }
    }

    MSS_USB_CIF_rx_ep_read_prepare(rxep_ptr->num,
    1d12:	5cc0      	ldrb	r0, [r0, r3]
    1d14:	79aa      	ldrb	r2, [r5, #6]
    1d16:	79eb      	ldrb	r3, [r5, #7]
    1d18:	7b2d      	ldrb	r5, [r5, #12]
    1d1a:	9401      	str	r4, [sp, #4]
    1d1c:	9500      	str	r5, [sp, #0]
    1d1e:	f7ff f877 	bl	e10 <MSS_USB_CIF_rx_ep_read_prepare>
                                   rxep_ptr->buf_addr,
                                   rxep_ptr->dma_enable,
                                   rxep_ptr->dma_channel,
                                   rxep_ptr->xfr_type,
                                   rxep_ptr->xfr_length);
}
    1d22:	b003      	add	sp, #12
    1d24:	bd30      	pop	{r4, r5, pc}
    1d26:	bf00      	nop
    1d28:	200008bc 	.word	0x200008bc

00001d2c <MSS_USBD_get_hwcore_info>:
MSS_USBD_get_hwcore_info
(
    mss_usb_core_info_t* hw_info
)
{
    MSS_USBD_CIF_get_hwcore_info(hw_info);
    1d2c:	f000 bf98 	b.w	2c60 <MSS_USBD_CIF_get_hwcore_info>

00001d30 <MSS_USBD_rx_ep_configure>:
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1d30:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1d34:	f240 74e0 	movw	r4, #2016	; 0x7e0
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1d38:	b084      	sub	sp, #16
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1d3a:	f2c2 0400 	movt	r4, #8192	; 0x2000
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1d3e:	4684      	mov	ip, r0
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1d40:	f894 41be 	ldrb.w	r4, [r4, #446]	; 0x1be
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1d44:	f89d 0038 	ldrb.w	r0, [sp, #56]	; 0x38
    1d48:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    1d4c:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
    1d50:	f89d 7034 	ldrb.w	r7, [sp, #52]	; 0x34
    1d54:	9001      	str	r0, [sp, #4]
    1d56:	f89d 503c 	ldrb.w	r5, [sp, #60]	; 0x3c
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1d5a:	b97c      	cbnz	r4, 1d7c <MSS_USBD_rx_ep_configure+0x4c>
                                                        ep_ptr->xfr_count);
                }
            }
        }
    }
}
    1d5c:	1e68      	subs	r0, r5, #1
    1d5e:	b2c0      	uxtb	r0, r0
    1d60:	2802      	cmp	r0, #2
    1d62:	d942      	bls.n	1dea <MSS_USBD_rx_ep_configure+0xba>
    1d64:	2000      	movs	r0, #0
    1d66:	f44f 7400 	mov.w	r4, #512	; 0x200
            default:
                err_check = USB_FAIL;
        }
    }

    if(max_pkt_size > std_max_pkt_sz)
    1d6a:	429c      	cmp	r4, r3
    1d6c:	bf38      	it	cc
    1d6e:	2000      	movcc	r0, #0
    {
        err_check = USB_FAIL;
    }
    if(fifo_size < max_pkt_size)
    1d70:	4293      	cmp	r3, r2
    1d72:	d90d      	bls.n	1d90 <MSS_USBD_rx_ep_configure+0x60>
        rxep_ptr->buf_addr = 0u;
        rxep_ptr->add_zlp = add_zlp;

        MSS_USBD_CIF_rx_ep_configure(rxep_ptr);
    }
}
    1d74:	b004      	add	sp, #16
    1d76:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    1d7a:	4770      	bx	lr
                break;
            default:
                err_check = USB_FAIL;
        }
    }
    else if(MSS_USB_DEVICE_FS == g_usbd_dev_conf.device_speed)
    1d7c:	2c01      	cmp	r4, #1
    1d7e:	d03e      	beq.n	1dfe <MSS_USBD_rx_ep_configure+0xce>
    1d80:	f44f 7400 	mov.w	r4, #512	; 0x200
    1d84:	2001      	movs	r0, #1
            default:
                err_check = USB_FAIL;
        }
    }

    if(max_pkt_size > std_max_pkt_sz)
    1d86:	429c      	cmp	r4, r3
    1d88:	bf38      	it	cc
    1d8a:	2000      	movcc	r0, #0
    {
        err_check = USB_FAIL;
    }
    if(fifo_size < max_pkt_size)
    1d8c:	4293      	cmp	r3, r2
    1d8e:	d8f1      	bhi.n	1d74 <MSS_USBD_rx_ep_configure+0x44>
        err_check = USB_FAIL;
    }

    ASSERT(err_check == USB_SUCCESS);

    if(USB_SUCCESS == err_check)
    1d90:	2801      	cmp	r0, #1
    1d92:	d1ef      	bne.n	1d74 <MSS_USBD_rx_ep_configure+0x44>
    uint32_t add_zlp
)
{
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* rxep_ptr = &gd_rx_ep[ep_num];
    1d94:	242c      	movs	r4, #44	; 0x2c
    1d96:	fb04 f40c 	mul.w	r4, r4, ip
    1d9a:	4e20      	ldr	r6, [pc, #128]	; (1e1c <MSS_USBD_rx_ep_configure+0xec>)
    1d9c:	9403      	str	r4, [sp, #12]
    1d9e:	1934      	adds	r4, r6, r4

    ASSERT(err_check == USB_SUCCESS);

    if(USB_SUCCESS == err_check)
    {
        if((max_pkt_size * 2u ) <= fifo_size)
    1da0:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
        {
            rxep_ptr->dpb_enable = DPB_ENABLE;
        }
        else
        {
            rxep_ptr->dpb_enable = DPB_DISABLE;
    1da4:	bf38      	it	cc
    1da6:	2000      	movcc	r0, #0
    1da8:	7060      	strb	r0, [r4, #1]
        }
        rxep_ptr->num = ep_num;
    1daa:	f8dd b00c 	ldr.w	fp, [sp, #12]
    1dae:	4e1b      	ldr	r6, [pc, #108]	; (1e1c <MSS_USBD_rx_ep_configure+0xec>)
        rxep_ptr->fifo_addr = fifo_addr;
        rxep_ptr->fifo_size = fifo_size;
        rxep_ptr->max_pkt_size = max_pkt_size;
        rxep_ptr->num_usb_pkt = num_usb_pkt;
    1db0:	f884 8014 	strb.w	r8, [r4, #20]
        rxep_ptr->dma_enable = dma_enable;
    1db4:	71a7      	strb	r7, [r4, #6]
        }
        else
        {
            rxep_ptr->dpb_enable = DPB_DISABLE;
        }
        rxep_ptr->num = ep_num;
    1db6:	f806 c00b 	strb.w	ip, [r6, fp]
        rxep_ptr->fifo_addr = fifo_addr;
        rxep_ptr->fifo_size = fifo_size;
        rxep_ptr->max_pkt_size = max_pkt_size;
        rxep_ptr->num_usb_pkt = num_usb_pkt;
        rxep_ptr->dma_enable = dma_enable;
        rxep_ptr->dma_channel = dma_channel;
    1dba:	f8dd b004 	ldr.w	fp, [sp, #4]
        rxep_ptr->stall = 0u;
    1dbe:	f04f 0a00 	mov.w	sl, #0
        rxep_ptr->state = MSS_USB_EP_VALID;
        rxep_ptr->xfr_type = xfr_type;
        rxep_ptr->buf_addr = 0u;
        rxep_ptr->add_zlp = add_zlp;

        MSS_USBD_CIF_rx_ep_configure(rxep_ptr);
    1dc2:	4620      	mov	r0, r4
        else
        {
            rxep_ptr->dpb_enable = DPB_DISABLE;
        }
        rxep_ptr->num = ep_num;
        rxep_ptr->fifo_addr = fifo_addr;
    1dc4:	80a1      	strh	r1, [r4, #4]
        rxep_ptr->fifo_size = fifo_size;
    1dc6:	8062      	strh	r2, [r4, #2]
        rxep_ptr->max_pkt_size = max_pkt_size;
    1dc8:	8123      	strh	r3, [r4, #8]
        rxep_ptr->num_usb_pkt = num_usb_pkt;
        rxep_ptr->dma_enable = dma_enable;
        rxep_ptr->dma_channel = dma_channel;
    1dca:	f884 b007 	strb.w	fp, [r4, #7]
        rxep_ptr->stall = 0u;
        rxep_ptr->state = MSS_USB_EP_VALID;
        rxep_ptr->xfr_type = xfr_type;
    1dce:	7325      	strb	r5, [r4, #12]
        rxep_ptr->buf_addr = 0u;
    1dd0:	f8c4 a018 	str.w	sl, [r4, #24]
        rxep_ptr->add_zlp = add_zlp;
    1dd4:	f8c4 9010 	str.w	r9, [r4, #16]
        rxep_ptr->fifo_size = fifo_size;
        rxep_ptr->max_pkt_size = max_pkt_size;
        rxep_ptr->num_usb_pkt = num_usb_pkt;
        rxep_ptr->dma_enable = dma_enable;
        rxep_ptr->dma_channel = dma_channel;
        rxep_ptr->stall = 0u;
    1dd8:	f884 a00a 	strb.w	sl, [r4, #10]
        rxep_ptr->state = MSS_USB_EP_VALID;
    1ddc:	f884 a00b 	strb.w	sl, [r4, #11]
        rxep_ptr->buf_addr = 0u;
        rxep_ptr->add_zlp = add_zlp;

        MSS_USBD_CIF_rx_ep_configure(rxep_ptr);
    }
}
    1de0:	b004      	add	sp, #16
    1de2:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
        rxep_ptr->state = MSS_USB_EP_VALID;
        rxep_ptr->xfr_type = xfr_type;
        rxep_ptr->buf_addr = 0u;
        rxep_ptr->add_zlp = add_zlp;

        MSS_USBD_CIF_rx_ep_configure(rxep_ptr);
    1de6:	f001 b8ef 	b.w	2fc8 <MSS_USBD_CIF_rx_ep_configure>
                                                        ep_ptr->xfr_count);
                }
            }
        }
    }
}
    1dea:	f648 5af8 	movw	sl, #36344	; 0x8df8
    1dee:	f2c0 0a00 	movt	sl, #0
    1df2:	eb0a 0440 	add.w	r4, sl, r0, lsl #1
    1df6:	88a4      	ldrh	r4, [r4, #4]
    1df8:	f81a 0000 	ldrb.w	r0, [sl, r0]
    1dfc:	e7c3      	b.n	1d86 <MSS_USBD_rx_ep_configure+0x56>
    1dfe:	1e68      	subs	r0, r5, #1
    1e00:	b2c0      	uxtb	r0, r0
    1e02:	2802      	cmp	r0, #2
    1e04:	d8ae      	bhi.n	1d64 <MSS_USBD_rx_ep_configure+0x34>
    1e06:	f648 5af8 	movw	sl, #36344	; 0x8df8
    1e0a:	f2c0 0a00 	movt	sl, #0
    1e0e:	eb0a 0440 	add.w	r4, sl, r0, lsl #1
    1e12:	4450      	add	r0, sl
    1e14:	7b00      	ldrb	r0, [r0, #12]
    1e16:	8a24      	ldrh	r4, [r4, #16]
    1e18:	e7b5      	b.n	1d86 <MSS_USBD_rx_ep_configure+0x56>
    1e1a:	bf00      	nop
    1e1c:	200008bc 	.word	0x200008bc

00001e20 <MSS_USBD_tx_ep_configure>:
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1e20:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1e24:	f240 74e0 	movw	r4, #2016	; 0x7e0
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1e28:	b084      	sub	sp, #16
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1e2a:	f2c2 0400 	movt	r4, #8192	; 0x2000
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1e2e:	4684      	mov	ip, r0
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1e30:	f894 51be 	ldrb.w	r5, [r4, #446]	; 0x1be
    uint8_t dma_enable,
    mss_usb_dma_channel_t dma_channel,
    mss_usb_xfr_type_t xfr_type,
    uint32_t add_zlp
)
{
    1e34:	f89d 0034 	ldrb.w	r0, [sp, #52]	; 0x34
    1e38:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
    1e3c:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
    1e40:	9001      	str	r0, [sp, #4]
    1e42:	f89d 9038 	ldrb.w	r9, [sp, #56]	; 0x38
    1e46:	f89d 603c 	ldrb.w	r6, [sp, #60]	; 0x3c
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];

    if(MSS_USB_DEVICE_HS == g_usbd_dev_conf.device_speed)
    1e4a:	b97d      	cbnz	r5, 1e6c <MSS_USBD_tx_ep_configure+0x4c>
                                                        ep_ptr->xfr_count);
                }
            }
        }
    }
}
    1e4c:	1e75      	subs	r5, r6, #1
    1e4e:	b2e8      	uxtb	r0, r5
    1e50:	2802      	cmp	r0, #2
    1e52:	d943      	bls.n	1edc <MSS_USBD_tx_ep_configure+0xbc>
    1e54:	2000      	movs	r0, #0
    1e56:	f44f 7500 	mov.w	r5, #512	; 0x200
            default:
                err_check = USB_FAIL;
        }
    }

    if(max_pkt_size > std_max_pkt_sz)
    1e5a:	429d      	cmp	r5, r3
    1e5c:	bf38      	it	cc
    1e5e:	2000      	movcc	r0, #0
    {
        err_check = USB_FAIL;
    }
    if(fifo_size < max_pkt_size)
    1e60:	4293      	cmp	r3, r2
    1e62:	d90d      	bls.n	1e80 <MSS_USBD_tx_ep_configure+0x60>
        txep_ptr->xfr_type = xfr_type;
        txep_ptr->buf_addr = 0u;
        txep_ptr->add_zlp = add_zlp;
        MSS_USBD_CIF_tx_ep_configure(txep_ptr);
    }
}
    1e64:	b004      	add	sp, #16
    1e66:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    1e6a:	4770      	bx	lr
                break;
            default:
                err_check = USB_FAIL;
        }
    }
    else if(MSS_USB_DEVICE_FS == g_usbd_dev_conf.device_speed)
    1e6c:	2d01      	cmp	r5, #1
    1e6e:	d040      	beq.n	1ef2 <MSS_USBD_tx_ep_configure+0xd2>
    1e70:	f44f 7500 	mov.w	r5, #512	; 0x200
    1e74:	2001      	movs	r0, #1
            default:
                err_check = USB_FAIL;
        }
    }

    if(max_pkt_size > std_max_pkt_sz)
    1e76:	429d      	cmp	r5, r3
    1e78:	bf38      	it	cc
    1e7a:	2000      	movcc	r0, #0
    {
        err_check = USB_FAIL;
    }
    if(fifo_size < max_pkt_size)
    1e7c:	4293      	cmp	r3, r2
    1e7e:	d8f1      	bhi.n	1e64 <MSS_USBD_tx_ep_configure+0x44>
        err_check = USB_FAIL;
    }

    ASSERT(err_check == USB_SUCCESS);

    if(USB_SUCCESS == err_check)
    1e80:	2801      	cmp	r0, #1
    1e82:	d1ef      	bne.n	1e64 <MSS_USBD_tx_ep_configure+0x44>
    uint32_t add_zlp
)
{
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];
    1e84:	272c      	movs	r7, #44	; 0x2c
    1e86:	fb07 f50c 	mul.w	r5, r7, ip
    1e8a:	9503      	str	r5, [sp, #12]
    1e8c:	9f03      	ldr	r7, [sp, #12]
    1e8e:	f240 75e0 	movw	r5, #2016	; 0x7e0
    1e92:	19e4      	adds	r4, r4, r7

    ASSERT(err_check == USB_SUCCESS);

    if(USB_SUCCESS == err_check)
    {
        if((max_pkt_size * 2) <= fifo_size)
    1e94:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
        {
            txep_ptr->dpb_enable = DPB_ENABLE;
        }
        else
        {
            txep_ptr->dpb_enable = DPB_DISABLE;
    1e98:	bfb8      	it	lt
    1e9a:	2000      	movlt	r0, #0
    1e9c:	7060      	strb	r0, [r4, #1]
        }

        txep_ptr->num = ep_num;
    1e9e:	9f03      	ldr	r7, [sp, #12]
        txep_ptr->fifo_addr = fifo_addr;
        txep_ptr->fifo_size = fifo_size;
        txep_ptr->max_pkt_size = max_pkt_size;
        txep_ptr->num_usb_pkt = num_usb_pkt;
    1ea0:	f884 8014 	strb.w	r8, [r4, #20]
        }

        txep_ptr->num = ep_num;
        txep_ptr->fifo_addr = fifo_addr;
        txep_ptr->fifo_size = fifo_size;
        txep_ptr->max_pkt_size = max_pkt_size;
    1ea4:	8123      	strh	r3, [r4, #8]
        txep_ptr->num_usb_pkt = num_usb_pkt;
        txep_ptr->dma_enable = dma_enable;
    1ea6:	9b01      	ldr	r3, [sp, #4]
        txep_ptr->dma_channel = dma_channel;
        txep_ptr->stall = 0u;
    1ea8:	f04f 0a00 	mov.w	sl, #0
    uint32_t add_zlp
)
{
    uint8_t err_check = USB_SUCCESS;
    uint16_t std_max_pkt_sz = USB_HS_BULK_MAX_PKT_SIZE;
    mss_usb_ep_t* txep_ptr = &gd_tx_ep[ep_num];
    1eac:	f2c2 0500 	movt	r5, #8192	; 0x2000
        txep_ptr->stall = 0u;
        txep_ptr->state = MSS_USB_EP_VALID;
        txep_ptr->xfr_type = xfr_type;
        txep_ptr->buf_addr = 0u;
        txep_ptr->add_zlp = add_zlp;
        MSS_USBD_CIF_tx_ep_configure(txep_ptr);
    1eb0:	4620      	mov	r0, r4
        else
        {
            txep_ptr->dpb_enable = DPB_DISABLE;
        }

        txep_ptr->num = ep_num;
    1eb2:	f805 c007 	strb.w	ip, [r5, r7]
        txep_ptr->fifo_addr = fifo_addr;
    1eb6:	80a1      	strh	r1, [r4, #4]
        txep_ptr->fifo_size = fifo_size;
    1eb8:	8062      	strh	r2, [r4, #2]
        txep_ptr->max_pkt_size = max_pkt_size;
        txep_ptr->num_usb_pkt = num_usb_pkt;
        txep_ptr->dma_enable = dma_enable;
    1eba:	71a3      	strb	r3, [r4, #6]
        txep_ptr->dma_channel = dma_channel;
    1ebc:	f884 9007 	strb.w	r9, [r4, #7]
        txep_ptr->stall = 0u;
        txep_ptr->state = MSS_USB_EP_VALID;
        txep_ptr->xfr_type = xfr_type;
    1ec0:	7326      	strb	r6, [r4, #12]
        txep_ptr->buf_addr = 0u;
    1ec2:	f8c4 a018 	str.w	sl, [r4, #24]
        txep_ptr->add_zlp = add_zlp;
    1ec6:	f8c4 b010 	str.w	fp, [r4, #16]
        txep_ptr->fifo_size = fifo_size;
        txep_ptr->max_pkt_size = max_pkt_size;
        txep_ptr->num_usb_pkt = num_usb_pkt;
        txep_ptr->dma_enable = dma_enable;
        txep_ptr->dma_channel = dma_channel;
        txep_ptr->stall = 0u;
    1eca:	f884 a00a 	strb.w	sl, [r4, #10]
        txep_ptr->state = MSS_USB_EP_VALID;
    1ece:	f884 a00b 	strb.w	sl, [r4, #11]
        txep_ptr->xfr_type = xfr_type;
        txep_ptr->buf_addr = 0u;
        txep_ptr->add_zlp = add_zlp;
        MSS_USBD_CIF_tx_ep_configure(txep_ptr);
    }
}
    1ed2:	b004      	add	sp, #16
    1ed4:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
        txep_ptr->stall = 0u;
        txep_ptr->state = MSS_USB_EP_VALID;
        txep_ptr->xfr_type = xfr_type;
        txep_ptr->buf_addr = 0u;
        txep_ptr->add_zlp = add_zlp;
        MSS_USBD_CIF_tx_ep_configure(txep_ptr);
    1ed8:	f001 b8da 	b.w	3090 <MSS_USBD_CIF_tx_ep_configure>
                                                        ep_ptr->xfr_count);
                }
            }
        }
    }
}
    1edc:	f648 55f8 	movw	r5, #36344	; 0x8df8
    1ee0:	f2c0 0500 	movt	r5, #0
    1ee4:	eb05 0a40 	add.w	sl, r5, r0, lsl #1
    1ee8:	1940      	adds	r0, r0, r5
    1eea:	7e00      	ldrb	r0, [r0, #24]
    1eec:	f8ba 501c 	ldrh.w	r5, [sl, #28]
    1ef0:	e7c1      	b.n	1e76 <MSS_USBD_tx_ep_configure+0x56>
    1ef2:	1e70      	subs	r0, r6, #1
    1ef4:	b2c0      	uxtb	r0, r0
    1ef6:	2802      	cmp	r0, #2
    1ef8:	d8ac      	bhi.n	1e54 <MSS_USBD_tx_ep_configure+0x34>
    1efa:	f648 55f8 	movw	r5, #36344	; 0x8df8
    1efe:	f2c0 0500 	movt	r5, #0
    1f02:	eb05 0a40 	add.w	sl, r5, r0, lsl #1
    1f06:	1940      	adds	r0, r0, r5
    1f08:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    1f0c:	f8ba 5028 	ldrh.w	r5, [sl, #40]	; 0x28
    1f10:	e7b1      	b.n	1e76 <MSS_USBD_tx_ep_configure+0x56>
    1f12:	bf00      	nop

00001f14 <MSS_USBD_cep_read_prepare>:
MSS_USBD_cep_read_prepare
(
    uint8_t * addr,
    uint32_t length
)
{
    1f14:	b410      	push	{r4}
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    1f16:	f240 73e0 	movw	r3, #2016	; 0x7e0
    1f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    cep_ptr->xfr_length = length;
    cep_ptr->xfr_count = 0u;
    cep_ptr->txn_count = 0u;

    if(cep_ptr->xfr_length > cep_ptr->max_pkt_size)
    1f1e:	891a      	ldrh	r2, [r3, #8]
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    cep_ptr->xfr_length = length;
    cep_ptr->xfr_count = 0u;
    1f20:	2400      	movs	r4, #0
    uint32_t length
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    1f22:	6198      	str	r0, [r3, #24]
    cep_ptr->xfr_count = 0u;
    cep_ptr->txn_count = 0u;

    if(cep_ptr->xfr_length > cep_ptr->max_pkt_size)
    {
        cep_ptr->txn_length = cep_ptr->max_pkt_size;
    1f24:	428a      	cmp	r2, r1
    1f26:	bf94      	ite	ls
    1f28:	625a      	strls	r2, [r3, #36]	; 0x24
    1f2a:	6259      	strhi	r1, [r3, #36]	; 0x24
    }
    else
    {
        cep_ptr->txn_length = length;
    }
    MSS_USBD_CIF_cep_rx_prepare(&gd_tx_ep[MSS_USB_CEP]);
    1f2c:	4618      	mov	r0, r3
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    cep_ptr->xfr_length = length;
    cep_ptr->xfr_count = 0u;
    cep_ptr->txn_count = 0u;
    1f2e:	629c      	str	r4, [r3, #40]	; 0x28
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->buf_addr = addr;
    cep_ptr->xfr_length = length;
    1f30:	61d9      	str	r1, [r3, #28]
    cep_ptr->xfr_count = 0u;
    1f32:	621c      	str	r4, [r3, #32]
    else
    {
        cep_ptr->txn_length = length;
    }
    MSS_USBD_CIF_cep_rx_prepare(&gd_tx_ep[MSS_USB_CEP]);
}
    1f34:	bc10      	pop	{r4}
    }
    else
    {
        cep_ptr->txn_length = length;
    }
    MSS_USBD_CIF_cep_rx_prepare(&gd_tx_ep[MSS_USB_CEP]);
    1f36:	f000 bed5 	b.w	2ce4 <MSS_USBD_CIF_cep_rx_prepare>
    1f3a:	bf00      	nop

00001f3c <mss_usbd_cep_tx_complete_cb>:

    /*
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    1f3c:	f010 0303 	ands.w	r3, r0, #3
static void
mss_usbd_cep_tx_complete_cb
(
    uint8_t status
)
{
    1f40:	b570      	push	{r4, r5, r6, lr}

    /*
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    1f42:	d01d      	beq.n	1f80 <mss_usbd_cep_tx_complete_cb+0x44>
    {
        SETUP_PKT_INIT();
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
    1f44:	f640 319c 	movw	r1, #2972	; 0xb9c
    1f48:	f2c2 0100 	movt	r1, #8192	; 0x2000
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    {
        SETUP_PKT_INIT();
    1f4c:	f240 74e0 	movw	r4, #2016	; 0x7e0
    1f50:	f2c2 0400 	movt	r4, #8192	; 0x2000
    1f54:	2300      	movs	r3, #0
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
    1f56:	680a      	ldr	r2, [r1, #0]
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    {
        SETUP_PKT_INIT();
    1f58:	f884 31c8 	strb.w	r3, [r4, #456]	; 0x1c8
    1f5c:	f884 31c9 	strb.w	r3, [r4, #457]	; 0x1c9
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
    1f60:	6992      	ldr	r2, [r2, #24]
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    {
        SETUP_PKT_INIT();
    1f62:	f8a4 31ce 	strh.w	r3, [r4, #462]	; 0x1ce
    1f66:	f8a4 31ca 	strh.w	r3, [r4, #458]	; 0x1ca
    1f6a:	f8a4 31cc 	strh.w	r3, [r4, #460]	; 0x1cc
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
    1f6e:	b102      	cbz	r2, 1f72 <mss_usbd_cep_tx_complete_cb+0x36>
        {
             g_usbd_class_cb->usbd_class_cep_tx_done(status);
    1f70:	4790      	blx	r2
        }
        cep_ptr->state = MSS_USB_CEP_IDLE;
        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    1f72:	4825      	ldr	r0, [pc, #148]	; (2008 <mss_usbd_cep_tx_complete_cb+0xcc>)
        SETUP_PKT_INIT();
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
        {
             g_usbd_class_cb->usbd_class_cep_tx_done(status);
        }
        cep_ptr->state = MSS_USB_CEP_IDLE;
    1f74:	2304      	movs	r3, #4
        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    1f76:	2108      	movs	r1, #8
        SETUP_PKT_INIT();
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
        {
             g_usbd_class_cb->usbd_class_cep_tx_done(status);
        }
        cep_ptr->state = MSS_USB_CEP_IDLE;
    1f78:	72e3      	strb	r3, [r4, #11]
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
        usbd_test_cb.test_cep_tx_complete(status);
#endif
}
    1f7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
        {
             g_usbd_class_cb->usbd_class_cep_tx_done(status);
        }
        cep_ptr->state = MSS_USB_CEP_IDLE;
        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    1f7e:	e7c9      	b.n	1f14 <MSS_USBD_cep_read_prepare>
    }
    else
    {
        /*Device should be in DATAIN phase.*/
        if(MSS_USB_CEP_TX == cep_ptr->state)
    1f80:	f240 74e0 	movw	r4, #2016	; 0x7e0
    1f84:	f2c2 0400 	movt	r4, #8192	; 0x2000
    1f88:	f894 c00b 	ldrb.w	ip, [r4, #11]
    1f8c:	f1bc 0f06 	cmp.w	ip, #6
    1f90:	d000      	beq.n	1f94 <mss_usbd_cep_tx_complete_cb+0x58>
    1f92:	bd70      	pop	{r4, r5, r6, pc}
        {
            if(cep_ptr->xfr_count < cep_ptr->xfr_length)
    1f94:	6a22      	ldr	r2, [r4, #32]
    1f96:	69e1      	ldr	r1, [r4, #28]
    1f98:	428a      	cmp	r2, r1
    1f9a:	d211      	bcs.n	1fc0 <mss_usbd_cep_tx_complete_cb+0x84>
            {
                /*Continue to transmit more data*/
                cep_ptr->buf_addr += cep_ptr->txn_count;
    1f9c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    1f9e:	69a5      	ldr	r5, [r4, #24]

                if((cep_ptr->xfr_length - cep_ptr->xfr_count) >=
    1fa0:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    1fa4:	1a8a      	subs	r2, r1, r2
        if(MSS_USB_CEP_TX == cep_ptr->state)
        {
            if(cep_ptr->xfr_count < cep_ptr->xfr_length)
            {
                /*Continue to transmit more data*/
                cep_ptr->buf_addr += cep_ptr->txn_count;
    1fa6:	182d      	adds	r5, r5, r0

                if((cep_ptr->xfr_length - cep_ptr->xfr_count) >=
                   cep_ptr->max_pkt_size)
                {
                    cep_ptr->txn_length = cep_ptr->max_pkt_size;
    1fa8:	4594      	cmp	ip, r2
    1faa:	bf94      	ite	ls
    1fac:	f8c4 c024 	strls.w	ip, [r4, #36]	; 0x24
    1fb0:	6262      	strhi	r2, [r4, #36]	; 0x24
                /*
                 Reset the txn_count since one transaction out of the transfer
                 is completed now
                 */
                cep_ptr->txn_count = 0u;
                MSS_USBD_CIF_cep_write_pkt(cep_ptr);
    1fb2:	4620      	mov	r0, r4
        if(MSS_USB_CEP_TX == cep_ptr->state)
        {
            if(cep_ptr->xfr_count < cep_ptr->xfr_length)
            {
                /*Continue to transmit more data*/
                cep_ptr->buf_addr += cep_ptr->txn_count;
    1fb4:	61a5      	str	r5, [r4, #24]

                /*
                 Reset the txn_count since one transaction out of the transfer
                 is completed now
                 */
                cep_ptr->txn_count = 0u;
    1fb6:	62a3      	str	r3, [r4, #40]	; 0x28
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
        usbd_test_cb.test_cep_tx_complete(status);
#endif
}
    1fb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                /*
                 Reset the txn_count since one transaction out of the transfer
                 is completed now
                 */
                cep_ptr->txn_count = 0u;
                MSS_USBD_CIF_cep_write_pkt(cep_ptr);
    1fbc:	f000 bf1e 	b.w	2dfc <MSS_USBD_CIF_cep_write_pkt>
            }
            else
            {
                /*Call USBD-Class indicating that the desired data is sent*/
                if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
    1fc0:	f640 339c 	movw	r3, #2972	; 0xb9c
    1fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    1fc8:	6819      	ldr	r1, [r3, #0]
    1fca:	698b      	ldr	r3, [r1, #24]
    1fcc:	b103      	cbz	r3, 1fd0 <mss_usbd_cep_tx_complete_cb+0x94>
                {
                    g_usbd_class_cb->usbd_class_cep_tx_done(status);
    1fce:	4798      	blx	r3

                cep_ptr->txn_count = 0u;
                cep_ptr->xfr_count = 0u;
                cep_ptr->xfr_length = 0u;
                cep_ptr->txn_length = 0u;
                cep_ptr->state = MSS_USB_CEP_IDLE;
    1fd0:	2004      	movs	r0, #4
                                        CSR0L_DEV_DATA_END_MASK);
}

static __INLINE void MSS_USBD_CIF_reset_index_reg(void)
{
    USB->INDEX = 0u;
    1fd2:	f243 0200 	movw	r2, #12288	; 0x3000
                if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
                {
                    g_usbd_class_cb->usbd_class_cep_tx_done(status);
                }

                cep_ptr->txn_count = 0u;
    1fd6:	2100      	movs	r1, #0
                cep_ptr->xfr_count = 0u;
                cep_ptr->xfr_length = 0u;
                cep_ptr->txn_length = 0u;
                cep_ptr->state = MSS_USB_CEP_IDLE;
    1fd8:	72e0      	strb	r0, [r4, #11]
    1fda:	f2c4 0204 	movt	r2, #16388	; 0x4004
                SETUP_PKT_INIT();
                MSS_USBD_CIF_reset_index_reg();
                MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    1fde:	480a      	ldr	r0, [pc, #40]	; (2008 <mss_usbd_cep_tx_complete_cb+0xcc>)
                cep_ptr->txn_count = 0u;
                cep_ptr->xfr_count = 0u;
                cep_ptr->xfr_length = 0u;
                cep_ptr->txn_length = 0u;
                cep_ptr->state = MSS_USB_CEP_IDLE;
                SETUP_PKT_INIT();
    1fe0:	f8a4 11ce 	strh.w	r1, [r4, #462]	; 0x1ce
                if(0 !=  g_usbd_class_cb->usbd_class_cep_tx_done)
                {
                    g_usbd_class_cb->usbd_class_cep_tx_done(status);
                }

                cep_ptr->txn_count = 0u;
    1fe4:	62a1      	str	r1, [r4, #40]	; 0x28
                cep_ptr->xfr_count = 0u;
    1fe6:	6221      	str	r1, [r4, #32]
                cep_ptr->xfr_length = 0u;
    1fe8:	61e1      	str	r1, [r4, #28]
                cep_ptr->txn_length = 0u;
    1fea:	6261      	str	r1, [r4, #36]	; 0x24
                cep_ptr->state = MSS_USB_CEP_IDLE;
                SETUP_PKT_INIT();
    1fec:	f884 11c8 	strb.w	r1, [r4, #456]	; 0x1c8
    1ff0:	f884 11c9 	strb.w	r1, [r4, #457]	; 0x1c9
    1ff4:	f8a4 11ca 	strh.w	r1, [r4, #458]	; 0x1ca
    1ff8:	f8a4 11cc 	strh.w	r1, [r4, #460]	; 0x1cc
    1ffc:	7391      	strb	r1, [r2, #14]
                MSS_USBD_CIF_reset_index_reg();
                MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    1ffe:	2108      	movs	r1, #8
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
        usbd_test_cb.test_cep_tx_complete(status);
#endif
}
    2000:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                cep_ptr->xfr_length = 0u;
                cep_ptr->txn_length = 0u;
                cep_ptr->state = MSS_USB_CEP_IDLE;
                SETUP_PKT_INIT();
                MSS_USBD_CIF_reset_index_reg();
                MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    2004:	e786      	b.n	1f14 <MSS_USBD_cep_read_prepare>
    2006:	bf00      	nop
    2008:	200009a8 	.word	0x200009a8

0000200c <mss_usbd_cep_rx_cb>:
static void
mss_usbd_cep_rx_cb
(
    uint8_t status
)
{
    200c:	b570      	push	{r4, r5, r6, lr}

    /*
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    200e:	f010 0503 	ands.w	r5, r0, #3
static void
mss_usbd_cep_rx_cb
(
    uint8_t status
)
{
    2012:	4606      	mov	r6, r0

    /*
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    2014:	d01d      	beq.n	2052 <mss_usbd_cep_rx_cb+0x46>
    {
        SETUP_PKT_INIT();

        if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
    2016:	f640 319c 	movw	r1, #2972	; 0xb9c
    201a:	f2c2 0100 	movt	r1, #8192	; 0x2000
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    {
        SETUP_PKT_INIT();
    201e:	f240 74e0 	movw	r4, #2016	; 0x7e0
    2022:	f2c2 0400 	movt	r4, #8192	; 0x2000
    2026:	2300      	movs	r3, #0

        if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
    2028:	680a      	ldr	r2, [r1, #0]
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    {
        SETUP_PKT_INIT();
    202a:	f884 31c8 	strb.w	r3, [r4, #456]	; 0x1c8
    202e:	f884 31c9 	strb.w	r3, [r4, #457]	; 0x1c9

        if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
    2032:	69d2      	ldr	r2, [r2, #28]
     xfr_rem_length should have been setup by the Specific request which needed
     data to arrive in the Data phase
     */
    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    {
        SETUP_PKT_INIT();
    2034:	f8a4 31ce 	strh.w	r3, [r4, #462]	; 0x1ce
    2038:	f8a4 31ca 	strh.w	r3, [r4, #458]	; 0x1ca
    203c:	f8a4 31cc 	strh.w	r3, [r4, #460]	; 0x1cc

        if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
    2040:	b102      	cbz	r2, 2044 <mss_usbd_cep_rx_cb+0x38>
        {
            g_usbd_class_cb->usbd_class_cep_rx_done(status);
    2042:	4790      	blx	r2
        }

        cep_ptr->state = MSS_USB_CEP_IDLE;
        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    2044:	4830      	ldr	r0, [pc, #192]	; (2108 <mss_usbd_cep_rx_cb+0xfc>)
        if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
        {
            g_usbd_class_cb->usbd_class_cep_rx_done(status);
        }

        cep_ptr->state = MSS_USB_CEP_IDLE;
    2046:	2304      	movs	r3, #4
        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    2048:	2108      	movs	r1, #8
        if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
        {
            g_usbd_class_cb->usbd_class_cep_rx_done(status);
        }

        cep_ptr->state = MSS_USB_CEP_IDLE;
    204a:	72e3      	strb	r3, [r4, #11]
        }
    }
#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_rx(status);
#endif
}
    204c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        {
            g_usbd_class_cb->usbd_class_cep_rx_done(status);
        }

        cep_ptr->state = MSS_USB_CEP_IDLE;
        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    2050:	e760      	b.n	1f14 <MSS_USBD_cep_read_prepare>
    }
    else
    {
        MSS_USBD_CIF_cep_read_pkt(cep_ptr);
    2052:	f240 74e0 	movw	r4, #2016	; 0x7e0
    2056:	f2c2 0400 	movt	r4, #8192	; 0x2000
    205a:	4620      	mov	r0, r4
    205c:	f000 ff44 	bl	2ee8 <MSS_USBD_CIF_cep_read_pkt>

        if(MSS_USB_CEP_RX == cep_ptr->state)
    2060:	7ae0      	ldrb	r0, [r4, #11]
    2062:	2807      	cmp	r0, #7
    2064:	d000      	beq.n	2068 <mss_usbd_cep_rx_cb+0x5c>
    2066:	bd70      	pop	{r4, r5, r6, pc}
        {
            if(cep_ptr->xfr_count == cep_ptr->xfr_length)
    2068:	6a22      	ldr	r2, [r4, #32]
    206a:	69e1      	ldr	r1, [r4, #28]
    206c:	428a      	cmp	r2, r1
    206e:	d026      	beq.n	20be <mss_usbd_cep_rx_cb+0xb2>
}

static __INLINE void MSS_USBD_CIF_cep_clr_rxpktrdy(void)
{
    /*Setting SERVICED_RX_PKT_RDY clears RxPktRdy bit*/
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK;
    2070:	f243 0300 	movw	r3, #12288	; 0x3000
    2074:	f2c4 0304 	movt	r3, #16388	; 0x4004
                MSS_USBD_CIF_cep_end_wdr();                 //WriteReq complete
                MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
                                          USB_SETUP_PKT_LEN);

            }
            else if(cep_ptr->xfr_count < cep_ptr->xfr_length)
    2078:	d210      	bcs.n	209c <mss_usbd_cep_rx_cb+0x90>
    207a:	f04f 0e40 	mov.w	lr, #64	; 0x40
    207e:	f8a3 e012 	strh.w	lr, [r3, #18]
                MSS_USBD_CIF_cep_clr_rxpktrdy();       //get more data from host

                /*Continue to read data on the CEP*/
                rem_length = cep_ptr->xfr_length - cep_ptr->xfr_count;

                if(rem_length >= cep_ptr->max_pkt_size)
    2082:	8923      	ldrh	r3, [r4, #8]
            else if(cep_ptr->xfr_count < cep_ptr->xfr_length)
            {
                MSS_USBD_CIF_cep_clr_rxpktrdy();       //get more data from host

                /*Continue to read data on the CEP*/
                rem_length = cep_ptr->xfr_length - cep_ptr->xfr_count;
    2084:	1a89      	subs	r1, r1, r2
                {
                    cep_ptr->txn_length = rem_length;
                }

                cep_ptr->txn_count = 0u;
                MSS_USBD_cep_read_prepare((cep_ptr->buf_addr+cep_ptr->xfr_count),
    2086:	69a0      	ldr	r0, [r4, #24]
                /*Continue to read data on the CEP*/
                rem_length = cep_ptr->xfr_length - cep_ptr->xfr_count;

                if(rem_length >= cep_ptr->max_pkt_size)
                {
                    cep_ptr->txn_length = cep_ptr->max_pkt_size;
    2088:	428b      	cmp	r3, r1
    208a:	bf28      	it	cs
    208c:	460b      	movcs	r3, r1
                {
                    cep_ptr->txn_length = rem_length;
                }

                cep_ptr->txn_count = 0u;
                MSS_USBD_cep_read_prepare((cep_ptr->buf_addr+cep_ptr->xfr_count),
    208e:	1880      	adds	r0, r0, r2
    2090:	4619      	mov	r1, r3
                else
                {
                    cep_ptr->txn_length = rem_length;
                }

                cep_ptr->txn_count = 0u;
    2092:	62a5      	str	r5, [r4, #40]	; 0x28
                /*Continue to read data on the CEP*/
                rem_length = cep_ptr->xfr_length - cep_ptr->xfr_count;

                if(rem_length >= cep_ptr->max_pkt_size)
                {
                    cep_ptr->txn_length = cep_ptr->max_pkt_size;
    2094:	6263      	str	r3, [r4, #36]	; 0x24
        }
    }
#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_rx(status);
#endif
}
    2096:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                {
                    cep_ptr->txn_length = rem_length;
                }

                cep_ptr->txn_count = 0u;
                MSS_USBD_cep_read_prepare((cep_ptr->buf_addr+cep_ptr->xfr_count),
    209a:	e73b      	b.n	1f14 <MSS_USBD_cep_read_prepare>
                                          cep_ptr->txn_length);
            }
            else
            {
                SETUP_PKT_INIT();
                cep_ptr->state = MSS_USB_CEP_IDLE;
    209c:	2204      	movs	r2, #4
}

static __INLINE void MSS_USBD_CIF_cep_stall(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = (CSR0L_DEV_SEND_STALL_MASK |
    209e:	f04f 0c60 	mov.w	ip, #96	; 0x60
    20a2:	72e2      	strb	r2, [r4, #11]
                MSS_USBD_cep_read_prepare((cep_ptr->buf_addr+cep_ptr->xfr_count),
                                          cep_ptr->txn_length);
            }
            else
            {
                SETUP_PKT_INIT();
    20a4:	f8a4 51ce 	strh.w	r5, [r4, #462]	; 0x1ce
    20a8:	f884 51c8 	strb.w	r5, [r4, #456]	; 0x1c8
    20ac:	f884 51c9 	strb.w	r5, [r4, #457]	; 0x1c9
    20b0:	f8a4 51ca 	strh.w	r5, [r4, #458]	; 0x1ca
    20b4:	f8a4 51cc 	strh.w	r5, [r4, #460]	; 0x1cc
    20b8:	f8a3 c012 	strh.w	ip, [r3, #18]
    20bc:	e7d3      	b.n	2066 <mss_usbd_cep_rx_cb+0x5a>
        if(MSS_USB_CEP_RX == cep_ptr->state)
        {
            if(cep_ptr->xfr_count == cep_ptr->xfr_length)
            {
                /*Call USBD-Class indicating that the desired data is arrived*/
                if(0 != g_usbd_class_cb->usbd_class_cep_rx_done)
    20be:	f640 319c 	movw	r1, #2972	; 0xb9c
    20c2:	f2c2 0100 	movt	r1, #8192	; 0x2000
    20c6:	680a      	ldr	r2, [r1, #0]
    20c8:	69d3      	ldr	r3, [r2, #28]
    20ca:	b10b      	cbz	r3, 20d0 <mss_usbd_cep_rx_cb+0xc4>
                {
                    g_usbd_class_cb->usbd_class_cep_rx_done(status);
    20cc:	4630      	mov	r0, r6
    20ce:	4798      	blx	r3
                                        CSR0L_DEV_DATA_END_MASK);
}

static __INLINE void MSS_USBD_CIF_reset_index_reg(void)
{
    USB->INDEX = 0u;
    20d0:	f243 0000 	movw	r0, #12288	; 0x3000
    20d4:	2300      	movs	r3, #0
    20d6:	f2c4 0004 	movt	r0, #16388	; 0x4004
                }

                MSS_USBD_CIF_reset_index_reg();
                SETUP_PKT_INIT();
                cep_ptr->state = MSS_USB_CEP_IDLE;
    20da:	2204      	movs	r2, #4
                                         CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK);
}
/*write Data Req, host writing on device (USB OUT) */
static __INLINE void MSS_USBD_CIF_cep_end_wdr(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = (CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK |
    20dc:	f04f 0c48 	mov.w	ip, #72	; 0x48
                                        CSR0L_DEV_DATA_END_MASK);
}

static __INLINE void MSS_USBD_CIF_reset_index_reg(void)
{
    USB->INDEX = 0u;
    20e0:	7383      	strb	r3, [r0, #14]
    20e2:	72e2      	strb	r2, [r4, #11]
                {
                    g_usbd_class_cb->usbd_class_cep_rx_done(status);
                }

                MSS_USBD_CIF_reset_index_reg();
                SETUP_PKT_INIT();
    20e4:	f8a4 31ce 	strh.w	r3, [r4, #462]	; 0x1ce
    20e8:	f884 31c8 	strb.w	r3, [r4, #456]	; 0x1c8
    20ec:	f884 31c9 	strb.w	r3, [r4, #457]	; 0x1c9
    20f0:	f8a4 31ca 	strh.w	r3, [r4, #458]	; 0x1ca
    20f4:	f8a4 31cc 	strh.w	r3, [r4, #460]	; 0x1cc
                                         CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK);
}
/*write Data Req, host writing on device (USB OUT) */
static __INLINE void MSS_USBD_CIF_cep_end_wdr(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = (CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK |
    20f8:	f8a0 c012 	strh.w	ip, [r0, #18]
                cep_ptr->state = MSS_USB_CEP_IDLE;
                MSS_USBD_CIF_cep_end_wdr();                 //WriteReq complete
                MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    20fc:	4802      	ldr	r0, [pc, #8]	; (2108 <mss_usbd_cep_rx_cb+0xfc>)
    20fe:	2108      	movs	r1, #8
        }
    }
#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_rx(status);
#endif
}
    2100:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

                MSS_USBD_CIF_reset_index_reg();
                SETUP_PKT_INIT();
                cep_ptr->state = MSS_USB_CEP_IDLE;
                MSS_USBD_CIF_cep_end_wdr();                 //WriteReq complete
                MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    2104:	e706      	b.n	1f14 <MSS_USBD_cep_read_prepare>
    2106:	bf00      	nop
    2108:	200009a8 	.word	0x200009a8

0000210c <mss_usbd_cep_setup_cb>:
static void
mss_usbd_cep_setup_cb
(
    uint8_t status
)
{
    210c:	b530      	push	{r4, r5, lr}
#ifndef MSS_USB_DEVICE_TEST_MODE
    uint8_t* buf = 0;
    210e:	2300      	movs	r3, #0
static void
mss_usbd_cep_setup_cb
(
    uint8_t status
)
{
    2110:	b085      	sub	sp, #20
    uint8_t* buf = 0;
    uint32_t length = 0u;
    uint8_t result = USB_FAIL;
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    2112:	f010 0f03 	tst.w	r0, #3
(
    uint8_t status
)
{
#ifndef MSS_USB_DEVICE_TEST_MODE
    uint8_t* buf = 0;
    2116:	9303      	str	r3, [sp, #12]
    uint32_t length = 0u;
    2118:	9302      	str	r3, [sp, #8]
    uint8_t result = USB_FAIL;
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    if(status & (CTRL_EP_SETUP_END_ERROR | CTRL_EP_STALL_ERROR))
    211a:	d11f      	bne.n	215c <mss_usbd_cep_setup_cb+0x50>

        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    }
    else
    {
        MSS_USBD_CIF_cep_read_pkt(cep_ptr);
    211c:	f240 74e0 	movw	r4, #2016	; 0x7e0
    2120:	f2c2 0400 	movt	r4, #8192	; 0x2000
    2124:	4620      	mov	r0, r4
    2126:	f000 fedf 	bl	2ee8 <MSS_USBD_CIF_cep_read_pkt>

        if(SETUP_PKT_SIZE == cep_ptr->txn_length)
    212a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    212c:	2b08      	cmp	r3, #8
    212e:	d02d      	beq.n	218c <mss_usbd_cep_setup_cb+0x80>
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK;
}

static __INLINE void MSS_USBD_CIF_cep_stall(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = (CSR0L_DEV_SEND_STALL_MASK |
    2130:	f243 0000 	movw	r0, #12288	; 0x3000
            }
        }
        else
        {
            cep_ptr->state = MSS_USB_CEP_IDLE;
            SETUP_PKT_INIT();
    2134:	2300      	movs	r3, #0
    2136:	f2c4 0004 	movt	r0, #16388	; 0x4004
                }
            }
        }
        else
        {
            cep_ptr->state = MSS_USB_CEP_IDLE;
    213a:	2204      	movs	r2, #4
    213c:	f04f 0160 	mov.w	r1, #96	; 0x60
            SETUP_PKT_INIT();
    2140:	f8a4 31ce 	strh.w	r3, [r4, #462]	; 0x1ce
                }
            }
        }
        else
        {
            cep_ptr->state = MSS_USB_CEP_IDLE;
    2144:	72e2      	strb	r2, [r4, #11]
            SETUP_PKT_INIT();
    2146:	f884 31c8 	strb.w	r3, [r4, #456]	; 0x1c8
    214a:	f884 31c9 	strb.w	r3, [r4, #457]	; 0x1c9
    214e:	f8a4 31ca 	strh.w	r3, [r4, #458]	; 0x1ca
    2152:	f8a4 31cc 	strh.w	r3, [r4, #460]	; 0x1cc
    2156:	8241      	strh	r1, [r0, #18]
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_setup(status);
#endif
}
    2158:	b005      	add	sp, #20
    215a:	bd30      	pop	{r4, r5, pc}
    {
        /*
         EP0 was previously stalled, clear the error condition and
         prepare for next transaction
         */
        cep_ptr->state = MSS_USB_CEP_IDLE;
    215c:	f240 72e0 	movw	r2, #2016	; 0x7e0
    2160:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2164:	f04f 0c04 	mov.w	ip, #4

        SETUP_PKT_INIT();

        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    2168:	f502 70e4 	add.w	r0, r2, #456	; 0x1c8
    216c:	2108      	movs	r1, #8
    {
        /*
         EP0 was previously stalled, clear the error condition and
         prepare for next transaction
         */
        cep_ptr->state = MSS_USB_CEP_IDLE;
    216e:	f882 c00b 	strb.w	ip, [r2, #11]

        SETUP_PKT_INIT();
    2172:	f8a2 31ce 	strh.w	r3, [r2, #462]	; 0x1ce
    2176:	f882 31c8 	strb.w	r3, [r2, #456]	; 0x1c8
    217a:	f882 31c9 	strb.w	r3, [r2, #457]	; 0x1c9
    217e:	f8a2 31ca 	strh.w	r3, [r2, #458]	; 0x1ca
    2182:	f8a2 31cc 	strh.w	r3, [r2, #460]	; 0x1cc

        MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    2186:	f7ff fec5 	bl	1f14 <MSS_USBD_cep_read_prepare>
    218a:	e7e5      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>

        if(SETUP_PKT_SIZE == cep_ptr->txn_length)
        {
            cep_ptr->state = MSS_USB_CEP_SETUP;

            if(USB_STANDARD_REQUEST == (g_setup_pkt.request_type &
    218c:	f894 21c8 	ldrb.w	r2, [r4, #456]	; 0x1c8
    {
        MSS_USBD_CIF_cep_read_pkt(cep_ptr);

        if(SETUP_PKT_SIZE == cep_ptr->txn_length)
        {
            cep_ptr->state = MSS_USB_CEP_SETUP;
    2190:	2005      	movs	r0, #5

            if(USB_STANDARD_REQUEST == (g_setup_pkt.request_type &
    2192:	f012 0360 	ands.w	r3, r2, #96	; 0x60
    {
        MSS_USBD_CIF_cep_read_pkt(cep_ptr);

        if(SETUP_PKT_SIZE == cep_ptr->txn_length)
        {
            cep_ptr->state = MSS_USB_CEP_SETUP;
    2196:	72e0      	strb	r0, [r4, #11]

            if(USB_STANDARD_REQUEST == (g_setup_pkt.request_type &
    2198:	d063      	beq.n	2262 <mss_usbd_cep_setup_cb+0x156>
                                        USB_STD_REQ_TYPE_MASK))
            {
                result = mss_usbd_std_requests(&buf, &length);
            }
            else if(USB_CLASS_REQUEST == (g_setup_pkt.request_type &
    219a:	2b20      	cmp	r3, #32
    219c:	d001      	beq.n	21a2 <mss_usbd_cep_setup_cb+0x96>
                                          USB_STD_REQ_TYPE_MASK))
            {
                result = mss_usbd_class_requests(&buf, &length);
            }
            else if(USB_VENDOR_REQUEST == (g_setup_pkt.request_type &
    219e:	2b40      	cmp	r3, #64	; 0x40
    21a0:	d1c6      	bne.n	2130 <mss_usbd_cep_setup_cb+0x24>
(
    uint8_t** buf_pp,
    uint32_t* len_p
)
{
    if((0 != g_usbd_class_cb->usbd_class_process_request))
    21a2:	f640 329c 	movw	r2, #2972	; 0xb9c
    21a6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    21aa:	6813      	ldr	r3, [r2, #0]
    21ac:	68db      	ldr	r3, [r3, #12]
    21ae:	2b00      	cmp	r3, #0
    21b0:	d0be      	beq.n	2130 <mss_usbd_cep_setup_cb+0x24>
    {
        if(USB_SUCCESS ==
    21b2:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
    21b6:	a903      	add	r1, sp, #12
    21b8:	aa02      	add	r2, sp, #8
    21ba:	4798      	blx	r3
    21bc:	2801      	cmp	r0, #1
    21be:	d1b7      	bne.n	2130 <mss_usbd_cep_setup_cb+0x24>
    21c0:	f8b4 11ce 	ldrh.w	r1, [r4, #462]	; 0x1ce
                                        CSR0L_DEV_DATA_END_MASK);
}

static __INLINE void MSS_USBD_CIF_reset_index_reg(void)
{
    USB->INDEX = 0u;
    21c4:	f243 0300 	movw	r3, #12288	; 0x3000
    21c8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    21cc:	2000      	movs	r0, #0
    21ce:	7398      	strb	r0, [r3, #14]
        }

        if(result)  //USB_SUCCESS
        {
            MSS_USBD_CIF_reset_index_reg();
            if(0u == g_setup_pkt.length)
    21d0:	bb39      	cbnz	r1, 2222 <mss_usbd_cep_setup_cb+0x116>
                                MSS_USB_BOOLEAN_TRUE : MSS_USB_BOOLEAN_FALSE));
}

static __INLINE void MSS_USBD_CIF_cep_end_zdr(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = (CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK |
    21d2:	f04f 0c48 	mov.w	ip, #72	; 0x48
            {
                volatile uint32_t delay = 0;
    21d6:	9101      	str	r1, [sp, #4]
    21d8:	f8a3 c012 	strh.w	ip, [r3, #18]
                MSS_USBD_CIF_cep_end_zdr();                 //zdl complete

                cep_ptr->state = MSS_USB_CEP_IDLE;
                if(USB_STD_REQ_SET_ADDRESS == g_setup_pkt.request)
    21dc:	f894 21c9 	ldrb.w	r2, [r4, #457]	; 0x1c9
            if(0u == g_setup_pkt.length)
            {
                volatile uint32_t delay = 0;
                MSS_USBD_CIF_cep_end_zdr();                 //zdl complete

                cep_ptr->state = MSS_USB_CEP_IDLE;
    21e0:	2004      	movs	r0, #4
    21e2:	f240 73e0 	movw	r3, #2016	; 0x7e0
                if(USB_STD_REQ_SET_ADDRESS == g_setup_pkt.request)
    21e6:	2a05      	cmp	r2, #5
            if(0u == g_setup_pkt.length)
            {
                volatile uint32_t delay = 0;
                MSS_USBD_CIF_cep_end_zdr();                 //zdl complete

                cep_ptr->state = MSS_USB_CEP_IDLE;
    21e8:	72e0      	strb	r0, [r4, #11]
    21ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
                if(USB_STD_REQ_SET_ADDRESS == g_setup_pkt.request)
    21ee:	f000 8213 	beq.w	2618 <mss_usbd_cep_setup_cb+0x50c>
                    //special case SetAddress Request
                    for(delay = 0; delay < 5000 ; delay ++);
                    MSS_USBD_CIF_set_dev_addr(g_usbd_dev_conf.device_addr);
                }

                if((USB_STD_REQ_SET_FEATURE == g_setup_pkt.request) &&
    21f2:	2a03      	cmp	r2, #3
    21f4:	d105      	bne.n	2202 <mss_usbd_cep_setup_cb+0xf6>
    21f6:	f8b3 c1ca 	ldrh.w	ip, [r3, #458]	; 0x1ca
    21fa:	f1bc 0f02 	cmp.w	ip, #2
    21fe:	f000 8220 	beq.w	2642 <mss_usbd_cep_setup_cb+0x536>
                        break;
                    }
                }
                else
                {
                    SETUP_PKT_INIT();
    2202:	2200      	movs	r2, #0
                    MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    2204:	48c4      	ldr	r0, [pc, #784]	; (2518 <mss_usbd_cep_setup_cb+0x40c>)
    2206:	2108      	movs	r1, #8
                        break;
                    }
                }
                else
                {
                    SETUP_PKT_INIT();
    2208:	f8a4 21ce 	strh.w	r2, [r4, #462]	; 0x1ce
    220c:	f884 21c8 	strb.w	r2, [r4, #456]	; 0x1c8
    2210:	f884 21c9 	strb.w	r2, [r4, #457]	; 0x1c9
    2214:	f8a4 21ca 	strh.w	r2, [r4, #458]	; 0x1ca
    2218:	f8a4 21cc 	strh.w	r2, [r4, #460]	; 0x1cc
                    MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt,
    221c:	f7ff fe7a 	bl	1f14 <MSS_USBD_cep_read_prepare>
    2220:	e79a      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
}

static __INLINE void MSS_USBD_CIF_cep_clr_rxpktrdy(void)
{
    /*Setting SERVICED_RX_PKT_RDY clears RxPktRdy bit*/
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = CSR0L_DEV_SERVICED_RX_PKT_RDY_MASK;
    2222:	f04f 0c40 	mov.w	ip, #64	; 0x40
    2226:	f8a3 c012 	strh.w	ip, [r3, #18]
            else
            {
                //end of setup phase for Read/Write Req
                MSS_USBD_CIF_cep_clr_rxpktrdy();

                if((g_setup_pkt.request_type & USB_STD_REQ_DATA_DIR_MASK))
    222a:	f994 e1c8 	ldrsb.w	lr, [r4, #456]	; 0x1c8
    222e:	f240 73e0 	movw	r3, #2016	; 0x7e0
    2232:	f1be 0f00 	cmp.w	lr, #0
    2236:	f2c2 0300 	movt	r3, #8192	; 0x2000
    223a:	da0b      	bge.n	2254 <mss_usbd_cep_setup_cb+0x148>
                    if((uint8_t*)0 == buf)
                    {
                        ASSERT(0);
                    }

                    if(length > g_setup_pkt.length)
    223c:	9a02      	ldr	r2, [sp, #8]
                //end of setup phase for Read/Write Req
                MSS_USBD_CIF_cep_clr_rxpktrdy();

                if((g_setup_pkt.request_type & USB_STD_REQ_DATA_DIR_MASK))
                {
                    cep_ptr->state = MSS_USB_CEP_TX;
    223e:	2006      	movs	r0, #6
                    if((uint8_t*)0 == buf)
                    {
                        ASSERT(0);
                    }

                    if(length > g_setup_pkt.length)
    2240:	4291      	cmp	r1, r2
                //end of setup phase for Read/Write Req
                MSS_USBD_CIF_cep_clr_rxpktrdy();

                if((g_setup_pkt.request_type & USB_STD_REQ_DATA_DIR_MASK))
                {
                    cep_ptr->state = MSS_USB_CEP_TX;
    2242:	72d8      	strb	r0, [r3, #11]
                    if((uint8_t*)0 == buf)
                    {
                        ASSERT(0);
                    }

                    if(length > g_setup_pkt.length)
    2244:	bf28      	it	cs
    2246:	4611      	movcs	r1, r2
                    {
                        length = g_setup_pkt.length;
                    }

                    MSS_USBD_cep_write(buf,length);
    2248:	9803      	ldr	r0, [sp, #12]
                        ASSERT(0);
                    }

                    if(length > g_setup_pkt.length)
                    {
                        length = g_setup_pkt.length;
    224a:	bf38      	it	cc
    224c:	9102      	strcc	r1, [sp, #8]
                    }

                    MSS_USBD_cep_write(buf,length);
    224e:	f7ff fae9 	bl	1824 <MSS_USBD_cep_write>
    2252:	e781      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
                }
                else
                {
                    cep_ptr->state = MSS_USB_CEP_RX;
    2254:	2207      	movs	r2, #7
                    MSS_USBD_cep_read_prepare(buf,length);
    2256:	9803      	ldr	r0, [sp, #12]
    2258:	9902      	ldr	r1, [sp, #8]

                    MSS_USBD_cep_write(buf,length);
                }
                else
                {
                    cep_ptr->state = MSS_USB_CEP_RX;
    225a:	72da      	strb	r2, [r3, #11]
                    MSS_USBD_cep_read_prepare(buf,length);
    225c:	f7ff fe5a 	bl	1f14 <MSS_USBD_cep_read_prepare>
    2260:	e77a      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
    uint32_t* length
)
{
    uint8_t result = USB_FAIL;
    /*TODO:result should be used for all the functions*/
    switch(g_setup_pkt.request)
    2262:	f894 e1c9 	ldrb.w	lr, [r4, #457]	; 0x1c9
    2266:	f1be 0f0b 	cmp.w	lr, #11
    226a:	f63f af61 	bhi.w	2130 <mss_usbd_cep_setup_cb+0x24>
    226e:	a101      	add	r1, pc, #4	; (adr r1, 2274 <mss_usbd_cep_setup_cb+0x168>)
    2270:	f851 f02e 	ldr.w	pc, [r1, lr, lsl #2]
    2274:	00002445 	.word	0x00002445
    2278:	000023bd 	.word	0x000023bd
    227c:	00002131 	.word	0x00002131
    2280:	00002345 	.word	0x00002345
    2284:	00002131 	.word	0x00002131
    2288:	00002317 	.word	0x00002317
    228c:	000023f1 	.word	0x000023f1
    2290:	000021c1 	.word	0x000021c1
    2294:	000022ed 	.word	0x000022ed
    2298:	000022c1 	.word	0x000022c1
    229c:	000022b3 	.word	0x000022b3
    22a0:	000022a5 	.word	0x000022a5
        case USB_STD_REQ_SET_DESCRIPTOR:
            mss_usbd_set_descriptor();
        break;

        case USB_STD_REQ_SET_INTERFACE:
            g_usbd_dev_conf.active_interface_num = (uint8_t)g_setup_pkt.value;
    22a4:	f8b4 e1ca 	ldrh.w	lr, [r4, #458]	; 0x1ca
    22a8:	f8b4 11ce 	ldrh.w	r1, [r4, #462]	; 0x1ce
    22ac:	f884 e1c0 	strb.w	lr, [r4, #448]	; 0x1c0
    22b0:	e788      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
        return USB_SUCCESS;

         case USB_STD_REQ_GET_INTERFACE:
            *buf = &g_usbd_dev_conf.active_interface_num;
    22b2:	489a      	ldr	r0, [pc, #616]	; (251c <mss_usbd_cep_setup_cb+0x410>)
            *length = 1u;
    22b4:	2101      	movs	r1, #1
    22b6:	9102      	str	r1, [sp, #8]
        case USB_STD_REQ_SET_INTERFACE:
            g_usbd_dev_conf.active_interface_num = (uint8_t)g_setup_pkt.value;
        return USB_SUCCESS;

         case USB_STD_REQ_GET_INTERFACE:
            *buf = &g_usbd_dev_conf.active_interface_num;
    22b8:	9003      	str	r0, [sp, #12]
            *length = 1u;
    22ba:	f8b4 11ce 	ldrh.w	r1, [r4, #462]	; 0x1ce
    22be:	e781      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    uint8_t cfgidx;

    cfgidx = (uint8_t)g_setup_pkt.value;

    /*USB2.0 section 9.4.6*/
    if(MSS_USB_DEFAULT_STATE == g_usbd_dev_conf.device_state)
    22c0:	f894 31bb 	ldrb.w	r3, [r4, #443]	; 0x1bb
    void
)
{
    uint8_t cfgidx;

    cfgidx = (uint8_t)g_setup_pkt.value;
    22c4:	f240 75e0 	movw	r5, #2016	; 0x7e0

    /*USB2.0 section 9.4.6*/
    if(MSS_USB_DEFAULT_STATE == g_usbd_dev_conf.device_state)
    22c8:	2b03      	cmp	r3, #3
    void
)
{
    uint8_t cfgidx;

    cfgidx = (uint8_t)g_setup_pkt.value;
    22ca:	f2c2 0500 	movt	r5, #8192	; 0x2000
    22ce:	f8b4 01ca 	ldrh.w	r0, [r4, #458]	; 0x1ca

    /*USB2.0 section 9.4.6*/
    if(MSS_USB_DEFAULT_STATE == g_usbd_dev_conf.device_state)
    22d2:	d008      	beq.n	22e6 <mss_usbd_cep_setup_cb+0x1da>
    void
)
{
    uint8_t cfgidx;

    cfgidx = (uint8_t)g_setup_pkt.value;
    22d4:	b2c0      	uxtb	r0, r0
    }
    else
    {
        /*This value will be returned in Get_config command*/
        g_usbd_dev_conf.active_config_num = cfgidx;
        if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
    22d6:	2b04      	cmp	r3, #4
        return USB_FAIL;
    }
    else
    {
        /*This value will be returned in Get_config command*/
        g_usbd_dev_conf.active_config_num = cfgidx;
    22d8:	f885 01bf 	strb.w	r0, [r5, #447]	; 0x1bf
        if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
    22dc:	f000 820b 	beq.w	26f6 <mss_usbd_cep_setup_cb+0x5ea>
                    g_usbd_class_cb->usbd_class_init(cfgidx,
                                                     g_usbd_dev_conf.device_speed);
                }
            }
        }
        else if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
    22e0:	2b05      	cmp	r3, #5
    22e2:	f000 80e2 	beq.w	24aa <mss_usbd_cep_setup_cb+0x39e>
            {
                g_usbd_dev_conf.device_state = MSS_USB_CONFIGURED_STATE;

                if(0 != g_usbd_class_cb->usbd_class_init)
                {
                    g_usbd_class_cb->usbd_class_init(cfgidx,
    22e6:	f8b5 11ce 	ldrh.w	r1, [r5, #462]	; 0x1ce
    22ea:	e76b      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    uint8_t** buf_pp,
    uint32_t* len_p
)
{
    /*The field value and index must be 0 and length must be 1*/
    if((0u == g_setup_pkt.value) &&
    22ec:	f8b4 01ca 	ldrh.w	r0, [r4, #458]	; 0x1ca
    22f0:	f240 73e0 	movw	r3, #2016	; 0x7e0
    22f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    22f8:	bb08      	cbnz	r0, 233e <mss_usbd_cep_setup_cb+0x232>
    22fa:	f8b3 11cc 	ldrh.w	r1, [r3, #460]	; 0x1cc
    22fe:	b9f1      	cbnz	r1, 233e <mss_usbd_cep_setup_cb+0x232>
       (0u == g_setup_pkt.index) &&
       (1u == g_setup_pkt.length))
    2300:	f8b3 11ce 	ldrh.w	r1, [r3, #462]	; 0x1ce
    uint8_t** buf_pp,
    uint32_t* len_p
)
{
    /*The field value and index must be 0 and length must be 1*/
    if((0u == g_setup_pkt.value) &&
    2304:	2901      	cmp	r1, #1
    2306:	f47f af5d 	bne.w	21c4 <mss_usbd_cep_setup_cb+0xb8>
       (0u == g_setup_pkt.index) &&
       (1u == g_setup_pkt.length))
    {
        /*This value was set in Set_config command*/
        *buf_pp = &g_usbd_dev_conf.active_config_num ;
    230a:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
    230e:	1cda      	adds	r2, r3, #3
    2310:	9203      	str	r2, [sp, #12]
        *len_p = 1u;
    2312:	9102      	str	r1, [sp, #8]
    2314:	e756      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
)
{
    uint8_t addr;

    /*USB device address is 7bit only*/
    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);
    2316:	f894 e1ca 	ldrb.w	lr, [r4, #458]	; 0x1ca
    g_usbd_dev_conf.device_addr = addr;

    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);

    /*USB2.0 section 9.4.6*/
    if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
    231a:	f894 21bb 	ldrb.w	r2, [r4, #443]	; 0x1bb
)
{
    uint8_t addr;

    /*USB device address is 7bit only*/
    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);
    231e:	f00e 017f 	and.w	r1, lr, #127	; 0x7f
    2322:	f240 73e0 	movw	r3, #2016	; 0x7e0
    g_usbd_dev_conf.device_addr = addr;

    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);

    /*USB2.0 section 9.4.6*/
    if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
    2326:	2a05      	cmp	r2, #5
{
    uint8_t addr;

    /*USB device address is 7bit only*/
    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);
    g_usbd_dev_conf.device_addr = addr;
    2328:	f884 11b8 	strb.w	r1, [r4, #440]	; 0x1b8
)
{
    uint8_t addr;

    /*USB device address is 7bit only*/
    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);
    232c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_usbd_dev_conf.device_addr = addr;

    addr = (uint8_t)(g_setup_pkt.value & 0x7Fu);

    /*USB2.0 section 9.4.6*/
    if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
    2330:	d005      	beq.n	233e <mss_usbd_cep_setup_cb+0x232>
        /*Behaviour not defined by USB2.0, May raise error here*/
        return USB_FAIL;
    }
    else
    {
        if(MSS_USB_DEFAULT_STATE == g_usbd_dev_conf.device_state)
    2332:	2a03      	cmp	r2, #3
    2334:	f000 81f4 	beq.w	2720 <mss_usbd_cep_setup_cb+0x614>
            if(0u != addr)
            {
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;
            }
        }
        else if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
    2338:	2a04      	cmp	r2, #4
    233a:	f000 80ad 	beq.w	2498 <mss_usbd_cep_setup_cb+0x38c>
    {
        if(MSS_USB_DEFAULT_STATE == g_usbd_dev_conf.device_state)
        {
            if(0u != addr)
            {
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;
    233e:	f8b3 11ce 	ldrh.w	r1, [r3, #462]	; 0x1ce
    2342:	e73f      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    void
)
{
    uint8_t result = USB_SUCCESS;

    if(0u == g_setup_pkt.length)
    2344:	f8b4 11ce 	ldrh.w	r1, [r4, #462]	; 0x1ce
    2348:	f240 73e0 	movw	r3, #2016	; 0x7e0
    234c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2350:	2900      	cmp	r1, #0
    2352:	f47f aeed 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    {
        switch(g_setup_pkt.value)
    2356:	f8b3 01ca 	ldrh.w	r0, [r3, #458]	; 0x1ca
    235a:	2801      	cmp	r0, #1
    235c:	f000 81f6 	beq.w	274c <mss_usbd_cep_setup_cb+0x640>
    2360:	f080 81bb 	bcs.w	26da <mss_usbd_cep_setup_cb+0x5ce>
            {
                result = USB_FAIL;
            }
            break;
        case USB_STD_FEATURE_EP_HALT:
            if((USB_STD_REQ_RECIPIENT_ENDPOINT ==
    2364:	f002 0c1f 	and.w	ip, r2, #31
    2368:	f1bc 0f02 	cmp.w	ip, #2
    236c:	f47f aee0 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)) &&
                ((uint8_t)(g_setup_pkt.index)) &&
    2370:	f8b3 21cc 	ldrh.w	r2, [r3, #460]	; 0x1cc
    2374:	b2d0      	uxtb	r0, r2
            {
                result = USB_FAIL;
            }
            break;
        case USB_STD_FEATURE_EP_HALT:
            if((USB_STD_REQ_RECIPIENT_ENDPOINT ==
    2376:	2800      	cmp	r0, #0
    2378:	f43f aeda 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
    237c:	f893 c1bb 	ldrb.w	ip, [r3, #443]	; 0x1bb
    2380:	f1bc 0f05 	cmp.w	ip, #5
    2384:	f47f aed4 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)) &&
                ((uint8_t)(g_setup_pkt.index)) &&
                (MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state))
            {
                /*8.5.3.4 Control EP should not be implementing HALT feature*/
                if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
    2388:	f012 0f80 	tst.w	r2, #128	; 0x80
    238c:	f040 827a 	bne.w	2884 <mss_usbd_cep_setup_cb+0x778>
                    MSS_USBD_CIF_tx_ep_stall((mss_usb_ep_num_t)((((uint8_t)(g_setup_pkt.index)) & 0x7fu)));
                }
                else    /*out, rx endpoint*/
                {
                    /*Enable HALT*/
                    gd_rx_ep[(uint8_t)(g_setup_pkt.index)].stall = 0x01;
    2390:	222c      	movs	r2, #44	; 0x2c
    2392:	fb02 3300 	mla	r3, r2, r0, r3
MSS_USB_CIF_rx_ep_set_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_SEND_STALL_MASK;
    2396:	f243 1200 	movw	r2, #12544	; 0x3100
    239a:	f04f 0e01 	mov.w	lr, #1
    239e:	0100      	lsls	r0, r0, #4
    23a0:	f2c4 0204 	movt	r2, #16388	; 0x4004
    23a4:	f883 e0e6 	strb.w	lr, [r3, #230]	; 0xe6
    23a8:	1882      	adds	r2, r0, r2
    23aa:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    23ae:	fa1f f38c 	uxth.w	r3, ip
    23b2:	f043 0e20 	orr.w	lr, r3, #32
    23b6:	f8a2 e006 	strh.w	lr, [r2, #6]
    23ba:	e703      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
)
{
    uint8_t result = USB_SUCCESS;

    /*TestMode Feature cant be cleared by clr_feature.Device power cycle required*/
    if((0u == g_setup_pkt.length) &&
    23bc:	f8b4 01ce 	ldrh.w	r0, [r4, #462]	; 0x1ce
    23c0:	f240 73e0 	movw	r3, #2016	; 0x7e0
    23c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23c8:	2800      	cmp	r0, #0
    23ca:	f47f aeb1 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    23ce:	f893 c1bb 	ldrb.w	ip, [r3, #443]	; 0x1bb
    23d2:	f1bc 0f03 	cmp.w	ip, #3
    23d6:	f67f aeab 	bls.w	2130 <mss_usbd_cep_setup_cb+0x24>
       (g_usbd_dev_conf.device_state > MSS_USB_DEFAULT_STATE))
    {
        switch(g_setup_pkt.value)
    23da:	f8b3 11ca 	ldrh.w	r1, [r3, #458]	; 0x1ca
    23de:	2900      	cmp	r1, #0
    23e0:	f040 81a7 	bne.w	2732 <mss_usbd_cep_setup_cb+0x626>
                /*Disable Remote wakeup capability for the device*/
                g_usbd_dev_conf.remote_wakeup = 0x00u;
            }
            break;
        case USB_STD_FEATURE_EP_HALT:
            if(USB_STD_REQ_RECIPIENT_ENDPOINT ==
    23e4:	f002 021f 	and.w	r2, r2, #31
    23e8:	2a02      	cmp	r2, #2
    23ea:	d071      	beq.n	24d0 <mss_usbd_cep_setup_cb+0x3c4>
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_setup(status);
#endif
}
    23ec:	2100      	movs	r1, #0
    23ee:	e6e9      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
(
    uint8_t** buf_pp,
    uint32_t* len_p
)
{
    if((g_usbd_dev_conf.device_state >= MSS_USB_DEFAULT_STATE) &&
    23f0:	f894 11bb 	ldrb.w	r1, [r4, #443]	; 0x1bb
    23f4:	f240 73e0 	movw	r3, #2016	; 0x7e0
    23f8:	2902      	cmp	r1, #2
    23fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    23fe:	f67f ae97 	bls.w	2130 <mss_usbd_cep_setup_cb+0x24>
    2402:	f012 0f80 	tst.w	r2, #128	; 0x80
    2406:	f43f ae93 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
        (USB_STD_REQ_DATA_DIR_IN ==
         (g_setup_pkt.request_type & USB_STD_REQ_DATA_DIR_MASK)))
    {
        if(USB_STD_REQ_RECIPIENT_DEVICE ==
    240a:	f012 001f 	ands.w	r0, r2, #31
    240e:	f040 81ab 	bne.w	2768 <mss_usbd_cep_setup_cb+0x65c>
           (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK))
        {
            switch(g_setup_pkt.value >> USB_WVALUE_HIBITE_SHIFT)
    2412:	f8b3 01ca 	ldrh.w	r0, [r3, #458]	; 0x1ca
    2416:	0a02      	lsrs	r2, r0, #8
    2418:	1e53      	subs	r3, r2, #1
    241a:	2b06      	cmp	r3, #6
    241c:	f63f ae88 	bhi.w	2130 <mss_usbd_cep_setup_cb+0x24>
    2420:	a201      	add	r2, pc, #4	; (adr r2, 2428 <mss_usbd_cep_setup_cb+0x31c>)
    2422:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2426:	bf00      	nop
    2428:	000025ab 	.word	0x000025ab
    242c:	00002585 	.word	0x00002585
    2430:	00002569 	.word	0x00002569
    2434:	00002131 	.word	0x00002131
    2438:	00002131 	.word	0x00002131
    243c:	000025d7 	.word	0x000025d7
    2440:	00002521 	.word	0x00002521
(
    uint8_t** buf_pp,
    uint32_t* len_p
)
{
    if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
    2444:	f894 11bb 	ldrb.w	r1, [r4, #443]	; 0x1bb
    2448:	f240 73e0 	movw	r3, #2016	; 0x7e0
    244c:	2904      	cmp	r1, #4
    244e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2452:	f000 8125 	beq.w	26a0 <mss_usbd_cep_setup_cb+0x594>
        else
        {
            return USB_FAIL;
        }
    }
    else if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
    2456:	2905      	cmp	r1, #5
    2458:	f47f af71 	bne.w	233e <mss_usbd_cep_setup_cb+0x232>
    {
        if((0u == g_setup_pkt.value) && (2u == g_setup_pkt.length))
    245c:	f8b3 01ca 	ldrh.w	r0, [r3, #458]	; 0x1ca
    2460:	2800      	cmp	r0, #0
    2462:	f47f af6c 	bne.w	233e <mss_usbd_cep_setup_cb+0x232>
    2466:	f8b3 11ce 	ldrh.w	r1, [r3, #462]	; 0x1ce
    246a:	2902      	cmp	r1, #2
    246c:	f47f aeaa 	bne.w	21c4 <mss_usbd_cep_setup_cb+0xb8>
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
    2470:	f002 021f 	and.w	r2, r2, #31
    2474:	2a01      	cmp	r2, #1
    2476:	f000 81dd 	beq.w	2834 <mss_usbd_cep_setup_cb+0x728>
    247a:	f080 81af 	bcs.w	27dc <mss_usbd_cep_setup_cb+0x6d0>
            {
             case USB_STD_REQ_RECIPIENT_DEVICE: /*SF2 device is self powered*/
                g_usbd_status = 0x0001;
                g_usbd_status |= (g_usbd_dev_conf.remote_wakeup << 0x0001u);
    247e:	f893 01c4 	ldrb.w	r0, [r3, #452]	; 0x1c4
                *buf_pp = (uint8_t*)&g_usbd_status;
    2482:	f503 72e9 	add.w	r2, r3, #466	; 0x1d2
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
            {
             case USB_STD_REQ_RECIPIENT_DEVICE: /*SF2 device is self powered*/
                g_usbd_status = 0x0001;
                g_usbd_status |= (g_usbd_dev_conf.remote_wakeup << 0x0001u);
    2486:	0040      	lsls	r0, r0, #1
    2488:	f040 0c01 	orr.w	ip, r0, #1
    248c:	f8a3 c1d2 	strh.w	ip, [r3, #466]	; 0x1d2
                *buf_pp = (uint8_t*)&g_usbd_status;
    2490:	9203      	str	r2, [sp, #12]
             break;

             default:
                return USB_FAIL;
            }
            * len_p = sizeof(g_usbd_status);
    2492:	2302      	movs	r3, #2
    2494:	9302      	str	r3, [sp, #8]
    2496:	e695      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;
            }
        }
        else if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
        {
            if(0u == addr)
    2498:	2900      	cmp	r1, #0
    249a:	f47f af50 	bne.w	233e <mss_usbd_cep_setup_cb+0x232>
            {
                g_usbd_dev_conf.device_state = MSS_USB_DEFAULT_STATE;
    249e:	2103      	movs	r1, #3
    24a0:	f883 11bb 	strb.w	r1, [r3, #443]	; 0x1bb
    24a4:	f8b3 11ce 	ldrh.w	r1, [r3, #462]	; 0x1ce
    24a8:	e68c      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
                }
            }
        }
        else if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
        {
            if(0 == cfgidx)
    24aa:	2800      	cmp	r0, #0
    24ac:	f040 8178 	bne.w	27a0 <mss_usbd_cep_setup_cb+0x694>
            {
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;

                if(0 != g_usbd_class_cb->usbd_class_release)
    24b0:	f640 319c 	movw	r1, #2972	; 0xb9c
    24b4:	f2c2 0100 	movt	r1, #8192	; 0x2000
    24b8:	680b      	ldr	r3, [r1, #0]
        }
        else if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
        {
            if(0 == cfgidx)
            {
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;
    24ba:	2204      	movs	r2, #4

                if(0 != g_usbd_class_cb->usbd_class_release)
    24bc:	685b      	ldr	r3, [r3, #4]
        }
        else if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
        {
            if(0 == cfgidx)
            {
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;
    24be:	f885 21bb 	strb.w	r2, [r5, #443]	; 0x1bb

                if(0 != g_usbd_class_cb->usbd_class_release)
    24c2:	2b00      	cmp	r3, #0
    24c4:	f43f af0f 	beq.w	22e6 <mss_usbd_cep_setup_cb+0x1da>
                {
                    g_usbd_class_cb->usbd_class_release(cfgidx);
    24c8:	4798      	blx	r3
    24ca:	f8b5 11ce 	ldrh.w	r1, [r5, #462]	; 0x1ce
    24ce:	e679      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
        case USB_STD_FEATURE_EP_HALT:
            if(USB_STD_REQ_RECIPIENT_ENDPOINT ==
               (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK))
            {
                /*8.5.3.4 HALT clear can be performed on CEP and Data EP*/
                if((uint8_t)(g_setup_pkt.index)) /*Not a control endpoint*/
    24d0:	f8b3 21cc 	ldrh.w	r2, [r3, #460]	; 0x1cc
    24d4:	b2d0      	uxtb	r0, r2
    24d6:	2800      	cmp	r0, #0
    24d8:	d088      	beq.n	23ec <mss_usbd_cep_setup_cb+0x2e0>
                {
                    if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
    24da:	f012 0f80 	tst.w	r2, #128	; 0x80
    24de:	f040 81b6 	bne.w	284e <mss_usbd_cep_setup_cb+0x742>
                        MSS_USBD_CIF_tx_ep_clr_stall((mss_usb_ep_num_t)((((uint8_t)(g_setup_pkt.index)) & 0x7fu)));
                    }
                    else    /* out, rx endpoint */
                    {
                        /*Enable HALT*/
                        gd_rx_ep[(uint8_t)(g_setup_pkt.index)].stall = 0x00u;
    24e2:	222c      	movs	r2, #44	; 0x2c
    24e4:	fb02 3300 	mla	r3, r2, r0, r3
MSS_USB_CIF_rx_ep_clr_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_SEND_STALL_MASK;
    24e8:	f243 1200 	movw	r2, #12544	; 0x3100
    24ec:	0100      	lsls	r0, r0, #4
    24ee:	f2c4 0204 	movt	r2, #16388	; 0x4004
    24f2:	f883 10e6 	strb.w	r1, [r3, #230]	; 0xe6
    24f6:	1882      	adds	r2, r0, r2
    24f8:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    24fc:	f02c 0020 	bic.w	r0, ip, #32
    2500:	0403      	lsls	r3, r0, #16
    2502:	0c18      	lsrs	r0, r3, #16
    2504:	80d0      	strh	r0, [r2, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    /*setting CLR_DAT_TOG bit clears USB Data toggle bit*/
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_CLR_DAT_TOG_MASK;
    2506:	88d3      	ldrh	r3, [r2, #6]
    2508:	fa1f fe83 	uxth.w	lr, r3
    250c:	f04e 0c80 	orr.w	ip, lr, #128	; 0x80
    2510:	f8a2 c006 	strh.w	ip, [r2, #6]
    2514:	e656      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    2516:	bf00      	nop
    2518:	200009a8 	.word	0x200009a8
    251c:	200009a0 	.word	0x200009a0
                    {
                        return(USB_FAIL);
                    }

                case USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE:
                    if(MSS_USB_DEVICE_HS == g_usbd_user_speed)
    2520:	f894 11d0 	ldrb.w	r1, [r4, #464]	; 0x1d0
    2524:	f240 73e0 	movw	r3, #2016	; 0x7e0
    2528:	f2c2 0300 	movt	r3, #8192	; 0x2000
    252c:	2900      	cmp	r1, #0
    252e:	f47f adff 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                    {
                        /*descriptor Index should be zero and Index field should be zero*/
                        if((0u == ((uint8_t)(g_setup_pkt.value))) &&
    2532:	f010 0fff 	tst.w	r0, #255	; 0xff
    2536:	f47f adfb 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    253a:	f8b3 01cc 	ldrh.w	r0, [r3, #460]	; 0x1cc
    253e:	2800      	cmp	r0, #0
    2540:	f47f adf6 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                           (0u == g_setup_pkt.index))
                        {
                            if(0 != g_usbd_class_cb->usbd_class_get_descriptor)
    2544:	f640 319c 	movw	r1, #2972	; 0xb9c
    2548:	f2c2 0100 	movt	r1, #8192	; 0x2000
    254c:	680a      	ldr	r2, [r1, #0]
    254e:	f8d2 c008 	ldr.w	ip, [r2, #8]
    2552:	f1bc 0f00 	cmp.w	ip, #0
    2556:	f43f adeb 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
                            {
                                *buf_pp = g_usbd_class_cb->usbd_class_get_descriptor
    255a:	f893 31be 	ldrb.w	r3, [r3, #446]	; 0x1be
    255e:	2107      	movs	r1, #7
    2560:	aa02      	add	r2, sp, #8
    2562:	47e0      	blx	ip
    2564:	9003      	str	r0, [sp, #12]
    2566:	e62b      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>

                    /*
                    * When descriptor index is 0, index field must be 0.
                    * When descriptor index is >0, index field indicates Lang ID
                    */
                    if(0 != g_usbd_user_descr_cb->usbd_string_descriptor)
    2568:	f640 31a0 	movw	r1, #2976	; 0xba0
    256c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    2570:	680a      	ldr	r2, [r1, #0]
    2572:	6893      	ldr	r3, [r2, #8]
    2574:	2b00      	cmp	r3, #0
    2576:	f43f addb 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
                    {
                        *buf_pp = g_usbd_user_descr_cb->usbd_string_descriptor
    257a:	b2c0      	uxtb	r0, r0
    257c:	a902      	add	r1, sp, #8
    257e:	4798      	blx	r3
    2580:	9003      	str	r0, [sp, #12]
    2582:	e61d      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>
                        /*Since User operates USBD at FS, Stall this request*/
                        return(USB_FAIL);
                    }

                case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                    if(0 != g_usbd_class_cb->usbd_class_get_descriptor)
    2584:	f640 309c 	movw	r0, #2972	; 0xb9c
    2588:	f2c2 0000 	movt	r0, #8192	; 0x2000
    258c:	6802      	ldr	r2, [r0, #0]
    258e:	f8d2 c008 	ldr.w	ip, [r2, #8]
    2592:	f1bc 0f00 	cmp.w	ip, #0
    2596:	f43f adcb 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
                    {
                        *buf_pp = g_usbd_class_cb->usbd_class_get_descriptor
    259a:	2000      	movs	r0, #0
    259c:	2102      	movs	r1, #2
    259e:	aa02      	add	r2, sp, #8
    25a0:	f894 31be 	ldrb.w	r3, [r4, #446]	; 0x1be
    25a4:	47e0      	blx	ip
    25a6:	9003      	str	r0, [sp, #12]
    25a8:	e60a      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>
            switch(g_setup_pkt.value >> USB_WVALUE_HIBITE_SHIFT)
            {
                case USB_DEVICE_DESCRIPTOR_TYPE:

                    /*descriptor Index and Index field should be zero*/
                    if((0u == ((uint8_t)(g_setup_pkt.value))) &&
    25aa:	f010 0fff 	tst.w	r0, #255	; 0xff
    25ae:	f47f adbf 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    25b2:	f8b4 01cc 	ldrh.w	r0, [r4, #460]	; 0x1cc
    25b6:	2800      	cmp	r0, #0
    25b8:	f47f adba 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                        (0u == g_setup_pkt.index) &&
                        (0 != g_usbd_user_descr_cb->usbd_device_descriptor))
    25bc:	f640 33a0 	movw	r3, #2976	; 0xba0
    25c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    25c4:	6819      	ldr	r1, [r3, #0]
    25c6:	680b      	ldr	r3, [r1, #0]
            switch(g_setup_pkt.value >> USB_WVALUE_HIBITE_SHIFT)
            {
                case USB_DEVICE_DESCRIPTOR_TYPE:

                    /*descriptor Index and Index field should be zero*/
                    if((0u == ((uint8_t)(g_setup_pkt.value))) &&
    25c8:	2b00      	cmp	r3, #0
    25ca:	f43f adb1 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
                        (0u == g_setup_pkt.index) &&
                        (0 != g_usbd_user_descr_cb->usbd_device_descriptor))
                    {
                        *buf_pp = g_usbd_user_descr_cb->usbd_device_descriptor(len_p);
    25ce:	a802      	add	r0, sp, #8
    25d0:	4798      	blx	r3
    25d2:	9003      	str	r0, [sp, #12]
    25d4:	e5f4      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>
                    {
                        return(USB_FAIL);
                    }

                case USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE:
                    if(MSS_USB_DEVICE_HS == g_usbd_user_speed)
    25d6:	f894 31d0 	ldrb.w	r3, [r4, #464]	; 0x1d0
    25da:	f240 72e0 	movw	r2, #2016	; 0x7e0
    25de:	f2c2 0200 	movt	r2, #8192	; 0x2000
    25e2:	2b00      	cmp	r3, #0
    25e4:	f47f ada4 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                    {
                        /*descriptor Index should be zero*/
                        if((0 == ((uint8_t)(g_setup_pkt.value))) &&
    25e8:	f010 0fff 	tst.w	r0, #255	; 0xff
    25ec:	f47f ada0 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    25f0:	f8b2 01cc 	ldrh.w	r0, [r2, #460]	; 0x1cc
    25f4:	2800      	cmp	r0, #0
    25f6:	f47f ad9b 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                            (0 == g_setup_pkt.index) &&
                            (0 != g_usbd_user_descr_cb->usbd_device_qual_descriptor))
    25fa:	f640 33a0 	movw	r3, #2976	; 0xba0
    25fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2602:	6819      	ldr	r1, [r3, #0]
    2604:	684b      	ldr	r3, [r1, #4]

                case USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE:
                    if(MSS_USB_DEVICE_HS == g_usbd_user_speed)
                    {
                        /*descriptor Index should be zero*/
                        if((0 == ((uint8_t)(g_setup_pkt.value))) &&
    2606:	2b00      	cmp	r3, #0
    2608:	f43f ad92 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
                            (0 == g_setup_pkt.index) &&
                            (0 != g_usbd_user_descr_cb->usbd_device_qual_descriptor))
                        {
                            *buf_pp = g_usbd_user_descr_cb->usbd_device_qual_descriptor
    260c:	f892 01be 	ldrb.w	r0, [r2, #446]	; 0x1be
    2610:	a902      	add	r1, sp, #8
    2612:	4798      	blx	r3
    2614:	9003      	str	r0, [sp, #12]
    2616:	e5d3      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>

                cep_ptr->state = MSS_USB_CEP_IDLE;
                if(USB_STD_REQ_SET_ADDRESS == g_setup_pkt.request)
                {
                    //special case SetAddress Request
                    for(delay = 0; delay < 5000 ; delay ++);
    2618:	9101      	str	r1, [sp, #4]
    261a:	9901      	ldr	r1, [sp, #4]
    261c:	f241 3287 	movw	r2, #4999	; 0x1387
    2620:	4291      	cmp	r1, r2
    2622:	d805      	bhi.n	2630 <mss_usbd_cep_setup_cb+0x524>
    2624:	9901      	ldr	r1, [sp, #4]
    2626:	1c48      	adds	r0, r1, #1
    2628:	9001      	str	r0, [sp, #4]
    262a:	9b01      	ldr	r3, [sp, #4]
    262c:	4293      	cmp	r3, r2
    262e:	d9f9      	bls.n	2624 <mss_usbd_cep_setup_cb+0x518>
                    MSS_USBD_CIF_set_dev_addr(g_usbd_dev_conf.device_addr);
    2630:	f894 e1b8 	ldrb.w	lr, [r4, #440]	; 0x1b8

/*lint -e20 -e522 -e10 -e40 -e63 -e35 -e26 -e78*/

static __INLINE void MSS_USBD_CIF_set_dev_addr(uint8_t addr)
{
    USB->FADDR = addr;
    2634:	f243 0200 	movw	r2, #12288	; 0x3000
    2638:	f2c4 0204 	movt	r2, #16388	; 0x4004
    263c:	f882 e000 	strb.w	lr, [r2]
    2640:	e5df      	b.n	2202 <mss_usbd_cep_setup_cb+0xf6>

                if((USB_STD_REQ_SET_FEATURE == g_setup_pkt.request) &&
                   (USB_STD_FEATURE_TEST_MODE == g_setup_pkt.value))
                {
                    //let the current request status phase complete.
                    for(delay = 0; delay < 5000 ; delay ++);
    2642:	9101      	str	r1, [sp, #4]
    2644:	9b01      	ldr	r3, [sp, #4]
    2646:	f241 3287 	movw	r2, #4999	; 0x1387
    264a:	4293      	cmp	r3, r2
    264c:	d805      	bhi.n	265a <mss_usbd_cep_setup_cb+0x54e>
    264e:	9b01      	ldr	r3, [sp, #4]
    2650:	1c59      	adds	r1, r3, #1
    2652:	9101      	str	r1, [sp, #4]
    2654:	9801      	ldr	r0, [sp, #4]
    2656:	4290      	cmp	r0, r2
    2658:	d9f9      	bls.n	264e <mss_usbd_cep_setup_cb+0x542>
                    switch(g_setup_pkt.index >> USB_WINDEX_HIBITE_SHIFT)
    265a:	f8b4 11cc 	ldrh.w	r1, [r4, #460]	; 0x1cc
    265e:	0a08      	lsrs	r0, r1, #8
    2660:	1e42      	subs	r2, r0, #1
    2662:	2a03      	cmp	r2, #3
    2664:	f63f ad78 	bhi.w	2158 <mss_usbd_cep_setup_cb+0x4c>
    2668:	e8df f002 	tbb	[pc, r2]
    266c:	02050c13 	.word	0x02050c13
                        case USB_TEST_MODE_SELECTOR_TEST_SE0NAK:
                            MSS_USB_CIF_start_testse0nak();
                        break;

                        case USB_TEST_MODE_SELECTOR_TEST_PACKET:
                            MSS_USB_CIF_start_testpacket();
    2670:	f7fe fed0 	bl	1414 <MSS_USB_CIF_start_testpacket>
    2674:	e570      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
    USB->INDEX = index;
}

static __INLINE void MSS_USB_CIF_start_testse0nak(void)
{
    USB->TEST_MODE = TESTMODE_SE0NAK_MASK;
    2676:	f243 0300 	movw	r3, #12288	; 0x3000
    267a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    267e:	2201      	movs	r2, #1
    2680:	73da      	strb	r2, [r3, #15]
                            MSS_USB_CIF_start_testk();
                        break;

                        case USB_TEST_MODE_SELECTOR_TEST_SE0NAK:
                            MSS_USB_CIF_start_testse0nak();
                        break;
    2682:	e569      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
    USB->TEST_MODE = TESTMODE_TESTJ_MASK;
}

static __INLINE void MSS_USB_CIF_start_testk(void)
{
    USB->TEST_MODE = TESTMODE_TESTK_MASK;
    2684:	f243 0100 	movw	r1, #12288	; 0x3000
    2688:	f2c4 0104 	movt	r1, #16388	; 0x4004
    268c:	2004      	movs	r0, #4
    268e:	73c8      	strb	r0, [r1, #15]
                            MSS_USB_CIF_start_testj();
                        break;

                        case USB_TEST_MODE_SELECTOR_TEST_K:
                            MSS_USB_CIF_start_testk();
                        break;
    2690:	e562      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
    USB->TEST_MODE = TESTMODE_SE0NAK_MASK;
}

static __INLINE void MSS_USB_CIF_start_testj(void)
{
    USB->TEST_MODE = TESTMODE_TESTJ_MASK;
    2692:	f243 0300 	movw	r3, #12288	; 0x3000
    2696:	f2c4 0304 	movt	r3, #16388	; 0x4004
    269a:	2202      	movs	r2, #2
    269c:	73da      	strb	r2, [r3, #15]
                    for(delay = 0; delay < 5000 ; delay ++);
                    switch(g_setup_pkt.index >> USB_WINDEX_HIBITE_SHIFT)
                    {
                        case USB_TEST_MODE_SELECTOR_TEST_J:
                            MSS_USB_CIF_start_testj();
                        break;
    269e:	e55b      	b.n	2158 <mss_usbd_cep_setup_cb+0x4c>
)
{
    if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
    {
        /*The field value and index must be 0 and length must be 2*/
        if((0u == g_setup_pkt.value) &&
    26a0:	f8b3 01ca 	ldrh.w	r0, [r3, #458]	; 0x1ca
    26a4:	2800      	cmp	r0, #0
    26a6:	f47f ae4a 	bne.w	233e <mss_usbd_cep_setup_cb+0x232>
    26aa:	f8b3 01cc 	ldrh.w	r0, [r3, #460]	; 0x1cc
    26ae:	2800      	cmp	r0, #0
    26b0:	f47f ae45 	bne.w	233e <mss_usbd_cep_setup_cb+0x232>
           (0u == g_setup_pkt.index) &&
           (2u == g_setup_pkt.length))
    26b4:	f8b3 11ce 	ldrh.w	r1, [r3, #462]	; 0x1ce
)
{
    if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
    {
        /*The field value and index must be 0 and length must be 2*/
        if((0u == g_setup_pkt.value) &&
    26b8:	2902      	cmp	r1, #2
    26ba:	f47f ad83 	bne.w	21c4 <mss_usbd_cep_setup_cb+0xb8>
           (0u == g_setup_pkt.index) &&
           (2u == g_setup_pkt.length))
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
    26be:	f002 021f 	and.w	r2, r2, #31
    26c2:	2a01      	cmp	r2, #1
    26c4:	f000 80bd 	beq.w	2842 <mss_usbd_cep_setup_cb+0x736>
    26c8:	d279      	bcs.n	27be <mss_usbd_cep_setup_cb+0x6b2>
            {
            case USB_STD_REQ_RECIPIENT_DEVICE:
                    /*SF2 device is always self powered. RemoteWakeup NotSupported*/
                    g_usbd_status = 0x0001;
                    *buf_pp = (uint8_t*)&g_usbd_status;
    26ca:	f503 72e9 	add.w	r2, r3, #466	; 0x1d2
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
            {
            case USB_STD_REQ_RECIPIENT_DEVICE:
                    /*SF2 device is always self powered. RemoteWakeup NotSupported*/
                    g_usbd_status = 0x0001;
    26ce:	f04f 0c01 	mov.w	ip, #1
                    *buf_pp = (uint8_t*)&g_usbd_status;
    26d2:	9203      	str	r2, [sp, #12]
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
            {
            case USB_STD_REQ_RECIPIENT_DEVICE:
                    /*SF2 device is always self powered. RemoteWakeup NotSupported*/
                    g_usbd_status = 0x0001;
    26d4:	f8a3 c1d2 	strh.w	ip, [r3, #466]	; 0x1d2
    26d8:	e6db      	b.n	2492 <mss_usbd_cep_setup_cb+0x386>
{
    uint8_t result = USB_SUCCESS;

    if(0u == g_setup_pkt.length)
    {
        switch(g_setup_pkt.value)
    26da:	2802      	cmp	r0, #2
    26dc:	f47f ad28 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
            {
                result = USB_FAIL;
            }
            break;
            case USB_STD_FEATURE_TEST_MODE:
                if((USB_STD_REQ_RECIPIENT_DEVICE ==
    26e0:	f012 0f1f 	tst.w	r2, #31
    26e4:	f47f ad24 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    26e8:	f893 11cc 	ldrb.w	r1, [r3, #460]	; 0x1cc
    26ec:	2900      	cmp	r1, #0
    26ee:	f47f ad1f 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_setup(status);
#endif
}
    26f2:	2100      	movs	r1, #0
    26f4:	e566      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    {
        /*This value will be returned in Get_config command*/
        g_usbd_dev_conf.active_config_num = cfgidx;
        if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
        {
            if(cfgidx)
    26f6:	2800      	cmp	r0, #0
    26f8:	f43f adf5 	beq.w	22e6 <mss_usbd_cep_setup_cb+0x1da>
            {
                g_usbd_dev_conf.device_state = MSS_USB_CONFIGURED_STATE;

                if(0 != g_usbd_class_cb->usbd_class_init)
    26fc:	f640 319c 	movw	r1, #2972	; 0xb9c
    2700:	f2c2 0100 	movt	r1, #8192	; 0x2000
    2704:	680b      	ldr	r3, [r1, #0]
        g_usbd_dev_conf.active_config_num = cfgidx;
        if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
        {
            if(cfgidx)
            {
                g_usbd_dev_conf.device_state = MSS_USB_CONFIGURED_STATE;
    2706:	2205      	movs	r2, #5

                if(0 != g_usbd_class_cb->usbd_class_init)
    2708:	681b      	ldr	r3, [r3, #0]
        g_usbd_dev_conf.active_config_num = cfgidx;
        if(MSS_USB_ADDRESS_STATE == g_usbd_dev_conf.device_state)
        {
            if(cfgidx)
            {
                g_usbd_dev_conf.device_state = MSS_USB_CONFIGURED_STATE;
    270a:	f885 21bb 	strb.w	r2, [r5, #443]	; 0x1bb

                if(0 != g_usbd_class_cb->usbd_class_init)
    270e:	2b00      	cmp	r3, #0
    2710:	f43f ade9 	beq.w	22e6 <mss_usbd_cep_setup_cb+0x1da>
                {
                    g_usbd_class_cb->usbd_class_init(cfgidx,
    2714:	f895 11be 	ldrb.w	r1, [r5, #446]	; 0x1be
    2718:	4798      	blx	r3
    271a:	f8b5 11ce 	ldrh.w	r1, [r5, #462]	; 0x1ce
    271e:	e551      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    }
    else
    {
        if(MSS_USB_DEFAULT_STATE == g_usbd_dev_conf.device_state)
        {
            if(0u != addr)
    2720:	2900      	cmp	r1, #0
    2722:	f43f ae0c 	beq.w	233e <mss_usbd_cep_setup_cb+0x232>
            {
                g_usbd_dev_conf.device_state = MSS_USB_ADDRESS_STATE;
    2726:	2004      	movs	r0, #4
    2728:	f883 01bb 	strb.w	r0, [r3, #443]	; 0x1bb
    272c:	f8b3 11ce 	ldrh.w	r1, [r3, #462]	; 0x1ce
    2730:	e548      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>

    /*TestMode Feature cant be cleared by clr_feature.Device power cycle required*/
    if((0u == g_setup_pkt.length) &&
       (g_usbd_dev_conf.device_state > MSS_USB_DEFAULT_STATE))
    {
        switch(g_setup_pkt.value)
    2732:	2901      	cmp	r1, #1
    2734:	f47f acfc 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
        {
        case USB_STD_FEATURE_REMOTE_WAKEUP:
            if(USB_STD_REQ_RECIPIENT_DEVICE ==
    2738:	f012 0e1f 	ands.w	lr, r2, #31
               (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK))
            {
                /*Disable Remote wakeup capability for the device*/
                g_usbd_dev_conf.remote_wakeup = 0x00u;
    273c:	bf04      	itt	eq
    273e:	f883 e1c4 	strbeq.w	lr, [r3, #452]	; 0x1c4
    2742:	4671      	moveq	r1, lr
       (g_usbd_dev_conf.device_state > MSS_USB_DEFAULT_STATE))
    {
        switch(g_setup_pkt.value)
        {
        case USB_STD_FEATURE_REMOTE_WAKEUP:
            if(USB_STD_REQ_RECIPIENT_DEVICE ==
    2744:	f43f ad3e 	beq.w	21c4 <mss_usbd_cep_setup_cb+0xb8>
    }

#else /*MSS_USB_DEVICE_TEST_MODE*/
    usbd_test_cb.test_cep_setup(status);
#endif
}
    2748:	2100      	movs	r1, #0
    274a:	e53b      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
    if(0u == g_setup_pkt.length)
    {
        switch(g_setup_pkt.value)
        {
        case USB_STD_FEATURE_REMOTE_WAKEUP:
            if((USB_STD_REQ_RECIPIENT_DEVICE ==
    274c:	f012 021f 	ands.w	r2, r2, #31
    2750:	f47f acee 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
    2754:	f893 11bb 	ldrb.w	r1, [r3, #443]	; 0x1bb
    2758:	2903      	cmp	r1, #3
                (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)) &&
                (g_usbd_dev_conf.device_state > MSS_USB_DEFAULT_STATE))
            {
                /*Enable Remote wakeup capability for the device*/
                g_usbd_dev_conf.remote_wakeup = 0x01u;
    275a:	bf84      	itt	hi
    275c:	f883 01c4 	strbhi.w	r0, [r3, #452]	; 0x1c4
    2760:	4611      	movhi	r1, r2
    if(0u == g_setup_pkt.length)
    {
        switch(g_setup_pkt.value)
        {
        case USB_STD_FEATURE_REMOTE_WAKEUP:
            if((USB_STD_REQ_RECIPIENT_DEVICE ==
    2762:	f63f ad2f 	bhi.w	21c4 <mss_usbd_cep_setup_cb+0xb8>
    2766:	e4e3      	b.n	2130 <mss_usbd_cep_setup_cb+0x24>
                default:
                    return(USB_FAIL);
            }

        }
        else if(USB_STD_REQ_RECIPIENT_INTERFACE ==
    2768:	2801      	cmp	r0, #1
    276a:	d04f      	beq.n	280c <mss_usbd_cep_setup_cb+0x700>
            else
            {
                return(USB_FAIL);
            }
        }
        else if(USB_STD_REQ_RECIPIENT_ENDPOINT ==
    276c:	2802      	cmp	r0, #2
    276e:	f47f acdf 	bne.w	2130 <mss_usbd_cep_setup_cb+0x24>
                (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK))
        {
            if((g_setup_pkt.value >> USB_WVALUE_HIBITE_SHIFT) &&
    2772:	f8b3 c1ca 	ldrh.w	ip, [r3, #458]	; 0x1ca
    2776:	ea5f 211c 	movs.w	r1, ip, lsr #8
    277a:	f43f acd9 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
               (0 != g_usbd_class_cb->usbd_class_get_descriptor))
    277e:	f640 329c 	movw	r2, #2972	; 0xb9c
    2782:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2786:	6812      	ldr	r2, [r2, #0]
    2788:	f8d2 c008 	ldr.w	ip, [r2, #8]
            }
        }
        else if(USB_STD_REQ_RECIPIENT_ENDPOINT ==
                (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK))
        {
            if((g_setup_pkt.value >> USB_WVALUE_HIBITE_SHIFT) &&
    278c:	f1bc 0f00 	cmp.w	ip, #0
    2790:	f43f acce 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
               (0 != g_usbd_class_cb->usbd_class_get_descriptor))
            {
                *buf_pp = g_usbd_class_cb->usbd_class_get_descriptor
    2794:	f893 31be 	ldrb.w	r3, [r3, #446]	; 0x1be
    2798:	aa02      	add	r2, sp, #8
    279a:	47e0      	blx	ip
    279c:	9003      	str	r0, [sp, #12]
    279e:	e50f      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>
                    g_usbd_class_cb->usbd_class_release(cfgidx);
                }
            }
            else
            {
                if(0 != g_usbd_class_cb->usbd_class_init)
    27a0:	f640 339c 	movw	r3, #2972	; 0xb9c
    27a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    27a8:	681a      	ldr	r2, [r3, #0]
    27aa:	6813      	ldr	r3, [r2, #0]
    27ac:	2b00      	cmp	r3, #0
    27ae:	f43f ad9a 	beq.w	22e6 <mss_usbd_cep_setup_cb+0x1da>
                {
                    g_usbd_class_cb->usbd_class_init(cfgidx,
    27b2:	f895 11be 	ldrb.w	r1, [r5, #446]	; 0x1be
    27b6:	4798      	blx	r3
    27b8:	f8b5 11ce 	ldrh.w	r1, [r5, #462]	; 0x1ce
    27bc:	e502      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
        /*The field value and index must be 0 and length must be 2*/
        if((0u == g_setup_pkt.value) &&
           (0u == g_setup_pkt.index) &&
           (2u == g_setup_pkt.length))
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
    27be:	2a02      	cmp	r2, #2
    27c0:	f47f acfe 	bne.w	21c0 <mss_usbd_cep_setup_cb+0xb4>
                    g_usbd_status = 0x0000u;
                    *buf_pp = (uint8_t*)&g_usbd_status;
                break;

            case USB_STD_REQ_RECIPIENT_ENDPOINT:/*Endpoint halt (stall) status*/
                    g_usbd_status = ((gd_tx_ep[g_setup_pkt.index].stall) ?
    27c4:	7a98      	ldrb	r0, [r3, #10]
                                     0x0001:0x0000);

                    *buf_pp = (uint8_t*)&g_usbd_status;
    27c6:	f503 72e9 	add.w	r2, r3, #466	; 0x1d2
                    g_usbd_status = 0x0000u;
                    *buf_pp = (uint8_t*)&g_usbd_status;
                break;

            case USB_STD_REQ_RECIPIENT_ENDPOINT:/*Endpoint halt (stall) status*/
                    g_usbd_status = ((gd_tx_ep[g_setup_pkt.index].stall) ?
    27ca:	f1b0 0e00 	subs.w	lr, r0, #0
    27ce:	bf18      	it	ne
    27d0:	f04f 0e01 	movne.w	lr, #1
    27d4:	f8a3 e1d2 	strh.w	lr, [r3, #466]	; 0x1d2
                                     0x0001:0x0000);

                    *buf_pp = (uint8_t*)&g_usbd_status;
    27d8:	9203      	str	r2, [sp, #12]
    27da:	e65a      	b.n	2492 <mss_usbd_cep_setup_cb+0x386>
    }
    else if(MSS_USB_CONFIGURED_STATE == g_usbd_dev_conf.device_state)
    {
        if((0u == g_setup_pkt.value) && (2u == g_setup_pkt.length))
        {
            switch (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK)
    27dc:	2a02      	cmp	r2, #2
    27de:	f47f acef 	bne.w	21c0 <mss_usbd_cep_setup_cb+0xb4>
                {
                    return USB_FAIL;
                }
            break;
            case USB_STD_REQ_RECIPIENT_ENDPOINT:
                if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
    27e2:	f8b3 21cc 	ldrh.w	r2, [r3, #460]	; 0x1cc
    27e6:	f012 0f80 	tst.w	r2, #128	; 0x80
    27ea:	d161      	bne.n	28b0 <mss_usbd_cep_setup_cb+0x7a4>
                    g_usbd_status = ((gd_tx_ep[idx].stall) ? 0x0001:0x0000) ;
                    *buf_pp = (uint8_t*)&g_usbd_status;
                }
                else    /*out, rx endpoint*/
                {
                    g_usbd_status = ((gd_rx_ep[g_setup_pkt.index].stall) ?
    27ec:	202c      	movs	r0, #44	; 0x2c
    27ee:	fb00 3202 	mla	r2, r0, r2, r3
    27f2:	f892 e0e6 	ldrb.w	lr, [r2, #230]	; 0xe6
                                     0x0001:0x0000) ;
                    *buf_pp = (uint8_t*)&g_usbd_status;
    27f6:	f503 72e9 	add.w	r2, r3, #466	; 0x1d2
                    g_usbd_status = ((gd_tx_ep[idx].stall) ? 0x0001:0x0000) ;
                    *buf_pp = (uint8_t*)&g_usbd_status;
                }
                else    /*out, rx endpoint*/
                {
                    g_usbd_status = ((gd_rx_ep[g_setup_pkt.index].stall) ?
    27fa:	f1be 0c00 	subs.w	ip, lr, #0
    27fe:	bf18      	it	ne
    2800:	f04f 0c01 	movne.w	ip, #1
    2804:	f8a3 c1d2 	strh.w	ip, [r3, #466]	; 0x1d2
                                     0x0001:0x0000) ;
                    *buf_pp = (uint8_t*)&g_usbd_status;
    2808:	9203      	str	r2, [sp, #12]
    280a:	e642      	b.n	2492 <mss_usbd_cep_setup_cb+0x386>

        }
        else if(USB_STD_REQ_RECIPIENT_INTERFACE ==
                (g_setup_pkt.request_type & USB_STD_REQ_RECIPIENT_MASK))
        {
            if(0 != g_usbd_class_cb->usbd_class_get_descriptor)
    280c:	f640 319c 	movw	r1, #2972	; 0xb9c
    2810:	f2c2 0100 	movt	r1, #8192	; 0x2000
    2814:	680a      	ldr	r2, [r1, #0]
    2816:	f8d2 c008 	ldr.w	ip, [r2, #8]
    281a:	f1bc 0f00 	cmp.w	ip, #0
    281e:	f43f ac87 	beq.w	2130 <mss_usbd_cep_setup_cb+0x24>
            {
                *buf_pp = g_usbd_class_cb->usbd_class_get_descriptor
    2822:	f8b3 21ca 	ldrh.w	r2, [r3, #458]	; 0x1ca
    2826:	f893 31be 	ldrb.w	r3, [r3, #446]	; 0x1be
    282a:	0a11      	lsrs	r1, r2, #8
    282c:	aa02      	add	r2, sp, #8
    282e:	47e0      	blx	ip
    2830:	9003      	str	r0, [sp, #12]
    2832:	e4c5      	b.n	21c0 <mss_usbd_cep_setup_cb+0xb4>
                *buf_pp = (uint8_t*)&g_usbd_status;

             break;

             case USB_STD_REQ_RECIPIENT_INTERFACE:
                if(g_setup_pkt.index <= g_usbd_dev_conf.device_total_interfaces)
    2834:	f8b3 21cc 	ldrh.w	r2, [r3, #460]	; 0x1cc
    2838:	f893 e1b9 	ldrb.w	lr, [r3, #441]	; 0x1b9
    283c:	4572      	cmp	r2, lr
    283e:	f63f acc1 	bhi.w	21c4 <mss_usbd_cep_setup_cb+0xb8>
                {
                    g_usbd_status = 0x0000u;        /*Reserved by USB2.0*/
                    *buf_pp = (uint8_t*)&g_usbd_status;
    2842:	f503 72e9 	add.w	r2, r3, #466	; 0x1d2
             break;

             case USB_STD_REQ_RECIPIENT_INTERFACE:
                if(g_setup_pkt.index <= g_usbd_dev_conf.device_total_interfaces)
                {
                    g_usbd_status = 0x0000u;        /*Reserved by USB2.0*/
    2846:	f8a3 01d2 	strh.w	r0, [r3, #466]	; 0x1d2
                    *buf_pp = (uint8_t*)&g_usbd_status;
    284a:	9203      	str	r2, [sp, #12]
    284c:	e621      	b.n	2492 <mss_usbd_cep_setup_cb+0x386>
                if((uint8_t)(g_setup_pkt.index)) /*Not a control endpoint*/
                {
                    if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
                    {
                        /*Disable HALT*/
                        gd_tx_ep[(((uint8_t)(g_setup_pkt.index))& 0x7fu)].stall = 0x00u;
    284e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    2852:	222c      	movs	r2, #44	; 0x2c
    2854:	fb02 3300 	mla	r3, r2, r0, r3
MSS_USB_CIF_tx_ep_clr_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_SEND_STALL_MASK;
    2858:	f243 1200 	movw	r2, #12544	; 0x3100
    285c:	0100      	lsls	r0, r0, #4
    285e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2862:	7299      	strb	r1, [r3, #10]
    2864:	1882      	adds	r2, r0, r2
    2866:	f8b2 e002 	ldrh.w	lr, [r2, #2]
    286a:	f02e 0310 	bic.w	r3, lr, #16
    286e:	0418      	lsls	r0, r3, #16
    2870:	0c03      	lsrs	r3, r0, #16
    2872:	8053      	strh	r3, [r2, #2]
MSS_USB_CIF_tx_ep_clr_data_tog
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_CLR_DATA_TOG_MASK;
    2874:	f8b2 c002 	ldrh.w	ip, [r2, #2]
    2878:	fa1f f08c 	uxth.w	r0, ip
    287c:	f040 0340 	orr.w	r3, r0, #64	; 0x40
    2880:	8053      	strh	r3, [r2, #2]
    2882:	e49f      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
            {
                /*8.5.3.4 Control EP should not be implementing HALT feature*/
                if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
                {
                    /*Enable HALT*/
                    gd_tx_ep[(((uint8_t)(g_setup_pkt.index))& 0x7fu)].stall = 0x01;
    2884:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    2888:	222c      	movs	r2, #44	; 0x2c
    288a:	fb02 3300 	mla	r3, r2, r0, r3
MSS_USB_CIF_tx_ep_set_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRL_REG_EPN_SEND_STALL_MASK;
    288e:	f243 1200 	movw	r2, #12544	; 0x3100
    2892:	0100      	lsls	r0, r0, #4
    2894:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2898:	f1ac 0c04 	sub.w	ip, ip, #4
    289c:	1882      	adds	r2, r0, r2
    289e:	f883 c00a 	strb.w	ip, [r3, #10]
    28a2:	8853      	ldrh	r3, [r2, #2]
    28a4:	b298      	uxth	r0, r3
    28a6:	f040 0e10 	orr.w	lr, r0, #16
    28aa:	f8a2 e002 	strh.w	lr, [r2, #2]
    28ae:	e489      	b.n	21c4 <mss_usbd_cep_setup_cb+0xb8>
            break;
            case USB_STD_REQ_RECIPIENT_ENDPOINT:
                if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
                {
                    uint8_t idx = (((uint8_t)(g_setup_pkt.index))& 0x7fu);
                    g_usbd_status = ((gd_tx_ep[idx].stall) ? 0x0001:0x0000) ;
    28b0:	202c      	movs	r0, #44	; 0x2c
    28b2:	f002 0e7f 	and.w	lr, r2, #127	; 0x7f
    28b6:	fb00 320e 	mla	r2, r0, lr, r3
    28ba:	7a90      	ldrb	r0, [r2, #10]
                    *buf_pp = (uint8_t*)&g_usbd_status;
    28bc:	f503 72e9 	add.w	r2, r3, #466	; 0x1d2
            break;
            case USB_STD_REQ_RECIPIENT_ENDPOINT:
                if(((uint8_t)(g_setup_pkt.index) & 0x80u)) /* IN,TX endpoint*/
                {
                    uint8_t idx = (((uint8_t)(g_setup_pkt.index))& 0x7fu);
                    g_usbd_status = ((gd_tx_ep[idx].stall) ? 0x0001:0x0000) ;
    28c0:	f1b0 0c00 	subs.w	ip, r0, #0
    28c4:	bf18      	it	ne
    28c6:	f04f 0c01 	movne.w	ip, #1
    28ca:	f8a3 c1d2 	strh.w	ip, [r3, #466]	; 0x1d2
                    *buf_pp = (uint8_t*)&g_usbd_status;
    28ce:	9203      	str	r2, [sp, #12]
    28d0:	e5df      	b.n	2492 <mss_usbd_cep_setup_cb+0x386>
    28d2:	bf00      	nop

000028d4 <MSS_USBD_cep_configure>:
    uint8_t max_pkt_size
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->num = MSS_USB_CEP;
    28d4:	f240 73e0 	movw	r3, #2016	; 0x7e0
    28d8:	f2c2 0300 	movt	r3, #8192	; 0x2000

    /*FIFO address */
    cep_ptr->buf_addr = 0u;

    cep_ptr->max_pkt_size = max_pkt_size;
    cep_ptr->txn_length = SETUP_PKT_SIZE;
    28dc:	2108      	movs	r1, #8
    uint8_t max_pkt_size
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->num = MSS_USB_CEP;
    28de:	2200      	movs	r2, #0

    /*FIFO address */
    cep_ptr->buf_addr = 0u;

    cep_ptr->max_pkt_size = max_pkt_size;
    cep_ptr->txn_length = SETUP_PKT_SIZE;
    28e0:	6259      	str	r1, [r3, #36]	; 0x24
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->num = MSS_USB_CEP;
    cep_ptr->stall = 0u;
    cep_ptr->state = MSS_USB_CEP_IDLE;
    28e2:	2104      	movs	r1, #4
    28e4:	72d9      	strb	r1, [r3, #11]
    cep_ptr->xfr_type = MSS_USB_XFR_CONTROL;

    /*FIFO address */
    cep_ptr->buf_addr = 0u;
    28e6:	619a      	str	r2, [r3, #24]

    cep_ptr->max_pkt_size = max_pkt_size;
    28e8:	8118      	strh	r0, [r3, #8]
    uint8_t max_pkt_size
)
{
    mss_usb_ep_t* cep_ptr = &gd_tx_ep[MSS_USB_CEP];

    cep_ptr->num = MSS_USB_CEP;
    28ea:	701a      	strb	r2, [r3, #0]
    cep_ptr->stall = 0u;
    28ec:	729a      	strb	r2, [r3, #10]
    cep_ptr->state = MSS_USB_CEP_IDLE;
    cep_ptr->xfr_type = MSS_USB_XFR_CONTROL;
    28ee:	731a      	strb	r2, [r3, #12]
    cep_ptr->buf_addr = 0u;

    cep_ptr->max_pkt_size = max_pkt_size;
    cep_ptr->txn_length = SETUP_PKT_SIZE;

    MSS_USBD_CIF_cep_configure();
    28f0:	f000 b9ea 	b.w	2cc8 <MSS_USBD_CIF_cep_configure>

000028f4 <mss_usbd_reset_cb>:
static void
mss_usbd_reset_cb
(
    void
)
{
    28f4:	b510      	push	{r4, lr}
#ifndef MSS_USB_DEVICE_TEST_MODE
    g_usbd_dev_conf.device_addr = 0x00u;
    28f6:	f240 73e0 	movw	r3, #2016	; 0x7e0
    28fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_usbd_dev_conf.device_total_interfaces = 0x00u;
    g_usbd_dev_conf.device_total_ep = 0x00u;
    g_usbd_dev_conf.device_state = MSS_USB_DEFAULT_STATE;
    28fe:	2003      	movs	r0, #3
(
    void
)
{
#ifndef MSS_USB_DEVICE_TEST_MODE
    g_usbd_dev_conf.device_addr = 0x00u;
    2900:	2200      	movs	r2, #0
    g_usbd_dev_conf.device_total_interfaces = 0x00u;
    g_usbd_dev_conf.device_total_ep = 0x00u;
    g_usbd_dev_conf.device_state = MSS_USB_DEFAULT_STATE;
    2902:	f883 01bb 	strb.w	r0, [r3, #443]	; 0x1bb
 In Host mode, becomes valid after reset bit is cleared.
 Remains valid till session ends
*/
static __INLINE uint8_t MSS_USBD_CIF_is_hs_mode(void)
{
    return(((USB->POWER & POWER_REG_HS_MODE_MASK) ?
    2906:	f243 0100 	movw	r1, #12288	; 0x3000

    gd_tx_ep[MSS_USB_CEP].state = MSS_USB_CEP_IDLE;
    290a:	2004      	movs	r0, #4
    290c:	72d8      	strb	r0, [r3, #11]
(
    void
)
{
#ifndef MSS_USB_DEVICE_TEST_MODE
    g_usbd_dev_conf.device_addr = 0x00u;
    290e:	f883 21b8 	strb.w	r2, [r3, #440]	; 0x1b8
    g_usbd_dev_conf.device_total_interfaces = 0x00u;
    2912:	f883 21b9 	strb.w	r2, [r3, #441]	; 0x1b9
    g_usbd_dev_conf.device_total_ep = 0x00u;
    2916:	f883 21ba 	strb.w	r2, [r3, #442]	; 0x1ba
    g_usbd_dev_conf.device_state = MSS_USB_DEFAULT_STATE;

    gd_tx_ep[MSS_USB_CEP].state = MSS_USB_CEP_IDLE;
    g_usbd_dev_conf.remote_wakeup = 0x00u;
    291a:	f883 21c4 	strb.w	r2, [r3, #452]	; 0x1c4
    291e:	f2c4 0104 	movt	r1, #16388	; 0x4004
    2922:	7849      	ldrb	r1, [r1, #1]
    2924:	f011 0f10 	tst.w	r1, #16
    2928:	d015      	beq.n	2956 <mss_usbd_reset_cb+0x62>

    if(MSS_USBD_CIF_is_hs_mode())
    {
        g_usbd_dev_conf.device_speed = MSS_USB_DEVICE_HS;
    292a:	f883 21be 	strb.w	r2, [r3, #446]	; 0x1be
    else
    {
        g_usbd_dev_conf.device_speed = MSS_USB_DEVICE_FS;
    }

    SETUP_PKT_INIT();
    292e:	2200      	movs	r2, #0

    MSS_USBD_cep_configure(64u);
    2930:	2040      	movs	r0, #64	; 0x40
    else
    {
        g_usbd_dev_conf.device_speed = MSS_USB_DEVICE_FS;
    }

    SETUP_PKT_INIT();
    2932:	f8a3 21ce 	strh.w	r2, [r3, #462]	; 0x1ce
    2936:	f883 21c8 	strb.w	r2, [r3, #456]	; 0x1c8
    293a:	f883 21c9 	strb.w	r2, [r3, #457]	; 0x1c9
    293e:	f8a3 21ca 	strh.w	r2, [r3, #458]	; 0x1ca
    2942:	f8a3 21cc 	strh.w	r2, [r3, #460]	; 0x1cc

    MSS_USBD_cep_configure(64u);
    2946:	f7ff ffc5 	bl	28d4 <MSS_USBD_cep_configure>
    MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    294a:	4805      	ldr	r0, [pc, #20]	; (2960 <mss_usbd_reset_cb+0x6c>)
    294c:	2108      	movs	r1, #8
#else
    usbd_test_cb.test_reset();
#endif

}
    294e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }

    SETUP_PKT_INIT();

    MSS_USBD_cep_configure(64u);
    MSS_USBD_cep_read_prepare((uint8_t*)&g_setup_pkt, USB_SETUP_PKT_LEN);
    2952:	f7ff badf 	b.w	1f14 <MSS_USBD_cep_read_prepare>
    {
        g_usbd_dev_conf.device_speed = MSS_USB_DEVICE_HS;
    }
    else
    {
        g_usbd_dev_conf.device_speed = MSS_USB_DEVICE_FS;
    2956:	2101      	movs	r1, #1
    2958:	f883 11be 	strb.w	r1, [r3, #446]	; 0x1be
    295c:	e7e7      	b.n	292e <mss_usbd_reset_cb+0x3a>
    295e:	bf00      	nop
    2960:	200009a8 	.word	0x200009a8

00002964 <MSS_USBD_init>:
void
MSS_USBD_init
(
    mss_usb_device_speed_t speed
)
{
    2964:	b510      	push	{r4, lr}
    g_usbd_dev_conf.device_addr = 0x00u;
    2966:	f240 74e0 	movw	r4, #2016	; 0x7e0
    296a:	f2c2 0400 	movt	r4, #8192	; 0x2000
    296e:	2300      	movs	r3, #0

    /*store this for usage with DevQual, OtherSpeed requests*/
    g_usbd_user_speed = speed;
    g_usbd_dev_conf.device_speed = speed;

    gd_tx_ep[MSS_USB_CEP].state = MSS_USB_CEP_IDLE;
    2970:	2204      	movs	r2, #4
)
{
    g_usbd_dev_conf.device_addr = 0x00u;
    g_usbd_dev_conf.device_total_interfaces = 0x00u;
    g_usbd_dev_conf.device_total_ep = 0x00u;
    g_usbd_dev_conf.device_state = MSS_USB_NOT_ATTACHED_STATE;
    2972:	f884 31bb 	strb.w	r3, [r4, #443]	; 0x1bb

    /*store this for usage with DevQual, OtherSpeed requests*/
    g_usbd_user_speed = speed;
    g_usbd_dev_conf.device_speed = speed;
    2976:	f884 01be 	strb.w	r0, [r4, #446]	; 0x1be

    gd_tx_ep[MSS_USB_CEP].state = MSS_USB_CEP_IDLE;
    297a:	72e2      	strb	r2, [r4, #11]
MSS_USBD_init
(
    mss_usb_device_speed_t speed
)
{
    g_usbd_dev_conf.device_addr = 0x00u;
    297c:	f884 31b8 	strb.w	r3, [r4, #440]	; 0x1b8
    g_usbd_dev_conf.device_total_interfaces = 0x00u;
    2980:	f884 31b9 	strb.w	r3, [r4, #441]	; 0x1b9
    g_usbd_dev_conf.device_total_ep = 0x00u;
    2984:	f884 31ba 	strb.w	r3, [r4, #442]	; 0x1ba
    g_usbd_dev_conf.device_state = MSS_USB_NOT_ATTACHED_STATE;

    /*store this for usage with DevQual, OtherSpeed requests*/
    g_usbd_user_speed = speed;
    2988:	f884 01d0 	strb.w	r0, [r4, #464]	; 0x1d0
    g_usbd_dev_conf.device_speed = speed;

    gd_tx_ep[MSS_USB_CEP].state = MSS_USB_CEP_IDLE;

    MSS_USBD_CIF_init(g_usbd_dev_conf.device_speed);
    298c:	f000 f922 	bl	2bd4 <MSS_USBD_CIF_init>
 mode only.
 */

static __INLINE void MSS_USBD_CIF_dev_connect(void)
{
    USB->POWER |= POWER_REG_SOFT_CONN_MASK;
    2990:	f243 0000 	movw	r0, #12288	; 0x3000
    2994:	f2c4 0004 	movt	r0, #16388	; 0x4004
    2998:	7841      	ldrb	r1, [r0, #1]

    MSS_USBD_CIF_dev_connect();

    g_usbd_dev_conf.device_state = MSS_USB_POWERED_STATE;
    299a:	2302      	movs	r3, #2
    299c:	f041 0240 	orr.w	r2, r1, #64	; 0x40
    29a0:	7042      	strb	r2, [r0, #1]
    29a2:	f884 31bb 	strb.w	r3, [r4, #443]	; 0x1bb
}
    29a6:	bd10      	pop	{r4, pc}

000029a8 <MSS_USBD_CDC_get_state>:
mss_usbd_cdc_state_t
MSS_USBD_CDC_get_state
(
    void
)
{
    29a8:	f640 13b4 	movw	r3, #2484	; 0x9b4
    29ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    return g_usbd_cdc_state;
}
    29b0:	7818      	ldrb	r0, [r3, #0]
    29b2:	4770      	bx	lr

000029b4 <CDC_get_descriptor_cb>:
    /*
     Since Endpoint Size is wMaxpacketSize is 64, which is valid for both
     FS and HS, no need to make decision based on musb_speed.
     */

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    29b4:	b958      	cbnz	r0, 29ce <CDC_get_descriptor_cb+0x1a>
    {
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
    29b6:	2902      	cmp	r1, #2
    29b8:	d107      	bne.n	29ca <CDC_get_descriptor_cb+0x16>
            *length = sizeof(cdc_conf_descr);
            return(cdc_conf_descr);
        }
        else if (USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
        {
            cdc_conf_descr[CDC_CONF_DESCR_DESCTYPE_IDX] =
    29ba:	f240 108c 	movw	r0, #396	; 0x18c
    29be:	f2c2 0000 	movt	r0, #8192	; 0x2000
                                        USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;

            *length = sizeof(cdc_conf_descr);
    29c2:	234b      	movs	r3, #75	; 0x4b
            *length = sizeof(cdc_conf_descr);
            return(cdc_conf_descr);
        }
        else if (USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
        {
            cdc_conf_descr[CDC_CONF_DESCR_DESCTYPE_IDX] =
    29c4:	7041      	strb	r1, [r0, #1]
                                        USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;

            *length = sizeof(cdc_conf_descr);
    29c6:	6013      	str	r3, [r2, #0]
            return(cdc_conf_descr);
    29c8:	4770      	bx	lr
                                            USB_CONFIGURATION_DESCRIPTOR_TYPE;

            *length = sizeof(cdc_conf_descr);
            return(cdc_conf_descr);
        }
        else if (USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
    29ca:	2907      	cmp	r1, #7
    29cc:	d0f5      	beq.n	29ba <CDC_get_descriptor_cb+0x6>
        {
            cdc_conf_descr[CDC_CONF_DESCR_DESCTYPE_IDX] =
                                        USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;

            *length = sizeof(cdc_conf_descr);
            return(cdc_conf_descr);
    29ce:	2000      	movs	r0, #0
    {
        /*Do nothing*/
    }

    return USB_FAIL;
}
    29d0:	4770      	bx	lr
    29d2:	bf00      	nop

000029d4 <CDC_release_cb>:
MSS_USB_CIF_tx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    29d4:	f243 0300 	movw	r3, #12288	; 0x3000
    29d8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    29dc:	f8b3 c006 	ldrh.w	ip, [r3, #6]
static uint8_t
CDC_release_cb
(
    uint8_t cfgidx
)
{
    29e0:	b510      	push	{r4, lr}
    29e2:	f02c 0404 	bic.w	r4, ip, #4
    29e6:	0421      	lsls	r1, r4, #16
MSS_USB_CIF_tx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR = 0x0000;
    29e8:	2200      	movs	r2, #0
MSS_USB_CIF_tx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    29ea:	0c0c      	lsrs	r4, r1, #16
    29ec:	80dc      	strh	r4, [r3, #6]
MSS_USB_CIF_tx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR = 0x0000;
    29ee:	f8a3 2122 	strh.w	r2, [r3, #290]	; 0x122
MSS_USB_CIF_dma_clr_ctrlreg
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL  = 0x0000;
    29f2:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
MSS_USB_CIF_rx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    29f6:	f8b3 c008 	ldrh.w	ip, [r3, #8]

    MSS_USB_CIF_tx_ep_disable_irq(VCP_BULK_TX_EP);
    MSS_USB_CIF_tx_ep_clr_csrreg(VCP_BULK_TX_EP);
    MSS_USB_CIF_dma_clr_ctrlreg(MSS_USB_DMA_CHANNEL2);

    if(0 != usbd_cdc_vcp_ops->usb_cdc_release)
    29fa:	f640 34a8 	movw	r4, #2984	; 0xba8
    29fe:	f02c 0102 	bic.w	r1, ip, #2
    2a02:	0409      	lsls	r1, r1, #16
    2a04:	0c09      	lsrs	r1, r1, #16
    2a06:	8119      	strh	r1, [r3, #8]
MSS_USB_CIF_rx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR = 0x0000;
    2a08:	f8a3 2116 	strh.w	r2, [r3, #278]	; 0x116
MSS_USB_CIF_dma_clr_ctrlreg
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL  = 0x0000;
    2a0c:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224
MSS_USB_CIF_tx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    2a10:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    2a14:	f2c2 0400 	movt	r4, #8192	; 0x2000
    2a18:	6824      	ldr	r4, [r4, #0]
    2a1a:	f02c 0102 	bic.w	r1, ip, #2
    2a1e:	0409      	lsls	r1, r1, #16
    2a20:	6864      	ldr	r4, [r4, #4]
    2a22:	0c09      	lsrs	r1, r1, #16
    2a24:	80d9      	strh	r1, [r3, #6]
MSS_USB_CIF_tx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR = 0x0000;
    2a26:	f8a3 2112 	strh.w	r2, [r3, #274]	; 0x112
MSS_USB_CIF_dma_clr_ctrlreg
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL  = 0x0000;
    2a2a:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    2a2e:	b104      	cbz	r4, 2a32 <CDC_release_cb+0x5e>
    {
        usbd_cdc_vcp_ops->usb_cdc_release(cfgidx);
    2a30:	47a0      	blx	r4
    }

    g_usbd_cdc_state = USBD_CDC_NOT_CONFIGURED;
    2a32:	f640 12b4 	movw	r2, #2484	; 0x9b4
    2a36:	2000      	movs	r0, #0
    2a38:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2a3c:	7010      	strb	r0, [r2, #0]

    return USB_SUCCESS;
}
    2a3e:	2001      	movs	r0, #1
    2a40:	bd10      	pop	{r4, pc}
    2a42:	bf00      	nop

00002a44 <CDC_process_request_cb>:
(
    mss_usbd_setup_pkt_t* setup_pkt,
    uint8_t** buf_pp,
    uint32_t* length
)
{
    2a44:	b508      	push	{r3, lr}
    if(0 != usbd_cdc_vcp_ops->usb_cdc_process_request)
    2a46:	f640 33a8 	movw	r3, #2984	; 0xba8
    2a4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2a4e:	681b      	ldr	r3, [r3, #0]
    2a50:	689b      	ldr	r3, [r3, #8]
    2a52:	b12b      	cbz	r3, 2a60 <CDC_process_request_cb+0x1c>
    {
        if(USB_SUCCESS == usbd_cdc_vcp_ops->usb_cdc_process_request(setup_pkt,
    2a54:	4798      	blx	r3
    2a56:	2801      	cmp	r0, #1
    2a58:	bf14      	ite	ne
    2a5a:	2000      	movne	r0, #0
    2a5c:	2001      	moveq	r0, #1
            return USB_FAIL;
        }
    }
    else
        return USB_FAIL;
}
    2a5e:	bd08      	pop	{r3, pc}
    mss_usbd_setup_pkt_t* setup_pkt,
    uint8_t** buf_pp,
    uint32_t* length
)
{
    if(0 != usbd_cdc_vcp_ops->usb_cdc_process_request)
    2a60:	4618      	mov	r0, r3
    2a62:	bd08      	pop	{r3, pc}

00002a64 <CDC_rx_cb>:
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    if(VCP_BULK_RX_EP == num)
    2a64:	2801      	cmp	r0, #1
(
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    2a66:	b510      	push	{r4, lr}
    2a68:	4604      	mov	r4, r0
    if(VCP_BULK_RX_EP == num)
    2a6a:	d001      	beq.n	2a70 <CDC_rx_cb+0xc>
    2a6c:	2000      	movs	r0, #0
    2a6e:	bd10      	pop	{r4, pc}
    {
        if(0 != usbd_cdc_vcp_ops->usb_cdc_rx)
    2a70:	f640 30a8 	movw	r0, #2984	; 0xba8
    2a74:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2a78:	6803      	ldr	r3, [r0, #0]
    2a7a:	691b      	ldr	r3, [r3, #16]
    2a7c:	b123      	cbz	r3, 2a88 <CDC_rx_cb+0x24>
        {
            usbd_cdc_vcp_ops->usb_cdc_rx(status, rx_count);
    2a7e:	4608      	mov	r0, r1
    2a80:	4611      	mov	r1, r2
    2a82:	4798      	blx	r3
    2a84:	4620      	mov	r0, r4
    {
        return USB_FAIL;
    }

    return USB_SUCCESS;
}
    2a86:	bd10      	pop	{r4, pc}
    uint32_t rx_count
)
{
    if(VCP_BULK_RX_EP == num)
    {
        if(0 != usbd_cdc_vcp_ops->usb_cdc_rx)
    2a88:	4620      	mov	r0, r4
    2a8a:	bd10      	pop	{r4, pc}

00002a8c <CDC_cep_tx_done_cb>:
CDC_cep_tx_done_cb
(
    uint8_t status
)
{
    if(0 != usbd_cdc_vcp_ops->usb_cdc_cep_tx_complete)
    2a8c:	f640 31a8 	movw	r1, #2984	; 0xba8
    2a90:	f2c2 0100 	movt	r1, #8192	; 0x2000
static uint8_t
CDC_cep_tx_done_cb
(
    uint8_t status
)
{
    2a94:	b508      	push	{r3, lr}
    if(0 != usbd_cdc_vcp_ops->usb_cdc_cep_tx_complete)
    2a96:	680b      	ldr	r3, [r1, #0]
    2a98:	699b      	ldr	r3, [r3, #24]
    2a9a:	b103      	cbz	r3, 2a9e <CDC_cep_tx_done_cb+0x12>
    {
        usbd_cdc_vcp_ops->usb_cdc_cep_tx_complete(status);
    2a9c:	4798      	blx	r3
    }

    return USB_SUCCESS;
}
    2a9e:	2001      	movs	r0, #1
    2aa0:	bd08      	pop	{r3, pc}
    2aa2:	bf00      	nop

00002aa4 <CDC_cep_rx_done_cb>:
CDC_cep_rx_done_cb
(
    uint8_t status
)
{
    if(0 != usbd_cdc_vcp_ops->usb_cdc_cep_rx)
    2aa4:	f640 31a8 	movw	r1, #2984	; 0xba8
    2aa8:	f2c2 0100 	movt	r1, #8192	; 0x2000
static uint8_t
CDC_cep_rx_done_cb
(
    uint8_t status
)
{
    2aac:	b508      	push	{r3, lr}
    if(0 != usbd_cdc_vcp_ops->usb_cdc_cep_rx)
    2aae:	680b      	ldr	r3, [r1, #0]
    2ab0:	69db      	ldr	r3, [r3, #28]
    2ab2:	b103      	cbz	r3, 2ab6 <CDC_cep_rx_done_cb+0x12>
    {
        usbd_cdc_vcp_ops->usb_cdc_cep_rx(status);
    2ab4:	4798      	blx	r3
    }

    return USB_SUCCESS;
}
    2ab6:	2001      	movs	r0, #1
    2ab8:	bd08      	pop	{r3, pc}
    2aba:	bf00      	nop

00002abc <CDC_tx_complete_cb>:
CDC_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    2abc:	b510      	push	{r4, lr}
    uint8_t *buf_p;
    uint32_t len;
    if(VCP_INTR_TX_EP == num)
    2abe:	2802      	cmp	r0, #2
CDC_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    2ac0:	b082      	sub	sp, #8
    2ac2:	4604      	mov	r4, r0
    uint8_t *buf_p;
    uint32_t len;
    if(VCP_INTR_TX_EP == num)
    2ac4:	d00f      	beq.n	2ae6 <CDC_tx_complete_cb+0x2a>
        if(buf_p)
        {
            MSS_USBD_tx_ep_write(VCP_INTR_TX_EP, buf_p, len);
        }
    }
    else if(VCP_BULK_TX_EP == num)
    2ac6:	2801      	cmp	r0, #1
    2ac8:	d002      	beq.n	2ad0 <CDC_tx_complete_cb+0x14>
    2aca:	2000      	movs	r0, #0
    {
        return USB_FAIL;
    }

    return USB_SUCCESS;
}
    2acc:	b002      	add	sp, #8
    2ace:	bd10      	pop	{r4, pc}
            MSS_USBD_tx_ep_write(VCP_INTR_TX_EP, buf_p, len);
        }
    }
    else if(VCP_BULK_TX_EP == num)
    {
        if(0 != usbd_cdc_vcp_ops->usb_cdc_tx_complete)
    2ad0:	f640 33a8 	movw	r3, #2984	; 0xba8
    2ad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2ad8:	681a      	ldr	r2, [r3, #0]
    2ada:	68d3      	ldr	r3, [r2, #12]
    2adc:	b1ab      	cbz	r3, 2b0a <CDC_tx_complete_cb+0x4e>
        {
            usbd_cdc_vcp_ops->usb_cdc_tx_complete(status);
    2ade:	4608      	mov	r0, r1
    2ae0:	4798      	blx	r3
    2ae2:	4620      	mov	r0, r4
    2ae4:	e7f2      	b.n	2acc <CDC_tx_complete_cb+0x10>
{
    uint8_t *buf_p;
    uint32_t len;
    if(VCP_INTR_TX_EP == num)
    {
        if(0 != usbd_cdc_vcp_ops->usb_cdc_notification)
    2ae6:	f640 30a8 	movw	r0, #2984	; 0xba8
    2aea:	f2c2 0000 	movt	r0, #8192	; 0x2000
    2aee:	6803      	ldr	r3, [r0, #0]
    2af0:	695b      	ldr	r3, [r3, #20]
    2af2:	b113      	cbz	r3, 2afa <CDC_tx_complete_cb+0x3e>
        {
            usbd_cdc_vcp_ops->usb_cdc_notification(&buf_p, &len);
    2af4:	a801      	add	r0, sp, #4
    2af6:	4669      	mov	r1, sp
    2af8:	4798      	blx	r3
        }

        if(buf_p)
    2afa:	9901      	ldr	r1, [sp, #4]
    2afc:	b129      	cbz	r1, 2b0a <CDC_tx_complete_cb+0x4e>
        {
            MSS_USBD_tx_ep_write(VCP_INTR_TX_EP, buf_p, len);
    2afe:	2002      	movs	r0, #2
    2b00:	9a00      	ldr	r2, [sp, #0]
    2b02:	f7fe ff17 	bl	1934 <MSS_USBD_tx_ep_write>
    2b06:	2001      	movs	r0, #1
    2b08:	e7e0      	b.n	2acc <CDC_tx_complete_cb+0x10>
    }
    else if(VCP_BULK_TX_EP == num)
    {
        if(0 != usbd_cdc_vcp_ops->usb_cdc_tx_complete)
        {
            usbd_cdc_vcp_ops->usb_cdc_tx_complete(status);
    2b0a:	2001      	movs	r0, #1
    2b0c:	e7de      	b.n	2acc <CDC_tx_complete_cb+0x10>
    2b0e:	bf00      	nop

00002b10 <MSS_USBD_CDC_tx>:
MSS_USBD_CDC_tx
(
    uint8_t* buf,
    uint32_t length
)
{
    2b10:	460a      	mov	r2, r1
    MSS_USBD_tx_ep_write(VCP_BULK_TX_EP, buf, length);
    2b12:	4601      	mov	r1, r0
    2b14:	2001      	movs	r0, #1
    2b16:	f7fe bf0d 	b.w	1934 <MSS_USBD_tx_ep_write>
    2b1a:	bf00      	nop

00002b1c <CDC_init_cb>:
CDC_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    2b1c:	b570      	push	{r4, r5, r6, lr}
     Since Endpoint Size is wMaxpacketSize is 64, which is valid for both
     FS and HS, no need to make decision based on musb_speed.

     g_usbd_cdc_user_speed variable stores the speed selected by user.
     */
    MSS_USBD_tx_ep_configure(VCP_INTR_TX_EP,
    2b1e:	2240      	movs	r2, #64	; 0x40
CDC_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    2b20:	b088      	sub	sp, #32
     Since Endpoint Size is wMaxpacketSize is 64, which is valid for both
     FS and HS, no need to make decision based on musb_speed.

     g_usbd_cdc_user_speed variable stores the speed selected by user.
     */
    MSS_USBD_tx_ep_configure(VCP_INTR_TX_EP,
    2b22:	2401      	movs	r4, #1
    2b24:	4613      	mov	r3, r2
    2b26:	2002      	movs	r0, #2
    2b28:	2150      	movs	r1, #80	; 0x50
    2b2a:	2600      	movs	r6, #0
    2b2c:	2503      	movs	r5, #3
    2b2e:	9602      	str	r6, [sp, #8]
    2b30:	9503      	str	r5, [sp, #12]
    2b32:	9400      	str	r4, [sp, #0]
    2b34:	9401      	str	r4, [sp, #4]
    2b36:	9404      	str	r4, [sp, #16]
    2b38:	f7ff f972 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL1,
                             MSS_USB_XFR_INTERRUPT,
                             ADD_ZLP_TO_XFR);

    MSS_USBD_tx_ep_configure(VCP_BULK_TX_EP,
    2b3c:	2240      	movs	r2, #64	; 0x40
    2b3e:	2602      	movs	r6, #2
    2b40:	4613      	mov	r3, r2
    2b42:	4620      	mov	r0, r4
    2b44:	f44f 7180 	mov.w	r1, #256	; 0x100
    2b48:	9400      	str	r4, [sp, #0]
    2b4a:	9401      	str	r4, [sp, #4]
    2b4c:	9402      	str	r4, [sp, #8]
    2b4e:	9603      	str	r6, [sp, #12]
    2b50:	9404      	str	r4, [sp, #16]
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    g_usbd_cdc_state = USBD_CDC_CONFIGURED;

    if(0 != usbd_cdc_vcp_ops->usb_cdc_init)
    2b52:	f640 35a8 	movw	r5, #2984	; 0xba8
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL1,
                             MSS_USB_XFR_INTERRUPT,
                             ADD_ZLP_TO_XFR);

    MSS_USBD_tx_ep_configure(VCP_BULK_TX_EP,
    2b56:	f7ff f963 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL2,
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    MSS_USBD_rx_ep_configure(VCP_BULK_RX_EP,
    2b5a:	2240      	movs	r2, #64	; 0x40
    2b5c:	4613      	mov	r3, r2
    2b5e:	f44f 6180 	mov.w	r1, #1024	; 0x400
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    g_usbd_cdc_state = USBD_CDC_CONFIGURED;

    if(0 != usbd_cdc_vcp_ops->usb_cdc_init)
    2b62:	f2c2 0500 	movt	r5, #8192	; 0x2000
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL2,
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    MSS_USBD_rx_ep_configure(VCP_BULK_RX_EP,
    2b66:	4620      	mov	r0, r4
    2b68:	9603      	str	r6, [sp, #12]
    2b6a:	9400      	str	r4, [sp, #0]
    2b6c:	9401      	str	r4, [sp, #4]
    2b6e:	9602      	str	r6, [sp, #8]
    2b70:	9404      	str	r4, [sp, #16]
    2b72:	f7ff f8dd 	bl	1d30 <MSS_USBD_rx_ep_configure>
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    g_usbd_cdc_state = USBD_CDC_CONFIGURED;

    if(0 != usbd_cdc_vcp_ops->usb_cdc_init)
    2b76:	682a      	ldr	r2, [r5, #0]
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL3,
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    g_usbd_cdc_state = USBD_CDC_CONFIGURED;
    2b78:	f640 13b4 	movw	r3, #2484	; 0x9b4

    if(0 != usbd_cdc_vcp_ops->usb_cdc_init)
    2b7c:	6811      	ldr	r1, [r2, #0]
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL3,
                             MSS_USB_XFR_BULK,
                             ADD_ZLP_TO_XFR);

    g_usbd_cdc_state = USBD_CDC_CONFIGURED;
    2b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2b82:	701c      	strb	r4, [r3, #0]

    if(0 != usbd_cdc_vcp_ops->usb_cdc_init)
    2b84:	b109      	cbz	r1, 2b8a <CDC_init_cb+0x6e>
    {
        usbd_cdc_vcp_ops->usb_cdc_init();
    2b86:	4788      	blx	r1
    2b88:	682a      	ldr	r2, [r5, #0]
    }

    if(0 != usbd_cdc_vcp_ops->usb_cdc_notification)
    2b8a:	6953      	ldr	r3, [r2, #20]
    2b8c:	b113      	cbz	r3, 2b94 <CDC_init_cb+0x78>
    {
        usbd_cdc_vcp_ops->usb_cdc_notification(&buf_p, &len);
    2b8e:	a807      	add	r0, sp, #28
    2b90:	a906      	add	r1, sp, #24
    2b92:	4798      	blx	r3
    }

    if(buf_p)
    2b94:	9907      	ldr	r1, [sp, #28]
    2b96:	b119      	cbz	r1, 2ba0 <CDC_init_cb+0x84>
    {
        MSS_USBD_tx_ep_write(VCP_INTR_TX_EP, buf_p, len);
    2b98:	2002      	movs	r0, #2
    2b9a:	9a06      	ldr	r2, [sp, #24]
    2b9c:	f7fe feca 	bl	1934 <MSS_USBD_tx_ep_write>
    }

    return USB_SUCCESS;
}
    2ba0:	2001      	movs	r0, #1
    2ba2:	b008      	add	sp, #32
    2ba4:	bd70      	pop	{r4, r5, r6, pc}
    2ba6:	bf00      	nop

00002ba8 <MSS_USBD_CDC_rx_prepare>:
MSS_USBD_CDC_rx_prepare
(
    uint8_t* buf,
    uint32_t length
)
{
    2ba8:	460a      	mov	r2, r1
    MSS_USBD_rx_ep_read_prepare(VCP_BULK_RX_EP, buf, length);
    2baa:	4601      	mov	r1, r0
    2bac:	2001      	movs	r0, #1
    2bae:	f7ff b89b 	b.w	1ce8 <MSS_USBD_rx_ep_read_prepare>
    2bb2:	bf00      	nop

00002bb4 <MSS_USBD_CDC_init>:
(
    mss_usbd_cdc_app_cb_t* vcp_app_cb,
    mss_usb_device_speed_t speed
)
{
    usbd_cdc_vcp_ops = vcp_app_cb;
    2bb4:	f640 32a8 	movw	r2, #2984	; 0xba8
    2bb8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2bbc:	6010      	str	r0, [r2, #0]
    g_usbd_cdc_user_speed = speed;
    2bbe:	f640 33a4 	movw	r3, #2980	; 0xba4
    MSS_USBD_set_class_cb_handler(&usbd_cdc_class_cb);
    2bc2:	4803      	ldr	r0, [pc, #12]	; (2bd0 <MSS_USBD_CDC_init+0x1c>)
    mss_usbd_cdc_app_cb_t* vcp_app_cb,
    mss_usb_device_speed_t speed
)
{
    usbd_cdc_vcp_ops = vcp_app_cb;
    g_usbd_cdc_user_speed = speed;
    2bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2bc8:	7019      	strb	r1, [r3, #0]
    MSS_USBD_set_class_cb_handler(&usbd_cdc_class_cb);
    2bca:	f7fe bc73 	b.w	14b4 <MSS_USBD_set_class_cb_handler>
    2bce:	bf00      	nop
    2bd0:	200001d8 	.word	0x200001d8

00002bd4 <MSS_USBD_CIF_init>:
void
MSS_USBD_CIF_init
(
    mss_usb_device_speed_t speed
)
{
    2bd4:	b410      	push	{r4}
    void
)
{
    volatile uint8_t soft_reset;

    USB->SOFT_RST = SOFT_RESET_REG_MASK;
    2bd6:	f243 0300 	movw	r3, #12288	; 0x3000
    cep_state = MSS_USB_CTRL_EP_IDLE;
    2bda:	f640 34ac 	movw	r4, #2988	; 0xbac
    2bde:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2be2:	f2c2 0400 	movt	r4, #8192	; 0x2000
    2be6:	2100      	movs	r1, #0
    2be8:	2203      	movs	r2, #3
    2bea:	7021      	strb	r1, [r4, #0]
void
MSS_USBD_CIF_init
(
    mss_usb_device_speed_t speed
)
{
    2bec:	b083      	sub	sp, #12
    2bee:	f883 207f 	strb.w	r2, [r3, #127]	; 0x7f
    do {
        soft_reset = USB->SOFT_RST;
    2bf2:	f893 c07f 	ldrb.w	ip, [r3, #127]	; 0x7f
    2bf6:	f243 0200 	movw	r2, #12288	; 0x3000
    2bfa:	f88d c007 	strb.w	ip, [sp, #7]
    } while(soft_reset != 0x00u);
    2bfe:	f89d 1007 	ldrb.w	r1, [sp, #7]
{
    volatile uint8_t soft_reset;

    USB->SOFT_RST = SOFT_RESET_REG_MASK;
    do {
        soft_reset = USB->SOFT_RST;
    2c02:	f2c4 0204 	movt	r2, #16388	; 0x4004
    } while(soft_reset != 0x00u);
    2c06:	468c      	mov	ip, r1
    2c08:	2900      	cmp	r1, #0
    2c0a:	d1f2      	bne.n	2bf2 <MSS_USBD_CIF_init+0x1e>
    2c0c:	f24e 1300 	movw	r3, #57600	; 0xe100
    2c10:	f2ce 0300 	movt	r3, #57344	; 0xe000
MSS_USB_CIF_clr_usb_irq_reg
(
    void
)
{
    USB->USB_IRQ = 0u;
    2c14:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    2c18:	f44f 1480 	mov.w	r4, #1048576	; 0x100000
    2c1c:	f882 c00a 	strb.w	ip, [r2, #10]
    2c20:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    2c24:	601c      	str	r4, [r3, #0]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    2c26:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    2c2a:	6019      	str	r1, [r3, #0]
MSS_USB_CIF_rx_ep_disable_irq_all
(
    void
)
{
    USB->RX_IRQ_ENABLE = 0u ;
    2c2c:	f8a2 c008 	strh.w	ip, [r2, #8]
(
    void
)
{
    /*Keep D0, CEP interrupt bit unaltered.*/
    USB->TX_IRQ_ENABLE = (USB->TX_IRQ_ENABLE & TX_IRQ_ENABLE_REG_CEP_MASK);
    2c30:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    NVIC_EnableIRQ(USB_DMA_IRQn);

    MSS_USB_CIF_rx_ep_disable_irq_all();
    MSS_USB_CIF_tx_ep_disable_irq_all();

    if(MSS_USB_DEVICE_FS == speed)
    2c34:	2801      	cmp	r0, #1
    2c36:	f00c 0101 	and.w	r1, ip, #1
    2c3a:	80d1      	strh	r1, [r2, #6]
MSS_USB_CIF_disable_hs_mode
(
    void
)
{
    USB->POWER &= ~POWER_REG_ENABLE_HS_MASK;
    2c3c:	bf08      	it	eq
    2c3e:	7851      	ldrbeq	r1, [r2, #1]
    {
        MSS_USB_CIF_disable_hs_mode();
    }

    /*This was added during Compliance testing. Refer MUSB section 3.8.5*/
    USB->C_T_HSBT = 0x01u;
    2c40:	f243 0300 	movw	r3, #12288	; 0x3000
    2c44:	bf08      	it	eq
    2c46:	f001 01df 	andeq.w	r1, r1, #223	; 0xdf
    2c4a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2c4e:	f04f 0001 	mov.w	r0, #1
    2c52:	bf08      	it	eq
    2c54:	7051      	strbeq	r1, [r2, #1]
    2c56:	f8a3 0348 	strh.w	r0, [r3, #840]	; 0x348
}
    2c5a:	b003      	add	sp, #12
    2c5c:	bc10      	pop	{r4}
    2c5e:	4770      	bx	lr

00002c60 <MSS_USBD_CIF_get_hwcore_info>:
MSS_USB_CIF_set_index_reg
(
    uint8_t index
)
{
    USB->INDEX = index;
    2c60:	f243 0100 	movw	r1, #12288	; 0x3000
    2c64:	f2c4 0104 	movt	r1, #16388	; 0x4004
    2c68:	2200      	movs	r2, #0
    2c6a:	738a      	strb	r2, [r1, #14]
(
    mss_usb_core_info_t* hw_core
)
{
    MSS_USB_CIF_set_index_reg(MSS_USB_CEP);
    hw_core->core_max_nbr_of_tx_ep = (USB->EP_INFO & 0x0Fu); /*lower nibble for txep*/
    2c6c:	f891 3078 	ldrb.w	r3, [r1, #120]	; 0x78
    2c70:	f003 0c0f 	and.w	ip, r3, #15
    2c74:	f880 c000 	strb.w	ip, [r0]
    hw_core->core_max_nbr_of_rx_ep = ((USB->EP_INFO & 0xF0u) >> 4u);/*higher nibble for txep*/
    2c78:	f891 2078 	ldrb.w	r2, [r1, #120]	; 0x78
    2c7c:	0913      	lsrs	r3, r2, #4
    2c7e:	7043      	strb	r3, [r0, #1]
    hw_core->core_ram_bus_width = (USB->RAM_INFO & 0x0Fu);/*lower nibble for bus width*/
    2c80:	f891 2079 	ldrb.w	r2, [r1, #121]	; 0x79
    2c84:	f002 0c0f 	and.w	ip, r2, #15
    2c88:	f880 c003 	strb.w	ip, [r0, #3]
    hw_core->core_max_nbr_of_dma_chan = ((USB->RAM_INFO & 0xF0u) >> 4u);/*higher nibble for dma channels*/
    2c8c:	f891 3079 	ldrb.w	r3, [r1, #121]	; 0x79
    2c90:	091a      	lsrs	r2, r3, #4
    2c92:	7082      	strb	r2, [r0, #2]
    hw_core->core_WTCON = ((USB->LINK_INFO & 0xF0u) >> 4u);/*refer musb section 3 . 7 . 3*/
    2c94:	f891 307a 	ldrb.w	r3, [r1, #122]	; 0x7a
    2c98:	091a      	lsrs	r2, r3, #4
    2c9a:	7102      	strb	r2, [r0, #4]
    hw_core->core_WTID = (USB->LINK_INFO & 0x0Fu);/*refer musb section 3 . 7 . 3*/
    2c9c:	f891 307a 	ldrb.w	r3, [r1, #122]	; 0x7a
    2ca0:	f003 0c0f 	and.w	ip, r3, #15
    2ca4:	f880 c005 	strb.w	ip, [r0, #5]
    hw_core->core_VPLEN = USB->VP_LEN;
    2ca8:	f891 207b 	ldrb.w	r2, [r1, #123]	; 0x7b
    2cac:	7182      	strb	r2, [r0, #6]
    hw_core->core_HS_EOF1 = USB->HS_EOF1;
    2cae:	f891 307c 	ldrb.w	r3, [r1, #124]	; 0x7c
    2cb2:	71c3      	strb	r3, [r0, #7]
    hw_core->core_FS_EOF1 = USB->FS_EOF1;
    2cb4:	f891 c07d 	ldrb.w	ip, [r1, #125]	; 0x7d
    2cb8:	f880 c008 	strb.w	ip, [r0, #8]
    hw_core->core_LS_EOF1 = USB->LS_EOF1;
    2cbc:	f891 207e 	ldrb.w	r2, [r1, #126]	; 0x7e
    2cc0:	7242      	strb	r2, [r0, #9]
    hw_core->core_configdata = USB->INDEXED_CSR.DEVICE_EP0.CONFIG_DATA;
    2cc2:	7fcb      	ldrb	r3, [r1, #31]
    2cc4:	7283      	strb	r3, [r0, #10]
}
    2cc6:	4770      	bx	lr

00002cc8 <MSS_USBD_CIF_cep_configure>:
    2cc8:	f243 0300 	movw	r3, #12288	; 0x3000
    2ccc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2cd0:	2200      	movs	r2, #0
    2cd2:	739a      	strb	r2, [r3, #14]
(
    void
)
{
    /*load the reset value for the register*/
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = 0u;
    2cd4:	825a      	strh	r2, [r3, #18]
MSS_USB_CIF_cep_enable_irq
(
    void
)
{
    USB->TX_IRQ_ENABLE |= (uint16_t)(TX_IRQ_ENABLE_REG_CEP_MASK);
    2cd6:	88d9      	ldrh	r1, [r3, #6]
    2cd8:	b288      	uxth	r0, r1
    2cda:	f040 0201 	orr.w	r2, r0, #1
    2cde:	80da      	strh	r2, [r3, #6]
{
    /*Control transfers will be handled without DMA*/
    MSS_USB_CIF_set_index_reg(MSS_USB_CEP);
    MSS_USB_CIF_cep_reset_csr0_reg();
    MSS_USB_CIF_cep_enable_irq();
}
    2ce0:	4770      	bx	lr
    2ce2:	bf00      	nop

00002ce4 <MSS_USBD_CIF_cep_rx_prepare>:
MSS_USBD_CIF_cep_rx_prepare
(
    mss_usb_ep_t* device_ep
)
{
    if(MSS_USB_CEP_IDLE == device_ep[MSS_USB_CEP].state)
    2ce4:	7ac3      	ldrb	r3, [r0, #11]
    2ce6:	2b04      	cmp	r3, #4
    2ce8:	d010      	beq.n	2d0c <MSS_USBD_CIF_cep_rx_prepare+0x28>
    {
        cep_state = MSS_USB_CTRL_EP_IDLE;
    }
    else if((MSS_USB_CEP_SETUP == device_ep[MSS_USB_CEP].state) ||
    2cea:	2b05      	cmp	r3, #5
    2cec:	bf14      	ite	ne
    2cee:	2100      	movne	r1, #0
    2cf0:	2101      	moveq	r1, #1
    2cf2:	2b07      	cmp	r3, #7
    2cf4:	bf14      	ite	ne
    2cf6:	4608      	movne	r0, r1
    2cf8:	f041 0001 	orreq.w	r0, r1, #1
    2cfc:	b128      	cbz	r0, 2d0a <MSS_USBD_CIF_cep_rx_prepare+0x26>
           (MSS_USB_CEP_RX == device_ep[MSS_USB_CEP].state))
    {
        cep_state = MSS_USB_CTRL_EP_RX;
    2cfe:	f640 33ac 	movw	r3, #2988	; 0xbac
    2d02:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d06:	2202      	movs	r2, #2
    2d08:	701a      	strb	r2, [r3, #0]
    2d0a:	4770      	bx	lr
    mss_usb_ep_t* device_ep
)
{
    if(MSS_USB_CEP_IDLE == device_ep[MSS_USB_CEP].state)
    {
        cep_state = MSS_USB_CTRL_EP_IDLE;
    2d0c:	f640 33ac 	movw	r3, #2988	; 0xbac
    2d10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    2d14:	2200      	movs	r2, #0
    2d16:	701a      	strb	r2, [r3, #0]
    2d18:	4770      	bx	lr
    2d1a:	bf00      	nop

00002d1c <MSS_USBD_CIF_rx_ep_read_prepare>:
void
MSS_USBD_CIF_rx_ep_read_prepare
(
    mss_usb_ep_t* device_ep
)
{
    2d1c:	b430      	push	{r4, r5}
    /*Fixed Buffer overwriting issue found with printer driver and
      issue with interrupt transfer with DMA by moving the location
      of interrupt enable function*/
    if(DMA_ENABLE == device_ep->dma_enable)
    2d1e:	7983      	ldrb	r3, [r0, #6]
    2d20:	2b01      	cmp	r3, #1
    2d22:	d00d      	beq.n	2d40 <MSS_USBD_CIF_rx_ep_read_prepare+0x24>
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    2d24:	7803      	ldrb	r3, [r0, #0]
    2d26:	2101      	movs	r1, #1
    2d28:	fa11 f203 	lsls.w	r2, r1, r3
    2d2c:	f243 0300 	movw	r3, #12288	; 0x3000
    2d30:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2d34:	8918      	ldrh	r0, [r3, #8]
    2d36:	4302      	orrs	r2, r0
    2d38:	b291      	uxth	r1, r2
    2d3a:	8119      	strh	r1, [r3, #8]
    }
    else
    {
        MSS_USB_CIF_rx_ep_enable_irq(device_ep->num);
    }
}
    2d3c:	bc30      	pop	{r4, r5}
    2d3e:	4770      	bx	lr
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t addr
)
{
    USB->DMA_CHANNEL[dma_channel].ADDR = addr;
    2d40:	f890 c007 	ldrb.w	ip, [r0, #7]
        /*
         DMA Count register will be loaded after receive interrupt occurs.
         Mode need to be set every time since M1 to M0 transition might have
         happened for "short packet".
         */
         if(MSS_USB_XFR_BULK == device_ep->xfr_type)
    2d44:	7b04      	ldrb	r4, [r0, #12]
    2d46:	ea4f 110c 	mov.w	r1, ip, lsl #4
    2d4a:	f101 4280 	add.w	r2, r1, #1073741824	; 0x40000000
    if(DMA_ENABLE == device_ep->dma_enable)
    {
        /*Make sure that address is Modulo-4.Bits D0-D1 are read only.*/
        ASSERT(!(((uint32_t)device_ep->buf_addr) & 0x00000002));

        MSS_USB_CIF_dma_write_addr(device_ep->dma_channel,
    2d4e:	6985      	ldr	r5, [r0, #24]
    2d50:	f502 2286 	add.w	r2, r2, #274432	; 0x43000
    2d54:	f243 0100 	movw	r1, #12288	; 0x3000
        /*
         DMA Count register will be loaded after receive interrupt occurs.
         Mode need to be set every time since M1 to M0 transition might have
         happened for "short packet".
         */
         if(MSS_USB_XFR_BULK == device_ep->xfr_type)
    2d58:	2c02      	cmp	r4, #2
    2d5a:	f8c2 5208 	str.w	r5, [r2, #520]	; 0x208
    2d5e:	f2c4 0104 	movt	r1, #16388	; 0x4004
    2d62:	d01e      	beq.n	2da2 <MSS_USBD_CIF_rx_ep_read_prepare+0x86>
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    2d64:	7800      	ldrb	r0, [r0, #0]
    2d66:	f243 1200 	movw	r2, #12544	; 0x3100
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    2d6a:	4083      	lsls	r3, r0
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    2d6c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2d70:	0100      	lsls	r0, r0, #4
    2d72:	1882      	adds	r2, r0, r2
    2d74:	88d0      	ldrh	r0, [r2, #6]
    2d76:	0440      	lsls	r0, r0, #17
    2d78:	0c40      	lsrs	r0, r0, #17
    2d7a:	80d0      	strh	r0, [r2, #6]
MSS_USB_CIF_rx_ep_set_dma_mode0
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_DMA_MODE_MASK;
    2d7c:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    2d80:	f42c 6000 	bic.w	r0, ip, #2048	; 0x800
    2d84:	0400      	lsls	r0, r0, #16
    2d86:	0c00      	lsrs	r0, r0, #16
    2d88:	80d0      	strh	r0, [r2, #6]
MSS_USB_CIF_rx_ep_disable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_DMA_MASK;
    2d8a:	f8b2 c006 	ldrh.w	ip, [r2, #6]
    2d8e:	f42c 5000 	bic.w	r0, ip, #8192	; 0x2000
    2d92:	0400      	lsls	r0, r0, #16
    2d94:	0c00      	lsrs	r0, r0, #16
    2d96:	80d0      	strh	r0, [r2, #6]
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    2d98:	890a      	ldrh	r2, [r1, #8]
    2d9a:	4313      	orrs	r3, r2
    2d9c:	b298      	uxth	r0, r3
    2d9e:	8108      	strh	r0, [r1, #8]
    2da0:	e7cc      	b.n	2d3c <MSS_USBD_CIF_rx_ep_read_prepare+0x20>
MSS_USB_CIF_rx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_DMA_MODE_MASK;
    2da2:	7805      	ldrb	r5, [r0, #0]
    2da4:	f243 1400 	movw	r4, #12544	; 0x3100
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    2da8:	40ab      	lsls	r3, r5
MSS_USB_CIF_rx_ep_set_dma_mode1
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_DMA_MODE_MASK;
    2daa:	f2c4 0404 	movt	r4, #16388	; 0x4004
    2dae:	012d      	lsls	r5, r5, #4
    2db0:	192c      	adds	r4, r5, r4
    2db2:	88e5      	ldrh	r5, [r4, #6]
        {
            MSS_USB_CIF_rx_ep_set_dma_mode1(device_ep->num);
            MSS_USB_CIF_rx_ep_set_autoclr(device_ep->num);
            MSS_USB_CIF_rx_ep_enable_dma(device_ep->num);

            MSS_USB_CIF_dma_write_count(device_ep->dma_channel,
    2db4:	69c0      	ldr	r0, [r0, #28]
    2db6:	b2ad      	uxth	r5, r5
    2db8:	f445 6500 	orr.w	r5, r5, #2048	; 0x800
    2dbc:	80e5      	strh	r5, [r4, #6]
MSS_USB_CIF_rx_ep_set_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    2dbe:	88e5      	ldrh	r5, [r4, #6]
    2dc0:	b2ad      	uxth	r5, r5
    2dc2:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
    2dc6:	80e5      	strh	r5, [r4, #6]
MSS_USB_CIF_rx_ep_enable_dma
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_DMA_MASK;
    2dc8:	88e5      	ldrh	r5, [r4, #6]
    2dca:	b2ad      	uxth	r5, r5
    2dcc:	f445 5500 	orr.w	r5, r5, #8192	; 0x2000
    2dd0:	80e5      	strh	r5, [r4, #6]
(
    mss_usb_dma_channel_t dma_channel,
    uint32_t count
)
{
    USB->DMA_CHANNEL[dma_channel].COUNT = count;
    2dd2:	f8c2 020c 	str.w	r0, [r2, #524]	; 0x20c
MSS_USB_CIF_rx_ep_enable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE |= (uint16_t)(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num);
    2dd6:	890a      	ldrh	r2, [r1, #8]
    2dd8:	4313      	orrs	r3, r2
    2dda:	b29b      	uxth	r3, r3
    2ddc:	810b      	strh	r3, [r1, #8]
                                        device_ep->xfr_length);

            MSS_USB_CIF_rx_ep_enable_irq(device_ep->num);

            /*Handling single NULL packet reception*/
            if(0u != device_ep->xfr_length )
    2dde:	2800      	cmp	r0, #0
    2de0:	d0ac      	beq.n	2d3c <MSS_USBD_CIF_rx_ep_read_prepare+0x20>
MSS_USB_CIF_dma_start_xfr
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL |= DMA_CNTL_REG_START_XFR_MASK;
    2de2:	f243 2300 	movw	r3, #12800	; 0x3200
    2de6:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    2dea:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2dee:	eb0c 0003 	add.w	r0, ip, r3
    2df2:	6842      	ldr	r2, [r0, #4]
    2df4:	f042 0101 	orr.w	r1, r2, #1
    2df8:	6041      	str	r1, [r0, #4]
    2dfa:	e79f      	b.n	2d3c <MSS_USBD_CIF_rx_ep_read_prepare+0x20>

00002dfc <MSS_USBD_CIF_cep_write_pkt>:
MSS_USBD_CIF_cep_write_pkt
(
    mss_usb_ep_t* device_ep
)
{
    if(device_ep->num == MSS_USB_CEP)
    2dfc:	7803      	ldrb	r3, [r0, #0]
void
MSS_USBD_CIF_cep_write_pkt
(
    mss_usb_ep_t* device_ep
)
{
    2dfe:	b470      	push	{r4, r5, r6}
    if(device_ep->num == MSS_USB_CEP)
    2e00:	2b00      	cmp	r3, #0
    2e02:	d16f      	bne.n	2ee4 <MSS_USBD_CIF_cep_write_pkt+0xe8>
    {
        /* null buffer, xfr type, transaction type */
        if((0 != device_ep->buf_addr) && (MSS_USB_XFR_CONTROL == device_ep->xfr_type))
    2e04:	6981      	ldr	r1, [r0, #24]
    2e06:	2900      	cmp	r1, #0
    2e08:	d05b      	beq.n	2ec2 <MSS_USBD_CIF_cep_write_pkt+0xc6>
    2e0a:	7b02      	ldrb	r2, [r0, #12]
    2e0c:	2a00      	cmp	r2, #0
    2e0e:	d158      	bne.n	2ec2 <MSS_USBD_CIF_cep_write_pkt+0xc6>
        {
            MSS_USB_CIF_load_tx_fifo(device_ep->num,
    2e10:	6a45      	ldr	r5, [r0, #36]	; 0x24

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e12:	f3c5 048f 	ubfx	r4, r5, #2, #16
    2e16:	b1e4      	cbz	r4, 2e52 <MSS_USBD_CIF_cep_write_pkt+0x56>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e18:	680e      	ldr	r6, [r1, #0]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e1a:	2301      	movs	r3, #1
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e1c:	f243 0200 	movw	r2, #12288	; 0x3000
    2e20:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2e24:	f104 3cff 	add.w	ip, r4, #4294967295

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e28:	42a3      	cmp	r3, r4
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e2a:	6216      	str	r6, [r2, #32]
    2e2c:	ea0c 0603 	and.w	r6, ip, r3

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e30:	d20f      	bcs.n	2e52 <MSS_USBD_CIF_cep_write_pkt+0x56>
    2e32:	b126      	cbz	r6, 2e3e <MSS_USBD_CIF_cep_write_pkt+0x42>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e34:	684e      	ldr	r6, [r1, #4]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e36:	2302      	movs	r3, #2
    2e38:	42a3      	cmp	r3, r4
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e3a:	6216      	str	r6, [r2, #32]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e3c:	d209      	bcs.n	2e52 <MSS_USBD_CIF_cep_write_pkt+0x56>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e3e:	f851 6023 	ldr.w	r6, [r1, r3, lsl #2]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e42:	3301      	adds	r3, #1
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e44:	6216      	str	r6, [r2, #32]
    2e46:	f851 6023 	ldr.w	r6, [r1, r3, lsl #2]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e4a:	3301      	adds	r3, #1
    2e4c:	42a3      	cmp	r3, r4
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    2e4e:	6216      	str	r6, [r2, #32]

    uint16_t words = length / 4;
    temp =in_data;
    temp_8bit = in_data;

    for(idx = 0u; idx < words; ++idx)
    2e50:	d3f5      	bcc.n	2e3e <MSS_USBD_CIF_cep_write_pkt+0x42>
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e52:	f025 0203 	bic.w	r2, r5, #3
    2e56:	4295      	cmp	r5, r2
    2e58:	d924      	bls.n	2ea4 <MSS_USBD_CIF_cep_write_pkt+0xa8>
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e5a:	188b      	adds	r3, r1, r2
    2e5c:	f243 0400 	movw	r4, #12288	; 0x3000
    2e60:	43d1      	mvns	r1, r2
    2e62:	f813 cb01 	ldrb.w	ip, [r3], #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e66:	3201      	adds	r2, #1
    2e68:	1949      	adds	r1, r1, r5
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e6a:	f2c4 0404 	movt	r4, #16388	; 0x4004
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e6e:	4295      	cmp	r5, r2
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e70:	f884 c020 	strb.w	ip, [r4, #32]
    2e74:	f001 0101 	and.w	r1, r1, #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e78:	d914      	bls.n	2ea4 <MSS_USBD_CIF_cep_write_pkt+0xa8>
    2e7a:	b131      	cbz	r1, 2e8a <MSS_USBD_CIF_cep_write_pkt+0x8e>
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e7c:	f813 cb01 	ldrb.w	ip, [r3], #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e80:	3201      	adds	r2, #1
    2e82:	4295      	cmp	r5, r2
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e84:	f884 c020 	strb.w	ip, [r4, #32]
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e88:	d90c      	bls.n	2ea4 <MSS_USBD_CIF_cep_write_pkt+0xa8>
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e8a:	4619      	mov	r1, r3
    2e8c:	f811 cb01 	ldrb.w	ip, [r1], #1
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e90:	3202      	adds	r2, #2
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e92:	f884 c020 	strb.w	ip, [r4, #32]
    2e96:	f893 c001 	ldrb.w	ip, [r3, #1]
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2e9a:	1c4b      	adds	r3, r1, #1
    2e9c:	4295      	cmp	r5, r2
    {
        USB->FIFO[ep_num].BYTE.VALUE = (uint8_t)temp_8bit[idx];
    2e9e:	f884 c020 	strb.w	ip, [r4, #32]
    for(idx = 0u; idx < words; ++idx)
    {
        USB->FIFO[ep_num].WORD.VALUE = (uint32_t)temp[idx];
    }

    for(idx = (length - (length % 4)); idx < length; ++idx)
    2ea2:	d8f2      	bhi.n	2e8a <MSS_USBD_CIF_cep_write_pkt+0x8e>
                                     device_ep->buf_addr,
                                     device_ep->txn_length);

            device_ep->txn_count = device_ep->txn_length;
            device_ep->xfr_count += device_ep->txn_length;
    2ea4:	6a03      	ldr	r3, [r0, #32]
    2ea6:	6a42      	ldr	r2, [r0, #36]	; 0x24
        }

        if(MSS_USB_CEP_TX == device_ep->state)
    2ea8:	7ac1      	ldrb	r1, [r0, #11]
            MSS_USB_CIF_load_tx_fifo(device_ep->num,
                                     device_ep->buf_addr,
                                     device_ep->txn_length);

            device_ep->txn_count = device_ep->txn_length;
            device_ep->xfr_count += device_ep->txn_length;
    2eaa:	18d3      	adds	r3, r2, r3
        }

        if(MSS_USB_CEP_TX == device_ep->state)
    2eac:	2906      	cmp	r1, #6
        {
            MSS_USB_CIF_load_tx_fifo(device_ep->num,
                                     device_ep->buf_addr,
                                     device_ep->txn_length);

            device_ep->txn_count = device_ep->txn_length;
    2eae:	6285      	str	r5, [r0, #40]	; 0x28
            device_ep->xfr_count += device_ep->txn_length;
    2eb0:	6203      	str	r3, [r0, #32]
        }

        if(MSS_USB_CEP_TX == device_ep->state)
    2eb2:	d10a      	bne.n	2eca <MSS_USBD_CIF_cep_write_pkt+0xce>
        {
            cep_state = MSS_USB_CTRL_EP_TX;
    2eb4:	f640 32ac 	movw	r2, #2988	; 0xbac
    2eb8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    2ebc:	2101      	movs	r1, #1
    2ebe:	7011      	strb	r1, [r2, #0]
    2ec0:	e003      	b.n	2eca <MSS_USBD_CIF_cep_write_pkt+0xce>

            device_ep->txn_count = device_ep->txn_length;
            device_ep->xfr_count += device_ep->txn_length;
        }

        if(MSS_USB_CEP_TX == device_ep->state)
    2ec2:	7ac1      	ldrb	r1, [r0, #11]
)
{
    if(device_ep->num == MSS_USB_CEP)
    {
        /* null buffer, xfr type, transaction type */
        if((0 != device_ep->buf_addr) && (MSS_USB_XFR_CONTROL == device_ep->xfr_type))
    2ec4:	6a03      	ldr	r3, [r0, #32]

            device_ep->txn_count = device_ep->txn_length;
            device_ep->xfr_count += device_ep->txn_length;
        }

        if(MSS_USB_CEP_TX == device_ep->state)
    2ec6:	2906      	cmp	r1, #6
    2ec8:	d0f4      	beq.n	2eb4 <MSS_USBD_CIF_cep_write_pkt+0xb8>
        {
            cep_state = MSS_USB_CTRL_EP_TX;
        }

        if(device_ep->xfr_count < device_ep->xfr_length)
    2eca:	69c1      	ldr	r1, [r0, #28]
MSS_USB_CIF_cep_set_txpktrdy
(
    void
)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 |= CSR0L_DEV_TX_PKT_RDY_MASK;
    2ecc:	f243 0000 	movw	r0, #12288	; 0x3000
    2ed0:	428b      	cmp	r3, r1
    2ed2:	f2c4 0004 	movt	r0, #16388	; 0x4004
    2ed6:	bf37      	itett	cc
    2ed8:	8a41      	ldrhcc	r1, [r0, #18]
/*Read Data Req, host reading from device (USB IN)*/
/*Taken care by MSS_USBD_CIF_cep_write_pkt
TODO: Check with Different Optimization levels*/
static __INLINE void MSS_USBD_CIF_cep_end_rdr(void)
{
    USB->INDEXED_CSR.DEVICE_EP0.CSR0 = (CSR0L_DEV_TX_PKT_RDY_MASK |
    2eda:	210a      	movcs	r1, #10
    2edc:	b289      	uxthcc	r1, r1
    2ede:	f041 0102 	orrcc.w	r1, r1, #2
    2ee2:	8241      	strh	r1, [r0, #18]
        else if(device_ep->xfr_count >= device_ep->xfr_length)
        {
            MSS_USBD_CIF_cep_end_rdr();
        }
    }
}
    2ee4:	bc70      	pop	{r4, r5, r6}
    2ee6:	4770      	bx	lr

00002ee8 <MSS_USBD_CIF_cep_read_pkt>:
void
MSS_USBD_CIF_cep_read_pkt
(
    mss_usb_ep_t* device_ep
)
{
    2ee8:	b470      	push	{r4, r5, r6}
MSS_USB_CIF_set_index_reg
(
    uint8_t index
)
{
    USB->INDEX = index;
    2eea:	f243 0300 	movw	r3, #12288	; 0x3000
    volatile uint16_t received_count = 0u;
    2eee:	f04f 0100 	mov.w	r1, #0
void
MSS_USBD_CIF_cep_read_pkt
(
    mss_usb_ep_t* device_ep
)
{
    2ef2:	b083      	sub	sp, #12
    2ef4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    volatile uint16_t received_count = 0u;
    2ef8:	f8ad 1006 	strh.w	r1, [sp, #6]
    2efc:	7399      	strb	r1, [r3, #14]

    MSS_USB_CIF_set_index_reg(MSS_USB_CEP);

    if((MSS_USB_CEP == device_ep->num) && (0 != device_ep->buf_addr))
    2efe:	7802      	ldrb	r2, [r0, #0]
    2f00:	2a00      	cmp	r2, #0
    2f02:	d15d      	bne.n	2fc0 <MSS_USBD_CIF_cep_read_pkt+0xd8>
    2f04:	6981      	ldr	r1, [r0, #24]
    2f06:	2900      	cmp	r1, #0
    2f08:	d05a      	beq.n	2fc0 <MSS_USBD_CIF_cep_read_pkt+0xd8>
(
    void
)
{
    /*TODO:confirm CSR0.D0 bit before returning*/
    return (USB->INDEXED_CSR.DEVICE_EP0.COUNT0 & COUNT0_REG_MASK);
    2f0a:	f8b3 c018 	ldrh.w	ip, [r3, #24]
    {
        /*TODO: check stalled, null buffer, transfer type, transaction type */
        received_count = MSS_USB_CIF_cep_rx_byte_count();
    2f0e:	f00c 067f 	and.w	r6, ip, #127	; 0x7f
    2f12:	f8ad 6006 	strh.w	r6, [sp, #6]

        MSS_USB_CIF_read_rx_fifo(MSS_USB_CEP,
    2f16:	f8bd 5006 	ldrh.w	r5, [sp, #6]
    2f1a:	b2ad      	uxth	r5, r5

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f1c:	08ae      	lsrs	r6, r5, #2
    2f1e:	d01a      	beq.n	2f56 <MSS_USBD_CIF_cep_read_pkt+0x6e>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f20:	6a1c      	ldr	r4, [r3, #32]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f22:	2201      	movs	r2, #1
    2f24:	f106 3cff 	add.w	ip, r6, #4294967295
    2f28:	42b2      	cmp	r2, r6
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f2a:	600c      	str	r4, [r1, #0]
    2f2c:	ea0c 0402 	and.w	r4, ip, r2

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f30:	d211      	bcs.n	2f56 <MSS_USBD_CIF_cep_read_pkt+0x6e>
    2f32:	b124      	cbz	r4, 2f3e <MSS_USBD_CIF_cep_read_pkt+0x56>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f34:	6a1c      	ldr	r4, [r3, #32]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f36:	2202      	movs	r2, #2
    2f38:	42b2      	cmp	r2, r6
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f3a:	604c      	str	r4, [r1, #4]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f3c:	d20b      	bcs.n	2f56 <MSS_USBD_CIF_cep_read_pkt+0x6e>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f3e:	6a1c      	ldr	r4, [r3, #32]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f40:	f102 0c01 	add.w	ip, r2, #1
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f44:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
    2f48:	6a1c      	ldr	r4, [r3, #32]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f4a:	f10c 0201 	add.w	r2, ip, #1
    2f4e:	42b2      	cmp	r2, r6
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    2f50:	f841 402c 	str.w	r4, [r1, ip, lsl #2]

    uint16_t words = length / 4;
    temp = out_data;
    temp_8bit = out_data;

    for(idx = 0u; idx < words; ++idx)
    2f54:	d3f3      	bcc.n	2f3e <MSS_USBD_CIF_cep_read_pkt+0x56>
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2f56:	f025 0203 	bic.w	r2, r5, #3
    2f5a:	4295      	cmp	r5, r2
    2f5c:	d925      	bls.n	2faa <MSS_USBD_CIF_cep_read_pkt+0xc2>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    2f5e:	f243 0400 	movw	r4, #12288	; 0x3000
    2f62:	43d3      	mvns	r3, r2
    2f64:	f2c4 0404 	movt	r4, #16388	; 0x4004
    2f68:	eb03 0c05 	add.w	ip, r3, r5
    2f6c:	f894 6020 	ldrb.w	r6, [r4, #32]
    2f70:	188b      	adds	r3, r1, r2
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2f72:	3201      	adds	r2, #1
    2f74:	4295      	cmp	r5, r2
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    2f76:	f803 6b01 	strb.w	r6, [r3], #1
    2f7a:	f00c 0101 	and.w	r1, ip, #1
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2f7e:	d914      	bls.n	2faa <MSS_USBD_CIF_cep_read_pkt+0xc2>
    2f80:	b131      	cbz	r1, 2f90 <MSS_USBD_CIF_cep_read_pkt+0xa8>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    2f82:	f894 c020 	ldrb.w	ip, [r4, #32]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2f86:	3201      	adds	r2, #1
    2f88:	4295      	cmp	r5, r2
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    2f8a:	f803 cb01 	strb.w	ip, [r3], #1
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2f8e:	d90c      	bls.n	2faa <MSS_USBD_CIF_cep_read_pkt+0xc2>
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    2f90:	f894 c020 	ldrb.w	ip, [r4, #32]
    2f94:	4619      	mov	r1, r3
    2f96:	f801 cb01 	strb.w	ip, [r1], #1
    2f9a:	f894 c020 	ldrb.w	ip, [r4, #32]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2f9e:	3202      	adds	r2, #2
    {
        temp_8bit[idx] = USB->FIFO[ep_num].BYTE.VALUE;
    2fa0:	f883 c001 	strb.w	ip, [r3, #1]
    for(idx = 0u; idx < words; ++idx)
    {
        temp[idx] = USB->FIFO[ep_num].WORD.VALUE;
    }

    for(idx = (length - (length % 4u)); idx < length; ++idx)
    2fa4:	1c4b      	adds	r3, r1, #1
    2fa6:	4295      	cmp	r5, r2
    2fa8:	d8f2      	bhi.n	2f90 <MSS_USBD_CIF_cep_read_pkt+0xa8>
                                 device_ep->buf_addr,
                                 received_count);

        device_ep->xfr_count += received_count;
    2faa:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    2fae:	6a01      	ldr	r1, [r0, #32]
        device_ep->txn_count = received_count;
    2fb0:	f8bd c006 	ldrh.w	ip, [sp, #6]

        MSS_USB_CIF_read_rx_fifo(MSS_USB_CEP,
                                 device_ep->buf_addr,
                                 received_count);

        device_ep->xfr_count += received_count;
    2fb4:	b293      	uxth	r3, r2
    2fb6:	18cb      	adds	r3, r1, r3
        device_ep->txn_count = received_count;
    2fb8:	fa1f f28c 	uxth.w	r2, ip
    2fbc:	6282      	str	r2, [r0, #40]	; 0x28

        MSS_USB_CIF_read_rx_fifo(MSS_USB_CEP,
                                 device_ep->buf_addr,
                                 received_count);

        device_ep->xfr_count += received_count;
    2fbe:	6203      	str	r3, [r0, #32]
        device_ep->txn_count = received_count;
    }
}
    2fc0:	b003      	add	sp, #12
    2fc2:	bc70      	pop	{r4, r5, r6}
    2fc4:	4770      	bx	lr
    2fc6:	bf00      	nop

00002fc8 <MSS_USBD_CIF_rx_ep_configure>:
MSS_USB_CIF_rx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR = 0x0000;
    2fc8:	7801      	ldrb	r1, [r0, #0]
    2fca:	f243 1300 	movw	r3, #12544	; 0x3100
    2fce:	010a      	lsls	r2, r1, #4
    2fd0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2fd4:	18d3      	adds	r3, r2, r3
    2fd6:	f04f 0100 	mov.w	r1, #0
    2fda:	80d9      	strh	r1, [r3, #6]
MSS_USB_CIF_rx_ep_clr_overrun
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_OVERRUN_MASK;
    2fdc:	f8b3 c006 	ldrh.w	ip, [r3, #6]

    MSS_USB_CIF_rx_ep_clr_overrun(device_ep->num);
    MSS_USB_CIF_rx_ep_clr_stall_sent_bit(device_ep->num);
    MSS_USB_CIF_rx_ep_clr_send_stall_bit(device_ep->num);

    switch(device_ep->xfr_type)
    2fe0:	7b01      	ldrb	r1, [r0, #12]
    2fe2:	f02c 0204 	bic.w	r2, ip, #4
    2fe6:	0412      	lsls	r2, r2, #16
    2fe8:	0c12      	lsrs	r2, r2, #16
    2fea:	80da      	strh	r2, [r3, #6]
MSS_USB_CIF_rx_ep_clr_stall_sent_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_STALL_SENT_MASK;
    2fec:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    2ff0:	f02c 0240 	bic.w	r2, ip, #64	; 0x40
    2ff4:	0412      	lsls	r2, r2, #16
    2ff6:	0c12      	lsrs	r2, r2, #16
    2ff8:	80da      	strh	r2, [r3, #6]
MSS_USB_CIF_rx_ep_clr_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_SEND_STALL_MASK;
    2ffa:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    2ffe:	f02c 0220 	bic.w	r2, ip, #32
    3002:	0412      	lsls	r2, r2, #16
    3004:	0c12      	lsrs	r2, r2, #16
    3006:	2902      	cmp	r1, #2
    3008:	80da      	strh	r2, [r3, #6]
    300a:	d02a      	beq.n	3062 <MSS_USBD_CIF_rx_ep_configure+0x9a>
    300c:	2903      	cmp	r1, #3
    300e:	d016      	beq.n	303e <MSS_USBD_CIF_rx_ep_configure+0x76>
    3010:	2901      	cmp	r1, #1
    3012:	d001      	beq.n	3018 <MSS_USBD_CIF_rx_ep_configure+0x50>
            ASSERT(0);
        break;
    }

    /*Do the common configuration for RX EP*/
    MSS_USB_CIF_rx_ep_configure(device_ep);
    3014:	f7fe b90c 	b.w	1230 <MSS_USB_CIF_rx_ep_configure>
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    3018:	88da      	ldrh	r2, [r3, #6]
    301a:	0451      	lsls	r1, r2, #17
    301c:	0c4a      	lsrs	r2, r1, #17
    301e:	80da      	strh	r2, [r3, #6]
MSS_USB_CIF_rx_ep_enable_iso
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_ISO_MASK;
    3020:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    3024:	fa1f f18c 	uxth.w	r1, ip
    3028:	f441 4280 	orr.w	r2, r1, #16384	; 0x4000
    302c:	80da      	strh	r2, [r3, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    /*Setting BI_DIS_NYET mask disables NYET*/
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_BI_DIS_NYET_MASK;
    302e:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    3032:	fa1f f18c 	uxth.w	r1, ip
    3036:	f441 5280 	orr.w	r2, r1, #4096	; 0x1000
    303a:	80da      	strh	r2, [r3, #6]
    303c:	e7ea      	b.n	3014 <MSS_USBD_CIF_rx_ep_configure+0x4c>
MSS_USB_CIF_rx_ep_disable_iso
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_ISO_MASK;
    303e:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    3042:	f42c 4180 	bic.w	r1, ip, #16384	; 0x4000
    3046:	040a      	lsls	r2, r1, #16
    3048:	0c11      	lsrs	r1, r2, #16
    304a:	80d9      	strh	r1, [r3, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    /*Setting BI_DIS_NYET mask disables NYET*/
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_BI_DIS_NYET_MASK;
    304c:	88da      	ldrh	r2, [r3, #6]
    304e:	b291      	uxth	r1, r2
    3050:	f441 5c80 	orr.w	ip, r1, #4096	; 0x1000
    3054:	f8a3 c006 	strh.w	ip, [r3, #6]
MSS_USB_CIF_rx_ep_clr_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    3058:	88da      	ldrh	r2, [r3, #6]
    305a:	0451      	lsls	r1, r2, #17
    305c:	0c4a      	lsrs	r2, r1, #17
    305e:	80da      	strh	r2, [r3, #6]
    3060:	e7d8      	b.n	3014 <MSS_USBD_CIF_rx_ep_configure+0x4c>
MSS_USB_CIF_rx_ep_disable_iso
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_ENABLE_ISO_MASK;
    3062:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    3066:	f42c 4180 	bic.w	r1, ip, #16384	; 0x4000
    306a:	040a      	lsls	r2, r1, #16
    306c:	0c11      	lsrs	r1, r2, #16
    306e:	80d9      	strh	r1, [r3, #6]
(
    mss_usb_ep_num_t ep_num
)
{
    /*Clearing BI_DIS_NYET mask disables NYET*/
    USB->ENDPOINT[ep_num].RX_CSR &= ~RxCSRL_REG_EPN_BI_DIS_NYET_MASK;
    3070:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    3074:	f42c 5280 	bic.w	r2, ip, #4096	; 0x1000
    3078:	0411      	lsls	r1, r2, #16
    307a:	0c0a      	lsrs	r2, r1, #16
    307c:	80da      	strh	r2, [r3, #6]
MSS_USB_CIF_rx_ep_set_autoclr
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR |= RxCSRL_REG_EPN_ENABLE_AUTOCLR_MASK;
    307e:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    3082:	fa1f f18c 	uxth.w	r1, ip
    3086:	f441 4200 	orr.w	r2, r1, #32768	; 0x8000
    308a:	80da      	strh	r2, [r3, #6]
    308c:	e7c2      	b.n	3014 <MSS_USBD_CIF_rx_ep_configure+0x4c>
    308e:	bf00      	nop

00003090 <MSS_USBD_CIF_tx_ep_configure>:
MSS_USB_CIF_tx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR = 0x0000;
    3090:	7801      	ldrb	r1, [r0, #0]
    3092:	f243 1300 	movw	r3, #12544	; 0x3100
    3096:	010a      	lsls	r2, r1, #4
    3098:	f2c4 0304 	movt	r3, #16388	; 0x4004
    309c:	18d3      	adds	r3, r2, r3
    309e:	f04f 0100 	mov.w	r1, #0
    30a2:	8059      	strh	r1, [r3, #2]
MSS_USB_CIF_tx_ep_clr_underrun
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_UNDERRUN_MASK;
    30a4:	f8b3 c002 	ldrh.w	ip, [r3, #2]

    MSS_USB_CIF_tx_ep_clr_underrun(device_ep->num);
    MSS_USB_CIF_tx_ep_clr_send_stall_bit(device_ep->num);
    MSS_USB_CIF_tx_ep_clr_stall_sent_bit(device_ep->num);

    switch(device_ep->xfr_type)
    30a8:	7b01      	ldrb	r1, [r0, #12]
    30aa:	f02c 0204 	bic.w	r2, ip, #4
    30ae:	0412      	lsls	r2, r2, #16
    30b0:	0c12      	lsrs	r2, r2, #16
    30b2:	805a      	strh	r2, [r3, #2]
MSS_USB_CIF_tx_ep_clr_send_stall_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_SEND_STALL_MASK;
    30b4:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    30b8:	f02c 0210 	bic.w	r2, ip, #16
    30bc:	0412      	lsls	r2, r2, #16
    30be:	0c12      	lsrs	r2, r2, #16
    30c0:	805a      	strh	r2, [r3, #2]
MSS_USB_CIF_tx_ep_clr_stall_sent_bit
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRL_REG_EPN_STALL_SENT_MASK;
    30c2:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    30c6:	f02c 0220 	bic.w	r2, ip, #32
    30ca:	0412      	lsls	r2, r2, #16
    30cc:	0c12      	lsrs	r2, r2, #16
    30ce:	2902      	cmp	r1, #2
    30d0:	805a      	strh	r2, [r3, #2]
    30d2:	d016      	beq.n	3102 <MSS_USBD_CIF_tx_ep_configure+0x72>
    30d4:	2903      	cmp	r1, #3
    30d6:	d00d      	beq.n	30f4 <MSS_USBD_CIF_tx_ep_configure+0x64>
    30d8:	2901      	cmp	r1, #1
    30da:	d001      	beq.n	30e0 <MSS_USBD_CIF_tx_ep_configure+0x50>
            ASSERT(0);
        break;
    }

    /*Do the common configuration for TX EP*/
    MSS_USB_CIF_tx_ep_configure(device_ep);
    30dc:	f7fd bfb6 	b.w	104c <MSS_USB_CIF_tx_ep_configure>
MSS_USB_CIF_tx_ep_enable_iso
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_ENABLE_ISO_MASK;
    30e0:	8859      	ldrh	r1, [r3, #2]
    30e2:	b28a      	uxth	r2, r1
    30e4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    30e8:	805a      	strh	r2, [r3, #2]
MSS_USB_CIF_tx_ep_clr_autoset
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRH_REG_EPN_ENABLE_AUTOSET_MASK;
    30ea:	885a      	ldrh	r2, [r3, #2]
    30ec:	0451      	lsls	r1, r2, #17
    30ee:	0c4a      	lsrs	r2, r1, #17
    30f0:	805a      	strh	r2, [r3, #2]
    30f2:	e7f3      	b.n	30dc <MSS_USBD_CIF_tx_ep_configure+0x4c>
MSS_USB_CIF_tx_ep_disable_iso
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR &= ~TxCSRH_REG_EPN_ENABLE_ISO_MASK;
    30f4:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    30f8:	f42c 4180 	bic.w	r1, ip, #16384	; 0x4000
    30fc:	040a      	lsls	r2, r1, #16
    30fe:	0c12      	lsrs	r2, r2, #16
    3100:	e7f2      	b.n	30e8 <MSS_USBD_CIF_tx_ep_configure+0x58>
            MSS_USB_CIF_tx_ep_clr_autoset(device_ep->num);
        break;

        case MSS_USB_XFR_BULK:
            MSS_USB_CIF_tx_ep_disable_iso(device_ep->num);
            if(device_ep->dma_enable == DMA_ENABLE)
    3102:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    3106:	f42c 4180 	bic.w	r1, ip, #16384	; 0x4000
    310a:	040a      	lsls	r2, r1, #16
    310c:	0c11      	lsrs	r1, r2, #16
    310e:	8059      	strh	r1, [r3, #2]
    3110:	7982      	ldrb	r2, [r0, #6]
    3112:	2a01      	cmp	r2, #1
    3114:	d1e2      	bne.n	30dc <MSS_USBD_CIF_tx_ep_configure+0x4c>
MSS_USB_CIF_tx_ep_set_autoset
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR |= TxCSRH_REG_EPN_ENABLE_AUTOSET_MASK;
    3116:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    311a:	fa1f f18c 	uxth.w	r1, ip
    311e:	f441 4200 	orr.w	r2, r1, #32768	; 0x8000
    3122:	805a      	strh	r2, [r3, #2]
    3124:	e7da      	b.n	30dc <MSS_USBD_CIF_tx_ep_configure+0x4c>
    3126:	bf00      	nop

00003128 <MSS_USBD_HID_tx_done>:
uint8_t
MSS_USBD_HID_tx_done
(
    void
)
{
    3128:	f240 13f8 	movw	r3, #504	; 0x1f8
    312c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    return(g_tx_complete_status);
}
    3130:	7818      	ldrb	r0, [r3, #0]
    3132:	4770      	bx	lr

00003134 <usbd_hid_get_descriptor_cb>:
    For HS it results in 4mSec polling period
    Since this is OK for mouse app, we will return same configuration for
    Other Speed Config as well.
    */

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient )
    3134:	b970      	cbnz	r0, 3154 <usbd_hid_get_descriptor_cb+0x20>
    {
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
    3136:	2902      	cmp	r1, #2
    3138:	d108      	bne.n	314c <usbd_hid_get_descriptor_cb+0x18>
            *length = sizeof(hid_conf_descr);
            return(hid_conf_descr);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
        {
            hid_conf_descr[HID_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    313a:	f240 10f8 	movw	r0, #504	; 0x1f8
    313e:	f2c2 0000 	movt	r0, #8192	; 0x2000
            *length = sizeof(hid_conf_descr);
    3142:	2322      	movs	r3, #34	; 0x22
            *length = sizeof(hid_conf_descr);
            return(hid_conf_descr);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
        {
            hid_conf_descr[HID_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    3144:	7141      	strb	r1, [r0, #5]
            *length = sizeof(hid_conf_descr);
    3146:	6013      	str	r3, [r2, #0]
    3148:	3004      	adds	r0, #4
            return(hid_conf_descr);
    314a:	4770      	bx	lr
        {
            hid_conf_descr[HID_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
            *length = sizeof(hid_conf_descr);
            return(hid_conf_descr);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
    314c:	2907      	cmp	r1, #7
    314e:	d0f4      	beq.n	313a <usbd_hid_get_descriptor_cb+0x6>
            return(report_descr);
        }
        else if (USB_HID_DESCRIPTOR_TYPE == type)
        {
            *length = USB_HID_DESCR_LENGTH;
            return(&hid_conf_descr[HID_CONF_DESCR_HIDDESCRTYPE_IDX]);
    3150:	2000      	movs	r0, #0
    {
        /*Do nothing*/
    }

    return USB_FAIL;
}
    3152:	4770      	bx	lr
            hid_conf_descr[HID_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
            *length = sizeof(hid_conf_descr);
            return(hid_conf_descr);
        }
    }
    else if( USB_STD_REQ_RECIPIENT_ENDPOINT == recepient )/*Need index(EP Num)*/
    3154:	2802      	cmp	r0, #2
    3156:	d0fb      	beq.n	3150 <usbd_hid_get_descriptor_cb+0x1c>
    {
        /*Do nothing*/
    }
    else if(USB_STD_REQ_RECIPIENT_INTERFACE == recepient)/*Need index(interface number)*/
    3158:	2801      	cmp	r0, #1
    315a:	d1f9      	bne.n	3150 <usbd_hid_get_descriptor_cb+0x1c>
    {
        if(USB_REPORT_DESCRIPTOR_TYPE == type)
    315c:	2922      	cmp	r1, #34	; 0x22
    315e:	d103      	bne.n	3168 <usbd_hid_get_descriptor_cb+0x34>
        {
            *length = sizeof(report_descr);
    3160:	2134      	movs	r1, #52	; 0x34
    3162:	6011      	str	r1, [r2, #0]
    3164:	4803      	ldr	r0, [pc, #12]	; (3174 <usbd_hid_get_descriptor_cb+0x40>)
            return(report_descr);
    3166:	4770      	bx	lr
        }
        else if (USB_HID_DESCRIPTOR_TYPE == type)
    3168:	2921      	cmp	r1, #33	; 0x21
    316a:	d1f1      	bne.n	3150 <usbd_hid_get_descriptor_cb+0x1c>
        {
            *length = USB_HID_DESCR_LENGTH;
    316c:	2009      	movs	r0, #9
    316e:	6010      	str	r0, [r2, #0]
    3170:	4801      	ldr	r0, [pc, #4]	; (3178 <usbd_hid_get_descriptor_cb+0x44>)
            return(&hid_conf_descr[HID_CONF_DESCR_HIDDESCRTYPE_IDX]);
    3172:	4770      	bx	lr
    3174:	20000220 	.word	0x20000220
    3178:	2000020e 	.word	0x2000020e

0000317c <usbd_hid_release_cb>:
usbd_hid_release_cb
(
    uint8_t cfgidx
)
{
    g_hid_state = USBD_HID_NOT_CONFIGURED;
    317c:	f640 13b5 	movw	r3, #2485	; 0x9b5
    3180:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3184:	2200      	movs	r2, #0
    3186:	701a      	strb	r2, [r3, #0]
    return USB_SUCCESS;
}
    3188:	2001      	movs	r0, #1
    318a:	4770      	bx	lr

0000318c <usbd_hid_process_request_cb>:
    uint8_t** buf_pp,
    uint32_t* length
)
{
    return USB_FAIL;
}
    318c:	2000      	movs	r0, #0
    318e:	4770      	bx	lr

00003190 <usbd_hid_rx_cb>:
    uint8_t status,
    uint32_t rx_count
)
{
    return USB_SUCCESS;
}
    3190:	2001      	movs	r0, #1
    3192:	4770      	bx	lr

00003194 <usbd_hid_cep_tx_done_cb>:
(
    uint8_t status
)
{
    return USB_SUCCESS;
}
    3194:	2001      	movs	r0, #1
    3196:	4770      	bx	lr

00003198 <usbd_hid_cep_rx_done_cb>:
(
    uint8_t status
)
{
    return USB_SUCCESS;
}
    3198:	2001      	movs	r0, #1
    319a:	4770      	bx	lr

0000319c <usbd_hid_tx_complete_cb>:
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    if(status & (TX_EP_UNDER_RUN_ERROR|TX_EP_STALL_ERROR) )
    319c:	f011 0f03 	tst.w	r1, #3
usbd_hid_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    31a0:	b508      	push	{r3, lr}
    if(status & (TX_EP_UNDER_RUN_ERROR|TX_EP_STALL_ERROR) )
    31a2:	d107      	bne.n	31b4 <usbd_hid_tx_complete_cb+0x18>
    {
        MSS_USBD_tx_ep_flush_fifo(HID_INTR_TX_EP);
    }
    else
    {
        g_tx_complete_status = 1u;
    31a4:	f240 13f8 	movw	r3, #504	; 0x1f8
    31a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31ac:	2201      	movs	r2, #1
    31ae:	601a      	str	r2, [r3, #0]
    }

    return USB_SUCCESS;
}
    31b0:	2001      	movs	r0, #1
    31b2:	bd08      	pop	{r3, pc}
    uint8_t status
)
{
    if(status & (TX_EP_UNDER_RUN_ERROR|TX_EP_STALL_ERROR) )
    {
        MSS_USBD_tx_ep_flush_fifo(HID_INTR_TX_EP);
    31b4:	2001      	movs	r0, #1
    31b6:	f7fe f9ad 	bl	1514 <MSS_USBD_tx_ep_flush_fifo>
    {
        g_tx_complete_status = 1u;
    }

    return USB_SUCCESS;
}
    31ba:	2001      	movs	r0, #1
    31bc:	bd08      	pop	{r3, pc}
    31be:	bf00      	nop

000031c0 <usbd_hid_init_cb>:
usbd_hid_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    31c0:	b570      	push	{r4, r5, r6, lr}
    /*
    Since Endpoint Size is wMaxpacketSize is 8, which is valid for both
    FS and HS, we don't need to make decision based on musb_speed
    */
    g_tx_complete_status = 1u;
    31c2:	f240 15f8 	movw	r5, #504	; 0x1f8
    31c6:	2401      	movs	r4, #1
    MSS_USBD_tx_ep_configure(HID_INTR_TX_EP,
    31c8:	2240      	movs	r2, #64	; 0x40
{
    /*
    Since Endpoint Size is wMaxpacketSize is 8, which is valid for both
    FS and HS, we don't need to make decision based on musb_speed
    */
    g_tx_complete_status = 1u;
    31ca:	f2c2 0500 	movt	r5, #8192	; 0x2000
    31ce:	602c      	str	r4, [r5, #0]
usbd_hid_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    31d0:	b086      	sub	sp, #24
    /*
    Since Endpoint Size is wMaxpacketSize is 8, which is valid for both
    FS and HS, we don't need to make decision based on musb_speed
    */
    g_tx_complete_status = 1u;
    MSS_USBD_tx_ep_configure(HID_INTR_TX_EP,
    31d2:	2600      	movs	r6, #0
    31d4:	4620      	mov	r0, r4
    31d6:	4613      	mov	r3, r2
    31d8:	f44f 7100 	mov.w	r1, #512	; 0x200
    31dc:	2503      	movs	r5, #3
    31de:	9503      	str	r5, [sp, #12]
    31e0:	9604      	str	r6, [sp, #16]
    31e2:	9400      	str	r4, [sp, #0]
    31e4:	9401      	str	r4, [sp, #4]
    31e6:	9602      	str	r6, [sp, #8]
    31e8:	f7fe fe1a 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL1,
                             MSS_USB_XFR_INTERRUPT,
                             NO_ZLP_TO_XFR);

    g_hid_state = USBD_HID_CONFIGURED;
    31ec:	f640 13b5 	movw	r3, #2485	; 0x9b5
    31f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    31f4:	701c      	strb	r4, [r3, #0]
    return USB_SUCCESS;
}
    31f6:	4620      	mov	r0, r4
    31f8:	b006      	add	sp, #24
    31fa:	bd70      	pop	{r4, r5, r6, pc}

000031fc <MSS_USBD_HID_tx_report>:
MSS_USBD_HID_tx_report
(
    uint8_t * buf,
    uint32_t length
)
{
    31fc:	b538      	push	{r3, r4, r5, lr}
    if(USBD_HID_CONFIGURED == g_hid_state)
    31fe:	f640 13b5 	movw	r3, #2485	; 0x9b5
    3202:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3206:	781c      	ldrb	r4, [r3, #0]
MSS_USBD_HID_tx_report
(
    uint8_t * buf,
    uint32_t length
)
{
    3208:	460a      	mov	r2, r1
    if(USBD_HID_CONFIGURED == g_hid_state)
    320a:	2c01      	cmp	r4, #1
    320c:	d001      	beq.n	3212 <MSS_USBD_HID_tx_report+0x16>
    320e:	2000      	movs	r0, #0
    3210:	bd38      	pop	{r3, r4, r5, pc}
    {
        g_tx_complete_status = 0u;
    3212:	f240 13f8 	movw	r3, #504	; 0x1f8
    3216:	f2c2 0300 	movt	r3, #8192	; 0x2000
    321a:	2500      	movs	r5, #0
        MSS_USBD_tx_ep_write(HID_INTR_TX_EP, buf, length);
    321c:	4601      	mov	r1, r0
    uint32_t length
)
{
    if(USBD_HID_CONFIGURED == g_hid_state)
    {
        g_tx_complete_status = 0u;
    321e:	601d      	str	r5, [r3, #0]
        MSS_USBD_tx_ep_write(HID_INTR_TX_EP, buf, length);
    3220:	4620      	mov	r0, r4
    3222:	f7fe fb87 	bl	1934 <MSS_USBD_tx_ep_write>
    3226:	4620      	mov	r0, r4
    }
    else
    {
        return (USB_FAIL);
    }
}
    3228:	bd38      	pop	{r3, r4, r5, pc}
    322a:	bf00      	nop

0000322c <MSS_USBD_HID_init>:
MSS_USBD_HID_init
(
    mss_usb_device_speed_t speed
)
{
    g_usbd_hid_user_speed = speed;
    322c:	f640 33ad 	movw	r3, #2989	; 0xbad
    3230:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3234:	7018      	strb	r0, [r3, #0]
    MSS_USBD_set_class_cb_handler(&usbd_hid_cb);
    3236:	4801      	ldr	r0, [pc, #4]	; (323c <MSS_USBD_HID_init+0x10>)
    3238:	f7fe b93c 	b.w	14b4 <MSS_USBD_set_class_cb_handler>
    323c:	20000254 	.word	0x20000254

00003240 <MSS_USBD_MSC_get_state>:
mss_usbd_msc_state_t
MSS_USBD_MSC_get_state
(
    void
)
{
    3240:	f640 13b8 	movw	r3, #2488	; 0x9b8
    3244:	f2c2 0300 	movt	r3, #8192	; 0x2000
    return g_usbd_msc_state;
}
    3248:	7818      	ldrb	r0, [r3, #0]
    324a:	4770      	bx	lr

0000324c <usbd_msc_get_descriptor_cb>:
    uint8_t recepient,
    uint8_t type,
    uint32_t* length,
    mss_usb_device_speed_t musb_speed
)
{
    324c:	b470      	push	{r4, r5, r6}
        Operate only in FS
      User Selected HS:
        Device connected to 2.0 Host(musb_speed = HS):Operate in HS
        Device connected to 1.x Host(musb_speed = FS):Operate in FS
    */
    if(MSS_USB_DEVICE_FS == g_usbd_msc_user_speed)
    324e:	f640 34b4 	movw	r4, #2996	; 0xbb4
    3252:	f2c2 0400 	movt	r4, #8192	; 0x2000
    3256:	7824      	ldrb	r4, [r4, #0]
    uint8_t recepient,
    uint8_t type,
    uint32_t* length,
    mss_usb_device_speed_t musb_speed
)
{
    3258:	4605      	mov	r5, r0
        Operate only in FS
      User Selected HS:
        Device connected to 2.0 Host(musb_speed = HS):Operate in HS
        Device connected to 1.x Host(musb_speed = FS):Operate in FS
    */
    if(MSS_USB_DEVICE_FS == g_usbd_msc_user_speed)
    325a:	2c01      	cmp	r4, #1
    325c:	d021      	beq.n	32a2 <usbd_msc_get_descriptor_cb+0x56>
        conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
        conf_desc_len = sizeof(msc_fs_conf_descr);
        os_conf_desc = 0u;
        os_conf_desc_len = 0u;
    }
    else if(MSS_USB_DEVICE_HS == g_usbd_msc_user_speed)
    325e:	b9c4      	cbnz	r4, 3292 <usbd_msc_get_descriptor_cb+0x46>
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
    3260:	2b00      	cmp	r3, #0
    3262:	d02a      	beq.n	32ba <usbd_msc_get_descriptor_cb+0x6e>
            conf_desc_len = sizeof(msc_hs_conf_descr);
            os_conf_desc = msc_fs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
            os_conf_desc_len = sizeof(msc_fs_conf_descr);
        }
        else if(MSS_USB_DEVICE_FS == musb_speed)
    3264:	2b01      	cmp	r3, #1
    3266:	d114      	bne.n	3292 <usbd_msc_get_descriptor_cb+0x46>
        {
            conf_desc = msc_fs_conf_descr;
            conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    3268:	f240 2674 	movw	r6, #628	; 0x274
    326c:	f2c2 0600 	movt	r6, #8192	; 0x2000
            conf_desc_len = sizeof(msc_fs_conf_descr);
            os_conf_desc = msc_hs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    3270:	2320      	movs	r3, #32
            os_conf_desc_len = sizeof(msc_fs_conf_descr);
        }
        else if(MSS_USB_DEVICE_FS == musb_speed)
        {
            conf_desc = msc_fs_conf_descr;
            conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    3272:	2402      	movs	r4, #2
            conf_desc_len = sizeof(msc_fs_conf_descr);
            os_conf_desc = msc_hs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    3274:	2007      	movs	r0, #7
            os_conf_desc_len = sizeof(msc_fs_conf_descr);
        }
        else if(MSS_USB_DEVICE_FS == musb_speed)
        {
            conf_desc = msc_fs_conf_descr;
            conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    3276:	7074      	strb	r4, [r6, #1]
            conf_desc_len = sizeof(msc_fs_conf_descr);
            os_conf_desc = msc_hs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    3278:	f886 0021 	strb.w	r0, [r6, #33]	; 0x21
    327c:	461c      	mov	r4, r3
    327e:	4630      	mov	r0, r6
    3280:	eb06 0c03 	add.w	ip, r6, r3
    else
    {
        ASSERT(0);      //user must select FS or HS, nothing else.
    }

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    3284:	b95d      	cbnz	r5, 329e <usbd_msc_get_descriptor_cb+0x52>
    {
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
    3286:	2902      	cmp	r1, #2
        {
           *length = conf_desc_len;
    3288:	bf08      	it	eq
    328a:	6014      	streq	r4, [r2, #0]
        ASSERT(0);      //user must select FS or HS, nothing else.
    }

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    {
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
    328c:	d123      	bne.n	32d6 <usbd_msc_get_descriptor_cb+0x8a>
    {
        /*Do nothing*/
    }

    return USB_FAIL;
}
    328e:	bc70      	pop	{r4, r5, r6}
    3290:	4770      	bx	lr
        {
            conf_desc = msc_fs_conf_descr;
            conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
            conf_desc_len = sizeof(msc_fs_conf_descr);
            os_conf_desc = msc_hs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    3292:	2300      	movs	r3, #0
    3294:	461c      	mov	r4, r3
    3296:	469c      	mov	ip, r3
    3298:	4618      	mov	r0, r3
    else
    {
        ASSERT(0);      //user must select FS or HS, nothing else.
    }

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    329a:	2d00      	cmp	r5, #0
    329c:	d0f3      	beq.n	3286 <usbd_msc_get_descriptor_cb+0x3a>
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
        {
            ASSERT(os_conf_desc != 0u);
            *length = os_conf_desc_len;

            return(os_conf_desc);
    329e:	2000      	movs	r0, #0
    32a0:	e7f5      	b.n	328e <usbd_msc_get_descriptor_cb+0x42>
        Device connected to 1.x Host(musb_speed = FS):Operate in FS
    */
    if(MSS_USB_DEVICE_FS == g_usbd_msc_user_speed)
    {
        conf_desc = msc_fs_conf_descr;
        conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    32a2:	f240 2074 	movw	r0, #628	; 0x274
    32a6:	f04f 0c02 	mov.w	ip, #2
    32aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    32ae:	2300      	movs	r3, #0
    32b0:	f880 c001 	strb.w	ip, [r0, #1]
    32b4:	2420      	movs	r4, #32
    32b6:	469c      	mov	ip, r3
    32b8:	e7e4      	b.n	3284 <usbd_msc_get_descriptor_cb+0x38>
    else if(MSS_USB_DEVICE_HS == g_usbd_msc_user_speed)
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
        {
            conf_desc = msc_hs_conf_descr;
            conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    32ba:	f240 2074 	movw	r0, #628	; 0x274
    32be:	f2c2 0000 	movt	r0, #8192	; 0x2000
    32c2:	2402      	movs	r4, #2
            conf_desc_len = sizeof(msc_hs_conf_descr);
            os_conf_desc = msc_fs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    32c4:	2320      	movs	r3, #32
    else if(MSS_USB_DEVICE_HS == g_usbd_msc_user_speed)
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
        {
            conf_desc = msc_hs_conf_descr;
            conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    32c6:	f880 4021 	strb.w	r4, [r0, #33]	; 0x21
            conf_desc_len = sizeof(msc_hs_conf_descr);
            os_conf_desc = msc_fs_conf_descr;
            os_conf_desc[MSCD_CONF_DESCR_DESCTYPE_IDX] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    32ca:	2407      	movs	r4, #7
    32cc:	7044      	strb	r4, [r0, #1]
    32ce:	4684      	mov	ip, r0
    32d0:	461c      	mov	r4, r3
    32d2:	18c0      	adds	r0, r0, r3
    32d4:	e7d6      	b.n	3284 <usbd_msc_get_descriptor_cb+0x38>
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
        {
           *length = conf_desc_len;
            return(conf_desc);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
    32d6:	2907      	cmp	r1, #7
        {
            ASSERT(os_conf_desc != 0u);
            *length = os_conf_desc_len;
    32d8:	bf04      	itt	eq
    32da:	6013      	streq	r3, [r2, #0]
    32dc:	4660      	moveq	r0, ip
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
        {
           *length = conf_desc_len;
            return(conf_desc);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
    32de:	d0d6      	beq.n	328e <usbd_msc_get_descriptor_cb+0x42>
        {
            ASSERT(os_conf_desc != 0u);
            *length = os_conf_desc_len;

            return(os_conf_desc);
    32e0:	2000      	movs	r0, #0
    32e2:	e7d4      	b.n	328e <usbd_msc_get_descriptor_cb+0x42>

000032e4 <usbd_msc_release_cb>:
static uint8_t
usbd_msc_release_cb
(
    uint8_t cfgidx
)
{
    32e4:	b538      	push	{r3, r4, r5, lr}
MSS_USB_CIF_tx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->TX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    32e6:	f243 0300 	movw	r3, #12288	; 0x3000
    32ea:	f2c4 0304 	movt	r3, #16388	; 0x4004
    32ee:	f8b3 c006 	ldrh.w	ip, [r3, #6]
    g_usbd_msc_state = USBD_MSC_NOT_CONFIGURED;
    32f2:	2200      	movs	r2, #0
    32f4:	f02c 0102 	bic.w	r1, ip, #2
    32f8:	040d      	lsls	r5, r1, #16
    32fa:	0c2c      	lsrs	r4, r5, #16
    32fc:	80dc      	strh	r4, [r3, #6]

    MSS_USB_CIF_rx_ep_disable_irq(MSC_CLASS_BULK_RX_EP);
    MSS_USB_CIF_rx_ep_clr_csrreg(MSC_CLASS_BULK_RX_EP);
    MSS_USB_CIF_dma_clr_ctrlreg(MSS_USB_DMA_CHANNEL1);

    if(0 != g_usbd_msc_media_ops->media_release)
    32fe:	f640 31b0 	movw	r1, #2992	; 0xbb0
MSS_USB_CIF_tx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].TX_CSR = 0x0000;
    3302:	f8a3 2112 	strh.w	r2, [r3, #274]	; 0x112
MSS_USB_CIF_dma_clr_ctrlreg
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL  = 0x0000;
    3306:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
MSS_USB_CIF_rx_ep_disable_irq
(
    mss_usb_ep_num_t ep_num
)
{
    USB->RX_IRQ_ENABLE &= (uint16_t)(~(MSS_USB_WORD_BIT_0_MASK << (uint8_t)ep_num));
    330a:	f8b3 c008 	ldrh.w	ip, [r3, #8]
    330e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    3312:	680c      	ldr	r4, [r1, #0]
    3314:	f02c 0502 	bic.w	r5, ip, #2
    3318:	0429      	lsls	r1, r5, #16
    331a:	6a65      	ldr	r5, [r4, #36]	; 0x24
usbd_msc_release_cb
(
    uint8_t cfgidx
)
{
    g_usbd_msc_state = USBD_MSC_NOT_CONFIGURED;
    331c:	f640 14b8 	movw	r4, #2488	; 0x9b8
    3320:	f2c2 0400 	movt	r4, #8192	; 0x2000
    3324:	0c09      	lsrs	r1, r1, #16
    3326:	8119      	strh	r1, [r3, #8]
    3328:	7022      	strb	r2, [r4, #0]
MSS_USB_CIF_rx_ep_clr_csrreg
(
    mss_usb_ep_num_t ep_num
)
{
    USB->ENDPOINT[ep_num].RX_CSR = 0x0000;
    332a:	f8a3 2116 	strh.w	r2, [r3, #278]	; 0x116
MSS_USB_CIF_dma_clr_ctrlreg
(
    mss_usb_dma_channel_t dma_channel
)
{
    USB->DMA_CHANNEL[dma_channel].CNTL  = 0x0000;
    332e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

    MSS_USB_CIF_rx_ep_disable_irq(MSC_CLASS_BULK_RX_EP);
    MSS_USB_CIF_rx_ep_clr_csrreg(MSC_CLASS_BULK_RX_EP);
    MSS_USB_CIF_dma_clr_ctrlreg(MSS_USB_DMA_CHANNEL1);

    if(0 != g_usbd_msc_media_ops->media_release)
    3332:	b105      	cbz	r5, 3336 <usbd_msc_release_cb+0x52>
    {
        g_usbd_msc_media_ops->media_release(cfgidx);
    3334:	47a8      	blx	r5
    }

    return USB_SUCCESS;
}
    3336:	2001      	movs	r0, #1
    3338:	bd38      	pop	{r3, r4, r5, pc}
    333a:	bf00      	nop

0000333c <usbd_msc_receive_data>:
usbd_msc_receive_data
(
    uint8_t* buf,
    uint32_t len
)
{
    333c:	b410      	push	{r4}
    g_bot_state = BOT_DATA_RX;
    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP, g_xfr_buf_ptr, len);
    333e:	f640 14b8 	movw	r4, #2488	; 0x9b8
    3342:	f2c2 0400 	movt	r4, #8192	; 0x2000
(
    uint8_t* buf,
    uint32_t len
)
{
    g_bot_state = BOT_DATA_RX;
    3346:	f04f 0c01 	mov.w	ip, #1
usbd_msc_receive_data
(
    uint8_t* buf,
    uint32_t len
)
{
    334a:	460a      	mov	r2, r1
    g_bot_state = BOT_DATA_RX;
    334c:	f640 33d8 	movw	r3, #3032	; 0xbd8
    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP, g_xfr_buf_ptr, len);
    3350:	6861      	ldr	r1, [r4, #4]
(
    uint8_t* buf,
    uint32_t len
)
{
    g_bot_state = BOT_DATA_RX;
    3352:	f2c2 0300 	movt	r3, #8192	; 0x2000
    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP, g_xfr_buf_ptr, len);
    3356:	4660      	mov	r0, ip
(
    uint8_t* buf,
    uint32_t len
)
{
    g_bot_state = BOT_DATA_RX;
    3358:	f883 c000 	strb.w	ip, [r3]
    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP, g_xfr_buf_ptr, len);
}
    335c:	bc10      	pop	{r4}
    uint8_t* buf,
    uint32_t len
)
{
    g_bot_state = BOT_DATA_RX;
    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP, g_xfr_buf_ptr, len);
    335e:	f7fe bcc3 	b.w	1ce8 <MSS_USBD_rx_ep_read_prepare>
    3362:	bf00      	nop

00003364 <usbd_msc_process_request_cb>:
(
    mss_usbd_setup_pkt_t* setup_pkt,
    uint8_t** buf_pp,
    uint32_t* length
)
{
    3364:	b5f0      	push	{r4, r5, r6, r7, lr}
    if((MSC_CLASS_INTERFACE_NUM == setup_pkt->index) && (0u == setup_pkt->value))
    3366:	8883      	ldrh	r3, [r0, #4]
(
    mss_usbd_setup_pkt_t* setup_pkt,
    uint8_t** buf_pp,
    uint32_t* length
)
{
    3368:	b083      	sub	sp, #12
    if((MSC_CLASS_INTERFACE_NUM == setup_pkt->index) && (0u == setup_pkt->value))
    336a:	b933      	cbnz	r3, 337a <usbd_msc_process_request_cb+0x16>
    336c:	8843      	ldrh	r3, [r0, #2]
    336e:	b923      	cbnz	r3, 337a <usbd_msc_process_request_cb+0x16>
    {
        switch(setup_pkt->request)
    3370:	7843      	ldrb	r3, [r0, #1]
    3372:	2bfe      	cmp	r3, #254	; 0xfe
    3374:	d040      	beq.n	33f8 <usbd_msc_process_request_cb+0x94>
    3376:	2bff      	cmp	r3, #255	; 0xff
    3378:	d002      	beq.n	3380 <usbd_msc_process_request_cb+0x1c>
                    g_xfr_lba_addr = 0u;
                    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
                                                (uint8_t*)&g_bot_cbw,
                                                USBD_MSC_BOT_CBW_LENGTH);

                    return USB_SUCCESS;
    337a:	2000      	movs	r0, #0
    }
    else
    {
        return USB_FAIL;
    }
}
    337c:	b003      	add	sp, #12
    337e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                *buf_pp = (uint8_t*)&get_max_lun_response;

            return USB_SUCCESS;

            case USB_MSC_BOT_REQ_BMS_RESET:
                if(0u == setup_pkt->length)
    3380:	88c3      	ldrh	r3, [r0, #6]
    3382:	2b00      	cmp	r3, #0
    3384:	d1f9      	bne.n	337a <usbd_msc_process_request_cb+0x16>
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
                    G_BOT_CBW_INIT();
    3386:	f640 35b8 	movw	r5, #3000	; 0xbb8
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
    338a:	f240 2774 	movw	r7, #628	; 0x274
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
                    G_BOT_CBW_INIT();
    338e:	f2c2 0500 	movt	r5, #8192	; 0x2000
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    3392:	2401      	movs	r4, #1
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
    3394:	f2c2 0700 	movt	r7, #8192	; 0x2000
                {
                    /*
                    LVp:62 - prepare for next CBW. Don't change the stall
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
    3398:	f640 16b8 	movw	r6, #2488	; 0x9b8
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
    339c:	f640 3cd8 	movw	ip, #3032	; 0xbd8
                {
                    /*
                    LVp:62 - prepare for next CBW. Don't change the stall
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
    33a0:	f2c2 0600 	movt	r6, #8192	; 0x2000
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
    33a4:	f2c2 0c00 	movt	ip, #8192	; 0x2000
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
                    G_BOT_CBW_INIT();
                    g_xfr_buf_ptr = (uint8_t*)0;
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
    33a8:	4620      	mov	r0, r4
    33aa:	4629      	mov	r1, r5
    33ac:	221f      	movs	r2, #31
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    33ae:	f887 404c 	strb.w	r4, [r7, #76]	; 0x4c
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
    33b2:	64bb      	str	r3, [r7, #72]	; 0x48
                    g_current_command_csw.tag = 0u;
    33b4:	647b      	str	r3, [r7, #68]	; 0x44
                {
                    /*
                    LVp:62 - prepare for next CBW. Don't change the stall
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
    33b6:	7273      	strb	r3, [r6, #9]
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
                    G_BOT_CBW_INIT();
                    g_xfr_buf_ptr = (uint8_t*)0;
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
    33b8:	6133      	str	r3, [r6, #16]
                    /*
                    LVp:62 - prepare for next CBW. Don't change the stall
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
    33ba:	72b3      	strb	r3, [r6, #10]
                    g_bot_state = BOT_IDLE;
                    g_current_command_csw.data_residue = 0u;
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
                    G_BOT_CBW_INIT();
    33bc:	602b      	str	r3, [r5, #0]
                    LVp:62 - prepare for next CBW. Don't change the stall
                    and Data toggle bit on Bulk EPs.
                    */
                    g_bottx_events = BOT_EVENT_IDLE;
                    g_botrx_events = BOT_EVENT_IDLE;
                    g_bot_state = BOT_IDLE;
    33be:	f88c 3000 	strb.w	r3, [ip]
                    g_current_command_csw.data_residue = 0u;
                    g_current_command_csw.tag = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_FAIL;
                    G_BOT_CBW_INIT();
    33c2:	606b      	str	r3, [r5, #4]
    33c4:	60ab      	str	r3, [r5, #8]
    33c6:	732b      	strb	r3, [r5, #12]
    33c8:	736b      	strb	r3, [r5, #13]
    33ca:	73ab      	strb	r3, [r5, #14]
    33cc:	73eb      	strb	r3, [r5, #15]
    33ce:	742b      	strb	r3, [r5, #16]
    33d0:	746b      	strb	r3, [r5, #17]
    33d2:	74ab      	strb	r3, [r5, #18]
    33d4:	74eb      	strb	r3, [r5, #19]
    33d6:	752b      	strb	r3, [r5, #20]
    33d8:	756b      	strb	r3, [r5, #21]
    33da:	75ab      	strb	r3, [r5, #22]
    33dc:	75eb      	strb	r3, [r5, #23]
    33de:	762b      	strb	r3, [r5, #24]
    33e0:	766b      	strb	r3, [r5, #25]
    33e2:	76ab      	strb	r3, [r5, #26]
    33e4:	76eb      	strb	r3, [r5, #27]
    33e6:	772b      	strb	r3, [r5, #28]
    33e8:	776b      	strb	r3, [r5, #29]
    33ea:	77ab      	strb	r3, [r5, #30]
                    g_xfr_buf_ptr = (uint8_t*)0;
    33ec:	6073      	str	r3, [r6, #4]
                    g_xfr_buf_len = 0u;
    33ee:	60f3      	str	r3, [r6, #12]
                    g_xfr_lba_addr = 0u;
                    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
    33f0:	f7fe fc7a 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
    33f4:	4620      	mov	r0, r4
                                                (uint8_t*)&g_bot_cbw,
                                                USBD_MSC_BOT_CBW_LENGTH);

                    return USB_SUCCESS;
    33f6:	e7c1      	b.n	337c <usbd_msc_process_request_cb+0x18>
        {
            case USB_MSC_BOT_REQ_GET_MAX_LUN:
                /*Return the max LUN index, not the actual number of LUNs*/
                ASSERT(g_usbd_msc_media_ops->media_get_max_lun !=0u);

                if(0 != g_usbd_msc_media_ops->media_get_max_lun)
    33f8:	f640 33b0 	movw	r3, #2992	; 0xbb0
    33fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3400:	6818      	ldr	r0, [r3, #0]
    3402:	69c3      	ldr	r3, [r0, #28]
    3404:	b153      	cbz	r3, 341c <usbd_msc_process_request_cb+0xb8>
                {
                    get_max_lun_response[0] = (g_usbd_msc_media_ops->media_get_max_lun() - 1u);
    3406:	9101      	str	r1, [sp, #4]
    3408:	9200      	str	r2, [sp, #0]
    340a:	4798      	blx	r3
    340c:	f640 12b8 	movw	r2, #2488	; 0x9b8
    3410:	f2c2 0200 	movt	r2, #8192	; 0x2000
    3414:	1e41      	subs	r1, r0, #1
    3416:	7211      	strb	r1, [r2, #8]
    3418:	9a00      	ldr	r2, [sp, #0]
    341a:	9901      	ldr	r1, [sp, #4]
                }

                *length = sizeof(get_max_lun_response);
                *buf_pp = (uint8_t*)&get_max_lun_response;
    341c:	4b02      	ldr	r3, [pc, #8]	; (3428 <usbd_msc_process_request_cb+0xc4>)
                if(0 != g_usbd_msc_media_ops->media_get_max_lun)
                {
                    get_max_lun_response[0] = (g_usbd_msc_media_ops->media_get_max_lun() - 1u);
                }

                *length = sizeof(get_max_lun_response);
    341e:	2001      	movs	r0, #1
                *buf_pp = (uint8_t*)&get_max_lun_response;
    3420:	600b      	str	r3, [r1, #0]
                if(0 != g_usbd_msc_media_ops->media_get_max_lun)
                {
                    get_max_lun_response[0] = (g_usbd_msc_media_ops->media_get_max_lun() - 1u);
                }

                *length = sizeof(get_max_lun_response);
    3422:	6010      	str	r0, [r2, #0]
                *buf_pp = (uint8_t*)&get_max_lun_response;

            return USB_SUCCESS;
    3424:	e7aa      	b.n	337c <usbd_msc_process_request_cb+0x18>
    3426:	bf00      	nop
    3428:	200009c0 	.word	0x200009c0

0000342c <usbd_msc_stallout_sendstatus>:
usbd_msc_stallout_sendstatus
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    342c:	f640 33d8 	movw	r3, #3032	; 0xbd8
    3430:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3434:	2203      	movs	r2, #3
    MSS_USBD_rx_ep_stall(MSC_CLASS_BULK_RX_EP);
    3436:	2001      	movs	r0, #1
usbd_msc_stallout_sendstatus
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    3438:	701a      	strb	r2, [r3, #0]
    MSS_USBD_rx_ep_stall(MSC_CLASS_BULK_RX_EP);
    343a:	f7fe b877 	b.w	152c <MSS_USBD_rx_ep_stall>
    343e:	bf00      	nop

00003440 <usbd_msc_send_data>:
    uint8_t* buf,
    uint32_t len
)
{
    /*TODO: check if the length can be accommodated in EP buffer*/
    g_bot_state = BOT_DATA_TX;
    3440:	f640 33d8 	movw	r3, #3032	; 0xbd8
usbd_msc_send_data
(
    uint8_t* buf,
    uint32_t len
)
{
    3444:	460a      	mov	r2, r1
    /*TODO: check if the length can be accommodated in EP buffer*/
    g_bot_state = BOT_DATA_TX;
    3446:	f2c2 0300 	movt	r3, #8192	; 0x2000
    MSS_USBD_tx_ep_write(MSC_CLASS_BULK_TX_EP, buf, len);
    344a:	4601      	mov	r1, r0
    uint8_t* buf,
    uint32_t len
)
{
    /*TODO: check if the length can be accommodated in EP buffer*/
    g_bot_state = BOT_DATA_TX;
    344c:	f04f 0c02 	mov.w	ip, #2
    MSS_USBD_tx_ep_write(MSC_CLASS_BULK_TX_EP, buf, len);
    3450:	2001      	movs	r0, #1
    uint8_t* buf,
    uint32_t len
)
{
    /*TODO: check if the length can be accommodated in EP buffer*/
    g_bot_state = BOT_DATA_TX;
    3452:	f883 c000 	strb.w	ip, [r3]
    MSS_USBD_tx_ep_write(MSC_CLASS_BULK_TX_EP, buf, len);
    3456:	f7fe ba6d 	b.w	1934 <MSS_USBD_tx_ep_write>
    345a:	bf00      	nop

0000345c <usbd_msc_send_csw>:
usbd_msc_send_csw
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    345c:	f640 33d8 	movw	r3, #3032	; 0xbd8
    MSS_USBD_tx_ep_write(MSC_CLASS_BULK_TX_EP,
    3460:	4905      	ldr	r1, [pc, #20]	; (3478 <usbd_msc_send_csw+0x1c>)
usbd_msc_send_csw
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    3462:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3466:	f04f 0c03 	mov.w	ip, #3
    MSS_USBD_tx_ep_write(MSC_CLASS_BULK_TX_EP,
    346a:	2001      	movs	r0, #1
    346c:	220d      	movs	r2, #13
usbd_msc_send_csw
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    346e:	f883 c000 	strb.w	ip, [r3]
    MSS_USBD_tx_ep_write(MSC_CLASS_BULK_TX_EP,
    3472:	f7fe ba5f 	b.w	1934 <MSS_USBD_tx_ep_write>
    3476:	bf00      	nop
    3478:	200002b4 	.word	0x200002b4

0000347c <usbd_msc_stallin_sendstatus>:
usbd_msc_stallin_sendstatus
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    347c:	f640 33d8 	movw	r3, #3032	; 0xbd8
    3480:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3484:	2203      	movs	r2, #3
    MSS_USBD_tx_ep_stall(MSC_CLASS_BULK_TX_EP);
    3486:	2001      	movs	r0, #1
usbd_msc_stallin_sendstatus
(
    void
)
{
    g_bot_state = BOT_SEND_STATUS;
    3488:	701a      	strb	r2, [r3, #0]
    MSS_USBD_tx_ep_stall(MSC_CLASS_BULK_TX_EP);
    348a:	f7fe b819 	b.w	14c0 <MSS_USBD_tx_ep_stall>
    348e:	bf00      	nop

00003490 <usbd_msc_abort_cbw>:
usbd_msc_abort_cbw
(
    uint8_t lun
)
{
    g_bot_state = BOT_ABORTED;
    3490:	f640 33d8 	movw	r3, #3032	; 0xbd8
    3494:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3498:	2204      	movs	r2, #4
    /*
    Don't respond to anything from host on Bulk IN or OUT Endpoint.
    Reset Recovery request is mandatory now.
    */

    MSS_USBD_tx_ep_stall(MSC_CLASS_BULK_TX_EP);
    349a:	2001      	movs	r0, #1
static void
usbd_msc_abort_cbw
(
    uint8_t lun
)
{
    349c:	b510      	push	{r4, lr}
    g_bot_state = BOT_ABORTED;
    349e:	701a      	strb	r2, [r3, #0]
    /*
    Don't respond to anything from host on Bulk IN or OUT Endpoint.
    Reset Recovery request is mandatory now.
    */

    MSS_USBD_tx_ep_stall(MSC_CLASS_BULK_TX_EP);
    34a0:	f7fe f80e 	bl	14c0 <MSS_USBD_tx_ep_stall>
    MSS_USBD_rx_ep_stall(MSC_CLASS_BULK_RX_EP);
    34a4:	2001      	movs	r0, #1
}
    34a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Don't respond to anything from host on Bulk IN or OUT Endpoint.
    Reset Recovery request is mandatory now.
    */

    MSS_USBD_tx_ep_stall(MSC_CLASS_BULK_TX_EP);
    MSS_USBD_rx_ep_stall(MSC_CLASS_BULK_RX_EP);
    34aa:	f7fe b83f 	b.w	152c <MSS_USBD_rx_ep_stall>
    34ae:	bf00      	nop

000034b0 <usbd_msc_init_cb>:
usbd_msc_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    34b0:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    34b4:	f640 32d8 	movw	r2, #3032	; 0xbd8
    uint16_t bulk_rxep_maxpktsz = 0u;

    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    34b8:	f640 15b8 	movw	r5, #2488	; 0x9b8
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    g_current_command_csw.data_residue = 0u;
    34bc:	f240 2074 	movw	r0, #628	; 0x274
    g_current_command_csw.tag = 0u;
    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    G_BOT_CBW_INIT();
    34c0:	f640 33b8 	movw	r3, #3000	; 0xbb8
    uint16_t bulk_rxep_maxpktsz = 0u;

    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    34c4:	2700      	movs	r7, #0
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    g_current_command_csw.data_residue = 0u;
    g_current_command_csw.tag = 0u;
    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    G_BOT_CBW_INIT();
    34c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    uint16_t bulk_rxep_maxpktsz = 0u;

    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    34ca:	f2c2 0500 	movt	r5, #8192	; 0x2000
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    g_current_command_csw.data_residue = 0u;
    34ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    34d2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    g_current_command_csw.data_residue = 0u;
    g_current_command_csw.tag = 0u;
    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    34d6:	2401      	movs	r4, #1
      /*
      We calculate the Bulk endpoint sizes and max_pkt_size based on the
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    34d8:	2901      	cmp	r1, #1
    uint16_t bulk_rxep_maxpktsz = 0u;

    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    34da:	726f      	strb	r7, [r5, #9]
usbd_msc_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    34dc:	b087      	sub	sp, #28

    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    g_botrx_events = BOT_EVENT_IDLE;
    34de:	72af      	strb	r7, [r5, #10]
    g_bot_state = BOT_IDLE;
    g_current_command_csw.data_residue = 0u;
    g_current_command_csw.tag = 0u;
    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    34e0:	f880 404c 	strb.w	r4, [r0, #76]	; 0x4c
    G_BOT_CBW_INIT();
    34e4:	779f      	strb	r7, [r3, #30]
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    g_current_command_csw.data_residue = 0u;
    34e6:	6487      	str	r7, [r0, #72]	; 0x48
    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_bottx_events = BOT_EVENT_IDLE;
    g_botrx_events = BOT_EVENT_IDLE;
    g_bot_state = BOT_IDLE;
    34e8:	7017      	strb	r7, [r2, #0]
    g_current_command_csw.data_residue = 0u;
    g_current_command_csw.tag = 0u;
    34ea:	6447      	str	r7, [r0, #68]	; 0x44
    g_current_command_csw.status = SCSI_COMMAND_FAIL;
    G_BOT_CBW_INIT();
    34ec:	601f      	str	r7, [r3, #0]
    34ee:	605f      	str	r7, [r3, #4]
    34f0:	609f      	str	r7, [r3, #8]
    34f2:	731f      	strb	r7, [r3, #12]
    34f4:	735f      	strb	r7, [r3, #13]
    34f6:	739f      	strb	r7, [r3, #14]
    34f8:	73df      	strb	r7, [r3, #15]
    34fa:	741f      	strb	r7, [r3, #16]
    34fc:	745f      	strb	r7, [r3, #17]
    34fe:	749f      	strb	r7, [r3, #18]
    3500:	74df      	strb	r7, [r3, #19]
    3502:	751f      	strb	r7, [r3, #20]
    3504:	755f      	strb	r7, [r3, #21]
    3506:	759f      	strb	r7, [r3, #22]
    3508:	75df      	strb	r7, [r3, #23]
    350a:	761f      	strb	r7, [r3, #24]
    350c:	765f      	strb	r7, [r3, #25]
    350e:	769f      	strb	r7, [r3, #26]
    3510:	76df      	strb	r7, [r3, #27]
    3512:	771f      	strb	r7, [r3, #28]
    3514:	775f      	strb	r7, [r3, #29]
    g_xfr_buf_ptr = 0;
    3516:	606f      	str	r7, [r5, #4]
    g_xfr_buf_len = 0u;
    3518:	60ef      	str	r7, [r5, #12]
    g_xfr_lba_addr = 0u;
    351a:	612f      	str	r7, [r5, #16]
      /*
      We calculate the Bulk endpoint sizes and max_pkt_size based on the
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    351c:	d045      	beq.n	35aa <usbd_msc_init_cb+0xfa>
        bulk_txep_fifo_sz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
        bulk_txep_maxpktsz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    351e:	2900      	cmp	r1, #0
    3520:	d034      	beq.n	358c <usbd_msc_init_cb+0xdc>
    3522:	46ba      	mov	sl, r7
    3524:	463b      	mov	r3, r7
    3526:	463a      	mov	r2, r7
    else
    {
        ASSERT(0); /*speed value can not be any other than FS or HS*/
    }

    MSS_USBD_rx_ep_configure(MSC_CLASS_BULK_RX_EP,
    3528:	2401      	movs	r4, #1
    352a:	2600      	movs	r6, #0
    352c:	f04f 0802 	mov.w	r8, #2
    3530:	f44f 7180 	mov.w	r1, #256	; 0x100
    3534:	4620      	mov	r0, r4
    3536:	9400      	str	r4, [sp, #0]
    3538:	9401      	str	r4, [sp, #4]
    353a:	9602      	str	r6, [sp, #8]
    353c:	f8cd 800c 	str.w	r8, [sp, #12]
    3540:	9604      	str	r6, [sp, #16]
    3542:	f7fe fbf5 	bl	1d30 <MSS_USBD_rx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL1,
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
    3546:	f640 31b8 	movw	r1, #3000	; 0xbb8
    354a:	4620      	mov	r0, r4
    354c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    3550:	221f      	movs	r2, #31
    3552:	f7fe fbc9 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
                                (uint8_t*)&g_bot_cbw,
                                USBD_MSC_BOT_CBW_LENGTH);

    MSS_USBD_tx_ep_configure(MSC_CLASS_BULK_TX_EP,
    3556:	4652      	mov	r2, sl
    3558:	463b      	mov	r3, r7
    355a:	4620      	mov	r0, r4
    355c:	f44f 7140 	mov.w	r1, #768	; 0x300
    3560:	f8cd 800c 	str.w	r8, [sp, #12]
    3564:	9400      	str	r4, [sp, #0]
    3566:	9401      	str	r4, [sp, #4]
    3568:	9402      	str	r4, [sp, #8]
    356a:	9604      	str	r6, [sp, #16]
    356c:	f7fe fc58 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    g_usbd_msc_state = USBD_MSC_CONFIGURED;

    if(0 != g_usbd_msc_media_ops->media_init)
    3570:	f640 32b0 	movw	r2, #2992	; 0xbb0
    3574:	f2c2 0200 	movt	r2, #8192	; 0x2000
    3578:	6810      	ldr	r0, [r2, #0]
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL2,
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    g_usbd_msc_state = USBD_MSC_CONFIGURED;
    357a:	702c      	strb	r4, [r5, #0]

    if(0 != g_usbd_msc_media_ops->media_init)
    357c:	6803      	ldr	r3, [r0, #0]
    357e:	b10b      	cbz	r3, 3584 <usbd_msc_init_cb+0xd4>
    {
        g_usbd_msc_media_ops->media_init(0);/*Todo:Remove the lun parameter*/
    3580:	4630      	mov	r0, r6
    3582:	4798      	blx	r3
    }

    return USB_SUCCESS;
}
    3584:	2001      	movs	r0, #1
    3586:	b007      	add	sp, #28
    3588:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((msc_hs_conf_descr[23u] << 8u) | (msc_hs_conf_descr[22u]));
    358c:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
        bulk_txep_maxpktsz = (uint16_t)((msc_hs_conf_descr[23u] << 8u) | (msc_hs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_hs_conf_descr[30u] << 8u) | (msc_hs_conf_descr[29u]));
    3590:	f890 e03d 	ldrb.w	lr, [r0, #61]	; 0x3d
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((msc_hs_conf_descr[23u] << 8u) | (msc_hs_conf_descr[22u]));
    3594:	f890 c036 	ldrb.w	ip, [r0, #54]	; 0x36
        bulk_txep_maxpktsz = (uint16_t)((msc_hs_conf_descr[23u] << 8u) | (msc_hs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_hs_conf_descr[30u] << 8u) | (msc_hs_conf_descr[29u]));
    3598:	f890 803e 	ldrb.w	r8, [r0, #62]	; 0x3e
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((msc_hs_conf_descr[23u] << 8u) | (msc_hs_conf_descr[22u]));
    359c:	ea4c 2a03 	orr.w	sl, ip, r3, lsl #8
        bulk_txep_maxpktsz = (uint16_t)((msc_hs_conf_descr[23u] << 8u) | (msc_hs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_hs_conf_descr[30u] << 8u) | (msc_hs_conf_descr[29u]));
    35a0:	ea4e 2208 	orr.w	r2, lr, r8, lsl #8
    35a4:	4657      	mov	r7, sl
    35a6:	4613      	mov	r3, r2
    35a8:	e7be      	b.n	3528 <usbd_msc_init_cb+0x78>
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
        bulk_txep_maxpktsz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    35aa:	7f47      	ldrb	r7, [r0, #29]
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
    35ac:	f890 a017 	ldrb.w	sl, [r0, #23]
    35b0:	7d81      	ldrb	r1, [r0, #22]
        bulk_txep_maxpktsz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    35b2:	7f86      	ldrb	r6, [r0, #30]
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
    35b4:	ea41 2a0a 	orr.w	sl, r1, sl, lsl #8
        bulk_txep_maxpktsz = (uint16_t)((msc_fs_conf_descr[23u] << 8u) | (msc_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((msc_fs_conf_descr[30u] << 8u) | (msc_fs_conf_descr[29u]));
    35b8:	ea47 2206 	orr.w	r2, r7, r6, lsl #8
    35bc:	4613      	mov	r3, r2
    35be:	4657      	mov	r7, sl
    35c0:	e7b2      	b.n	3528 <usbd_msc_init_cb+0x78>
    35c2:	bf00      	nop

000035c4 <MSS_USBD_MSC_init>:
(
    mss_usbd_msc_media_t* media_ops,
    mss_usb_device_speed_t speed
)
{
    g_usbd_msc_media_ops = media_ops;
    35c4:	f640 32b0 	movw	r2, #2992	; 0xbb0
    35c8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    35cc:	6010      	str	r0, [r2, #0]
    g_usbd_msc_user_speed = speed;
    35ce:	f640 33b4 	movw	r3, #2996	; 0xbb4

    MSS_USBD_set_class_cb_handler(&usb_msd_class_cb);
    35d2:	4803      	ldr	r0, [pc, #12]	; (35e0 <MSS_USBD_MSC_init+0x1c>)
    mss_usbd_msc_media_t* media_ops,
    mss_usb_device_speed_t speed
)
{
    g_usbd_msc_media_ops = media_ops;
    g_usbd_msc_user_speed = speed;
    35d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35d8:	7019      	strb	r1, [r3, #0]

    MSS_USBD_set_class_cb_handler(&usb_msd_class_cb);
    35da:	f7fd bf6b 	b.w	14b4 <MSS_USBD_set_class_cb_handler>
    35de:	bf00      	nop
    35e0:	200002c4 	.word	0x200002c4

000035e4 <usbd_msc_bot_fsm>:
usbd_msc_bot_fsm
(
    uint8_t status,
    uint32_t rx_count
)
{
    35e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t cb_result = CB_INTERNAL_ERROR;
    switch (g_bot_state)
    35e8:	f640 33d8 	movw	r3, #3032	; 0xbd8
    35ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    35f0:	781a      	ldrb	r2, [r3, #0]
usbd_msc_bot_fsm
(
    uint8_t status,
    uint32_t rx_count
)
{
    35f2:	b087      	sub	sp, #28
    uint8_t cb_result = CB_INTERNAL_ERROR;
    switch (g_bot_state)
    35f4:	2a04      	cmp	r2, #4
    35f6:	d80b      	bhi.n	3610 <usbd_msc_bot_fsm+0x2c>
    35f8:	e8df f012 	tbh	[pc, r2, lsl #1]
    35fc:	00280014 	.word	0x00280014
    3600:	00cc007e 	.word	0x00cc007e
    3604:	0005      	.short	0x0005
            }
        break;

        case BOT_ABORTED:
        {
            g_bot_state = BOT_ABORTED;
    3606:	2404      	movs	r4, #4
            usbd_msc_abort_cbw(0u);
    3608:	2000      	movs	r0, #0
            }
        break;

        case BOT_ABORTED:
        {
            g_bot_state = BOT_ABORTED;
    360a:	701c      	strb	r4, [r3, #0]
            usbd_msc_abort_cbw(0u);
    360c:	f7ff ff40 	bl	3490 <usbd_msc_abort_cbw>
    3610:	f640 14b8 	movw	r4, #2488	; 0x9b8
    3614:	f2c2 0400 	movt	r4, #8192	; 0x2000
            ASSERT(0);  //invalid BOT state
        }
        break;
    }

    g_bottx_events = BOT_EVENT_IDLE;
    3618:	2300      	movs	r3, #0
    361a:	7263      	strb	r3, [r4, #9]
    g_botrx_events = BOT_EVENT_IDLE;
    361c:	72a3      	strb	r3, [r4, #10]
}
    361e:	b007      	add	sp, #28
    3620:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
    uint8_t cb_result = CB_INTERNAL_ERROR;
    switch (g_bot_state)
    {
    case BOT_IDLE:
        if(BOT_EVENT_RX == g_botrx_events)
    3624:	f640 14b8 	movw	r4, #2488	; 0x9b8
    3628:	f2c2 0400 	movt	r4, #8192	; 0x2000
    362c:	7aa3      	ldrb	r3, [r4, #10]
    362e:	2b02      	cmp	r3, #2
    3630:	d1f2      	bne.n	3618 <usbd_msc_bot_fsm+0x34>
        {
            if(rx_count != USBD_MSC_BOT_CBW_LENGTH )
    3632:	291f      	cmp	r1, #31
    3634:	f000 80e0 	beq.w	37f8 <usbd_msc_bot_fsm+0x214>
            {
                g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    3638:	f240 2174 	movw	r1, #628	; 0x274
    363c:	f2c2 0100 	movt	r1, #8192	; 0x2000
                usbd_msc_abort_cbw(0u);
    3640:	2000      	movs	r0, #0
    case BOT_IDLE:
        if(BOT_EVENT_RX == g_botrx_events)
        {
            if(rx_count != USBD_MSC_BOT_CBW_LENGTH )
            {
                g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    3642:	f881 304c 	strb.w	r3, [r1, #76]	; 0x4c
                usbd_msc_abort_cbw(0u);
    3646:	f7ff ff23 	bl	3490 <usbd_msc_abort_cbw>
    364a:	e7e5      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                ASSERT(0);/*corrupt g_bottx_events value*/
            }
        break;

        case BOT_DATA_RX:
            if(BOT_EVENT_RX == g_botrx_events)
    364c:	f640 14b8 	movw	r4, #2488	; 0x9b8
    3650:	f2c2 0400 	movt	r4, #8192	; 0x2000
    3654:	f894 c00a 	ldrb.w	ip, [r4, #10]
    3658:	f1bc 0f02 	cmp.w	ip, #2
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    usbd_msc_send_csw();
                }
            }
            else if(BOT_EVENT_RX_ERROR == g_botrx_events)
    365c:	bf18      	it	ne
    365e:	f894 c00a 	ldrbne.w	ip, [r4, #10]
                ASSERT(0);/*corrupt g_bottx_events value*/
            }
        break;

        case BOT_DATA_RX:
            if(BOT_EVENT_RX == g_botrx_events)
    3662:	d1d9      	bne.n	3618 <usbd_msc_bot_fsm+0x34>
            {
                if(SCSI_COMMAND_LESSDATAPASS == g_current_command_csw.status)
    3664:	f240 2574 	movw	r5, #628	; 0x274
    3668:	f2c2 0500 	movt	r5, #8192	; 0x2000
    366c:	f895 304c 	ldrb.w	r3, [r5, #76]	; 0x4c
    3670:	2b03      	cmp	r3, #3
    3672:	f000 810f 	beq.w	3894 <usbd_msc_bot_fsm+0x2b0>
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_PASS;
                    usbd_msc_stallin_sendstatus();
                }
                else if(SCSI_COMMAND_PASS == g_current_command_csw.status)
    3676:	2b00      	cmp	r3, #0
    3678:	f040 80b4 	bne.w	37e4 <usbd_msc_bot_fsm+0x200>
                {
                    uint8_t result = CB_DATAPHASE_ERROR;

                    if(g_current_command_csw.data_residue >= g_xfr_buf_len)
    367c:	6caa      	ldr	r2, [r5, #72]	; 0x48
    367e:	68e3      	ldr	r3, [r4, #12]
    3680:	429a      	cmp	r2, r3
    3682:	d301      	bcc.n	3688 <usbd_msc_bot_fsm+0xa4>
                    {
                        g_current_command_csw.data_residue -= g_xfr_buf_len;
    3684:	1ad6      	subs	r6, r2, r3
    3686:	64ae      	str	r6, [r5, #72]	; 0x48
                    else
                    {
                        result = CB_DATAPHASE_ERROR;
                    }

                    if(0 != g_usbd_msc_media_ops->media_write_ready)
    3688:	f640 36b0 	movw	r6, #2992	; 0xbb0
    368c:	f2c2 0600 	movt	r6, #8192	; 0x2000
    3690:	6830      	ldr	r0, [r6, #0]
    3692:	6983      	ldr	r3, [r0, #24]
    3694:	2b00      	cmp	r3, #0
    3696:	f000 8106 	beq.w	38a6 <usbd_msc_bot_fsm+0x2c2>
                    {
                        g_usbd_msc_media_ops->media_write_ready(g_bot_cbw.lun,
    369a:	f640 37b8 	movw	r7, #3000	; 0xbb8
    369e:	f2c2 0700 	movt	r7, #8192	; 0x2000
    36a2:	6921      	ldr	r1, [r4, #16]
    36a4:	68e2      	ldr	r2, [r4, #12]
    36a6:	7b78      	ldrb	r0, [r7, #13]
    36a8:	4798      	blx	r3
                    {
                        /*
                        data_residue == 0 means we are done with current Data
                        phase of OUT transaction, send the status.
                        */
                        if(0u == g_current_command_csw.data_residue)
    36aa:	6ca9      	ldr	r1, [r5, #72]	; 0x48
                        result = CB_DATAPHASE_ERROR;
                    }

                    if(0 != g_usbd_msc_media_ops->media_write_ready)
                    {
                        g_usbd_msc_media_ops->media_write_ready(g_bot_cbw.lun,
    36ac:	f640 12b8 	movw	r2, #2488	; 0x9b8
                    {
                        /*
                        data_residue == 0 means we are done with current Data
                        phase of OUT transaction, send the status.
                        */
                        if(0u == g_current_command_csw.data_residue)
    36b0:	f240 2374 	movw	r3, #628	; 0x274
                        result = CB_DATAPHASE_ERROR;
                    }

                    if(0 != g_usbd_msc_media_ops->media_write_ready)
                    {
                        g_usbd_msc_media_ops->media_write_ready(g_bot_cbw.lun,
    36b4:	f2c2 0200 	movt	r2, #8192	; 0x2000
                    {
                        /*
                        data_residue == 0 means we are done with current Data
                        phase of OUT transaction, send the status.
                        */
                        if(0u == g_current_command_csw.data_residue)
    36b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    36bc:	2900      	cmp	r1, #0
    36be:	f000 812e 	beq.w	391e <usbd_msc_bot_fsm+0x33a>
                            progress.
                            Prepare to write more data on flash
                            */
                            g_xfr_lba_addr += g_xfr_buf_len;

                            if(0 != g_usbd_msc_media_ops->media_acquire_write_buf)
    36c2:	6833      	ldr	r3, [r6, #0]
                            /*
                            Data phase of current OUT transaction is still in
                            progress.
                            Prepare to write more data on flash
                            */
                            g_xfr_lba_addr += g_xfr_buf_len;
    36c4:	6911      	ldr	r1, [r2, #16]
    36c6:	68d0      	ldr	r0, [r2, #12]

                            if(0 != g_usbd_msc_media_ops->media_acquire_write_buf)
    36c8:	695b      	ldr	r3, [r3, #20]
                            /*
                            Data phase of current OUT transaction is still in
                            progress.
                            Prepare to write more data on flash
                            */
                            g_xfr_lba_addr += g_xfr_buf_len;
    36ca:	1841      	adds	r1, r0, r1
    36cc:	6111      	str	r1, [r2, #16]

                            if(0 != g_usbd_msc_media_ops->media_acquire_write_buf)
    36ce:	b11b      	cbz	r3, 36d8 <usbd_msc_bot_fsm+0xf4>
                                write_buf = g_usbd_msc_media_ops->media_acquire_write_buf(g_bot_cbw.lun,
    36d0:	7b78      	ldrb	r0, [r7, #13]
    36d2:	aa03      	add	r2, sp, #12
    36d4:	4798      	blx	r3
    36d6:	4603      	mov	r3, r0
                            requested data from Host,then read amount of data
                            that the application can handle at the moment.
                            */
                            if(app_write_len < g_current_command_csw.data_residue)
                            {
                                g_xfr_buf_len = app_write_len;
    36d8:	9903      	ldr	r1, [sp, #12]
                            /*
                            If application buffer is not big enough to handle all
                            requested data from Host,then read amount of data
                            that the application can handle at the moment.
                            */
                            if(app_write_len < g_current_command_csw.data_residue)
    36da:	6caa      	ldr	r2, [r5, #72]	; 0x48
                            {
                                g_xfr_buf_len = g_current_command_csw.data_residue;
                            }

                            g_xfr_buf_ptr = write_buf;
                            g_current_command_csw.status = SCSI_COMMAND_PASS;
    36dc:	f04f 0e00 	mov.w	lr, #0
                            requested data from Host,then read amount of data
                            that the application can handle at the moment.
                            */
                            if(app_write_len < g_current_command_csw.data_residue)
                            {
                                g_xfr_buf_len = app_write_len;
    36e0:	4291      	cmp	r1, r2
    36e2:	bf38      	it	cc
    36e4:	460a      	movcc	r2, r1
                                g_xfr_buf_len = g_current_command_csw.data_residue;
                            }

                            g_xfr_buf_ptr = write_buf;
                            g_current_command_csw.status = SCSI_COMMAND_PASS;
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
    36e6:	4618      	mov	r0, r3
    36e8:	4611      	mov	r1, r2
                            {
                                g_xfr_buf_len = g_current_command_csw.data_residue;
                            }

                            g_xfr_buf_ptr = write_buf;
                            g_current_command_csw.status = SCSI_COMMAND_PASS;
    36ea:	f885 e04c 	strb.w	lr, [r5, #76]	; 0x4c
                            requested data from Host,then read amount of data
                            that the application can handle at the moment.
                            */
                            if(app_write_len < g_current_command_csw.data_residue)
                            {
                                g_xfr_buf_len = app_write_len;
    36ee:	60e2      	str	r2, [r4, #12]
                            else
                            {
                                g_xfr_buf_len = g_current_command_csw.data_residue;
                            }

                            g_xfr_buf_ptr = write_buf;
    36f0:	6063      	str	r3, [r4, #4]
                            g_current_command_csw.status = SCSI_COMMAND_PASS;
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
    36f2:	f7ff fe23 	bl	333c <usbd_msc_receive_data>
    36f6:	e78f      	b.n	3618 <usbd_msc_bot_fsm+0x34>
            ASSERT(0);
        }

    break;
        case BOT_DATA_TX:
            if(BOT_EVENT_TX == g_bottx_events) /* Data TX from Device*/
    36f8:	f640 14b8 	movw	r4, #2488	; 0x9b8
    36fc:	f2c2 0400 	movt	r4, #8192	; 0x2000
    3700:	f894 c009 	ldrb.w	ip, [r4, #9]
    3704:	f1bc 0f01 	cmp.w	ip, #1
                else
                {
                    ASSERT(0); //should never come there with Phase Error status
                }
            }
            else if(BOT_EVENT_TX_ERROR == g_bottx_events)
    3708:	bf18      	it	ne
    370a:	f894 c009 	ldrbne.w	ip, [r4, #9]
            ASSERT(0);
        }

    break;
        case BOT_DATA_TX:
            if(BOT_EVENT_TX == g_bottx_events) /* Data TX from Device*/
    370e:	d183      	bne.n	3618 <usbd_msc_bot_fsm+0x34>
            {
                if(SCSI_COMMAND_LESSDATAPASS == g_current_command_csw.status)
    3710:	f240 2574 	movw	r5, #628	; 0x274
    3714:	f2c2 0500 	movt	r5, #8192	; 0x2000
    3718:	f895 304c 	ldrb.w	r3, [r5, #76]	; 0x4c
    371c:	2b03      	cmp	r3, #3
    371e:	f000 80b9 	beq.w	3894 <usbd_msc_bot_fsm+0x2b0>
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_PASS;
                    usbd_msc_stallin_sendstatus();
                }
                else if(SCSI_COMMAND_PASS == g_current_command_csw.status)
    3722:	2b00      	cmp	r3, #0
    3724:	d154      	bne.n	37d0 <usbd_msc_bot_fsm+0x1ec>
                {
                    if(g_current_command_csw.data_residue >= g_xfr_buf_len)
    3726:	6cab      	ldr	r3, [r5, #72]	; 0x48
    3728:	68e2      	ldr	r2, [r4, #12]
    372a:	4293      	cmp	r3, r2
    372c:	d301      	bcc.n	3732 <usbd_msc_bot_fsm+0x14e>
                    {
                        g_current_command_csw.data_residue -= g_xfr_buf_len;
    372e:	1a9b      	subs	r3, r3, r2
    3730:	64ab      	str	r3, [r5, #72]	; 0x48
                    else
                    {
                        ASSERT(0);/*corrupt/invalid data_residue value*/
                    }

                    if(0u == g_current_command_csw.data_residue)
    3732:	2b00      	cmp	r3, #0
    3734:	f000 80eb 	beq.w	390e <usbd_msc_bot_fsm+0x32a>
                         of the data now.
                        */
                        uint32_t actual_read_len;
                        uint8_t* buf;

                        if(0 != g_usbd_msc_media_ops->media_read)
    3738:	f640 36b0 	movw	r6, #2992	; 0xbb0
    373c:	f2c2 0600 	movt	r6, #8192	; 0x2000
    3740:	6830      	ldr	r0, [r6, #0]
    3742:	6906      	ldr	r6, [r0, #16]
    3744:	2e00      	cmp	r6, #0
    3746:	f000 80f2 	beq.w	392e <usbd_msc_bot_fsm+0x34a>
                        {
                            g_xfr_lba_addr += g_xfr_buf_len;
    374a:	6922      	ldr	r2, [r4, #16]
    374c:	68e0      	ldr	r0, [r4, #12]
                            actual_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    374e:	f640 33b8 	movw	r3, #3000	; 0xbb8
                        uint32_t actual_read_len;
                        uint8_t* buf;

                        if(0 != g_usbd_msc_media_ops->media_read)
                        {
                            g_xfr_lba_addr += g_xfr_buf_len;
    3752:	1882      	adds	r2, r0, r2
                            actual_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    3754:	f2c2 0300 	movt	r3, #8192	; 0x2000
                        uint32_t actual_read_len;
                        uint8_t* buf;

                        if(0 != g_usbd_msc_media_ops->media_read)
                        {
                            g_xfr_lba_addr += g_xfr_buf_len;
    3758:	6122      	str	r2, [r4, #16]
                            actual_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    375a:	7b58      	ldrb	r0, [r3, #13]
    375c:	a905      	add	r1, sp, #20
    375e:	6cab      	ldr	r3, [r5, #72]	; 0x48
    3760:	47b0      	blx	r6
                                                                               &buf,
                                                                               g_xfr_lba_addr,
                                                                               g_current_command_csw.data_residue);
                            if (actual_read_len > g_current_command_csw.data_residue)
    3762:	6ca9      	ldr	r1, [r5, #72]	; 0x48
                        uint32_t actual_read_len;
                        uint8_t* buf;

                        if(0 != g_usbd_msc_media_ops->media_read)
                        {
                            g_xfr_lba_addr += g_xfr_buf_len;
    3764:	f640 13b8 	movw	r3, #2488	; 0x9b8
                            actual_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    3768:	f240 2274 	movw	r2, #628	; 0x274
                                                                               &buf,
                                                                               g_xfr_lba_addr,
                                                                               g_current_command_csw.data_residue);
                            if (actual_read_len > g_current_command_csw.data_residue)
    376c:	4288      	cmp	r0, r1
                        uint8_t* buf;

                        if(0 != g_usbd_msc_media_ops->media_read)
                        {
                            g_xfr_lba_addr += g_xfr_buf_len;
                            actual_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    376e:	4606      	mov	r6, r0
                        uint32_t actual_read_len;
                        uint8_t* buf;

                        if(0 != g_usbd_msc_media_ops->media_read)
                        {
                            g_xfr_lba_addr += g_xfr_buf_len;
    3770:	f2c2 0300 	movt	r3, #8192	; 0x2000
                            actual_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    3774:	f2c2 0200 	movt	r2, #8192	; 0x2000
                                                                               &buf,
                                                                               g_xfr_lba_addr,
                                                                               g_current_command_csw.data_residue);
                            if (actual_read_len > g_current_command_csw.data_residue)
    3778:	f63f af4e 	bhi.w	3618 <usbd_msc_bot_fsm+0x34>
                            {
                                ASSERT(0);/*App should not read more data than asked for*/
                            }
                            else
                            {
                                g_xfr_buf_ptr = buf;
    377c:	9d05      	ldr	r5, [sp, #20]
                                g_xfr_buf_len = actual_read_len;
                                g_current_command_csw.status = SCSI_COMMAND_PASS;
    377e:	f04f 0e00 	mov.w	lr, #0
                                usbd_msc_send_data(buf, g_xfr_buf_len);
    3782:	4601      	mov	r1, r0
                            }
                            else
                            {
                                g_xfr_buf_ptr = buf;
                                g_xfr_buf_len = actual_read_len;
                                g_current_command_csw.status = SCSI_COMMAND_PASS;
    3784:	f882 e04c 	strb.w	lr, [r2, #76]	; 0x4c
                                usbd_msc_send_data(buf, g_xfr_buf_len);
    3788:	4628      	mov	r0, r5
                                ASSERT(0);/*App should not read more data than asked for*/
                            }
                            else
                            {
                                g_xfr_buf_ptr = buf;
                                g_xfr_buf_len = actual_read_len;
    378a:	60de      	str	r6, [r3, #12]
                            {
                                ASSERT(0);/*App should not read more data than asked for*/
                            }
                            else
                            {
                                g_xfr_buf_ptr = buf;
    378c:	605d      	str	r5, [r3, #4]
                                g_xfr_buf_len = actual_read_len;
                                g_current_command_csw.status = SCSI_COMMAND_PASS;
                                usbd_msc_send_data(buf, g_xfr_buf_len);
    378e:	f7ff fe57 	bl	3440 <usbd_msc_send_data>
    3792:	e741      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                ASSERT(0); //invalid g_botrx_events
            }
        break;

        case BOT_SEND_STATUS:
            if(BOT_EVENT_TX == g_bottx_events)
    3794:	f640 14b8 	movw	r4, #2488	; 0x9b8
    3798:	f2c2 0400 	movt	r4, #8192	; 0x2000
    379c:	f894 c009 	ldrb.w	ip, [r4, #9]
    37a0:	f1bc 0f01 	cmp.w	ip, #1
    37a4:	d049      	beq.n	383a <usbd_msc_bot_fsm+0x256>
                /*Prepare to receive next command*/
                MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
                                            (uint8_t*)&g_bot_cbw,
                                            USBD_MSC_BOT_CBW_LENGTH);
            }
            else if(BOT_EVENT_TX_ERROR == g_bottx_events)
    37a6:	f894 c009 	ldrb.w	ip, [r4, #9]
    37aa:	f1bc 0f03 	cmp.w	ip, #3
    37ae:	f47f af33 	bne.w	3618 <usbd_msc_bot_fsm+0x34>
            {
                /* Stall Error*/
                if(status & TX_EP_STALL_ERROR)
    37b2:	f010 0f02 	tst.w	r0, #2
    37b6:	f43f af2f 	beq.w	3618 <usbd_msc_bot_fsm+0x34>
                {
                    if(g_current_command_csw.status == SCSI_COMMAND_LESSDATAPASS)
    37ba:	f240 2374 	movw	r3, #628	; 0x274
    37be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    37c2:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
    37c6:	2a03      	cmp	r2, #3
    37c8:	d031      	beq.n	382e <usbd_msc_bot_fsm+0x24a>
                else if(SCSI_COMMAND_FAIL == g_current_command_csw.status)
                {
                    g_xfr_buf_ptr = 0;
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    usbd_msc_send_csw();
    37ca:	f7ff fe47 	bl	345c <usbd_msc_send_csw>
    37ce:	e723      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                            g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
                            usbd_msc_abort_cbw(0u);             //Internal Error
                        }
                    }
                }
                else if(SCSI_COMMAND_FAIL == g_current_command_csw.status)
    37d0:	2b01      	cmp	r3, #1
    37d2:	f47f af21 	bne.w	3618 <usbd_msc_bot_fsm+0x34>
                {
                    g_xfr_buf_ptr = (uint8_t*)0;
    37d6:	2300      	movs	r3, #0
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
    37d8:	6123      	str	r3, [r4, #16]
                        }
                    }
                }
                else if(SCSI_COMMAND_FAIL == g_current_command_csw.status)
                {
                    g_xfr_buf_ptr = (uint8_t*)0;
    37da:	6063      	str	r3, [r4, #4]
                    g_xfr_buf_len = 0u;
    37dc:	60e3      	str	r3, [r4, #12]
                    break;

                    case CB_INVALID_CDB_FIELD:
                        /*No data, only stall*/
                        g_current_command_csw.status = SCSI_COMMAND_FAIL;
                        usbd_msc_stallin_sendstatus();
    37de:	f7ff fe4d 	bl	347c <usbd_msc_stallin_sendstatus>
                    break;
    37e2:	e719      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                    {
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
                        usbd_msc_abort_cbw(0u);                //Internal Error
                    }
                }
                else if(SCSI_COMMAND_FAIL == g_current_command_csw.status)
    37e4:	2b01      	cmp	r3, #1
    37e6:	f47f af17 	bne.w	3618 <usbd_msc_bot_fsm+0x34>
                {
                    g_xfr_buf_ptr = 0;
    37ea:	2000      	movs	r0, #0
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
    37ec:	6120      	str	r0, [r4, #16]
                        usbd_msc_abort_cbw(0u);                //Internal Error
                    }
                }
                else if(SCSI_COMMAND_FAIL == g_current_command_csw.status)
                {
                    g_xfr_buf_ptr = 0;
    37ee:	6060      	str	r0, [r4, #4]
                    g_xfr_buf_len = 0u;
    37f0:	60e0      	str	r0, [r4, #12]
                    g_xfr_lba_addr = 0u;
                    usbd_msc_send_csw();
    37f2:	f7ff fe33 	bl	345c <usbd_msc_send_csw>
    37f6:	e70f      	b.n	3618 <usbd_msc_bot_fsm+0x34>
usbd_msc_process_cbw
(
    mss_usb_msc_cbw_t * cbw
)
{
    uint8_t cbw_command = cbw->cmd_block[0];
    37f8:	f640 35b8 	movw	r5, #3000	; 0xbb8
    37fc:	f2c2 0500 	movt	r5, #8192	; 0x2000
     Lun value is supported
     CBWCBLength and cbwcb are valid for the interface subclass.
     No. Max LUN index provided by App in get_max_lun request.
     */

    if((cbw->signature != USB_MSC_BOT_CBW_SIGNATURE) ||
    3800:	f245 3355 	movw	r3, #21333	; 0x5355
    3804:	6828      	ldr	r0, [r5, #0]
    mss_usb_msc_cbw_t * cbw
)
{
    uint8_t cbw_command = cbw->cmd_block[0];
    uint8_t result = CB_PASS;
    g_current_command_csw.tag = cbw->tag;
    3806:	f240 2674 	movw	r6, #628	; 0x274
    380a:	686a      	ldr	r2, [r5, #4]
     Lun value is supported
     CBWCBLength and cbwcb are valid for the interface subclass.
     No. Max LUN index provided by App in get_max_lun request.
     */

    if((cbw->signature != USB_MSC_BOT_CBW_SIGNATURE) ||
    380c:	f2c4 3342 	movt	r3, #17218	; 0x4342
    mss_usb_msc_cbw_t * cbw
)
{
    uint8_t cbw_command = cbw->cmd_block[0];
    uint8_t result = CB_PASS;
    g_current_command_csw.tag = cbw->tag;
    3810:	f2c2 0600 	movt	r6, #8192	; 0x2000
     Lun value is supported
     CBWCBLength and cbwcb are valid for the interface subclass.
     No. Max LUN index provided by App in get_max_lun request.
     */

    if((cbw->signature != USB_MSC_BOT_CBW_SIGNATURE) ||
    3814:	4298      	cmp	r0, r3
    mss_usb_msc_cbw_t * cbw
)
{
    uint8_t cbw_command = cbw->cmd_block[0];
    uint8_t result = CB_PASS;
    g_current_command_csw.tag = cbw->tag;
    3816:	6472      	str	r2, [r6, #68]	; 0x44
usbd_msc_process_cbw
(
    mss_usb_msc_cbw_t * cbw
)
{
    uint8_t cbw_command = cbw->cmd_block[0];
    3818:	7be9      	ldrb	r1, [r5, #15]
     Lun value is supported
     CBWCBLength and cbwcb are valid for the interface subclass.
     No. Max LUN index provided by App in get_max_lun request.
     */

    if((cbw->signature != USB_MSC_BOT_CBW_SIGNATURE) ||
    381a:	d04b      	beq.n	38b4 <usbd_msc_bot_fsm+0x2d0>
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    381c:	68ab      	ldr	r3, [r5, #8]
    381e:	64b3      	str	r3, [r6, #72]	; 0x48
                        usbd_msc_abort_cbw(0u);
                    break;

                    default:
                        /*Don't respond till reset recovery*/
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    3820:	2202      	movs	r2, #2
                        usbd_msc_abort_cbw(0u);                 //Internal Error
    3822:	2000      	movs	r0, #0
                        usbd_msc_abort_cbw(0u);
                    break;

                    default:
                        /*Don't respond till reset recovery*/
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    3824:	f886 204c 	strb.w	r2, [r6, #76]	; 0x4c
                        usbd_msc_abort_cbw(0u);                 //Internal Error
    3828:	f7ff fe32 	bl	3490 <usbd_msc_abort_cbw>
    382c:	e6f4      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                /* Stall Error*/
                if(status & TX_EP_STALL_ERROR)
                {
                    if(g_current_command_csw.status == SCSI_COMMAND_LESSDATAPASS)
                    {
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
    382e:	2100      	movs	r1, #0
    3830:	f883 104c 	strb.w	r1, [r3, #76]	; 0x4c
                else if(SCSI_COMMAND_FAIL == g_current_command_csw.status)
                {
                    g_xfr_buf_ptr = 0;
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    usbd_msc_send_csw();
    3834:	f7ff fe12 	bl	345c <usbd_msc_send_csw>
    3838:	e6ee      	b.n	3618 <usbd_msc_bot_fsm+0x34>
        break;

        case BOT_SEND_STATUS:
            if(BOT_EVENT_TX == g_bottx_events)
            {
                G_BOT_CBW_INIT();
    383a:	f640 36b8 	movw	r6, #3000	; 0xbb8
                g_current_command_csw.data_residue = 0u;
    383e:	f240 2774 	movw	r7, #628	; 0x274
        break;

        case BOT_SEND_STATUS:
            if(BOT_EVENT_TX == g_bottx_events)
            {
                G_BOT_CBW_INIT();
    3842:	2500      	movs	r5, #0
    3844:	f2c2 0600 	movt	r6, #8192	; 0x2000
                g_current_command_csw.data_residue = 0u;
    3848:	f2c2 0700 	movt	r7, #8192	; 0x2000
                g_xfr_buf_len = 0u;
                g_xfr_lba_addr = 0u;

                g_bot_state = BOT_IDLE;
                /*Prepare to receive next command*/
                MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
    384c:	4660      	mov	r0, ip
    384e:	4631      	mov	r1, r6
    3850:	221f      	movs	r2, #31
                g_current_command_csw.status = SCSI_COMMAND_FAIL;
                g_xfr_buf_ptr = (uint8_t*)0;
                g_xfr_buf_len = 0u;
                g_xfr_lba_addr = 0u;

                g_bot_state = BOT_IDLE;
    3852:	701d      	strb	r5, [r3, #0]
            if(BOT_EVENT_TX == g_bottx_events)
            {
                G_BOT_CBW_INIT();
                g_current_command_csw.data_residue = 0u;
                g_current_command_csw.tag = 0u;
                g_current_command_csw.status = SCSI_COMMAND_FAIL;
    3854:	f887 c04c 	strb.w	ip, [r7, #76]	; 0x4c
        break;

        case BOT_SEND_STATUS:
            if(BOT_EVENT_TX == g_bottx_events)
            {
                G_BOT_CBW_INIT();
    3858:	6035      	str	r5, [r6, #0]
    385a:	6075      	str	r5, [r6, #4]
    385c:	60b5      	str	r5, [r6, #8]
    385e:	7335      	strb	r5, [r6, #12]
    3860:	7375      	strb	r5, [r6, #13]
    3862:	73b5      	strb	r5, [r6, #14]
    3864:	73f5      	strb	r5, [r6, #15]
    3866:	7435      	strb	r5, [r6, #16]
    3868:	7475      	strb	r5, [r6, #17]
    386a:	74b5      	strb	r5, [r6, #18]
    386c:	74f5      	strb	r5, [r6, #19]
    386e:	7535      	strb	r5, [r6, #20]
    3870:	7575      	strb	r5, [r6, #21]
    3872:	75b5      	strb	r5, [r6, #22]
    3874:	75f5      	strb	r5, [r6, #23]
    3876:	7635      	strb	r5, [r6, #24]
    3878:	7675      	strb	r5, [r6, #25]
    387a:	76b5      	strb	r5, [r6, #26]
    387c:	76f5      	strb	r5, [r6, #27]
    387e:	7735      	strb	r5, [r6, #28]
    3880:	7775      	strb	r5, [r6, #29]
    3882:	77b5      	strb	r5, [r6, #30]
                g_current_command_csw.data_residue = 0u;
    3884:	64bd      	str	r5, [r7, #72]	; 0x48
                g_current_command_csw.tag = 0u;
    3886:	647d      	str	r5, [r7, #68]	; 0x44
                g_current_command_csw.status = SCSI_COMMAND_FAIL;
                g_xfr_buf_ptr = (uint8_t*)0;
    3888:	6065      	str	r5, [r4, #4]
                g_xfr_buf_len = 0u;
    388a:	60e5      	str	r5, [r4, #12]
                g_xfr_lba_addr = 0u;
    388c:	6125      	str	r5, [r4, #16]

                g_bot_state = BOT_IDLE;
                /*Prepare to receive next command*/
                MSS_USBD_rx_ep_read_prepare(MSC_CLASS_BULK_RX_EP,
    388e:	f7fe fa2b 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
    3892:	e6c1      	b.n	3618 <usbd_msc_bot_fsm+0x34>
        case BOT_DATA_RX:
            if(BOT_EVENT_RX == g_botrx_events)
            {
                if(SCSI_COMMAND_LESSDATAPASS == g_current_command_csw.status)
                {
                    g_xfr_buf_ptr = (uint8_t*)0;
    3894:	2200      	movs	r2, #0
                    g_xfr_buf_len = 0u;
                    g_xfr_lba_addr = 0u;
                    g_current_command_csw.status = SCSI_COMMAND_PASS;
    3896:	f885 204c 	strb.w	r2, [r5, #76]	; 0x4c
        case BOT_DATA_RX:
            if(BOT_EVENT_RX == g_botrx_events)
            {
                if(SCSI_COMMAND_LESSDATAPASS == g_current_command_csw.status)
                {
                    g_xfr_buf_ptr = (uint8_t*)0;
    389a:	6062      	str	r2, [r4, #4]
                    g_xfr_buf_len = 0u;
    389c:	60e2      	str	r2, [r4, #12]
                    g_xfr_lba_addr = 0u;
    389e:	6122      	str	r2, [r4, #16]
                    g_current_command_csw.status = SCSI_COMMAND_PASS;
                    usbd_msc_stallin_sendstatus();
    38a0:	f7ff fdec 	bl	347c <usbd_msc_stallin_sendstatus>
    38a4:	e6b8      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
                        }
                    }
                    else
                    {
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    38a6:	2202      	movs	r2, #2
                        usbd_msc_abort_cbw(0u);                //Internal Error
    38a8:	4618      	mov	r0, r3
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
                        }
                    }
                    else
                    {
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    38aa:	f885 204c 	strb.w	r2, [r5, #76]	; 0x4c
                        usbd_msc_abort_cbw(0u);                //Internal Error
    38ae:	f7ff fdef 	bl	3490 <usbd_msc_abort_cbw>
    38b2:	e6b1      	b.n	3618 <usbd_msc_bot_fsm+0x34>
     CBWCBLength and cbwcb are valid for the interface subclass.
     No. Max LUN index provided by App in get_max_lun request.
     */

    if((cbw->signature != USB_MSC_BOT_CBW_SIGNATURE) ||
       (cbw->lun > get_max_lun_response[0]) ||
    38b4:	7b68      	ldrb	r0, [r5, #13]
    38b6:	f894 c008 	ldrb.w	ip, [r4, #8]
    38ba:	4584      	cmp	ip, r0
    38bc:	d3ae      	bcc.n	381c <usbd_msc_bot_fsm+0x238>
       (cbw->cmd_length < 1) ||
    38be:	7bab      	ldrb	r3, [r5, #14]
     Lun value is supported
     CBWCBLength and cbwcb are valid for the interface subclass.
     No. Max LUN index provided by App in get_max_lun request.
     */

    if((cbw->signature != USB_MSC_BOT_CBW_SIGNATURE) ||
    38c0:	2b00      	cmp	r3, #0
    38c2:	d0ab      	beq.n	381c <usbd_msc_bot_fsm+0x238>
    38c4:	2b10      	cmp	r3, #16
    38c6:	d8a9      	bhi.n	381c <usbd_msc_bot_fsm+0x238>
        if(g_current_command_csw.data_residue != 0u)
        {
            ASSERT(0);
        }

        switch(cbw_command)
    38c8:	2923      	cmp	r1, #35	; 0x23
    38ca:	f000 81cd 	beq.w	3c68 <usbd_msc_bot_fsm+0x684>
    38ce:	d835      	bhi.n	393c <usbd_msc_bot_fsm+0x358>
    38d0:	2903      	cmp	r1, #3
    38d2:	f000 8126 	beq.w	3b22 <usbd_msc_bot_fsm+0x53e>
    38d6:	f200 814e 	bhi.w	3b76 <usbd_msc_bot_fsm+0x592>
    38da:	2900      	cmp	r1, #0
    38dc:	d134      	bne.n	3948 <usbd_msc_bot_fsm+0x364>
                g_req_type = SCSI_ZDR;
                g_xfr_buf_ptr = (uint8_t*)0;
                g_xfr_buf_len = 0u;

                /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
                if(0 != g_bot_cbw.xfr_length)
    38de:	68ab      	ldr	r3, [r5, #8]
            break;

            case USB_MSC_SCSI_TEST_UNIT_READY:
                g_req_type = SCSI_ZDR;
                g_xfr_buf_ptr = (uint8_t*)0;
                g_xfr_buf_len = 0u;
    38e0:	60e1      	str	r1, [r4, #12]
            case USB_MSC_SCSI_WRITE_10:
                result = usbd_msc_process_write_10();
            break;

            case USB_MSC_SCSI_TEST_UNIT_READY:
                g_req_type = SCSI_ZDR;
    38e2:	7521      	strb	r1, [r4, #20]
                g_xfr_buf_ptr = (uint8_t*)0;
    38e4:	6061      	str	r1, [r4, #4]
                g_xfr_buf_len = 0u;

                /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
                if(0 != g_bot_cbw.xfr_length)
    38e6:	2b00      	cmp	r3, #0
    38e8:	d162      	bne.n	39b0 <usbd_msc_bot_fsm+0x3cc>
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    38ea:	64b3      	str	r3, [r6, #72]	; 0x48

                switch(cb_result)
                {
                    case CB_PASS:
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
                        if(g_req_type == SCSI_OUT)
    38ec:	7d22      	ldrb	r2, [r4, #20]
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;

                switch(cb_result)
                {
                    case CB_PASS:
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
    38ee:	2100      	movs	r1, #0
                        if(g_req_type == SCSI_OUT)
    38f0:	f640 13b8 	movw	r3, #2488	; 0x9b8
    38f4:	2a02      	cmp	r2, #2
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;

                switch(cb_result)
                {
                    case CB_PASS:
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
    38f6:	f886 104c 	strb.w	r1, [r6, #76]	; 0x4c
                        if(g_req_type == SCSI_OUT)
    38fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    38fe:	f000 80b0 	beq.w	3a62 <usbd_msc_bot_fsm+0x47e>
                        {
                            //CASE:12 (Success)
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
                        }
                        else if(g_req_type == SCSI_IN)
    3902:	2a01      	cmp	r2, #1
    3904:	d043      	beq.n	398e <usbd_msc_bot_fsm+0x3aa>
                        {
                            //CASE:6 (Success)
                            usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
                        }
                        else if(g_req_type == SCSI_ZDR)
    3906:	2a00      	cmp	r2, #0
    3908:	f47f ae86 	bne.w	3618 <usbd_msc_bot_fsm+0x34>
    390c:	e75d      	b.n	37ca <usbd_msc_bot_fsm+0x1e6>
                    if(0u == g_current_command_csw.data_residue)
                    {
                        g_xfr_buf_ptr = (uint8_t*)0;
                        g_xfr_buf_len = 0u;
                        g_xfr_lba_addr = 0u;
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
    390e:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
                        ASSERT(0);/*corrupt/invalid data_residue value*/
                    }

                    if(0u == g_current_command_csw.data_residue)
                    {
                        g_xfr_buf_ptr = (uint8_t*)0;
    3912:	6063      	str	r3, [r4, #4]
                        g_xfr_buf_len = 0u;
    3914:	60e3      	str	r3, [r4, #12]
                        g_xfr_lba_addr = 0u;
    3916:	6123      	str	r3, [r4, #16]
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
                        usbd_msc_send_csw();
    3918:	f7ff fda0 	bl	345c <usbd_msc_send_csw>
    391c:	e67c      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                        if(0u == g_current_command_csw.data_residue)
                        {
                            g_xfr_buf_ptr = 0; // Data end.
                            g_xfr_buf_len = 0u;
                            g_xfr_lba_addr = 0u;
                            g_current_command_csw.status = SCSI_COMMAND_PASS;
    391e:	f883 104c 	strb.w	r1, [r3, #76]	; 0x4c
                        */
                        if(0u == g_current_command_csw.data_residue)
                        {
                            g_xfr_buf_ptr = 0; // Data end.
                            g_xfr_buf_len = 0u;
                            g_xfr_lba_addr = 0u;
    3922:	6111      	str	r1, [r2, #16]
                        data_residue == 0 means we are done with current Data
                        phase of OUT transaction, send the status.
                        */
                        if(0u == g_current_command_csw.data_residue)
                        {
                            g_xfr_buf_ptr = 0; // Data end.
    3924:	6051      	str	r1, [r2, #4]
                            g_xfr_buf_len = 0u;
    3926:	60d1      	str	r1, [r2, #12]
                            g_xfr_lba_addr = 0u;
                            g_current_command_csw.status = SCSI_COMMAND_PASS;
                            usbd_msc_send_csw();
    3928:	f7ff fd98 	bl	345c <usbd_msc_send_csw>
    392c:	e674      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                                usbd_msc_send_data(buf, g_xfr_buf_len);
                            }
                        }
                        else
                        {
                            g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    392e:	2102      	movs	r1, #2
                            usbd_msc_abort_cbw(0u);             //Internal Error
    3930:	4630      	mov	r0, r6
                                usbd_msc_send_data(buf, g_xfr_buf_len);
                            }
                        }
                        else
                        {
                            g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    3932:	f885 104c 	strb.w	r1, [r5, #76]	; 0x4c
                            usbd_msc_abort_cbw(0u);             //Internal Error
    3936:	f7ff fdab 	bl	3490 <usbd_msc_abort_cbw>
    393a:	e66d      	b.n	3618 <usbd_msc_bot_fsm+0x34>
        if(g_current_command_csw.data_residue != 0u)
        {
            ASSERT(0);
        }

        switch(cbw_command)
    393c:	2928      	cmp	r1, #40	; 0x28
    393e:	f000 8095 	beq.w	3a6c <usbd_msc_bot_fsm+0x488>
    3942:	d829      	bhi.n	3998 <usbd_msc_bot_fsm+0x3b4>
    3944:	2925      	cmp	r1, #37	; 0x25
    3946:	d06f      	beq.n	3a28 <usbd_msc_bot_fsm+0x444>

            break;

            default:
                result = CB_NOT_SUPPORTED;
                g_req_type = SCSI_IN;
    3948:	2201      	movs	r2, #1
    uint8_t lun,
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    394a:	1d11      	adds	r1, r2, #4
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    394c:	68ab      	ldr	r3, [r5, #8]
            break;

            default:
                result = CB_NOT_SUPPORTED;
                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = (uint8_t*)0;
    394e:	2000      	movs	r0, #0
    uint8_t lun,
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    3950:	f886 1072 	strb.w	r1, [r6, #114]	; 0x72
    g_sense_response.asc = asc;
    3954:	311f      	adds	r1, #31

            break;

            default:
                result = CB_NOT_SUPPORTED;
                g_req_type = SCSI_IN;
    3956:	7522      	strb	r2, [r4, #20]
                g_xfr_buf_ptr = (uint8_t*)0;
                g_xfr_buf_len = 0u;
    3958:	60e0      	str	r0, [r4, #12]
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    g_sense_response.asc = asc;
    395a:	f886 107c 	strb.w	r1, [r6, #124]	; 0x7c
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    395e:	64b3      	str	r3, [r6, #72]	; 0x48
            break;

            default:
                result = CB_NOT_SUPPORTED;
                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = (uint8_t*)0;
    3960:	6060      	str	r0, [r4, #4]

                    case CB_NOT_SUPPORTED:
                        /*Command Not supported.*/
                        g_current_command_csw.status = SCSI_COMMAND_FAIL;

                        if(0 == g_bot_cbw.xfr_length)
    3962:	68a8      	ldr	r0, [r5, #8]
    3964:	f640 33b8 	movw	r3, #3000	; 0xbb8
                        usbd_msc_stallin_sendstatus();
                    break;

                    case CB_NOT_SUPPORTED:
                        /*Command Not supported.*/
                        g_current_command_csw.status = SCSI_COMMAND_FAIL;
    3968:	2101      	movs	r1, #1
    396a:	f886 104c 	strb.w	r1, [r6, #76]	; 0x4c

                        if(0 == g_bot_cbw.xfr_length)
    396e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3972:	2800      	cmp	r0, #0
    3974:	f43f af33 	beq.w	37de <usbd_msc_bot_fsm+0x1fa>
                        {
                            usbd_msc_stallin_sendstatus();
                        }
                        else
                        {
                            if(g_bot_cbw.flags & 0x80u) //IN D2H
    3978:	f993 c00c 	ldrsb.w	ip, [r3, #12]
    397c:	f1bc 0f00 	cmp.w	ip, #0
    3980:	f6ff af2d 	blt.w	37de <usbd_msc_bot_fsm+0x1fa>
                            {
                                usbd_msc_stallin_sendstatus();
                            }
                            else    //OUT H2D
                            {
                                usbd_msc_stallout_sendstatus();
    3984:	f7ff fd52 	bl	342c <usbd_msc_stallout_sendstatus>
                                usbd_msc_stallin_sendstatus();
    3988:	f7ff fd78 	bl	347c <usbd_msc_stallin_sendstatus>
    398c:	e644      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
                        }
                        else if(g_req_type == SCSI_IN)
                        {
                            //CASE:6 (Success)
                            usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
    398e:	68d9      	ldr	r1, [r3, #12]
    3990:	6858      	ldr	r0, [r3, #4]
    3992:	f7ff fd55 	bl	3440 <usbd_msc_send_data>
    3996:	e63f      	b.n	3618 <usbd_msc_bot_fsm+0x34>
        if(g_current_command_csw.data_residue != 0u)
        {
            ASSERT(0);
        }

        switch(cbw_command)
    3998:	292a      	cmp	r1, #42	; 0x2a
    399a:	f000 819d 	beq.w	3cd8 <usbd_msc_bot_fsm+0x6f4>
    399e:	292f      	cmp	r1, #47	; 0x2f
    39a0:	d1d2      	bne.n	3948 <usbd_msc_bot_fsm+0x364>
                g_req_type = SCSI_ZDR;
                g_xfr_buf_ptr = (uint8_t*)0;
                g_xfr_buf_len = 0u;

                /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
                if(0 != g_bot_cbw.xfr_length)
    39a2:	68ab      	ldr	r3, [r5, #8]
                    result = CB_PASS;
                }

            break;
            case USB_MSC_SCSI_VERIFY_10:
                g_req_type = SCSI_ZDR;
    39a4:	2200      	movs	r2, #0
                g_xfr_buf_ptr = (uint8_t*)0;
                g_xfr_buf_len = 0u;
    39a6:	60e2      	str	r2, [r4, #12]
                    result = CB_PASS;
                }

            break;
            case USB_MSC_SCSI_VERIFY_10:
                g_req_type = SCSI_ZDR;
    39a8:	7522      	strb	r2, [r4, #20]
                g_xfr_buf_ptr = (uint8_t*)0;
    39aa:	6062      	str	r2, [r4, #4]
                g_xfr_buf_len = 0u;

                /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
                if(0 != g_bot_cbw.xfr_length)
    39ac:	2b00      	cmp	r3, #0
    39ae:	d09c      	beq.n	38ea <usbd_msc_bot_fsm+0x306>
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    39b0:	64b3      	str	r3, [r6, #72]	; 0x48
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
                        usbd_msc_abort_cbw(0u);
                    break;

                    case CB_LENGTH_MISMATCH:
                        if(SCSI_OUT == g_req_type)
    39b2:	7d23      	ldrb	r3, [r4, #20]
    39b4:	f640 12b8 	movw	r2, #2488	; 0x9b8
    39b8:	2b02      	cmp	r3, #2
    39ba:	f2c2 0200 	movt	r2, #8192	; 0x2000
    39be:	d015      	beq.n	39ec <usbd_msc_bot_fsm+0x408>
                                //CASE11(lvr:dont stall this)
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
                                usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
                            }
                        }
                        else if(SCSI_IN == g_req_type)
    39c0:	2b01      	cmp	r3, #1
    39c2:	d025      	beq.n	3a10 <usbd_msc_bot_fsm+0x42c>
                        }
                        else
                        {
                            g_current_command_csw.status = SCSI_COMMAND_FAIL;

                            if(g_bot_cbw.flags & 0x80u)
    39c4:	f995 e00c 	ldrsb.w	lr, [r5, #12]
                                usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
                            }
                        }
                        else
                        {
                            g_current_command_csw.status = SCSI_COMMAND_FAIL;
    39c8:	2201      	movs	r2, #1
    39ca:	f240 2374 	movw	r3, #628	; 0x274

                            if(g_bot_cbw.flags & 0x80u)
    39ce:	f1be 0f00 	cmp.w	lr, #0
                                usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
                            }
                        }
                        else
                        {
                            g_current_command_csw.status = SCSI_COMMAND_FAIL;
    39d2:	f886 204c 	strb.w	r2, [r6, #76]	; 0x4c
    39d6:	f2c2 0300 	movt	r3, #8192	; 0x2000

                            if(g_bot_cbw.flags & 0x80u)
    39da:	f6ff af00 	blt.w	37de <usbd_msc_bot_fsm+0x1fa>
                            {
                                usbd_msc_stallin_sendstatus();
                            }
                            else
                            {
                                g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    39de:	2102      	movs	r1, #2
                                usbd_msc_abort_cbw(0u);
    39e0:	2000      	movs	r0, #0
                            {
                                usbd_msc_stallin_sendstatus();
                            }
                            else
                            {
                                g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    39e2:	f883 104c 	strb.w	r1, [r3, #76]	; 0x4c
                                usbd_msc_abort_cbw(0u);
    39e6:	f7ff fd53 	bl	3490 <usbd_msc_abort_cbw>
    39ea:	e615      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                    break;

                    case CB_LENGTH_MISMATCH:
                        if(SCSI_OUT == g_req_type)
                        {
                            if(0u == g_xfr_buf_len)
    39ec:	68d1      	ldr	r1, [r2, #12]
    39ee:	b149      	cbz	r1, 3a04 <usbd_msc_bot_fsm+0x420>
                            {
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
                                usbd_msc_stallout_sendstatus();
                            }
                            else if(g_xfr_buf_len > g_bot_cbw.xfr_length)
    39f0:	68a8      	ldr	r0, [r5, #8]
    39f2:	4281      	cmp	r1, r0
    39f4:	d807      	bhi.n	3a06 <usbd_msc_bot_fsm+0x422>
                                usbd_msc_stallout_sendstatus();
                            }
                            else
                            {
                                //CASE11(lvr:dont stall this)
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
    39f6:	2301      	movs	r3, #1
                                usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
    39f8:	6850      	ldr	r0, [r2, #4]
                                usbd_msc_stallout_sendstatus();
                            }
                            else
                            {
                                //CASE11(lvr:dont stall this)
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
    39fa:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
                                usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
    39fe:	f7ff fc9d 	bl	333c <usbd_msc_receive_data>
    3a02:	e609      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                    case CB_LENGTH_MISMATCH:
                        if(SCSI_OUT == g_req_type)
                        {
                            if(0u == g_xfr_buf_len)
                            {
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
    3a04:	3b01      	subs	r3, #1
    3a06:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
                                usbd_msc_stallout_sendstatus();
    3a0a:	f7ff fd0f 	bl	342c <usbd_msc_stallout_sendstatus>
    3a0e:	e603      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                                usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
                            }
                        }
                        else if(SCSI_IN == g_req_type)
                        {
                            if(0u == g_xfr_buf_len)
    3a10:	68d1      	ldr	r1, [r2, #12]
    3a12:	2900      	cmp	r1, #0
    3a14:	d0f7      	beq.n	3a06 <usbd_msc_bot_fsm+0x422>
                            {
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
                                usbd_msc_stallout_sendstatus();
                            }
                            else if(g_xfr_buf_len > g_bot_cbw.xfr_length)
    3a16:	68a8      	ldr	r0, [r5, #8]
    3a18:	4281      	cmp	r1, r0
    3a1a:	d81c      	bhi.n	3a56 <usbd_msc_bot_fsm+0x472>
                                usbd_msc_stallin_sendstatus();
                            }
                            else
                            {
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
                                usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
    3a1c:	6850      	ldr	r0, [r2, #4]
                                g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
                                usbd_msc_stallin_sendstatus();
                            }
                            else
                            {
                                g_current_command_csw.status = SCSI_COMMAND_FAIL;
    3a1e:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
                                usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
    3a22:	f7ff fd0d 	bl	3440 <usbd_msc_send_data>
    3a26:	e5f7      	b.n	3618 <usbd_msc_bot_fsm+0x34>
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;
    g_req_type = SCSI_IN;
    
    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3a28:	f995 c00c 	ldrsb.w	ip, [r5, #12]

    /*
     Returns last block address and block size
     Last_blk_lba = no_of_blocks-1
    */
    g_xfr_buf_ptr = (uint8_t*)0;
    3a2c:	2300      	movs	r3, #0
    g_xfr_buf_len = 0u;
    g_req_type = SCSI_IN;
    3a2e:	2201      	movs	r2, #1

    /*
     Returns last block address and block size
     Last_blk_lba = no_of_blocks-1
    */
    g_xfr_buf_ptr = (uint8_t*)0;
    3a30:	f640 18b8 	movw	r8, #2488	; 0x9b8
    g_xfr_buf_len = 0u;
    g_req_type = SCSI_IN;
    
    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3a34:	f640 37b8 	movw	r7, #3000	; 0xbb8
    3a38:	459c      	cmp	ip, r3
    /*
     Returns last block address and block size
     Last_blk_lba = no_of_blocks-1
    */
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;
    3a3a:	60e3      	str	r3, [r4, #12]
    g_req_type = SCSI_IN;
    3a3c:	7522      	strb	r2, [r4, #20]

    /*
     Returns last block address and block size
     Last_blk_lba = no_of_blocks-1
    */
    g_xfr_buf_ptr = (uint8_t*)0;
    3a3e:	6063      	str	r3, [r4, #4]
    3a40:	f2c2 0800 	movt	r8, #8192	; 0x2000
    g_xfr_buf_len = 0u;
    g_req_type = SCSI_IN;
    
    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3a44:	f2c2 0700 	movt	r7, #8192	; 0x2000
    3a48:	f2c0 81ae 	blt.w	3da8 <usbd_msc_bot_fsm+0x7c4>
    {
        g_xfr_buf_len = 8u;
    3a4c:	3308      	adds	r3, #8
    3a4e:	f8c8 300c 	str.w	r3, [r8, #12]
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3a52:	68a9      	ldr	r1, [r5, #8]
    3a54:	64b1      	str	r1, [r6, #72]	; 0x48
                            }
                        }
                    break;

                    case CB_DATA_DIR_MISMATCH:
                        g_current_command_csw.status = SCSI_COMMAND_PHASE_ERR;
    3a56:	2302      	movs	r3, #2
    3a58:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
                        usbd_msc_stallin_sendstatus();
    3a5c:	f7ff fd0e 	bl	347c <usbd_msc_stallin_sendstatus>
                    break;
    3a60:	e5da      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                    case CB_PASS:
                        g_current_command_csw.status = SCSI_COMMAND_PASS;
                        if(g_req_type == SCSI_OUT)
                        {
                            //CASE:12 (Success)
                            usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
    3a62:	68d9      	ldr	r1, [r3, #12]
    3a64:	6858      	ldr	r0, [r3, #4]
    3a66:	f7ff fc69 	bl	333c <usbd_msc_receive_data>
    3a6a:	e5d5      	b.n	3618 <usbd_msc_bot_fsm+0x34>
           (g_bot_cbw.cmd_block[3u] << 16u) |
           (g_bot_cbw.cmd_block[4u] << 8u) |
            g_bot_cbw.cmd_block[5u];

    /*Block size was received in USB_MSC_SCSI_READ_CAPACITY_10 command*/
    lba_addr = (lba * lun_capacity[g_bot_cbw.lun].blk_sz_len);
    3a6c:	210c      	movs	r1, #12
    3a6e:	fb01 4700 	mla	r7, r1, r0, r4

    /*
    Number of LBAs to be read is provided in command block byte 7 to 8,
    calculate the total size to be read
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]) *
    3a72:	f895 9016 	ldrb.w	r9, [r5, #22]
    3a76:	f895 a017 	ldrb.w	sl, [r5, #23]
           (g_bot_cbw.cmd_block[3u] << 16u) |
           (g_bot_cbw.cmd_block[4u] << 8u) |
            g_bot_cbw.cmd_block[5u];

    /*Block size was received in USB_MSC_SCSI_READ_CAPACITY_10 command*/
    lba_addr = (lba * lun_capacity[g_bot_cbw.lun].blk_sz_len);
    3a7a:	6a39      	ldr	r1, [r7, #32]

    /*
    Number of LBAs to be read is provided in command block byte 7 to 8,
    calculate the total size to be read
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]) *
    3a7c:	ea4a 2809 	orr.w	r8, sl, r9, lsl #8
                                            lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3a80:	f995 c00c 	ldrsb.w	ip, [r5, #12]
    if(dev_data_len != g_bot_cbw.xfr_length)
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_read)
    3a84:	f640 33b0 	movw	r3, #2992	; 0xbb0
)
{
    uint32_t app_read_len = 0u;
    uint32_t lba = 0u;
    uint32_t lba_addr = 0u;
    uint8_t* buf = 0;
    3a88:	2200      	movs	r2, #0

    /*
    Number of LBAs to be read is provided in command block byte 7 to 8,
    calculate the total size to be read
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]) *
    3a8a:	fb01 f708 	mul.w	r7, r1, r8
    if(dev_data_len != g_bot_cbw.xfr_length)
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_read)
    3a8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
)
{
    uint32_t app_read_len = 0u;
    uint32_t lba = 0u;
    uint32_t lba_addr = 0u;
    uint8_t* buf = 0;
    3a92:	9205      	str	r2, [sp, #20]
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_IN;
    3a94:	3201      	adds	r2, #1
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]) *
                                            lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3a96:	f1bc 0f00 	cmp.w	ip, #0
    if(dev_data_len != g_bot_cbw.xfr_length)
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_read)
    3a9a:	f8d3 c000 	ldr.w	ip, [r3]
    {
        g_xfr_buf_len = dev_data_len;
        cb_res = CB_DATA_DIR_MISMATCH;
    }
    /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
    if(dev_data_len != g_bot_cbw.xfr_length)
    3a9e:	68ab      	ldr	r3, [r5, #8]
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_read)
    3aa0:	f8dc c010 	ldr.w	ip, [ip, #16]
    uint32_t lba_addr = 0u;
    uint8_t* buf = 0;
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_IN;
    3aa4:	7522      	strb	r2, [r4, #20]
                                            lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    {
        g_xfr_buf_len = dev_data_len;
    3aa6:	bfa4      	itt	ge
    3aa8:	60e7      	strge	r7, [r4, #12]
    3aaa:	2205      	movge	r2, #5
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_IN;
    /*Lba address is in command block byte 2 to 4 with MSB first.*/
    lba =  (g_bot_cbw.cmd_block[2u] << 24u) |
    3aac:	f895 a011 	ldrb.w	sl, [r5, #17]
           (g_bot_cbw.cmd_block[3u] << 16u) |
    3ab0:	f895 9012 	ldrb.w	r9, [r5, #18]
           (g_bot_cbw.cmd_block[4u] << 8u) |
    3ab4:	7ce8      	ldrb	r0, [r5, #19]
            g_bot_cbw.cmd_block[5u];
    3ab6:	f895 8014 	ldrb.w	r8, [r5, #20]
    {
        g_xfr_buf_len = dev_data_len;
        cb_res = CB_DATA_DIR_MISMATCH;
    }
    /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
    if(dev_data_len != g_bot_cbw.xfr_length)
    3aba:	429f      	cmp	r7, r3
    3abc:	bf18      	it	ne
    3abe:	2204      	movne	r2, #4
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_read)
    3ac0:	f1bc 0f00 	cmp.w	ip, #0
    3ac4:	f000 8167 	beq.w	3d96 <usbd_msc_bot_fsm+0x7b2>
    {
        cb_res = CB_INTERNAL_ERROR;
    }

    if(CB_PASS == cb_res)
    3ac8:	2a01      	cmp	r2, #1
    3aca:	f000 81b5 	beq.w	3e38 <usbd_msc_bot_fsm+0x854>
        }
    }

    if(CB_PASS != cb_res)
    {
        g_xfr_buf_ptr = (uint8_t*)0;
    3ace:	2300      	movs	r3, #0
        g_xfr_buf_len = 0u;
        g_xfr_lba_addr = 0u;
    3ad0:	6123      	str	r3, [r4, #16]
        }
    }

    if(CB_PASS != cb_res)
    {
        g_xfr_buf_ptr = (uint8_t*)0;
    3ad2:	6063      	str	r3, [r4, #4]
        g_xfr_buf_len = 0u;
    3ad4:	60e3      	str	r3, [r4, #12]
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3ad6:	68ab      	ldr	r3, [r5, #8]

                switch(cb_result)
    3ad8:	1e50      	subs	r0, r2, #1
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3ada:	64b3      	str	r3, [r6, #72]	; 0x48

                switch(cb_result)
    3adc:	2809      	cmp	r0, #9
    3ade:	f63f ae9f 	bhi.w	3820 <usbd_msc_bot_fsm+0x23c>
    3ae2:	f20f 0c08 	addw	ip, pc, #8
    3ae6:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
    3aea:	bf00      	nop
    3aec:	000038ed 	.word	0x000038ed
    3af0:	00003963 	.word	0x00003963
    3af4:	00003821 	.word	0x00003821
    3af8:	000039b3 	.word	0x000039b3
    3afc:	00003a57 	.word	0x00003a57
    3b00:	00003ba9 	.word	0x00003ba9
    3b04:	00003b4d 	.word	0x00003b4d
    3b08:	00003821 	.word	0x00003821
    3b0c:	00003b17 	.word	0x00003b17
    3b10:	00003821 	.word	0x00003821
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3b14:	64b7      	str	r7, [r6, #72]	; 0x48
                        }
                    break;

                    case CB_INVALID_CDB_FIELD:
                        /*No data, only stall*/
                        g_current_command_csw.status = SCSI_COMMAND_FAIL;
    3b16:	2301      	movs	r3, #1
    3b18:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
                        usbd_msc_stallin_sendstatus();
    3b1c:	f7ff fcae 	bl	347c <usbd_msc_stallin_sendstatus>
    3b20:	e57a      	b.n	3618 <usbd_msc_bot_fsm+0x34>
            case USB_MSC_SCSI_REQUEST_SENSE:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];

                if(g_bot_cbw.cmd_block[1u] & 0x01u)//DESC bit 0 - only fixed format is supported
    3b22:	7c2b      	ldrb	r3, [r5, #16]
            break;

            case USB_MSC_SCSI_REQUEST_SENSE:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];
    3b24:	7cea      	ldrb	r2, [r5, #19]

                if(g_bot_cbw.cmd_block[1u] & 0x01u)//DESC bit 0 - only fixed format is supported
    3b26:	f013 0f01 	tst.w	r3, #1
    3b2a:	bf18      	it	ne
    3b2c:	68af      	ldrne	r7, [r5, #8]
    3b2e:	d1f1      	bne.n	3b14 <usbd_msc_bot_fsm+0x530>
                    return(CB_INVALID_CDB_FIELD);
                }

                /*SPC-4, table 39*/
                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = (uint8_t*)&g_sense_response;
    3b30:	489a      	ldr	r0, [pc, #616]	; (3d9c <usbd_msc_bot_fsm+0x7b8>)
                {
                    return(CB_INVALID_CDB_FIELD);
                }

                /*SPC-4, table 39*/
                g_req_type = SCSI_IN;
    3b32:	f640 13b8 	movw	r3, #2488	; 0x9b8
    3b36:	2101      	movs	r1, #1
    3b38:	7521      	strb	r1, [r4, #20]
                g_xfr_buf_ptr = (uint8_t*)&g_sense_response;
    3b3a:	6060      	str	r0, [r4, #4]
                {
                    return(CB_INVALID_CDB_FIELD);
                }

                /*SPC-4, table 39*/
                g_req_type = SCSI_IN;
    3b3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
                g_xfr_buf_ptr = (uint8_t*)&g_sense_response;

                if(0 == dev_data_len)
    3b40:	2a00      	cmp	r2, #0
    3b42:	f040 811b 	bne.w	3d7c <usbd_msc_bot_fsm+0x798>
                {
                    result = CB_LESSDATA;
                    g_xfr_buf_len = dev_data_len;
    3b46:	60da      	str	r2, [r3, #12]
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3b48:	68aa      	ldr	r2, [r5, #8]
    3b4a:	64b2      	str	r2, [r6, #72]	; 0x48
                    break;

                    case CB_LESSDATA:
                        g_current_command_csw.status = SCSI_COMMAND_LESSDATAPASS;

                        if(SCSI_OUT == g_req_type)
    3b4c:	7d22      	ldrb	r2, [r4, #20]
                            ASSERT(0); /*invalid req_type value*/
                        }
                    break;

                    case CB_LESSDATA:
                        g_current_command_csw.status = SCSI_COMMAND_LESSDATAPASS;
    3b4e:	2003      	movs	r0, #3

                        if(SCSI_OUT == g_req_type)
    3b50:	f640 13b8 	movw	r3, #2488	; 0x9b8
    3b54:	2a02      	cmp	r2, #2
                            ASSERT(0); /*invalid req_type value*/
                        }
                    break;

                    case CB_LESSDATA:
                        g_current_command_csw.status = SCSI_COMMAND_LESSDATAPASS;
    3b56:	f886 004c 	strb.w	r0, [r6, #76]	; 0x4c

                        if(SCSI_OUT == g_req_type)
    3b5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3b5e:	d02e      	beq.n	3bbe <usbd_msc_bot_fsm+0x5da>
                            {
                                //CASE9-This needs to be cross-checked
                                usbd_msc_stallin_sendstatus();
                            }
                        }
                        else if(SCSI_IN == g_req_type)
    3b60:	2a01      	cmp	r2, #1
    3b62:	f47f ad59 	bne.w	3618 <usbd_msc_bot_fsm+0x34>
                        {
                            if(g_xfr_buf_len)
    3b66:	68d9      	ldr	r1, [r3, #12]
    3b68:	2900      	cmp	r1, #0
    3b6a:	f43f ae38 	beq.w	37de <usbd_msc_bot_fsm+0x1fa>
                            {
                                //CASE5: send a stall and status after dataPhase.
                                usbd_msc_send_data(g_xfr_buf_ptr, g_xfr_buf_len);
    3b6e:	6858      	ldr	r0, [r3, #4]
    3b70:	f7ff fc66 	bl	3440 <usbd_msc_send_data>
    3b74:	e550      	b.n	3618 <usbd_msc_bot_fsm+0x34>
        if(g_current_command_csw.data_residue != 0u)
        {
            ASSERT(0);
        }

        switch(cbw_command)
    3b76:	2912      	cmp	r1, #18
    3b78:	d02e      	beq.n	3bd8 <usbd_msc_bot_fsm+0x5f4>
    3b7a:	291a      	cmp	r1, #26
    3b7c:	f47f aee4 	bne.w	3948 <usbd_msc_bot_fsm+0x364>
              break;

            case USB_MSC_SCSI_MODE_SENSE_6:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];
    3b80:	f895 c013 	ldrb.w	ip, [r5, #19]

                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = mode_sense_response;
                g_xfr_buf_len = sizeof(mode_sense_response);
    3b84:	2004      	movs	r0, #4
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];

                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = mode_sense_response;
    3b86:	4a86      	ldr	r2, [pc, #536]	; (3da0 <usbd_msc_bot_fsm+0x7bc>)
            case USB_MSC_SCSI_MODE_SENSE_6:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];

                g_req_type = SCSI_IN;
    3b88:	2101      	movs	r1, #1
              break;

            case USB_MSC_SCSI_MODE_SENSE_6:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];
    3b8a:	f640 33b8 	movw	r3, #3000	; 0xbb8

                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = mode_sense_response;
                g_xfr_buf_len = sizeof(mode_sense_response);

                if(dev_data_len > g_xfr_buf_len)
    3b8e:	4584      	cmp	ip, r0
            case USB_MSC_SCSI_MODE_SENSE_6:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];

                g_req_type = SCSI_IN;
    3b90:	7521      	strb	r1, [r4, #20]
                g_xfr_buf_ptr = mode_sense_response;
    3b92:	6062      	str	r2, [r4, #4]
                g_xfr_buf_len = sizeof(mode_sense_response);
    3b94:	60e0      	str	r0, [r4, #12]
              break;

            case USB_MSC_SCSI_MODE_SENSE_6:
            {
                uint32_t dev_data_len =0;
                dev_data_len = g_bot_cbw.cmd_block[4u];
    3b96:	f2c2 0300 	movt	r3, #8192	; 0x2000

                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = mode_sense_response;
                g_xfr_buf_len = sizeof(mode_sense_response);

                if(dev_data_len > g_xfr_buf_len)
    3b9a:	d8d5      	bhi.n	3b48 <usbd_msc_bot_fsm+0x564>
                {
                    result = CB_LESSDATA;
                }
                else if(dev_data_len < g_xfr_buf_len)
    3b9c:	bf08      	it	eq
    3b9e:	689b      	ldreq	r3, [r3, #8]
    3ba0:	f43f aea3 	beq.w	38ea <usbd_msc_bot_fsm+0x306>
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3ba4:	68a8      	ldr	r0, [r5, #8]
    3ba6:	64b0      	str	r0, [r6, #72]	; 0x48
                            ASSERT(0);/*invalid req_type value*/
                        }
                    break;

                    case CB_MOREDATA:
                        if(SCSI_OUT == g_req_type )
    3ba8:	7d23      	ldrb	r3, [r4, #20]
    3baa:	f640 12b8 	movw	r2, #2488	; 0x9b8
    3bae:	2b02      	cmp	r3, #2
    3bb0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    3bb4:	d00b      	beq.n	3bce <usbd_msc_bot_fsm+0x5ea>
                            else
                            {
                                ASSERT(0);   //shouldn't happen
                            }
                        }
                        else if(SCSI_IN == g_req_type)
    3bb6:	2b01      	cmp	r3, #1
    3bb8:	f47f ad2e 	bne.w	3618 <usbd_msc_bot_fsm+0x34>
    3bbc:	e7ac      	b.n	3b18 <usbd_msc_bot_fsm+0x534>
                    case CB_LESSDATA:
                        g_current_command_csw.status = SCSI_COMMAND_LESSDATAPASS;

                        if(SCSI_OUT == g_req_type)
                        {
                            if(g_xfr_buf_len)
    3bbe:	68d9      	ldr	r1, [r3, #12]
    3bc0:	2900      	cmp	r1, #0
    3bc2:	f43f ae0c 	beq.w	37de <usbd_msc_bot_fsm+0x1fa>
                            {
                                //CASE11(lvr:dont stall this)
                                usbd_msc_receive_data(g_xfr_buf_ptr, g_xfr_buf_len);
    3bc6:	6858      	ldr	r0, [r3, #4]
    3bc8:	f7ff fbb8 	bl	333c <usbd_msc_receive_data>
    3bcc:	e524      	b.n	3618 <usbd_msc_bot_fsm+0x34>
                    break;

                    case CB_MOREDATA:
                        if(SCSI_OUT == g_req_type )
                        {
                            if(g_xfr_buf_len)
    3bce:	68d2      	ldr	r2, [r2, #12]
    3bd0:	2a00      	cmp	r2, #0
    3bd2:	f43f ad21 	beq.w	3618 <usbd_msc_bot_fsm+0x34>
    3bd6:	e716      	b.n	3a06 <usbd_msc_bot_fsm+0x422>

    g_req_type = SCSI_IN;
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;

    dev_data_len = ((g_bot_cbw.cmd_block[3u] << 8u) | g_bot_cbw.cmd_block[4u]);
    3bd8:	7caf      	ldrb	r7, [r5, #18]
    3bda:	f895 c013 	ldrb.w	ip, [r5, #19]

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3bde:	f995 000c 	ldrsb.w	r0, [r5, #12]
    uint32_t dev_data_len = 0u;
    uint8_t* buf = (uint8_t*)0;
    uint32_t app_data_len;

    g_req_type = SCSI_IN;
    g_xfr_buf_ptr = (uint8_t*)0;
    3be2:	2100      	movs	r1, #0
{
    uint32_t dev_data_len = 0u;
    uint8_t* buf = (uint8_t*)0;
    uint32_t app_data_len;

    g_req_type = SCSI_IN;
    3be4:	f640 13b8 	movw	r3, #2488	; 0x9b8
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;

    dev_data_len = ((g_bot_cbw.cmd_block[3u] << 8u) | g_bot_cbw.cmd_block[4u]);
    3be8:	f640 32b8 	movw	r2, #3000	; 0xbb8
{
    uint32_t dev_data_len = 0u;
    uint8_t* buf = (uint8_t*)0;
    uint32_t app_data_len;

    g_req_type = SCSI_IN;
    3bec:	f04f 0e01 	mov.w	lr, #1
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;

    dev_data_len = ((g_bot_cbw.cmd_block[3u] << 8u) | g_bot_cbw.cmd_block[4u]);
    3bf0:	ea4c 2707 	orr.w	r7, ip, r7, lsl #8
{
    uint32_t dev_data_len = 0u;
    uint8_t* buf = (uint8_t*)0;
    uint32_t app_data_len;

    g_req_type = SCSI_IN;
    3bf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_xfr_buf_len = 0u;

    dev_data_len = ((g_bot_cbw.cmd_block[3u] << 8u) | g_bot_cbw.cmd_block[4u]);

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3bf8:	4288      	cmp	r0, r1
    uint8_t* buf = (uint8_t*)0;
    uint32_t app_data_len;

    g_req_type = SCSI_IN;
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;
    3bfa:	60e1      	str	r1, [r4, #12]
{
    uint32_t dev_data_len = 0u;
    uint8_t* buf = (uint8_t*)0;
    uint32_t app_data_len;

    g_req_type = SCSI_IN;
    3bfc:	f884 e014 	strb.w	lr, [r4, #20]
    g_xfr_buf_ptr = (uint8_t*)0;
    3c00:	6061      	str	r1, [r4, #4]
    g_xfr_buf_len = 0u;

    dev_data_len = ((g_bot_cbw.cmd_block[3u] << 8u) | g_bot_cbw.cmd_block[4u]);
    3c02:	f2c2 0200 	movt	r2, #8192	; 0x2000

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    {
        g_xfr_buf_len = dev_data_len;
    3c06:	bfa8      	it	ge
    3c08:	60df      	strge	r7, [r3, #12]
    g_xfr_buf_len = 0u;

    dev_data_len = ((g_bot_cbw.cmd_block[3u] << 8u) | g_bot_cbw.cmd_block[4u]);

    /*Data Direction must be D2H (IN)*/
    if(!(g_bot_cbw.flags & 0x80u))
    3c0a:	f6bf af22 	bge.w	3a52 <usbd_msc_bot_fsm+0x46e>
        g_xfr_buf_len = dev_data_len;
        return(CB_DATA_DIR_MISMATCH);
    }

    /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
    if(dev_data_len != g_bot_cbw.xfr_length)
    3c0e:	6893      	ldr	r3, [r2, #8]
    3c10:	429f      	cmp	r7, r3
    3c12:	f47f aecd 	bne.w	39b0 <usbd_msc_bot_fsm+0x3cc>
    {
        return(CB_LENGTH_MISMATCH);
    }

    /*If EVPD is zero then Page code must be zero*/
    if((!(g_bot_cbw.cmd_block[1u] & 0x01u)) && (g_bot_cbw.cmd_block[1u]))
    3c16:	7c13      	ldrb	r3, [r2, #16]
    3c18:	f013 0f01 	tst.w	r3, #1
    3c1c:	d102      	bne.n	3c24 <usbd_msc_bot_fsm+0x640>
    3c1e:	2b00      	cmp	r3, #0
    3c20:	f47f af78 	bne.w	3b14 <usbd_msc_bot_fsm+0x530>
    {
        return(CB_INVALID_CDB_FIELD);
    }

    if(0 == g_usbd_msc_media_ops->media_inquiry)
    3c24:	f640 33b0 	movw	r3, #2992	; 0xbb0
    3c28:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c2c:	681a      	ldr	r2, [r3, #0]
    3c2e:	6a13      	ldr	r3, [r2, #32]
    3c30:	2b00      	cmp	r3, #0
    3c32:	f000 80ae 	beq.w	3d92 <usbd_msc_bot_fsm+0x7ae>
        return(CB_INTERNAL_ERROR);
    }

    if(0 != g_usbd_msc_media_ops->media_inquiry)
    {
        buf = g_usbd_msc_media_ops->media_inquiry(g_bot_cbw.lun, &app_data_len);
    3c36:	7b68      	ldrb	r0, [r5, #13]
    3c38:	a904      	add	r1, sp, #16
    3c3a:	4798      	blx	r3
    3c3c:	f640 33b8 	movw	r3, #3000	; 0xbb8
    }

    if((uint8_t*)0 == buf)
    3c40:	4602      	mov	r2, r0
        return(CB_INTERNAL_ERROR);
    }

    if(0 != g_usbd_msc_media_ops->media_inquiry)
    {
        buf = g_usbd_msc_media_ops->media_inquiry(g_bot_cbw.lun, &app_data_len);
    3c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
    }

    if((uint8_t*)0 == buf)
    3c46:	2800      	cmp	r0, #0
    3c48:	f000 80a2 	beq.w	3d90 <usbd_msc_bot_fsm+0x7ac>
    }
    else
    {
        g_xfr_buf_ptr = buf;

        if(dev_data_len <= app_data_len)
    3c4c:	9804      	ldr	r0, [sp, #16]
    {
        return(CB_INTERNAL_ERROR);
    }
    else
    {
        g_xfr_buf_ptr = buf;
    3c4e:	f640 11b8 	movw	r1, #2488	; 0x9b8

        if(dev_data_len <= app_data_len)
    3c52:	4287      	cmp	r7, r0
    {
        return(CB_INTERNAL_ERROR);
    }
    else
    {
        g_xfr_buf_ptr = buf;
    3c54:	f2c2 0100 	movt	r1, #8192	; 0x2000
    3c58:	6062      	str	r2, [r4, #4]

        if(dev_data_len <= app_data_len)
        {
            g_xfr_buf_len = dev_data_len;
    3c5a:	bf9a      	itte	ls
    3c5c:	60cf      	strls	r7, [r1, #12]
    3c5e:	689b      	ldrls	r3, [r3, #8]
            return(CB_PASS);
        }
        else
        {
            g_xfr_buf_len = app_data_len;
    3c60:	60c8      	strhi	r0, [r1, #12]
    }
    else
    {
        g_xfr_buf_ptr = buf;

        if(dev_data_len <= app_data_len)
    3c62:	f63f af71 	bhi.w	3b48 <usbd_msc_bot_fsm+0x564>
    3c66:	e640      	b.n	38ea <usbd_msc_bot_fsm+0x306>
                uint32_t no_of_blocks, block_size;
                uint32_t dev_data_len =0;

                dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]);

                if(0 != g_usbd_msc_media_ops->media_get_capacity)
    3c68:	f640 33b0 	movw	r3, #2992	; 0xbb0
    3c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3c70:	681f      	ldr	r7, [r3, #0]
            case USB_MSC_SCSI_READ_FORMAT_CAPACITIES:/*Returns no. of blocks and block size*/
            {
                uint32_t no_of_blocks, block_size;
                uint32_t dev_data_len =0;

                dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]);
    3c72:	f895 8016 	ldrb.w	r8, [r5, #22]

                if(0 != g_usbd_msc_media_ops->media_get_capacity)
    3c76:	687b      	ldr	r3, [r7, #4]
            case USB_MSC_SCSI_READ_FORMAT_CAPACITIES:/*Returns no. of blocks and block size*/
            {
                uint32_t no_of_blocks, block_size;
                uint32_t dev_data_len =0;

                dev_data_len = ((g_bot_cbw.cmd_block[7u] << 8u) | g_bot_cbw.cmd_block[8u]);
    3c78:	7def      	ldrb	r7, [r5, #23]

                if(0 != g_usbd_msc_media_ops->media_get_capacity)
    3c7a:	b113      	cbz	r3, 3c82 <usbd_msc_bot_fsm+0x69e>
                {
                    g_usbd_msc_media_ops->media_get_capacity(cbw->lun,
    3c7c:	a904      	add	r1, sp, #16
    3c7e:	aa03      	add	r2, sp, #12
    3c80:	4798      	blx	r3
                format_capacity_list [5u] = (uint8_t)(no_of_blocks >> 16u);
                format_capacity_list [6u] = (uint8_t)(no_of_blocks >> 8u);
                format_capacity_list [7u] = (uint8_t)(no_of_blocks);

                /* format_capacity_list [8] = Descriptor Code*/
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
    3c82:	9a03      	ldr	r2, [sp, #12]
                    g_usbd_msc_media_ops->media_get_capacity(cbw->lun,
                                                           (uint32_t*)&no_of_blocks,
                                                           (uint32_t*)&block_size);
                }

                format_capacity_list [4u] = (uint8_t)(no_of_blocks >> 24u);
    3c84:	9b04      	ldr	r3, [sp, #16]
                format_capacity_list [5u] = (uint8_t)(no_of_blocks >> 16u);
                format_capacity_list [6u] = (uint8_t)(no_of_blocks >> 8u);
                format_capacity_list [7u] = (uint8_t)(no_of_blocks);

                /* format_capacity_list [8] = Descriptor Code*/
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
    3c86:	0c10      	lsrs	r0, r2, #16
                format_capacity_list [10u] = (uint8_t)(block_size >> 8u);
    3c88:	0a11      	lsrs	r1, r2, #8
                format_capacity_list [5u] = (uint8_t)(no_of_blocks >> 16u);
                format_capacity_list [6u] = (uint8_t)(no_of_blocks >> 8u);
                format_capacity_list [7u] = (uint8_t)(no_of_blocks);

                /* format_capacity_list [8] = Descriptor Code*/
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
    3c8a:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
                format_capacity_list [10u] = (uint8_t)(block_size >> 8u);
                format_capacity_list [11u] = (uint8_t)(block_size);

                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = (uint8_t*)format_capacity_list;
                g_xfr_buf_len = sizeof(format_capacity_list);
    3c8e:	200c      	movs	r0, #12

                if(g_xfr_buf_len < dev_data_len)
                {
                    result = CB_LESSDATA;
                }
                else if(g_xfr_buf_len > dev_data_len)
    3c90:	ea47 2708 	orr.w	r7, r7, r8, lsl #8
                format_capacity_list [6u] = (uint8_t)(no_of_blocks >> 8u);
                format_capacity_list [7u] = (uint8_t)(no_of_blocks);

                /* format_capacity_list [8] = Descriptor Code*/
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
                format_capacity_list [10u] = (uint8_t)(block_size >> 8u);
    3c94:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
                format_capacity_list [11u] = (uint8_t)(block_size);
    3c98:	f884 2053 	strb.w	r2, [r4, #83]	; 0x53
    uint8_t lun,
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    3c9c:	1fc1      	subs	r1, r0, #7
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
                format_capacity_list [10u] = (uint8_t)(block_size >> 8u);
                format_capacity_list [11u] = (uint8_t)(block_size);

                g_req_type = SCSI_IN;
                g_xfr_buf_ptr = (uint8_t*)format_capacity_list;
    3c9e:	4a41      	ldr	r2, [pc, #260]	; (3da4 <usbd_msc_bot_fsm+0x7c0>)
                    g_usbd_msc_media_ops->media_get_capacity(cbw->lun,
                                                           (uint32_t*)&no_of_blocks,
                                                           (uint32_t*)&block_size);
                }

                format_capacity_list [4u] = (uint8_t)(no_of_blocks >> 24u);
    3ca0:	ea4f 6a13 	mov.w	sl, r3, lsr #24
                format_capacity_list [5u] = (uint8_t)(no_of_blocks >> 16u);
    3ca4:	ea4f 4813 	mov.w	r8, r3, lsr #16
                format_capacity_list [6u] = (uint8_t)(no_of_blocks >> 8u);
    3ca8:	ea4f 2c13 	mov.w	ip, r3, lsr #8
                format_capacity_list [7u] = (uint8_t)(no_of_blocks);
    3cac:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
    uint8_t lun,
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    3cb0:	f886 1072 	strb.w	r1, [r6, #114]	; 0x72
                /* format_capacity_list [8] = Descriptor Code*/
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
                format_capacity_list [10u] = (uint8_t)(block_size >> 8u);
                format_capacity_list [11u] = (uint8_t)(block_size);

                g_req_type = SCSI_IN;
    3cb4:	2301      	movs	r3, #1
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    g_sense_response.asc = asc;
    3cb6:	311b      	adds	r1, #27

                if(g_xfr_buf_len < dev_data_len)
                {
                    result = CB_LESSDATA;
                }
                else if(g_xfr_buf_len > dev_data_len)
    3cb8:	2f0c      	cmp	r7, #12
                    g_usbd_msc_media_ops->media_get_capacity(cbw->lun,
                                                           (uint32_t*)&no_of_blocks,
                                                           (uint32_t*)&block_size);
                }

                format_capacity_list [4u] = (uint8_t)(no_of_blocks >> 24u);
    3cba:	f884 a04c 	strb.w	sl, [r4, #76]	; 0x4c
                format_capacity_list [5u] = (uint8_t)(no_of_blocks >> 16u);
    3cbe:	f884 804d 	strb.w	r8, [r4, #77]	; 0x4d
                format_capacity_list [6u] = (uint8_t)(no_of_blocks >> 8u);
    3cc2:	f884 c04e 	strb.w	ip, [r4, #78]	; 0x4e
                /* format_capacity_list [8] = Descriptor Code*/
                format_capacity_list [9u]  = (uint8_t)(block_size >> 16u);
                format_capacity_list [10u] = (uint8_t)(block_size >> 8u);
                format_capacity_list [11u] = (uint8_t)(block_size);

                g_req_type = SCSI_IN;
    3cc6:	7523      	strb	r3, [r4, #20]
                g_xfr_buf_ptr = (uint8_t*)format_capacity_list;
    3cc8:	6062      	str	r2, [r4, #4]
                g_xfr_buf_len = sizeof(format_capacity_list);
    3cca:	60e0      	str	r0, [r4, #12]
    uint8_t skey,
    uint8_t asc
)
{
    g_sense_response.sense_key = skey;
    g_sense_response.asc = asc;
    3ccc:	f886 107c 	strb.w	r1, [r6, #124]	; 0x7c

                if(g_xfr_buf_len < dev_data_len)
                {
                    result = CB_LESSDATA;
                }
                else if(g_xfr_buf_len > dev_data_len)
    3cd0:	f47f af3a 	bne.w	3b48 <usbd_msc_bot_fsm+0x564>
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3cd4:	68ab      	ldr	r3, [r5, #8]
    3cd6:	e608      	b.n	38ea <usbd_msc_bot_fsm+0x306>
          (g_bot_cbw.cmd_block[3u] << 16u) |
          (g_bot_cbw.cmd_block[4u] << 8u) |
           g_bot_cbw.cmd_block[5u];

    /*Block size was received in USB_MSC_SCSI_READ_CAPACITY_10 command*/
    lba_addr = (lba * lun_capacity[g_bot_cbw.lun].blk_sz_len);
    3cd8:	f895 c00d 	ldrb.w	ip, [r5, #13]
    3cdc:	210c      	movs	r1, #12
    3cde:	fb01 420c 	mla	r2, r1, ip, r4
)
{
    uint32_t lba = 0u;
    uint32_t lba_addr = 0u;
    uint8_t* write_buf;
    uint32_t app_write_len = 0u;
    3ce2:	2300      	movs	r3, #0

    /*
    Number of LBA to be written is provided in command block byte 7 to 8,
    calculate the total size to be written
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7] << 8u) | g_bot_cbw.cmd_block[8u]) *
    3ce4:	f895 a016 	ldrb.w	sl, [r5, #22]
    3ce8:	7def      	ldrb	r7, [r5, #23]
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_OUT;
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;
    g_xfr_lba_addr = 0u;
    3cea:	6123      	str	r3, [r4, #16]
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_OUT;
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;
    3cec:	60e3      	str	r3, [r4, #12]
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7] << 8u) | g_bot_cbw.cmd_block[8u]) *
                                         lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be H2D (OUT)*/
    if(g_bot_cbw.flags & 0x80u)
    3cee:	f995 900c 	ldrsb.w	r9, [r5, #12]
          (g_bot_cbw.cmd_block[3u] << 16u) |
          (g_bot_cbw.cmd_block[4u] << 8u) |
           g_bot_cbw.cmd_block[5u];

    /*Block size was received in USB_MSC_SCSI_READ_CAPACITY_10 command*/
    lba_addr = (lba * lun_capacity[g_bot_cbw.lun].blk_sz_len);
    3cf2:	6a11      	ldr	r1, [r2, #32]

    /*
    Number of LBA to be written is provided in command block byte 7 to 8,
    calculate the total size to be written
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7] << 8u) | g_bot_cbw.cmd_block[8u]) *
    3cf4:	ea47 280a 	orr.w	r8, r7, sl, lsl #8
    uint8_t* write_buf;
    uint32_t app_write_len = 0u;
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_OUT;
    3cf8:	2002      	movs	r0, #2
    3cfa:	f640 12b8 	movw	r2, #2488	; 0x9b8
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7] << 8u) | g_bot_cbw.cmd_block[8u]) *
                                         lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be H2D (OUT)*/
    if(g_bot_cbw.flags & 0x80u)
    3cfe:	4599      	cmp	r9, r3
    uint8_t* write_buf;
    uint32_t app_write_len = 0u;
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_OUT;
    3d00:	7520      	strb	r0, [r4, #20]

    /*
    Number of LBA to be written is provided in command block byte 7 to 8,
    calculate the total size to be written
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7] << 8u) | g_bot_cbw.cmd_block[8u]) *
    3d02:	fb01 f708 	mul.w	r7, r1, r8
)
{
    uint32_t lba = 0u;
    uint32_t lba_addr = 0u;
    uint8_t* write_buf;
    uint32_t app_write_len = 0u;
    3d06:	9303      	str	r3, [sp, #12]
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_OUT;
    g_xfr_buf_ptr = (uint8_t*)0;
    3d08:	6063      	str	r3, [r4, #4]
    uint8_t* write_buf;
    uint32_t app_write_len = 0u;
    uint32_t dev_data_len = 0u;
    uint8_t cb_res = CB_PASS;

    g_req_type = SCSI_OUT;
    3d0a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    g_xfr_buf_ptr = (uint8_t*)0;
    g_xfr_buf_len = 0u;
    g_xfr_lba_addr = 0u;

    /*Lba address is in command block byte 2 to 4 with MSB first.*/
    lba = (g_bot_cbw.cmd_block[2u] << 24u) |
    3d0e:	f895 8011 	ldrb.w	r8, [r5, #17]
          (g_bot_cbw.cmd_block[3u] << 16u) |
    3d12:	f895 a012 	ldrb.w	sl, [r5, #18]
          (g_bot_cbw.cmd_block[4u] << 8u) |
    3d16:	7ce8      	ldrb	r0, [r5, #19]
           g_bot_cbw.cmd_block[5u];
    3d18:	f895 c014 	ldrb.w	ip, [r5, #20]
    */
    dev_data_len = ((g_bot_cbw.cmd_block[7] << 8u) | g_bot_cbw.cmd_block[8u]) *
                                         lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be H2D (OUT)*/
    if(g_bot_cbw.flags & 0x80u)
    3d1c:	db35      	blt.n	3d8a <usbd_msc_bot_fsm+0x7a6>
    3d1e:	2201      	movs	r2, #1
    if(dev_data_len != g_bot_cbw.xfr_length)
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_acquire_write_buf)
    3d20:	f640 33b0 	movw	r3, #2992	; 0xbb0
    3d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3d28:	681b      	ldr	r3, [r3, #0]
    {
        g_xfr_buf_len = dev_data_len;
        cb_res = CB_DATA_DIR_MISMATCH;
    }
    /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
    if(dev_data_len != g_bot_cbw.xfr_length)
    3d2a:	f8d5 9008 	ldr.w	r9, [r5, #8]
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_acquire_write_buf)
    3d2e:	695b      	ldr	r3, [r3, #20]
    {
        g_xfr_buf_len = dev_data_len;
        cb_res = CB_DATA_DIR_MISMATCH;
    }
    /*Fail if DataTransferLength and Allocation length in CBW are mismatched*/
    if(dev_data_len != g_bot_cbw.xfr_length)
    3d30:	454f      	cmp	r7, r9
    3d32:	bf18      	it	ne
    3d34:	2204      	movne	r2, #4
    {
        cb_res = CB_LENGTH_MISMATCH;
    }

    if(0 == g_usbd_msc_media_ops->media_acquire_write_buf)
    3d36:	2b00      	cmp	r3, #0
    3d38:	d02d      	beq.n	3d96 <usbd_msc_bot_fsm+0x7b2>
    {
        cb_res = CB_INTERNAL_ERROR;
    }

    if(CB_PASS == cb_res)
    3d3a:	2a01      	cmp	r2, #1
    3d3c:	f47f aec7 	bne.w	3ace <usbd_msc_bot_fsm+0x4ea>
          (g_bot_cbw.cmd_block[3u] << 16u) |
          (g_bot_cbw.cmd_block[4u] << 8u) |
           g_bot_cbw.cmd_block[5u];

    /*Block size was received in USB_MSC_SCSI_READ_CAPACITY_10 command*/
    lba_addr = (lba * lun_capacity[g_bot_cbw.lun].blk_sz_len);
    3d40:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
    3d44:	ea4a 6808 	orr.w	r8, sl, r8, lsl #24
    3d48:	ea48 020c 	orr.w	r2, r8, ip
    3d4c:	ea42 2e00 	orr.w	lr, r2, r0, lsl #8
    3d50:	fb01 f80e 	mul.w	r8, r1, lr
        cb_res = CB_INTERNAL_ERROR;
    }

    if(CB_PASS == cb_res)
    {
        write_buf = g_usbd_msc_media_ops->media_acquire_write_buf(g_bot_cbw.lun,
    3d54:	7b68      	ldrb	r0, [r5, #13]
    3d56:	4641      	mov	r1, r8
    3d58:	aa03      	add	r2, sp, #12
    3d5a:	4798      	blx	r3
                                                                  lba_addr,
                                                                  &app_write_len);
        if(write_buf == (uint8_t*)0)
    3d5c:	4603      	mov	r3, r0
    3d5e:	b1d0      	cbz	r0, 3d96 <usbd_msc_bot_fsm+0x7b2>
            /*
            Since App is not capable of handling all data at the moment.
            Store the current LBA address so that it will be used to calculate
            new LBA address when remaining data is received.
            */
            g_xfr_lba_addr = lba_addr;
    3d60:	f640 11b8 	movw	r1, #2488	; 0x9b8
            from Host, then read the amount of data that the application can
            handle at the moment
            */
            if(app_write_len < dev_data_len)
            {
                g_xfr_buf_len = app_write_len;
    3d64:	9803      	ldr	r0, [sp, #12]
            /*
            Since App is not capable of handling all data at the moment.
            Store the current LBA address so that it will be used to calculate
            new LBA address when remaining data is received.
            */
            g_xfr_lba_addr = lba_addr;
    3d66:	f2c2 0100 	movt	r1, #8192	; 0x2000
            g_xfr_buf_ptr = write_buf;
    3d6a:	6063      	str	r3, [r4, #4]
            from Host, then read the amount of data that the application can
            handle at the moment
            */
            if(app_write_len < dev_data_len)
            {
                g_xfr_buf_len = app_write_len;
    3d6c:	42b8      	cmp	r0, r7
    3d6e:	bf94      	ite	ls
    3d70:	60c8      	strls	r0, [r1, #12]
    3d72:	60cf      	strhi	r7, [r1, #12]
            /*
            Since App is not capable of handling all data at the moment.
            Store the current LBA address so that it will be used to calculate
            new LBA address when remaining data is received.
            */
            g_xfr_lba_addr = lba_addr;
    3d74:	f8c4 8010 	str.w	r8, [r4, #16]
        break;
    }

    g_bottx_events = BOT_EVENT_IDLE;
    g_botrx_events = BOT_EVENT_IDLE;
}
    3d78:	68ab      	ldr	r3, [r5, #8]
    3d7a:	e5b6      	b.n	38ea <usbd_msc_bot_fsm+0x306>
                if(0 == dev_data_len)
                {
                    result = CB_LESSDATA;
                    g_xfr_buf_len = dev_data_len;
                }
                else if(dev_data_len > (sizeof(g_sense_response)))
    3d7c:	2a12      	cmp	r2, #18
                {
                    g_xfr_buf_len = dev_data_len;
    3d7e:	60da      	str	r2, [r3, #12]
                    result = CB_MOREDATA;
                }
                else
                {
                    g_xfr_buf_len = dev_data_len;
    3d80:	bf98      	it	ls
    3d82:	68ab      	ldrls	r3, [r5, #8]
                if(0 == dev_data_len)
                {
                    result = CB_LESSDATA;
                    g_xfr_buf_len = dev_data_len;
                }
                else if(dev_data_len > (sizeof(g_sense_response)))
    3d84:	f67f adb1 	bls.w	38ea <usbd_msc_bot_fsm+0x306>
    3d88:	e70c      	b.n	3ba4 <usbd_msc_bot_fsm+0x5c0>
                                         lun_capacity[g_bot_cbw.lun].blk_sz_len;

    /*Data Direction must be H2D (OUT)*/
    if(g_bot_cbw.flags & 0x80u)
    {
        g_xfr_buf_len = dev_data_len;
    3d8a:	60d7      	str	r7, [r2, #12]
    3d8c:	2205      	movs	r2, #5
    3d8e:	e7c7      	b.n	3d20 <usbd_msc_bot_fsm+0x73c>
    if(0 != g_usbd_msc_media_ops->media_inquiry)
    {
        buf = g_usbd_msc_media_ops->media_inquiry(g_bot_cbw.lun, &app_data_len);
    }

    if((uint8_t*)0 == buf)
    3d90:	689f      	ldr	r7, [r3, #8]
                usbd_msc_abort_cbw(0u);
            }
            else
            {
                cb_result = usbd_msc_process_cbw(&g_bot_cbw);
                g_current_command_csw.data_residue = g_bot_cbw.xfr_length;
    3d92:	64b7      	str	r7, [r6, #72]	; 0x48
    3d94:	e544      	b.n	3820 <usbd_msc_bot_fsm+0x23c>
            {
                g_xfr_buf_len = app_write_len;
            }
            else
            {
                g_xfr_buf_len = dev_data_len;
    3d96:	2203      	movs	r2, #3
    3d98:	e699      	b.n	3ace <usbd_msc_bot_fsm+0x4ea>
    3d9a:	bf00      	nop
    3d9c:	200002e4 	.word	0x200002e4
    3da0:	200002f8 	.word	0x200002f8
    3da4:	20000a00 	.word	0x20000a00
        g_xfr_buf_len = 8u;
        return(CB_DATA_DIR_MISMATCH);
    }

    /*PMI bit set to one is not supported*/
    if(g_bot_cbw.cmd_block[8u] & 0x01u)
    3da8:	f897 e017 	ldrb.w	lr, [r7, #23]
    3dac:	f01e 0f01 	tst.w	lr, #1
    3db0:	bf18      	it	ne
    3db2:	68bf      	ldrne	r7, [r7, #8]
    3db4:	f47f aeae 	bne.w	3b14 <usbd_msc_bot_fsm+0x530>
    {
        return(CB_INVALID_CDB_FIELD);
    }

    if(0 == g_usbd_msc_media_ops->media_get_capacity)
    3db8:	f640 30b0 	movw	r0, #2992	; 0xbb0
    3dbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3dc0:	6803      	ldr	r3, [r0, #0]
    3dc2:	685b      	ldr	r3, [r3, #4]
    3dc4:	2b00      	cmp	r3, #0
    3dc6:	d056      	beq.n	3e76 <usbd_msc_bot_fsm+0x892>
        return(CB_INTERNAL_ERROR);
    }

    if(0 != g_usbd_msc_media_ops->media_get_capacity)
    {
        g_usbd_msc_media_ops->media_get_capacity(g_bot_cbw.lun,
    3dc8:	a903      	add	r1, sp, #12
    3dca:	aa04      	add	r2, sp, #16
    3dcc:	7b78      	ldrb	r0, [r7, #13]
    3dce:	4798      	blx	r3
                                                 (uint32_t*)&no_of_blocks,
                                                 (uint32_t*)&block_size);
    }

    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    3dd0:	f897 b00d 	ldrb.w	fp, [r7, #13]
    3dd4:	220c      	movs	r2, #12
    3dd6:	fb02 f90b 	mul.w	r9, r2, fp
    3dda:	9803      	ldr	r0, [sp, #12]
    lun_capacity[g_bot_cbw.lun].last_lba_2 = (uint8_t)((no_of_blocks - 1u) >> 16u);
    lun_capacity[g_bot_cbw.lun].last_lba_1 = (uint8_t)((no_of_blocks - 1u) >> 8u);
    lun_capacity[g_bot_cbw.lun].last_lba_lsb = (uint8_t)((no_of_blocks - 1u));

    lun_capacity[g_bot_cbw.lun].blk_sz_len = block_size;
    3ddc:	9a04      	ldr	r2, [sp, #16]
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);

    g_xfr_buf_ptr = (uint8_t*)&lun_capacity[g_bot_cbw.lun];
    3dde:	f108 0a18 	add.w	sl, r8, #24
        g_usbd_msc_media_ops->media_get_capacity(g_bot_cbw.lun,
                                                 (uint32_t*)&no_of_blocks,
                                                 (uint32_t*)&block_size);
    }

    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    3de2:	1e41      	subs	r1, r0, #1
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);

    g_xfr_buf_ptr = (uint8_t*)&lun_capacity[g_bot_cbw.lun];
    3de4:	eb0a 0509 	add.w	r5, sl, r9
        g_usbd_msc_media_ops->media_get_capacity(g_bot_cbw.lun,
                                                 (uint32_t*)&no_of_blocks,
                                                 (uint32_t*)&block_size);
    }

    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    3de8:	eb09 0008 	add.w	r0, r9, r8
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);

    g_xfr_buf_ptr = (uint8_t*)&lun_capacity[g_bot_cbw.lun];
    3dec:	9501      	str	r5, [sp, #4]
        g_usbd_msc_media_ops->media_get_capacity(g_bot_cbw.lun,
                                                 (uint32_t*)&no_of_blocks,
                                                 (uint32_t*)&block_size);
    }

    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    3dee:	f100 0318 	add.w	r3, r0, #24
    lun_capacity[g_bot_cbw.lun].last_lba_1 = (uint8_t)((no_of_blocks - 1u) >> 8u);
    lun_capacity[g_bot_cbw.lun].last_lba_lsb = (uint8_t)((no_of_blocks - 1u));

    lun_capacity[g_bot_cbw.lun].blk_sz_len = block_size;
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    3df2:	ea4f 4c12 	mov.w	ip, r2, lsr #16
        g_usbd_msc_media_ops->media_get_capacity(g_bot_cbw.lun,
                                                 (uint32_t*)&no_of_blocks,
                                                 (uint32_t*)&block_size);
    }

    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    3df6:	ea4f 6911 	mov.w	r9, r1, lsr #24
    lun_capacity[g_bot_cbw.lun].last_lba_2 = (uint8_t)((no_of_blocks - 1u) >> 16u);
    3dfa:	ea4f 4a11 	mov.w	sl, r1, lsr #16
    lun_capacity[g_bot_cbw.lun].last_lba_1 = (uint8_t)((no_of_blocks - 1u) >> 8u);
    3dfe:	0a0d      	lsrs	r5, r1, #8
    lun_capacity[g_bot_cbw.lun].last_lba_lsb = (uint8_t)((no_of_blocks - 1u));

    lun_capacity[g_bot_cbw.lun].blk_sz_len = block_size;
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    3e00:	ea4f 6b12 	mov.w	fp, r2, lsr #24
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    3e04:	f8cd c000 	str.w	ip, [sp]
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);
    3e08:	71da      	strb	r2, [r3, #7]
        g_usbd_msc_media_ops->media_get_capacity(g_bot_cbw.lun,
                                                 (uint32_t*)&no_of_blocks,
                                                 (uint32_t*)&block_size);
    }

    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    3e0a:	f880 9018 	strb.w	r9, [r0, #24]
    lun_capacity[g_bot_cbw.lun].last_lba_2 = (uint8_t)((no_of_blocks - 1u) >> 16u);
    3e0e:	f883 a001 	strb.w	sl, [r3, #1]
    lun_capacity[g_bot_cbw.lun].last_lba_1 = (uint8_t)((no_of_blocks - 1u) >> 8u);
    3e12:	709d      	strb	r5, [r3, #2]
    lun_capacity[g_bot_cbw.lun].last_lba_lsb = (uint8_t)((no_of_blocks - 1u));
    3e14:	70d9      	strb	r1, [r3, #3]

    lun_capacity[g_bot_cbw.lun].blk_sz_len = block_size;
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    3e16:	f883 b004 	strb.w	fp, [r3, #4]
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    3e1a:	9900      	ldr	r1, [sp, #0]
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    3e1c:	ea4f 2c12 	mov.w	ip, r2, lsr #8
    lun_capacity[g_bot_cbw.lun].last_lba_1 = (uint8_t)((no_of_blocks - 1u) >> 8u);
    lun_capacity[g_bot_cbw.lun].last_lba_lsb = (uint8_t)((no_of_blocks - 1u));

    lun_capacity[g_bot_cbw.lun].blk_sz_len = block_size;
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    3e20:	7159      	strb	r1, [r3, #5]
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    3e22:	f883 c006 	strb.w	ip, [r3, #6]
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);

    g_xfr_buf_ptr = (uint8_t*)&lun_capacity[g_bot_cbw.lun];
    3e26:	9901      	ldr	r1, [sp, #4]
    lun_capacity[g_bot_cbw.lun].last_lba_msb = (uint8_t)((no_of_blocks - 1u) >> 24u);
    lun_capacity[g_bot_cbw.lun].last_lba_2 = (uint8_t)((no_of_blocks - 1u) >> 16u);
    lun_capacity[g_bot_cbw.lun].last_lba_1 = (uint8_t)((no_of_blocks - 1u) >> 8u);
    lun_capacity[g_bot_cbw.lun].last_lba_lsb = (uint8_t)((no_of_blocks - 1u));

    lun_capacity[g_bot_cbw.lun].blk_sz_len = block_size;
    3e28:	6202      	str	r2, [r0, #32]
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);

    g_xfr_buf_ptr = (uint8_t*)&lun_capacity[g_bot_cbw.lun];
    g_xfr_buf_len = 8u;
    3e2a:	2208      	movs	r2, #8
    3e2c:	f8c8 200c 	str.w	r2, [r8, #12]
    lun_capacity[g_bot_cbw.lun].block_size_msb = (uint8_t)(block_size >> 24u);
    lun_capacity[g_bot_cbw.lun].block_size_2 = (uint8_t)(block_size >> 16u);
    lun_capacity[g_bot_cbw.lun].block_size_1 = (uint8_t)(block_size >> 8u);
    lun_capacity[g_bot_cbw.lun].block_size_lsb = (uint8_t)(block_size);

    g_xfr_buf_ptr = (uint8_t*)&lun_capacity[g_bot_cbw.lun];
    3e30:	f8c8 1004 	str.w	r1, [r8, #4]
    g_xfr_buf_len = 8u;
    3e34:	68bb      	ldr	r3, [r7, #8]
    3e36:	e558      	b.n	38ea <usbd_msc_bot_fsm+0x306>
           (g_bot_cbw.cmd_block[3u] << 16u) |
           (g_bot_cbw.cmd_block[4u] << 8u) |
            g_bot_cbw.cmd_block[5u];

    /*Block size was received in USB_MSC_SCSI_READ_CAPACITY_10 command*/
    lba_addr = (lba * lun_capacity[g_bot_cbw.lun].blk_sz_len);
    3e38:	ea4f 4909 	mov.w	r9, r9, lsl #16
    3e3c:	ea49 6a0a 	orr.w	sl, r9, sl, lsl #24
    3e40:	ea4a 0308 	orr.w	r3, sl, r8
    3e44:	ea43 2e00 	orr.w	lr, r3, r0, lsl #8
    3e48:	fb01 f80e 	mul.w	r8, r1, lr

    if(CB_PASS == cb_res)
    {
        if(0 != g_usbd_msc_media_ops->media_read)
        {
            app_read_len = g_usbd_msc_media_ops->media_read(g_bot_cbw.lun,
    3e4c:	7b68      	ldrb	r0, [r5, #13]
    3e4e:	4642      	mov	r2, r8
    3e50:	a905      	add	r1, sp, #20
    3e52:	463b      	mov	r3, r7
    3e54:	47e0      	blx	ip
                                                            &buf,
                                                            lba_addr,
                                                            dev_data_len);
        }

        if((uint8_t*)0 == buf)
    3e56:	9a05      	ldr	r2, [sp, #20]
    3e58:	2a00      	cmp	r2, #0
    3e5a:	d09c      	beq.n	3d96 <usbd_msc_bot_fsm+0x7b2>
            cb_res = CB_INTERNAL_ERROR;
        }
        else
        {
            cb_res = CB_PASS;
            g_xfr_buf_ptr = buf;
    3e5c:	f640 11b8 	movw	r1, #2488	; 0x9b8
    3e60:	f2c2 0100 	movt	r1, #8192	; 0x2000

            if(app_read_len < dev_data_len)
            {
                g_xfr_buf_len = app_read_len;
    3e64:	42b8      	cmp	r0, r7
    3e66:	bf94      	ite	ls
    3e68:	60c8      	strls	r0, [r1, #12]
    3e6a:	60cf      	strhi	r7, [r1, #12]
            cb_res = CB_INTERNAL_ERROR;
        }
        else
        {
            cb_res = CB_PASS;
            g_xfr_buf_ptr = buf;
    3e6c:	6062      	str	r2, [r4, #4]
            }
            /*
            Store the current LBA address so that it will be used to calculate
            new LBA  address when remaining data is read from flash.
            */
            g_xfr_lba_addr = lba_addr;
    3e6e:	f8c4 8010 	str.w	r8, [r4, #16]
    3e72:	68ab      	ldr	r3, [r5, #8]
    3e74:	e539      	b.n	38ea <usbd_msc_bot_fsm+0x306>
    if(g_bot_cbw.cmd_block[8u] & 0x01u)
    {
        return(CB_INVALID_CDB_FIELD);
    }

    if(0 == g_usbd_msc_media_ops->media_get_capacity)
    3e76:	68bf      	ldr	r7, [r7, #8]
    3e78:	e78b      	b.n	3d92 <usbd_msc_bot_fsm+0x7ae>
    3e7a:	bf00      	nop

00003e7c <usbd_msc_rx_cb>:
(
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    3e7c:	b508      	push	{r3, lr}
    xfr length > Allocation length field ==> Terminate with CHECK CONDITION status,
    sense key = ILLEGAL_REQUEST, additional sense code = INVALID FIELD in CDB
    when NACA bit = 0 ==> ACA condition is not set = command abort should be done
    as per sam-5, 5.8.2
    */
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
    3e7e:	f011 0f0f 	tst.w	r1, #15
                 RX_EP_DATA_ERROR | RX_EP_PID_ERROR | RX_EP_ISO_INCOMP_ERROR))
    {
        g_botrx_events = BOT_EVENT_RX_ERROR;
    3e82:	f640 13b8 	movw	r3, #2488	; 0x9b8
(
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    3e86:	4608      	mov	r0, r1
    as per sam-5, 5.8.2
    */
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
                 RX_EP_DATA_ERROR | RX_EP_PID_ERROR | RX_EP_ISO_INCOMP_ERROR))
    {
        g_botrx_events = BOT_EVENT_RX_ERROR;
    3e88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    xfr length > Allocation length field ==> Terminate with CHECK CONDITION status,
    sense key = ILLEGAL_REQUEST, additional sense code = INVALID FIELD in CDB
    when NACA bit = 0 ==> ACA condition is not set = command abort should be done
    as per sam-5, 5.8.2
    */
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
    3e8c:	d106      	bne.n	3e9c <usbd_msc_rx_cb+0x20>
    {
        g_botrx_events = BOT_EVENT_RX_ERROR;
    }
    else
    {
        g_botrx_events = BOT_EVENT_RX;
    3e8e:	2102      	movs	r1, #2
    3e90:	7299      	strb	r1, [r3, #10]
    }

    usbd_msc_bot_fsm(status, rx_count);
    3e92:	4611      	mov	r1, r2
    3e94:	f7ff fba6 	bl	35e4 <usbd_msc_bot_fsm>

    return USB_SUCCESS;
}
    3e98:	2001      	movs	r0, #1
    3e9a:	bd08      	pop	{r3, pc}
    as per sam-5, 5.8.2
    */
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
                 RX_EP_DATA_ERROR | RX_EP_PID_ERROR | RX_EP_ISO_INCOMP_ERROR))
    {
        g_botrx_events = BOT_EVENT_RX_ERROR;
    3e9c:	2104      	movs	r1, #4
    3e9e:	7299      	strb	r1, [r3, #10]
    else
    {
        g_botrx_events = BOT_EVENT_RX;
    }

    usbd_msc_bot_fsm(status, rx_count);
    3ea0:	4611      	mov	r1, r2
    3ea2:	f7ff fb9f 	bl	35e4 <usbd_msc_bot_fsm>

    return USB_SUCCESS;
}
    3ea6:	2001      	movs	r0, #1
    3ea8:	bd08      	pop	{r3, pc}
    3eaa:	bf00      	nop

00003eac <usbd_msc_tx_complete_cb>:
static uint8_t usbd_msc_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    3eac:	b508      	push	{r3, lr}
    /*Underrun error ignore, it only means we are slow and that is because of
    the slow serial flash memory*/
    if(status & (TX_EP_STALL_ERROR))
    3eae:	f011 0f02 	tst.w	r1, #2
    {
        g_bottx_events = BOT_EVENT_TX_ERROR;
    3eb2:	f640 13b8 	movw	r3, #2488	; 0x9b8
    3eb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    uint8_t status
)
{
    /*Underrun error ignore, it only means we are slow and that is because of
    the slow serial flash memory*/
    if(status & (TX_EP_STALL_ERROR))
    3eba:	d107      	bne.n	3ecc <usbd_msc_tx_complete_cb+0x20>
    {
        g_bottx_events = BOT_EVENT_TX_ERROR;
    }
    else
    {
        g_bottx_events = BOT_EVENT_TX;
    3ebc:	2001      	movs	r0, #1
    3ebe:	7258      	strb	r0, [r3, #9]
    }

    usbd_msc_bot_fsm(status, 0u);
    3ec0:	4608      	mov	r0, r1
    3ec2:	2100      	movs	r1, #0
    3ec4:	f7ff fb8e 	bl	35e4 <usbd_msc_bot_fsm>

    return USB_SUCCESS;
}
    3ec8:	2001      	movs	r0, #1
    3eca:	bd08      	pop	{r3, pc}
{
    /*Underrun error ignore, it only means we are slow and that is because of
    the slow serial flash memory*/
    if(status & (TX_EP_STALL_ERROR))
    {
        g_bottx_events = BOT_EVENT_TX_ERROR;
    3ecc:	2203      	movs	r2, #3
    else
    {
        g_bottx_events = BOT_EVENT_TX;
    }

    usbd_msc_bot_fsm(status, 0u);
    3ece:	4608      	mov	r0, r1
{
    /*Underrun error ignore, it only means we are slow and that is because of
    the slow serial flash memory*/
    if(status & (TX_EP_STALL_ERROR))
    {
        g_bottx_events = BOT_EVENT_TX_ERROR;
    3ed0:	725a      	strb	r2, [r3, #9]
    else
    {
        g_bottx_events = BOT_EVENT_TX;
    }

    usbd_msc_bot_fsm(status, 0u);
    3ed2:	2100      	movs	r1, #0
    3ed4:	f7ff fb86 	bl	35e4 <usbd_msc_bot_fsm>

    return USB_SUCCESS;
}
    3ed8:	2001      	movs	r0, #1
    3eda:	bd08      	pop	{r3, pc}

00003edc <MSS_USBD_PRINTER_set_cb_handler>:
MSS_USBD_PRINTER_set_cb_handler
(
    mss_usbd_printer_cb_t* user_desc_cb
)
{
    g_mss_usbd_printer_ops = user_desc_cb;
    3edc:	f640 33dc 	movw	r3, #3036	; 0xbdc
    3ee0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3ee4:	6018      	str	r0, [r3, #0]
}
    3ee6:	4770      	bx	lr

00003ee8 <MSS_USBD_printer_get_state>:
mss_usbd_printer_state_t
MSS_USBD_printer_get_state
(
    void
)
{
    3ee8:	f640 230c 	movw	r3, #2572	; 0xa0c
    3eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    return g_usbd_printer_state;
}
    3ef0:	7818      	ldrb	r0, [r3, #0]
    3ef2:	4770      	bx	lr

00003ef4 <usbd_printer_release_cb>:
(
    uint8_t cfgidx
)
{
    /* Inform to the application about clear configuration command. */
    if(g_mss_usbd_printer_ops->usb_printer_release != 0)
    3ef4:	f640 31dc 	movw	r1, #3036	; 0xbdc
    3ef8:	f2c2 0100 	movt	r1, #8192	; 0x2000
static uint8_t
usbd_printer_release_cb
(
    uint8_t cfgidx
)
{
    3efc:	b508      	push	{r3, lr}
    /* Inform to the application about clear configuration command. */
    if(g_mss_usbd_printer_ops->usb_printer_release != 0)
    3efe:	680b      	ldr	r3, [r1, #0]
    3f00:	685b      	ldr	r3, [r3, #4]
    3f02:	b103      	cbz	r3, 3f06 <usbd_printer_release_cb+0x12>
    {
        g_mss_usbd_printer_ops->usb_printer_release(cfgidx);
    3f04:	4798      	blx	r3
    }

    g_usbd_printer_state = USBD_PRINTER_NOT_CONFIGURED;
    3f06:	f640 200c 	movw	r0, #2572	; 0xa0c
    3f0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
    3f0e:	2200      	movs	r2, #0
    3f10:	7002      	strb	r2, [r0, #0]

    return USB_SUCCESS;
}
    3f12:	2001      	movs	r0, #1
    3f14:	bd08      	pop	{r3, pc}
    3f16:	bf00      	nop

00003f18 <usbd_printer_get_descriptor_cb>:
    uint8_t recepient,
    uint8_t type,
    uint32_t* length,
    mss_usb_device_speed_t musb_speed
)
{
    3f18:	b510      	push	{r4, lr}
    uint8_t* conf_descripter = 0x00u;

    /* Inform to the application about GET_DESCRIPTOR request from USB Host. */
    if(g_mss_usbd_printer_ops->usb_printer_get_descriptor != 0)
    3f1a:	f640 34dc 	movw	r4, #3036	; 0xbdc
    3f1e:	f2c2 0400 	movt	r4, #8192	; 0x2000
    3f22:	6824      	ldr	r4, [r4, #0]
    3f24:	68a4      	ldr	r4, [r4, #8]
    3f26:	b10c      	cbz	r4, 3f2c <usbd_printer_get_descriptor_cb+0x14>
    {
        conf_descripter = g_mss_usbd_printer_ops->usb_printer_get_descriptor(recepient,
    3f28:	47a0      	blx	r4
                                                                            length,
                                                                            musb_speed);
    }

    return conf_descripter;
}
    3f2a:	bd10      	pop	{r4, pc}
)
{
    uint8_t* conf_descripter = 0x00u;

    /* Inform to the application about GET_DESCRIPTOR request from USB Host. */
    if(g_mss_usbd_printer_ops->usb_printer_get_descriptor != 0)
    3f2c:	4620      	mov	r0, r4
    3f2e:	bd10      	pop	{r4, pc}

00003f30 <usbd_printer_process_request_cb>:
(
    mss_usbd_setup_pkt_t* setup_pkt,
    uint8_t** buf_pp,
    uint32_t* length
)
{
    3f30:	b508      	push	{r3, lr}
    uint8_t status = 0x0u;

    if(g_mss_usbd_printer_ops->usb_printer_process_request != 0)
    3f32:	f640 33dc 	movw	r3, #3036	; 0xbdc
    3f36:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f3a:	681b      	ldr	r3, [r3, #0]
    3f3c:	68db      	ldr	r3, [r3, #12]
    3f3e:	b10b      	cbz	r3, 3f44 <usbd_printer_process_request_cb+0x14>
    {
        status = g_mss_usbd_printer_ops->usb_printer_process_request(setup_pkt,
    3f40:	4798      	blx	r3
                                                                    buf_pp,
                                                                    length);
    }
    return status;
}
    3f42:	bd08      	pop	{r3, pc}
    uint32_t* length
)
{
    uint8_t status = 0x0u;

    if(g_mss_usbd_printer_ops->usb_printer_process_request != 0)
    3f44:	4618      	mov	r0, r3
    3f46:	bd08      	pop	{r3, pc}

00003f48 <usbd_printer_tx_complete_cb>:
static uint8_t usbd_printer_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    3f48:	b508      	push	{r3, lr}
    if(status & (TX_EP_UNDER_RUN_ERROR | TX_EP_STALL_ERROR) )
    3f4a:	f011 0f03 	tst.w	r1, #3
    {
        g_printer_events = PRINTER_EVENT_TX_ERROR;
    3f4e:	f640 230c 	movw	r3, #2572	; 0xa0c
    3f52:	f2c2 0300 	movt	r3, #8192	; 0x2000
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    if(status & (TX_EP_UNDER_RUN_ERROR | TX_EP_STALL_ERROR) )
    3f56:	d00b      	beq.n	3f70 <usbd_printer_tx_complete_cb+0x28>
    {
        g_printer_events = PRINTER_EVENT_TX_ERROR;
    3f58:	2203      	movs	r2, #3
    3f5a:	705a      	strb	r2, [r3, #1]
    {
        g_printer_events = PRINTER_EVENT_TX;
    }

    /* Inform to the application about IN transaction completion. */
    if(g_mss_usbd_printer_ops->usb_printer_tx_complete != 0)
    3f5c:	f640 32dc 	movw	r2, #3036	; 0xbdc
    3f60:	f2c2 0200 	movt	r2, #8192	; 0x2000
    3f64:	6813      	ldr	r3, [r2, #0]
    3f66:	691b      	ldr	r3, [r3, #16]
    3f68:	b103      	cbz	r3, 3f6c <usbd_printer_tx_complete_cb+0x24>
    {
        g_mss_usbd_printer_ops->usb_printer_tx_complete(num, status);
    3f6a:	4798      	blx	r3
    }

    return USB_SUCCESS;
}
    3f6c:	2001      	movs	r0, #1
    3f6e:	bd08      	pop	{r3, pc}
    {
        g_printer_events = PRINTER_EVENT_TX_ERROR;
    }
    else
    {
        g_printer_events = PRINTER_EVENT_TX;
    3f70:	2201      	movs	r2, #1
    3f72:	705a      	strb	r2, [r3, #1]
    3f74:	e7f2      	b.n	3f5c <usbd_printer_tx_complete_cb+0x14>
    3f76:	bf00      	nop

00003f78 <usbd_printer_rx_cb>:
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
    3f78:	f011 0f0f 	tst.w	r1, #15
(
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    3f7c:	b508      	push	{r3, lr}
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
                 RX_EP_DATA_ERROR | RX_EP_PID_ERROR | RX_EP_ISO_INCOMP_ERROR))
    {
        g_printer_events = PRINTER_EVENT_RX_ERROR;
    3f7e:	f640 230c 	movw	r3, #2572	; 0xa0c
    3f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f86:	bf14      	ite	ne
    3f88:	f04f 0c04 	movne.w	ip, #4
    }
    else
    {
        g_printer_events = PRINTER_EVENT_RX;
    3f8c:	f04f 0c02 	moveq.w	ip, #2
    3f90:	f883 c001 	strb.w	ip, [r3, #1]
    }

    /* Inform to the application about OUT transaction completion. */
    if(g_mss_usbd_printer_ops->usb_printer_rx != 0)
    3f94:	f640 33dc 	movw	r3, #3036	; 0xbdc
    3f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    3f9c:	681b      	ldr	r3, [r3, #0]
    3f9e:	695b      	ldr	r3, [r3, #20]
    3fa0:	b103      	cbz	r3, 3fa4 <usbd_printer_rx_cb+0x2c>
    {
        g_mss_usbd_printer_ops->usb_printer_rx(num, status, rx_count);
    3fa2:	4798      	blx	r3
    }

    return USB_SUCCESS;
}
    3fa4:	2001      	movs	r0, #1
    3fa6:	bd08      	pop	{r3, pc}

00003fa8 <usbd_printer_cep_tx_complete_cb>:
    uint8_t status
)
{
    uint8_t return_status = 0x00u;

    if(g_mss_usbd_printer_ops->usb_printer_cep_tx_complete != 0)
    3fa8:	f640 31dc 	movw	r1, #3036	; 0xbdc
    3fac:	f2c2 0100 	movt	r1, #8192	; 0x2000
static uint8_t
usbd_printer_cep_tx_complete_cb
(
    uint8_t status
)
{
    3fb0:	b508      	push	{r3, lr}
    uint8_t return_status = 0x00u;

    if(g_mss_usbd_printer_ops->usb_printer_cep_tx_complete != 0)
    3fb2:	680b      	ldr	r3, [r1, #0]
    3fb4:	699b      	ldr	r3, [r3, #24]
    3fb6:	b10b      	cbz	r3, 3fbc <usbd_printer_cep_tx_complete_cb+0x14>
    {
        return_status = g_mss_usbd_printer_ops->usb_printer_cep_tx_complete(status);
    3fb8:	4798      	blx	r3
    }
    return return_status;
}
    3fba:	bd08      	pop	{r3, pc}
    uint8_t status
)
{
    uint8_t return_status = 0x00u;

    if(g_mss_usbd_printer_ops->usb_printer_cep_tx_complete != 0)
    3fbc:	4618      	mov	r0, r3
    3fbe:	bd08      	pop	{r3, pc}

00003fc0 <usbd_printer_cep_rx_cb>:
    uint8_t status
)
{
    uint8_t return_status = 0x00u;

    if(g_mss_usbd_printer_ops->usb_printer_cep_rx != 0)
    3fc0:	f640 31dc 	movw	r1, #3036	; 0xbdc
    3fc4:	f2c2 0100 	movt	r1, #8192	; 0x2000
static uint8_t
usbd_printer_cep_rx_cb
(
    uint8_t status
)
{
    3fc8:	b508      	push	{r3, lr}
    uint8_t return_status = 0x00u;

    if(g_mss_usbd_printer_ops->usb_printer_cep_rx != 0)
    3fca:	680b      	ldr	r3, [r1, #0]
    3fcc:	69db      	ldr	r3, [r3, #28]
    3fce:	b10b      	cbz	r3, 3fd4 <usbd_printer_cep_rx_cb+0x14>
    {
        return_status = g_mss_usbd_printer_ops->usb_printer_cep_rx(status);
    3fd0:	4798      	blx	r3
    }

    return return_status;
}
    3fd2:	bd08      	pop	{r3, pc}
    uint8_t status
)
{
    uint8_t return_status = 0x00u;

    if(g_mss_usbd_printer_ops->usb_printer_cep_rx != 0)
    3fd4:	4618      	mov	r0, r3
    3fd6:	bd08      	pop	{r3, pc}

00003fd8 <usbd_printer_init_cb>:
usbd_printer_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    3fd8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint16_t bulk_txep_maxpktsz = 0u;

    g_printer_events = PRINTER_EVENT_IDLE;
    g_usbd_printer_state = USBD_PRINTER_NOT_CONFIGURED;

    bulk_txep_fifo_sz = (uint16_t)((conf_descr[23u] << 8u) | (conf_descr[22u]));
    3fdc:	f240 24fc 	movw	r4, #764	; 0x2fc
    3fe0:	f2c2 0400 	movt	r4, #8192	; 0x2000
    bulk_txep_maxpktsz = (uint16_t)((conf_descr[23u] << 8u) | (conf_descr[22u]));
    bulk_rxep_fifo_sz = (uint16_t)((conf_descr[30u] << 8u) | (conf_descr[29u]));
    3fe4:	f894 c01e 	ldrb.w	ip, [r4, #30]
    3fe8:	7f62      	ldrb	r2, [r4, #29]
    uint16_t bulk_txep_maxpktsz = 0u;

    g_printer_events = PRINTER_EVENT_IDLE;
    g_usbd_printer_state = USBD_PRINTER_NOT_CONFIGURED;

    bulk_txep_fifo_sz = (uint16_t)((conf_descr[23u] << 8u) | (conf_descr[22u]));
    3fea:	7da6      	ldrb	r6, [r4, #22]
    3fec:	f894 8017 	ldrb.w	r8, [r4, #23]
    bulk_txep_maxpktsz = (uint16_t)((conf_descr[23u] << 8u) | (conf_descr[22u]));
    bulk_rxep_fifo_sz = (uint16_t)((conf_descr[30u] << 8u) | (conf_descr[29u]));
    3ff0:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
    /*NO_ZLP_TO_XFR is selected for both endpoints because the Printers
    generally have a transfer level protocol (Similar to SCSI in MSC class)
    by which the transfer size is known before starting the transfer.
    So, a ZLP is not required to terminate the BULK transfer when the transfer
    size is WMaxPktlen or its multiple*/
    MSS_USBD_rx_ep_configure(PRINTER_CLASS_BULK_RX_EP,
    3ff4:	2401      	movs	r4, #1
    uint16_t bulk_rxep_fifo_sz = 0u;
    uint16_t bulk_rxep_maxpktsz = 0u;
    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_printer_events = PRINTER_EVENT_IDLE;
    3ff6:	f640 250c 	movw	r5, #2572	; 0xa0c
usbd_printer_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    3ffa:	b086      	sub	sp, #24
    uint16_t bulk_txep_maxpktsz = 0u;

    g_printer_events = PRINTER_EVENT_IDLE;
    g_usbd_printer_state = USBD_PRINTER_NOT_CONFIGURED;

    bulk_txep_fifo_sz = (uint16_t)((conf_descr[23u] << 8u) | (conf_descr[22u]));
    3ffc:	ea46 2808 	orr.w	r8, r6, r8, lsl #8
    /*NO_ZLP_TO_XFR is selected for both endpoints because the Printers
    generally have a transfer level protocol (Similar to SCSI in MSC class)
    by which the transfer size is known before starting the transfer.
    So, a ZLP is not required to terminate the BULK transfer when the transfer
    size is WMaxPktlen or its multiple*/
    MSS_USBD_rx_ep_configure(PRINTER_CLASS_BULK_RX_EP,
    4000:	4613      	mov	r3, r2
    uint16_t bulk_rxep_fifo_sz = 0u;
    uint16_t bulk_rxep_maxpktsz = 0u;
    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_printer_events = PRINTER_EVENT_IDLE;
    4002:	2600      	movs	r6, #0
    4004:	f2c2 0500 	movt	r5, #8192	; 0x2000
    /*NO_ZLP_TO_XFR is selected for both endpoints because the Printers
    generally have a transfer level protocol (Similar to SCSI in MSC class)
    by which the transfer size is known before starting the transfer.
    So, a ZLP is not required to terminate the BULK transfer when the transfer
    size is WMaxPktlen or its multiple*/
    MSS_USBD_rx_ep_configure(PRINTER_CLASS_BULK_RX_EP,
    4008:	2702      	movs	r7, #2
usbd_printer_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    400a:	4682      	mov	sl, r0
    400c:	4689      	mov	r9, r1
    /*NO_ZLP_TO_XFR is selected for both endpoints because the Printers
    generally have a transfer level protocol (Similar to SCSI in MSC class)
    by which the transfer size is known before starting the transfer.
    So, a ZLP is not required to terminate the BULK transfer when the transfer
    size is WMaxPktlen or its multiple*/
    MSS_USBD_rx_ep_configure(PRINTER_CLASS_BULK_RX_EP,
    400e:	4620      	mov	r0, r4
    4010:	f44f 7180 	mov.w	r1, #256	; 0x100
    uint16_t bulk_rxep_fifo_sz = 0u;
    uint16_t bulk_rxep_maxpktsz = 0u;
    uint16_t bulk_txep_fifo_sz = 0u;
    uint16_t bulk_txep_maxpktsz = 0u;

    g_printer_events = PRINTER_EVENT_IDLE;
    4014:	706e      	strb	r6, [r5, #1]
    g_usbd_printer_state = USBD_PRINTER_NOT_CONFIGURED;
    4016:	702e      	strb	r6, [r5, #0]
    /*NO_ZLP_TO_XFR is selected for both endpoints because the Printers
    generally have a transfer level protocol (Similar to SCSI in MSC class)
    by which the transfer size is known before starting the transfer.
    So, a ZLP is not required to terminate the BULK transfer when the transfer
    size is WMaxPktlen or its multiple*/
    MSS_USBD_rx_ep_configure(PRINTER_CLASS_BULK_RX_EP,
    4018:	9400      	str	r4, [sp, #0]
    401a:	9401      	str	r4, [sp, #4]
    401c:	9602      	str	r6, [sp, #8]
    401e:	9703      	str	r7, [sp, #12]
    4020:	9604      	str	r6, [sp, #16]
    4022:	f7fd fe85 	bl	1d30 <MSS_USBD_rx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL1,
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    MSS_USBD_tx_ep_configure(PRINTER_CLASS_BULK_TX_EP,
    4026:	4620      	mov	r0, r4
    4028:	4643      	mov	r3, r8
    402a:	4642      	mov	r2, r8
    402c:	f44f 7100 	mov.w	r1, #512	; 0x200
    4030:	9703      	str	r7, [sp, #12]
    4032:	9604      	str	r6, [sp, #16]
    4034:	9400      	str	r4, [sp, #0]
    4036:	9401      	str	r4, [sp, #4]
    4038:	9402      	str	r4, [sp, #8]
    403a:	f7fd fef1 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             MSS_USB_DMA_CHANNEL2,
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    /* Inform to the application. */
    if(g_mss_usbd_printer_ops->usb_printer_init != 0)
    403e:	f640 30dc 	movw	r0, #3036	; 0xbdc
    4042:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4046:	6803      	ldr	r3, [r0, #0]
    4048:	681b      	ldr	r3, [r3, #0]
    404a:	b113      	cbz	r3, 4052 <usbd_printer_init_cb+0x7a>
    {
        g_mss_usbd_printer_ops->usb_printer_init(cfgidx, musb_speed);
    404c:	4650      	mov	r0, sl
    404e:	4649      	mov	r1, r9
    4050:	4798      	blx	r3
    }

    g_usbd_printer_state = USBD_PRINTER_CONFIGURED;
    4052:	2001      	movs	r0, #1
    4054:	7028      	strb	r0, [r5, #0]

    return USB_SUCCESS;
}
    4056:	b006      	add	sp, #24
    4058:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000405c <MSS_USBD_PRINTER_read_prepare>:
MSS_USBD_PRINTER_read_prepare
(
    uint8_t* buf,
    uint32_t len
)
{
    405c:	460a      	mov	r2, r1
    MSS_USBD_rx_ep_read_prepare(PRINTER_CLASS_BULK_RX_EP, (uint8_t*)buf, len);
    405e:	4601      	mov	r1, r0
    4060:	2001      	movs	r0, #1
    4062:	f7fd be41 	b.w	1ce8 <MSS_USBD_rx_ep_read_prepare>
    4066:	bf00      	nop

00004068 <MSS_USBD_PRINTER_write>:
MSS_USBD_PRINTER_write
(
    uint8_t* buf,
    uint32_t len
)
{
    4068:	460a      	mov	r2, r1
    MSS_USBD_tx_ep_write(PRINTER_CLASS_BULK_TX_EP, buf, len);
    406a:	4601      	mov	r1, r0
    406c:	2001      	movs	r0, #1
    406e:	f7fd bc61 	b.w	1934 <MSS_USBD_tx_ep_write>
    4072:	bf00      	nop

00004074 <MSS_USBD_printer_init>:
MSS_USBD_printer_init
(
    void
)
{
    MSS_USBD_set_class_cb_handler(&usb_printer_class_cb);
    4074:	4801      	ldr	r0, [pc, #4]	; (407c <MSS_USBD_printer_init+0x8>)
    4076:	f7fd ba1d 	b.w	14b4 <MSS_USBD_set_class_cb_handler>
    407a:	bf00      	nop
    407c:	2000031c 	.word	0x2000031c

00004080 <usbd_vendor_get_descriptor_cb>:

static uint8_t* usbd_vendor_get_descriptor_cb(uint8_t recepient,
                                              uint8_t type,
                                              uint32_t* length,
                                              mss_usb_device_speed_t musb_speed)
{
    4080:	b470      	push	{r4, r5, r6}
        Operate only in FS
      User Selected HS:
        Device connected to 2.0 Host(musb_speed = HS):Operate in HS
        Device connected to 1.x Host(musb_speed = FS):Operate in FS
    */
    if(MSS_USB_DEVICE_FS == g_usbd_vendor_user_speed)
    4082:	f640 34e0 	movw	r4, #3040	; 0xbe0
    4086:	f2c2 0400 	movt	r4, #8192	; 0x2000
    408a:	7824      	ldrb	r4, [r4, #0]

static uint8_t* usbd_vendor_get_descriptor_cb(uint8_t recepient,
                                              uint8_t type,
                                              uint32_t* length,
                                              mss_usb_device_speed_t musb_speed)
{
    408c:	4605      	mov	r5, r0
        Operate only in FS
      User Selected HS:
        Device connected to 2.0 Host(musb_speed = HS):Operate in HS
        Device connected to 1.x Host(musb_speed = FS):Operate in FS
    */
    if(MSS_USB_DEVICE_FS == g_usbd_vendor_user_speed)
    408e:	2c01      	cmp	r4, #1
    4090:	d020      	beq.n	40d4 <usbd_vendor_get_descriptor_cb+0x54>

        conf_desc_len = sizeof(vendor_fs_conf_descr);
        os_conf_desc = 0u;
        os_conf_desc_len = 0u;
    }
    else if(MSS_USB_DEVICE_HS == g_usbd_vendor_user_speed)
    4092:	b9bc      	cbnz	r4, 40c4 <usbd_vendor_get_descriptor_cb+0x44>
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
    4094:	2b00      	cmp	r3, #0
    4096:	d029      	beq.n	40ec <usbd_vendor_get_descriptor_cb+0x6c>
            os_conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
                                        USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;

            os_conf_desc_len = sizeof(vendor_fs_conf_descr);
        }
        else if(MSS_USB_DEVICE_FS ==musb_speed)
    4098:	2b01      	cmp	r3, #1
    409a:	d113      	bne.n	40c4 <usbd_vendor_get_descriptor_cb+0x44>
        {
            conf_desc = vendor_fs_conf_descr;
            conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    409c:	f240 335c 	movw	r3, #860	; 0x35c
    40a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    40a4:	2402      	movs	r4, #2
                                             USB_CONFIGURATION_DESCRIPTOR_TYPE;

            conf_desc_len = sizeof(vendor_fs_conf_descr);
            os_conf_desc = vendor_hs_conf_descr;
            os_conf_desc[1u] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    40a6:	2007      	movs	r0, #7
    40a8:	262e      	movs	r6, #46	; 0x2e
            os_conf_desc_len = sizeof(vendor_fs_conf_descr);
        }
        else if(MSS_USB_DEVICE_FS ==musb_speed)
        {
            conf_desc = vendor_fs_conf_descr;
            conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    40aa:	705c      	strb	r4, [r3, #1]
                                             USB_CONFIGURATION_DESCRIPTOR_TYPE;

            conf_desc_len = sizeof(vendor_fs_conf_descr);
            os_conf_desc = vendor_hs_conf_descr;
            os_conf_desc[1u] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    40ac:	f883 0031 	strb.w	r0, [r3, #49]	; 0x31
    40b0:	4634      	mov	r4, r6
    40b2:	4618      	mov	r0, r3
    40b4:	3330      	adds	r3, #48	; 0x30
    else
    {
        ASSERT(0);      //user must select FS or HS, nothing else.
    }

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    40b6:	b95d      	cbnz	r5, 40d0 <usbd_vendor_get_descriptor_cb+0x50>
    {
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
    40b8:	2902      	cmp	r1, #2
        {
           *length = conf_desc_len;
    40ba:	bf08      	it	eq
    40bc:	6014      	streq	r4, [r2, #0]
        ASSERT(0);      //user must select FS or HS, nothing else.
    }

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    {
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
    40be:	d124      	bne.n	410a <usbd_vendor_get_descriptor_cb+0x8a>
    {
        /*Do nothing*/
    }
    return USB_FAIL;

}
    40c0:	bc70      	pop	{r4, r5, r6}
    40c2:	4770      	bx	lr
            conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
                                             USB_CONFIGURATION_DESCRIPTOR_TYPE;

            conf_desc_len = sizeof(vendor_fs_conf_descr);
            os_conf_desc = vendor_hs_conf_descr;
            os_conf_desc[1u] = USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE;
    40c4:	2300      	movs	r3, #0
    40c6:	4618      	mov	r0, r3
    40c8:	461e      	mov	r6, r3
    40ca:	461c      	mov	r4, r3
    else
    {
        ASSERT(0);      //user must select FS or HS, nothing else.
    }

    if(USB_STD_REQ_RECIPIENT_DEVICE == recepient)
    40cc:	2d00      	cmp	r5, #0
    40ce:	d0f3      	beq.n	40b8 <usbd_vendor_get_descriptor_cb+0x38>
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
        {
            ASSERT(os_conf_desc != 0u);
            *length = os_conf_desc_len;
            return(os_conf_desc);
    40d0:	2000      	movs	r0, #0
    40d2:	e7f5      	b.n	40c0 <usbd_vendor_get_descriptor_cb+0x40>
        Device connected to 1.x Host(musb_speed = FS):Operate in FS
    */
    if(MSS_USB_DEVICE_FS == g_usbd_vendor_user_speed)
    {
        conf_desc = vendor_fs_conf_descr;
        conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    40d4:	f240 305c 	movw	r0, #860	; 0x35c
    40d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    40dc:	2300      	movs	r3, #0
    40de:	f04f 0c02 	mov.w	ip, #2
    40e2:	f880 c001 	strb.w	ip, [r0, #1]
    40e6:	461e      	mov	r6, r3
    40e8:	242e      	movs	r4, #46	; 0x2e
    40ea:	e7e4      	b.n	40b6 <usbd_vendor_get_descriptor_cb+0x36>
    else if(MSS_USB_DEVICE_HS == g_usbd_vendor_user_speed)
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
        {
            conf_desc = vendor_hs_conf_descr;
            conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    40ec:	f240 305c 	movw	r0, #860	; 0x35c
    40f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
                                              USB_CONFIGURATION_DESCRIPTOR_TYPE;

            conf_desc_len = sizeof(vendor_hs_conf_descr);
            os_conf_desc = vendor_fs_conf_descr;
            os_conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    40f4:	2407      	movs	r4, #7
    40f6:	262e      	movs	r6, #46	; 0x2e
    else if(MSS_USB_DEVICE_HS == g_usbd_vendor_user_speed)
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
        {
            conf_desc = vendor_hs_conf_descr;
            conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    40f8:	f04f 0c02 	mov.w	ip, #2
                                              USB_CONFIGURATION_DESCRIPTOR_TYPE;

            conf_desc_len = sizeof(vendor_hs_conf_descr);
            os_conf_desc = vendor_fs_conf_descr;
            os_conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    40fc:	7044      	strb	r4, [r0, #1]
    40fe:	4603      	mov	r3, r0
    else if(MSS_USB_DEVICE_HS == g_usbd_vendor_user_speed)
    {
        if(MSS_USB_DEVICE_HS == musb_speed)
        {
            conf_desc = vendor_hs_conf_descr;
            conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    4100:	f880 c031 	strb.w	ip, [r0, #49]	; 0x31
                                              USB_CONFIGURATION_DESCRIPTOR_TYPE;

            conf_desc_len = sizeof(vendor_hs_conf_descr);
            os_conf_desc = vendor_fs_conf_descr;
            os_conf_desc[VENDOR_CONF_DESCR_DESCTYPE_IDX] =
    4104:	4634      	mov	r4, r6
    4106:	3030      	adds	r0, #48	; 0x30
    4108:	e7d5      	b.n	40b6 <usbd_vendor_get_descriptor_cb+0x36>
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
        {
           *length = conf_desc_len;
            return(conf_desc);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
    410a:	2907      	cmp	r1, #7
        {
            ASSERT(os_conf_desc != 0u);
            *length = os_conf_desc_len;
    410c:	bf04      	itt	eq
    410e:	6016      	streq	r6, [r2, #0]
    4110:	4618      	moveq	r0, r3
        if(USB_CONFIGURATION_DESCRIPTOR_TYPE == type)
        {
           *length = conf_desc_len;
            return(conf_desc);
        }
        else if(USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE == type)
    4112:	d0d5      	beq.n	40c0 <usbd_vendor_get_descriptor_cb+0x40>
        {
            ASSERT(os_conf_desc != 0u);
            *length = os_conf_desc_len;
            return(os_conf_desc);
    4114:	2000      	movs	r0, #0
    4116:	e7d3      	b.n	40c0 <usbd_vendor_get_descriptor_cb+0x40>

00004118 <usbd_vendor_process_request_cb>:
    mss_usbd_setup_pkt_t* setup_pkt,
    uint8_t** buf_pp,
    uint32_t* length
)
{
    if(setup_pkt->length)
    4118:	88c3      	ldrh	r3, [r0, #6]
    411a:	b16b      	cbz	r3, 4138 <usbd_vendor_process_request_cb+0x20>
    {
        if(setup_pkt->request_type & USB_STD_REQ_DATA_DIR_MASK) /*DtoH*/
    411c:	f990 0000 	ldrsb.w	r0, [r0]
    4120:	2800      	cmp	r0, #0
            /*CEP configuration and read_prepare is taken care by USBD.
              Here we only pass the buffer address
              Once the data is received the callback function
              usbd_vendor_cep_rx_cb will be called by USBD driver.
              The actual processing of the data shall be done then.*/
            *buf_pp = (uint8_t*)&g_req_rx_data;
    4122:	bfad      	iteet	ge
    4124:	f640 2010 	movwge	r0, #2576	; 0xa10
    if(setup_pkt->length)
    {
        if(setup_pkt->request_type & USB_STD_REQ_DATA_DIR_MASK) /*DtoH*/
        {
            *buf_pp = (uint8_t*)&g_req_tx_data;
            *length = setup_pkt->length;
    4128:	6013      	strlt	r3, [r2, #0]
{
    if(setup_pkt->length)
    {
        if(setup_pkt->request_type & USB_STD_REQ_DATA_DIR_MASK) /*DtoH*/
        {
            *buf_pp = (uint8_t*)&g_req_tx_data;
    412a:	4b04      	ldrlt	r3, [pc, #16]	; (413c <usbd_vendor_process_request_cb+0x24>)
            /*CEP configuration and read_prepare is taken care by USBD.
              Here we only pass the buffer address
              Once the data is received the callback function
              usbd_vendor_cep_rx_cb will be called by USBD driver.
              The actual processing of the data shall be done then.*/
            *buf_pp = (uint8_t*)&g_req_rx_data;
    412c:	f2c2 0000 	movtge	r0, #8192	; 0x2000
{
    if(setup_pkt->length)
    {
        if(setup_pkt->request_type & USB_STD_REQ_DATA_DIR_MASK) /*DtoH*/
        {
            *buf_pp = (uint8_t*)&g_req_tx_data;
    4130:	bfb2      	itee	lt
    4132:	600b      	strlt	r3, [r1, #0]
            /*CEP configuration and read_prepare is taken care by USBD.
              Here we only pass the buffer address
              Once the data is received the callback function
              usbd_vendor_cep_rx_cb will be called by USBD driver.
              The actual processing of the data shall be done then.*/
            *buf_pp = (uint8_t*)&g_req_rx_data;
    4134:	6008      	strge	r0, [r1, #0]
            *length = setup_pkt->length;
    4136:	6013      	strge	r3, [r2, #0]
    }
    else
    {
        return USB_SUCCESS;
    }
}
    4138:	2001      	movs	r0, #1
    413a:	4770      	bx	lr
    413c:	200003bc 	.word	0x200003bc

00004140 <usbd_vendor_cep_tx_complete_cb>:
     function is called at the end of the IN data phase of that control transfer.
     The status parameter of this function indicates the error status of the OUT
     data phase.
     */
    return USB_SUCCESS;
}
    4140:	2001      	movs	r0, #1
    4142:	4770      	bx	lr

00004144 <usbd_vendor_cep_rx_cb>:
     You can process the data now. The status parameter of this function
     indicates the error status of the OUT data phase.
     */

    return USB_SUCCESS;
}
    4144:	2001      	movs	r0, #1
    4146:	4770      	bx	lr

00004148 <usbd_vendor_rx_cb>:
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
    4148:	f011 0f0f 	tst.w	r1, #15
(
    mss_usb_ep_num_t num,
    uint8_t status,
    uint32_t rx_count
)
{
    414c:	b508      	push	{r3, lr}
    if(status & (RX_EP_OVER_RUN_ERROR | RX_EP_STALL_ERROR |
    414e:	d103      	bne.n	4158 <usbd_vendor_rx_cb+0x10>
    {
        /* Take error mitigation action based on the error indication "status" */
    }
    else
    {
        if (VENDOR_INTR_TX_EP == num)
    4150:	2801      	cmp	r0, #1
    4152:	d009      	beq.n	4168 <usbd_vendor_rx_cb+0x20>
        {
            MSS_USBD_tx_ep_write(VENDOR_INTR_TX_EP,
                                 g_intr_tx_data,
                                 sizeof(g_intr_tx_data));
        }
        else if (VENDOR_BULK_TX_EP == num)
    4154:	2802      	cmp	r0, #2
    4156:	d001      	beq.n	415c <usbd_vendor_rx_cb+0x14>
        }

    }

    return USB_SUCCESS;
}
    4158:	2001      	movs	r0, #1
    415a:	bd08      	pop	{r3, pc}
                                 g_intr_tx_data,
                                 sizeof(g_intr_tx_data));
        }
        else if (VENDOR_BULK_TX_EP == num)
        {
            MSS_USBD_tx_ep_write(VENDOR_BULK_TX_EP,
    415c:	4905      	ldr	r1, [pc, #20]	; (4174 <usbd_vendor_rx_cb+0x2c>)
    415e:	2240      	movs	r2, #64	; 0x40
    4160:	f7fd fbe8 	bl	1934 <MSS_USBD_tx_ep_write>
        }

    }

    return USB_SUCCESS;
}
    4164:	2001      	movs	r0, #1
    4166:	bd08      	pop	{r3, pc}
    }
    else
    {
        if (VENDOR_INTR_TX_EP == num)
        {
            MSS_USBD_tx_ep_write(VENDOR_INTR_TX_EP,
    4168:	4903      	ldr	r1, [pc, #12]	; (4178 <usbd_vendor_rx_cb+0x30>)
    416a:	2240      	movs	r2, #64	; 0x40
    416c:	f7fd fbe2 	bl	1934 <MSS_USBD_tx_ep_write>
    4170:	e7f2      	b.n	4158 <usbd_vendor_rx_cb+0x10>
    4172:	bf00      	nop
    4174:	2000043c 	.word	0x2000043c
    4178:	200003fc 	.word	0x200003fc

0000417c <usbd_vendor_tx_complete_cb>:
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    if(status & (TX_EP_UNDER_RUN_ERROR | TX_EP_STALL_ERROR) )
    417c:	f011 0f03 	tst.w	r1, #3
static uint8_t usbd_vendor_tx_complete_cb
(
    mss_usb_ep_num_t num,
    uint8_t status
)
{
    4180:	b508      	push	{r3, lr}
    if(status & (TX_EP_UNDER_RUN_ERROR | TX_EP_STALL_ERROR) )
    4182:	d103      	bne.n	418c <usbd_vendor_tx_complete_cb+0x10>
    {
        /* Take error mitigation action based on the error indication "status" */
    }
    else
    {
        if (VENDOR_INTR_TX_EP == num)
    4184:	2801      	cmp	r0, #1
    4186:	d009      	beq.n	419c <usbd_vendor_tx_complete_cb+0x20>
        {
            MSS_USBD_rx_ep_read_prepare(VENDOR_INTR_RX_EP,
                                        (uint8_t*)&g_intr_rx_data,
                                        sizeof(g_intr_rx_data));
        }
        else if (VENDOR_BULK_TX_EP == num)
    4188:	2802      	cmp	r0, #2
    418a:	d001      	beq.n	4190 <usbd_vendor_tx_complete_cb+0x14>
            ASSERT(0); /*Endpoint number not as per descriptors.*/
        }
    }

    return USB_SUCCESS;
}
    418c:	2001      	movs	r0, #1
    418e:	bd08      	pop	{r3, pc}
                                        (uint8_t*)&g_intr_rx_data,
                                        sizeof(g_intr_rx_data));
        }
        else if (VENDOR_BULK_TX_EP == num)
        {
            MSS_USBD_rx_ep_read_prepare(VENDOR_BULK_RX_EP,
    4190:	4905      	ldr	r1, [pc, #20]	; (41a8 <usbd_vendor_tx_complete_cb+0x2c>)
    4192:	2240      	movs	r2, #64	; 0x40
    4194:	f7fd fda8 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
            ASSERT(0); /*Endpoint number not as per descriptors.*/
        }
    }

    return USB_SUCCESS;
}
    4198:	2001      	movs	r0, #1
    419a:	bd08      	pop	{r3, pc}
    }
    else
    {
        if (VENDOR_INTR_TX_EP == num)
        {
            MSS_USBD_rx_ep_read_prepare(VENDOR_INTR_RX_EP,
    419c:	4903      	ldr	r1, [pc, #12]	; (41ac <usbd_vendor_tx_complete_cb+0x30>)
    419e:	2240      	movs	r2, #64	; 0x40
    41a0:	f7fd fda2 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
    41a4:	e7f2      	b.n	418c <usbd_vendor_tx_complete_cb+0x10>
    41a6:	bf00      	nop
    41a8:	20000a90 	.word	0x20000a90
    41ac:	20000a50 	.word	0x20000a50

000041b0 <usbd_vendor_init_cb>:
usbd_vendor_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    41b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /*
      We calculate the Bulk endpoint sizes and max_pkt_size based on the
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    41b4:	2901      	cmp	r1, #1
usbd_vendor_init_cb
(
    uint8_t cfgidx,
    mss_usb_device_speed_t musb_speed
)
{
    41b6:	b087      	sub	sp, #28
      /*
      We calculate the Bulk endpoint sizes and max_pkt_size based on the
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    41b8:	d05b      	beq.n	4272 <usbd_vendor_init_cb+0xc2>
        bulk_txep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_txep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    41ba:	2900      	cmp	r1, #0
    41bc:	d153      	bne.n	4266 <usbd_vendor_init_cb+0xb6>
    {
        bulk_txep_fifo_sz = (uint16_t)((vendor_hs_conf_descr[23u] << 8u) | (vendor_hs_conf_descr[22u]));
    41be:	f240 375c 	movw	r7, #860	; 0x35c
    41c2:	f2c2 0700 	movt	r7, #8192	; 0x2000
        bulk_txep_maxpktsz = (uint16_t)((vendor_hs_conf_descr[23u] << 8u) | (vendor_hs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_hs_conf_descr[30u] << 8u) | (vendor_hs_conf_descr[29u]));
    41c6:	f897 404d 	ldrb.w	r4, [r7, #77]	; 0x4d
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((vendor_hs_conf_descr[23u] << 8u) | (vendor_hs_conf_descr[22u]));
    41ca:	f897 5047 	ldrb.w	r5, [r7, #71]	; 0x47
    41ce:	f897 6046 	ldrb.w	r6, [r7, #70]	; 0x46
        bulk_txep_maxpktsz = (uint16_t)((vendor_hs_conf_descr[23u] << 8u) | (vendor_hs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_hs_conf_descr[30u] << 8u) | (vendor_hs_conf_descr[29u]));
    41d2:	f897 004e 	ldrb.w	r0, [r7, #78]	; 0x4e
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((vendor_hs_conf_descr[23u] << 8u) | (vendor_hs_conf_descr[22u]));
    41d6:	ea46 2905 	orr.w	r9, r6, r5, lsl #8
        bulk_txep_maxpktsz = (uint16_t)((vendor_hs_conf_descr[23u] << 8u) | (vendor_hs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_hs_conf_descr[30u] << 8u) | (vendor_hs_conf_descr[29u]));
    41da:	ea44 2a00 	orr.w	sl, r4, r0, lsl #8
    41de:	46c8      	mov	r8, r9
    41e0:	46d3      	mov	fp, sl
    }
    else
    {
        ASSERT(0);
    }
    MSS_USBD_rx_ep_configure(VENDOR_INTR_RX_EP,
    41e2:	2401      	movs	r4, #1
    41e4:	2240      	movs	r2, #64	; 0x40
    41e6:	2600      	movs	r6, #0
    41e8:	4613      	mov	r3, r2
    41ea:	2703      	movs	r7, #3
    41ec:	4620      	mov	r0, r4
    41ee:	f44f 7180 	mov.w	r1, #256	; 0x100
    41f2:	9400      	str	r4, [sp, #0]
    41f4:	9401      	str	r4, [sp, #4]
    41f6:	9602      	str	r6, [sp, #8]
    41f8:	9703      	str	r7, [sp, #12]
    41fa:	9604      	str	r6, [sp, #16]
    41fc:	f7fd fd98 	bl	1d30 <MSS_USBD_rx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL1,
                             MSS_USB_XFR_INTERRUPT,
                             NO_ZLP_TO_XFR);

    MSS_USBD_rx_ep_read_prepare(VENDOR_INTR_RX_EP,
    4200:	4620      	mov	r0, r4
    4202:	2240      	movs	r2, #64	; 0x40
    4204:	4923      	ldr	r1, [pc, #140]	; (4294 <usbd_vendor_init_cb+0xe4>)
    4206:	f7fd fd6f 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
                                (uint8_t*)&g_intr_rx_data,
                                sizeof(g_intr_rx_data));

    MSS_USBD_tx_ep_configure(VENDOR_INTR_TX_EP,
    420a:	2240      	movs	r2, #64	; 0x40
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL2,
                             MSS_USB_XFR_INTERRUPT,
                             NO_ZLP_TO_XFR);

    MSS_USBD_rx_ep_configure(VENDOR_BULK_RX_EP,
    420c:	2502      	movs	r5, #2

    MSS_USBD_rx_ep_read_prepare(VENDOR_INTR_RX_EP,
                                (uint8_t*)&g_intr_rx_data,
                                sizeof(g_intr_rx_data));

    MSS_USBD_tx_ep_configure(VENDOR_INTR_TX_EP,
    420e:	4613      	mov	r3, r2
    4210:	4620      	mov	r0, r4
    4212:	f44f 71a0 	mov.w	r1, #320	; 0x140
    4216:	9400      	str	r4, [sp, #0]
    4218:	9401      	str	r4, [sp, #4]
    421a:	9402      	str	r4, [sp, #8]
    421c:	9703      	str	r7, [sp, #12]
    421e:	9604      	str	r6, [sp, #16]
    4220:	f7fd fdfe 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL2,
                             MSS_USB_XFR_INTERRUPT,
                             NO_ZLP_TO_XFR);

    MSS_USBD_rx_ep_configure(VENDOR_BULK_RX_EP,
    4224:	465b      	mov	r3, fp
    4226:	4652      	mov	r2, sl
    4228:	4628      	mov	r0, r5
    422a:	f44f 71c0 	mov.w	r1, #384	; 0x180
    422e:	9400      	str	r4, [sp, #0]
    4230:	9401      	str	r4, [sp, #4]
    4232:	9502      	str	r5, [sp, #8]
    4234:	9503      	str	r5, [sp, #12]
    4236:	9604      	str	r6, [sp, #16]
    4238:	f7fd fd7a 	bl	1d30 <MSS_USBD_rx_ep_configure>
                             DMA_ENABLE,
                             MSS_USB_DMA_CHANNEL3,
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    MSS_USBD_rx_ep_read_prepare(VENDOR_BULK_RX_EP,
    423c:	4628      	mov	r0, r5
    423e:	2240      	movs	r2, #64	; 0x40
    4240:	4915      	ldr	r1, [pc, #84]	; (4298 <usbd_vendor_init_cb+0xe8>)
    4242:	f7fd fd51 	bl	1ce8 <MSS_USBD_rx_ep_read_prepare>
                                (uint8_t*)&g_bulk_rx_data,
                                sizeof(g_bulk_rx_data));

    MSS_USBD_tx_ep_configure(VENDOR_BULK_TX_EP,
    4246:	4628      	mov	r0, r5
    4248:	464a      	mov	r2, r9
    424a:	4643      	mov	r3, r8
    424c:	f44f 7160 	mov.w	r1, #896	; 0x380
    4250:	9702      	str	r7, [sp, #8]
    4252:	9604      	str	r6, [sp, #16]
    4254:	9400      	str	r4, [sp, #0]
    4256:	9401      	str	r4, [sp, #4]
    4258:	9503      	str	r5, [sp, #12]
    425a:	f7fd fde1 	bl	1e20 <MSS_USBD_tx_ep_configure>
                             MSS_USB_DMA_CHANNEL4,
                             MSS_USB_XFR_BULK,
                             NO_ZLP_TO_XFR);

    return USB_SUCCESS;
}
    425e:	4620      	mov	r0, r4
    4260:	b007      	add	sp, #28
    4262:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bulk_txep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_txep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
        bulk_rxep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    }
    else if(MSS_USB_DEVICE_HS == musb_speed)
    4266:	f04f 0800 	mov.w	r8, #0
    426a:	46c1      	mov	r9, r8
    426c:	46c3      	mov	fp, r8
    426e:	46c2      	mov	sl, r8
    4270:	e7b7      	b.n	41e2 <usbd_vendor_init_cb+0x32>
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
    4272:	f240 335c 	movw	r3, #860	; 0x35c
    4276:	f2c2 0300 	movt	r3, #8192	; 0x2000
        bulk_txep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    427a:	7f5a      	ldrb	r2, [r3, #29]
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
    427c:	f893 9017 	ldrb.w	r9, [r3, #23]
    4280:	7d99      	ldrb	r1, [r3, #22]
        bulk_txep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    4282:	f893 a01e 	ldrb.w	sl, [r3, #30]
      respective endpoint speed. This is done so that the config descriptor change
      reflects here and this function need not be updated for that.
      */
    if(MSS_USB_DEVICE_FS == musb_speed)
    {
        bulk_txep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
    4286:	ea41 2909 	orr.w	r9, r1, r9, lsl #8
        bulk_txep_maxpktsz = (uint16_t)((vendor_fs_conf_descr[23u] << 8u) | (vendor_fs_conf_descr[22u]));
        bulk_rxep_fifo_sz = (uint16_t)((vendor_fs_conf_descr[30u] << 8u) | (vendor_fs_conf_descr[29u]));
    428a:	ea42 2a0a 	orr.w	sl, r2, sl, lsl #8
    428e:	46c8      	mov	r8, r9
    4290:	46d3      	mov	fp, sl
    4292:	e7a6      	b.n	41e2 <usbd_vendor_init_cb+0x32>
    4294:	20000a50 	.word	0x20000a50
    4298:	20000a90 	.word	0x20000a90

0000429c <MSS_USBD_VENDOR_init>:
MSS_USBD_VENDOR_init
(
    mss_usb_device_speed_t speed
)
{
    g_usbd_vendor_user_speed = speed;
    429c:	f640 33e0 	movw	r3, #3040	; 0xbe0
    42a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    42a4:	7018      	strb	r0, [r3, #0]

    MSS_USBD_set_class_cb_handler(&usb_vendor_class_cb);
    42a6:	4801      	ldr	r0, [pc, #4]	; (42ac <MSS_USBD_VENDOR_init+0x10>)
    42a8:	f7fd b904 	b.w	14b4 <MSS_USBD_set_class_cb_handler>
    42ac:	2000047c 	.word	0x2000047c

000042b0 <MSS_UART_polled_tx>:

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(pbuff != ( (uint8_t *)0));
    ASSERT(tx_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    42b0:	f640 4324 	movw	r3, #3108	; 0xc24
    42b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    42b8:	4298      	cmp	r0, r3
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    42ba:	e92d 05f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl}

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(pbuff != ( (uint8_t *)0));
    ASSERT(tx_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    42be:	d008      	beq.n	42d2 <MSS_UART_polled_tx+0x22>
    42c0:	f640 3ce4 	movw	ip, #3044	; 0xbe4
    42c4:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    42c8:	4560      	cmp	r0, ip
    42ca:	d002      	beq.n	42d2 <MSS_UART_polled_tx+0x22>
                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
            }
        } while(tx_size);
    }
}
    42cc:	e8bd 05f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl}
    42d0:	4770      	bx	lr

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(pbuff != ( (uint8_t *)0));
    ASSERT(tx_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    42d2:	1e0b      	subs	r3, r1, #0
    42d4:	bf18      	it	ne
    42d6:	2301      	movne	r3, #1
    42d8:	2a00      	cmp	r2, #0
    42da:	bf0c      	ite	eq
    42dc:	2300      	moveq	r3, #0
    42de:	f003 0301 	andne.w	r3, r3, #1
    42e2:	2b00      	cmp	r3, #0
    42e4:	d0f2      	beq.n	42cc <MSS_UART_polled_tx+0x1c>
    42e6:	f890 800d 	ldrb.w	r8, [r0, #13]
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
    42ea:	f8d0 a000 	ldr.w	sl, [r0]
    42ee:	2500      	movs	r5, #0
    42f0:	f89a c014 	ldrb.w	ip, [sl, #20]
            this_uart->status |= status;
    42f4:	ea48 080c 	orr.w	r8, r8, ip

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
    42f8:	f01c 0f20 	tst.w	ip, #32
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
    42fc:	f880 800d 	strb.w	r8, [r0, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
    4300:	d023      	beq.n	434a <MSS_UART_polled_tx+0x9a>
            {
                uint32_t fill_size = TX_FIFO_SIZE;

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
    4302:	2a0f      	cmp	r2, #15
    4304:	d924      	bls.n	4350 <MSS_UART_polled_tx+0xa0>
    4306:	2710      	movs	r7, #16

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    4308:	5d4e      	ldrb	r6, [r1, r5]
            if(status & MSS_UART_THRE)
            {
                uint32_t fill_size = TX_FIFO_SIZE;

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
    430a:	6804      	ldr	r4, [r0, #0]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    430c:	2301      	movs	r3, #1
    430e:	f107 3cff 	add.w	ip, r7, #4294967295
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    4312:	7026      	strb	r6, [r4, #0]
    4314:	ea0c 0603 	and.w	r6, ip, r3
                    char_idx++;
    4318:	eb05 0c03 	add.w	ip, r5, r3
    431c:	194d      	adds	r5, r1, r5
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    431e:	42bb      	cmp	r3, r7
    4320:	d211      	bcs.n	4346 <MSS_UART_polled_tx+0x96>
    4322:	b136      	cbz	r6, 4332 <MSS_UART_polled_tx+0x82>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    4324:	5cee      	ldrb	r6, [r5, r3]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    4326:	2302      	movs	r3, #2
    4328:	42bb      	cmp	r3, r7
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    432a:	7026      	strb	r6, [r4, #0]
                    char_idx++;
    432c:	f10c 0c01 	add.w	ip, ip, #1
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    4330:	d209      	bcs.n	4346 <MSS_UART_polled_tx+0x96>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    4332:	5cee      	ldrb	r6, [r5, r3]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    4334:	3301      	adds	r3, #1
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    4336:	7026      	strb	r6, [r4, #0]
    4338:	5cee      	ldrb	r6, [r5, r3]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    433a:	3301      	adds	r3, #1
    433c:	42bb      	cmp	r3, r7
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
    433e:	7026      	strb	r6, [r4, #0]
                    char_idx++;
    4340:	f10c 0c02 	add.w	ip, ip, #2
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    4344:	d3f5      	bcc.n	4332 <MSS_UART_polled_tx+0x82>
    4346:	4665      	mov	r5, ip
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
    4348:	1ad2      	subs	r2, r2, r3
            }
        } while(tx_size);
    434a:	2a00      	cmp	r2, #0
    434c:	d1d0      	bne.n	42f0 <MSS_UART_polled_tx+0x40>
    434e:	e7bd      	b.n	42cc <MSS_UART_polled_tx+0x1c>
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    4350:	b10a      	cbz	r2, 4356 <MSS_UART_polled_tx+0xa6>
    4352:	4617      	mov	r7, r2
    4354:	e7d8      	b.n	4308 <MSS_UART_polled_tx+0x58>
    4356:	4613      	mov	r3, r2
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
    4358:	1ad2      	subs	r2, r2, r3
    435a:	e7f6      	b.n	434a <MSS_UART_polled_tx+0x9a>

0000435c <MSS_UART_polled_tx_string>:
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(p_sz_string != ((uint8_t *)0));

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    435c:	f640 4324 	movw	r3, #3108	; 0xc24
    4360:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4364:	4298      	cmp	r0, r3
MSS_UART_polled_tx_string
(
    mss_uart_instance_t * this_uart,
    const uint8_t * p_sz_string
)
{
    4366:	e92d 05f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl}
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(p_sz_string != ((uint8_t *)0));

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    436a:	d008      	beq.n	437e <MSS_UART_polled_tx_string+0x22>
    436c:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4370:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4374:	4290      	cmp	r0, r2
    4376:	d002      	beq.n	437e <MSS_UART_polled_tx_string+0x22>
                /* Get the next data byte from the input buffer */
                data_byte = p_sz_string[char_idx];
            }
        }
    }
}
    4378:	e8bd 05f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl}
    437c:	4770      	bx	lr
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(p_sz_string != ((uint8_t *)0));

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    437e:	2900      	cmp	r1, #0
    4380:	d0fa      	beq.n	4378 <MSS_UART_polled_tx_string+0x1c>
       (p_sz_string != ((uint8_t *)0)))
    {
        /* Get the first data byte from the input buffer */
        data_byte = p_sz_string[char_idx];
    4382:	780d      	ldrb	r5, [r1, #0]

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while(0u != data_byte)
    4384:	2d00      	cmp	r5, #0
    4386:	d0f7      	beq.n	4378 <MSS_UART_polled_tx_string+0x1c>
    4388:	7b42      	ldrb	r2, [r0, #13]
        {
            /* Wait until TX FIFO is empty. */
            do {
                status = this_uart->hw_reg->LSR;
    438a:	6804      	ldr	r4, [r0, #0]
    438c:	f04f 0c00 	mov.w	ip, #0
    4390:	7d23      	ldrb	r3, [r4, #20]
                this_uart->status |= status;
    4392:	431a      	orrs	r2, r3
            } while (0u == (status & MSS_UART_THRE));
    4394:	f013 0f20 	tst.w	r3, #32
    4398:	d0fa      	beq.n	4390 <MSS_UART_polled_tx_string+0x34>
    439a:	7342      	strb	r2, [r0, #13]

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0u;
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
    439c:	b925      	cbnz	r5, 43a8 <MSS_UART_polled_tx_string+0x4c>
    439e:	4663      	mov	r3, ip

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while(0u != data_byte)
    43a0:	2d00      	cmp	r5, #0
    43a2:	d0e9      	beq.n	4378 <MSS_UART_polled_tx_string+0x1c>
    43a4:	469c      	mov	ip, r3
    43a6:	e7f3      	b.n	4390 <MSS_UART_polled_tx_string+0x34>

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0u;
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
    43a8:	f8d0 a000 	ldr.w	sl, [r0]
    43ac:	2600      	movs	r6, #0
    43ae:	eb01 080c 	add.w	r8, r1, ip
            {
                /* Send the data byte */
                this_uart->hw_reg->THR = data_byte;
                ++fill_size;
    43b2:	3601      	adds	r6, #1
             */
            fill_size = 0u;
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
            {
                /* Send the data byte */
                this_uart->hw_reg->THR = data_byte;
    43b4:	f88a 5000 	strb.w	r5, [sl]
                ++fill_size;
                char_idx++;
                /* Get the next data byte from the input buffer */
                data_byte = p_sz_string[char_idx];
    43b8:	f818 5006 	ldrb.w	r5, [r8, r6]
            fill_size = 0u;
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
            {
                /* Send the data byte */
                this_uart->hw_reg->THR = data_byte;
                ++fill_size;
    43bc:	eb06 030c 	add.w	r3, r6, ip

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0u;
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
    43c0:	1e2f      	subs	r7, r5, #0
    43c2:	bf18      	it	ne
    43c4:	2701      	movne	r7, #1
    43c6:	2e0f      	cmp	r6, #15
    43c8:	bf8c      	ite	hi
    43ca:	2700      	movhi	r7, #0
    43cc:	f007 0701 	andls.w	r7, r7, #1
    43d0:	2f00      	cmp	r7, #0
    43d2:	d0e5      	beq.n	43a0 <MSS_UART_polled_tx_string+0x44>
    43d4:	e7ed      	b.n	43b2 <MSS_UART_polled_tx_string+0x56>
    43d6:	bf00      	nop

000043d8 <MSS_UART_irq_tx>:
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(pbuff != ((uint8_t *)0));
    ASSERT(tx_size > 0u);

    if((tx_size > 0u) && ( pbuff != ((uint8_t *)0)) &&
    43d8:	1e0b      	subs	r3, r1, #0
    43da:	bf18      	it	ne
    43dc:	2301      	movne	r3, #1
    43de:	2a00      	cmp	r2, #0
    43e0:	bf0c      	ite	eq
    43e2:	2300      	moveq	r3, #0
    43e4:	f003 0301 	andne.w	r3, r3, #1
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
    43e8:	e92d 05f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(pbuff != ((uint8_t *)0));
    ASSERT(tx_size > 0u);

    if((tx_size > 0u) && ( pbuff != ((uint8_t *)0)) &&
    43ec:	b15b      	cbz	r3, 4406 <MSS_UART_irq_tx+0x2e>
      ((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)))
    43ee:	f640 4c24 	movw	ip, #3108	; 0xc24
    43f2:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    43f6:	4560      	cmp	r0, ip
    43f8:	d008      	beq.n	440c <MSS_UART_irq_tx+0x34>
    43fa:	f640 33e4 	movw	r3, #3044	; 0xbe4
    43fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4402:	4298      	cmp	r0, r3
    4404:	d002      	beq.n	440c <MSS_UART_irq_tx+0x34>
        set_bit_reg8(&this_uart->hw_reg->IER,ETBEI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4406:	e8bd 05f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl}
    440a:	4770      	bx	lr
        this_uart->tx_buffer = pbuff;
        this_uart->tx_buff_size = tx_size;
        this_uart->tx_idx = (uint16_t)0;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    440c:	f890 a004 	ldrb.w	sl, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4410:	f04f 0801 	mov.w	r8, #1
    4414:	f00a 071f 	and.w	r7, sl, #31
    4418:	fa08 f707 	lsl.w	r7, r8, r7

        /* assign default handler for data transfer */
        this_uart->tx_handler = default_tx_handler;

        /* enables TX interrupt */
        set_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
    441c:	6805      	ldr	r5, [r0, #0]
    441e:	fa4f f68a 	sxtb.w	r6, sl
    4422:	f105 0c04 	add.w	ip, r5, #4
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4426:	f02c 447f 	bic.w	r4, ip, #4278190080	; 0xff000000
    442a:	f00c 4370 	and.w	r3, ip, #4026531840	; 0xf0000000
    442e:	f103 7a00 	add.w	sl, r3, #33554432	; 0x2000000
    4432:	0976      	lsrs	r6, r6, #5
    4434:	f424 0570 	bic.w	r5, r4, #15728640	; 0xf00000
    4438:	f24e 1300 	movw	r3, #57600	; 0xe100

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);

        /* assign default handler for data transfer */
        this_uart->tx_handler = default_tx_handler;
    443c:	f245 1461 	movw	r4, #20833	; 0x5161
    if((tx_size > 0u) && ( pbuff != ((uint8_t *)0)) &&
      ((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)))
    {
        /*Initialise the transmit info for the UART instance with the arguments.*/
        this_uart->tx_buffer = pbuff;
        this_uart->tx_buff_size = tx_size;
    4440:	6142      	str	r2, [r0, #20]
    4442:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4446:	f10a 0c04 	add.w	ip, sl, #4

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);

        /* assign default handler for data transfer */
        this_uart->tx_handler = default_tx_handler;
    444a:	f2c0 0400 	movt	r4, #0
    444e:	016d      	lsls	r5, r5, #5
    4450:	f106 0a60 	add.w	sl, r6, #96	; 0x60
      ((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)))
    {
        /*Initialise the transmit info for the UART instance with the arguments.*/
        this_uart->tx_buffer = pbuff;
        this_uart->tx_buff_size = tx_size;
        this_uart->tx_idx = (uint16_t)0;
    4454:	2200      	movs	r2, #0
    4456:	6182      	str	r2, [r0, #24]

    if((tx_size > 0u) && ( pbuff != ((uint8_t *)0)) &&
      ((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)))
    {
        /*Initialise the transmit info for the UART instance with the arguments.*/
        this_uart->tx_buffer = pbuff;
    4458:	6101      	str	r1, [r0, #16]
    445a:	f843 702a 	str.w	r7, [r3, sl, lsl #2]

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);

        /* assign default handler for data transfer */
        this_uart->tx_handler = default_tx_handler;
    445e:	6244      	str	r4, [r0, #36]	; 0x24
    4460:	f84c 8005 	str.w	r8, [ip, r5]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4464:	f843 7026 	str.w	r7, [r3, r6, lsl #2]
    4468:	e7cd      	b.n	4406 <MSS_UART_irq_tx+0x2e>
    446a:	bf00      	nop

0000446c <MSS_UART_tx_complete>:
    int8_t ret_value = 0;
    uint8_t status = 0u;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    446c:	f640 4324 	movw	r3, #3108	; 0xc24
    4470:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4474:	4298      	cmp	r0, r3
    4476:	d007      	beq.n	4488 <MSS_UART_tx_complete+0x1c>
    4478:	f640 31e4 	movw	r1, #3044	; 0xbe4
    447c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4480:	4288      	cmp	r0, r1
    4482:	d001      	beq.n	4488 <MSS_UART_tx_complete+0x1c>
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        if((TX_COMPLETE == this_uart->tx_buff_size) &&
    4484:	2000      	movs	r0, #0
        {
            ret_value = (int8_t)1;
        }
    }
    return ret_value;
}
    4486:	4770      	bx	lr
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    4488:	6803      	ldr	r3, [r0, #0]
        this_uart->status |= status;
    448a:	7b41      	ldrb	r1, [r0, #13]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    448c:	7d1b      	ldrb	r3, [r3, #20]
        this_uart->status |= status;

        if((TX_COMPLETE == this_uart->tx_buff_size) &&
    448e:	6942      	ldr	r2, [r0, #20]

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;
    4490:	ea43 0c01 	orr.w	ip, r3, r1
    4494:	f880 c00d 	strb.w	ip, [r0, #13]

        if((TX_COMPLETE == this_uart->tx_buff_size) &&
    4498:	2a00      	cmp	r2, #0
    449a:	d1f3      	bne.n	4484 <MSS_UART_tx_complete+0x18>
    449c:	f3c3 1080 	ubfx	r0, r3, #6, #1
    44a0:	4770      	bx	lr
    44a2:	bf00      	nop

000044a4 <MSS_UART_get_rx>:

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(rx_buff != ((uint8_t *)0));
    ASSERT(buff_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    44a4:	f640 4324 	movw	r3, #3108	; 0xc24
    44a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    44ac:	4298      	cmp	r0, r3
(
    mss_uart_instance_t * this_uart,
    uint8_t * rx_buff,
    size_t buff_size
)
{
    44ae:	b470      	push	{r4, r5, r6}

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(rx_buff != ((uint8_t *)0));
    ASSERT(buff_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    44b0:	d009      	beq.n	44c6 <MSS_UART_get_rx+0x22>
    44b2:	f640 3ce4 	movw	ip, #3044	; 0xbe4
    44b6:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    44ba:	4560      	cmp	r0, ip
    44bc:	d003      	beq.n	44c6 <MSS_UART_get_rx+0x22>
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        while(((status & MSS_UART_DATA_READY) != 0u) &&
    44be:	2300      	movs	r3, #0
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
        }
    }
    return rx_size;
}
    44c0:	4618      	mov	r0, r3
    44c2:	bc70      	pop	{r4, r5, r6}
    44c4:	4770      	bx	lr

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(rx_buff != ((uint8_t *)0));
    ASSERT(buff_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    44c6:	1e0b      	subs	r3, r1, #0
    44c8:	bf18      	it	ne
    44ca:	2301      	movne	r3, #1
    44cc:	2a00      	cmp	r2, #0
    44ce:	bf0c      	ite	eq
    44d0:	2300      	moveq	r3, #0
    44d2:	f003 0301 	andne.w	r3, r3, #1
    44d6:	2b00      	cmp	r3, #0
    44d8:	d0f1      	beq.n	44be <MSS_UART_get_rx+0x1a>
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
    44da:	6804      	ldr	r4, [r0, #0]
        this_uart->status |= status;
    44dc:	f890 c00d 	ldrb.w	ip, [r0, #13]
    ASSERT(buff_size > 0u);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
    44e0:	7d23      	ldrb	r3, [r4, #20]
        this_uart->status |= status;
    44e2:	ea43 0c0c 	orr.w	ip, r3, ip

        while(((status & MSS_UART_DATA_READY) != 0u) &&
    44e6:	f013 0f01 	tst.w	r3, #1

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;
    44ea:	f880 c00d 	strb.w	ip, [r0, #13]

        while(((status & MSS_UART_DATA_READY) != 0u) &&
    44ee:	d0e6      	beq.n	44be <MSS_UART_get_rx+0x1a>
    44f0:	2300      	movs	r3, #0
              (rx_size < buff_size))
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
    44f2:	7825      	ldrb	r5, [r4, #0]
    44f4:	54cd      	strb	r5, [r1, r3]
            ++rx_size;
            status = this_uart->hw_reg->LSR;
    44f6:	6804      	ldr	r4, [r0, #0]
            this_uart->status |= status;
    44f8:	7b46      	ldrb	r6, [r0, #13]
        while(((status & MSS_UART_DATA_READY) != 0u) &&
              (rx_size < buff_size))
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
            ++rx_size;
            status = this_uart->hw_reg->LSR;
    44fa:	f894 c014 	ldrb.w	ip, [r4, #20]

        while(((status & MSS_UART_DATA_READY) != 0u) &&
              (rx_size < buff_size))
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
            ++rx_size;
    44fe:	3301      	adds	r3, #1
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
    4500:	ea4c 0606 	orr.w	r6, ip, r6
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        while(((status & MSS_UART_DATA_READY) != 0u) &&
    4504:	429a      	cmp	r2, r3
    4506:	bf94      	ite	ls
    4508:	2500      	movls	r5, #0
    450a:	f00c 0501 	andhi.w	r5, ip, #1
              (rx_size < buff_size))
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
            ++rx_size;
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
    450e:	7346      	strb	r6, [r0, #13]
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        while(((status & MSS_UART_DATA_READY) != 0u) &&
    4510:	2d00      	cmp	r5, #0
    4512:	d1ee      	bne.n	44f2 <MSS_UART_get_rx+0x4e>
    4514:	e7d4      	b.n	44c0 <MSS_UART_get_rx+0x1c>
    4516:	bf00      	nop

00004518 <MSS_UART_enable_irq>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_IRQ > irq_mask);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
    4518:	f640 4324 	movw	r3, #3108	; 0xc24
    451c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4520:	4298      	cmp	r0, r3
MSS_UART_enable_irq
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_t irq_mask
)
{
    4522:	b430      	push	{r4, r5}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_IRQ > irq_mask);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
    4524:	d007      	beq.n	4536 <MSS_UART_enable_irq+0x1e>
    4526:	f640 32e4 	movw	r2, #3044	; 0xbe4
    452a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    452e:	4290      	cmp	r0, r2
    4530:	d001      	beq.n	4536 <MSS_UART_enable_irq+0x1e>
        this_uart->hw_reg->IEM |= (uint8_t)(((uint32_t)irq_mask & ~((uint32_t)IIRF_MASK)) >> 4u);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4532:	bc30      	pop	{r4, r5}
    4534:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_IRQ > irq_mask);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
    4536:	f64f 7cff 	movw	ip, #65535	; 0xffff
    453a:	4561      	cmp	r1, ip
    453c:	d0f9      	beq.n	4532 <MSS_UART_enable_irq+0x1a>
       (MSS_UART_INVALID_IRQ > irq_mask))
    {
        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    453e:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4542:	2401      	movs	r4, #1
    4544:	f00c 021f 	and.w	r2, ip, #31
    4548:	4094      	lsls	r4, r2
    454a:	fa4f f38c 	sxtb.w	r3, ip
    454e:	ea4f 1c53 	mov.w	ip, r3, lsr #5
    4552:	f24e 1300 	movw	r3, #57600	; 0xe100
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER |= (uint8_t)irq_mask & IIRF_MASK;
    4556:	6802      	ldr	r2, [r0, #0]
    4558:	f2ce 0300 	movt	r3, #57344	; 0xe000
    455c:	f10c 0560 	add.w	r5, ip, #96	; 0x60
    4560:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
    4564:	7915      	ldrb	r5, [r2, #4]
    4566:	f001 000f 	and.w	r0, r1, #15
    456a:	ea45 0000 	orr.w	r0, r5, r0
    456e:	7110      	strb	r0, [r2, #4]
         * bit 5 - NACK / ERR signal interrupt
         * bit 6 - PID parity error interrupt 
         * bit 7 - LIN break detection interrupt
         * bit 8 - LIN Sync detection interrupt
         */
        this_uart->hw_reg->IEM |= (uint8_t)(((uint32_t)irq_mask & ~((uint32_t)IIRF_MASK)) >> 4u);
    4570:	f892 0024 	ldrb.w	r0, [r2, #36]	; 0x24
    4574:	ea40 1111 	orr.w	r1, r0, r1, lsr #4
    4578:	b2c9      	uxtb	r1, r1
    457a:	f882 1024 	strb.w	r1, [r2, #36]	; 0x24

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    457e:	f843 402c 	str.w	r4, [r3, ip, lsl #2]
    4582:	e7d6      	b.n	4532 <MSS_UART_enable_irq+0x1a>

00004584 <MSS_UART_disable_irq>:
    mss_uart_irq_t irq_mask
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4584:	f640 4324 	movw	r3, #3108	; 0xc24
    4588:	f2c2 0300 	movt	r3, #8192	; 0x2000
    458c:	4298      	cmp	r0, r3
MSS_UART_disable_irq
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_t irq_mask
)
{
    458e:	b410      	push	{r4}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4590:	d007      	beq.n	45a2 <MSS_UART_disable_irq+0x1e>
    4592:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4596:	f2c2 0200 	movt	r2, #8192	; 0x2000
    459a:	4290      	cmp	r0, r2
    459c:	d001      	beq.n	45a2 <MSS_UART_disable_irq+0x1e>
            /* Disable UART instance interrupt in Cortex-M3 NVIC. */
            NVIC_DisableIRQ(this_uart->irqn);

        }
    }
}
    459e:	bc10      	pop	{r4}
    45a0:	4770      	bx	lr
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER &= ((uint8_t)(~((uint32_t)irq_mask & (uint32_t)IIRF_MASK)));
    45a2:	6803      	ldr	r3, [r0, #0]
    45a4:	f001 040f 	and.w	r4, r1, #15
    45a8:	791a      	ldrb	r2, [r3, #4]
         * bit 5 - NACK / ERR signal interrupt
         * bit 6 - PID parity error interrupt 
         * bit 7 - LIN break detection interrupt
         * bit 8 - LIN Sync detection interrupt
         */
        this_uart->hw_reg->IEM |= (uint8_t)(~(((uint32_t)irq_mask & ~((uint32_t)IIRF_MASK)) >> 8u));
    45aa:	f481 4c7f 	eor.w	ip, r1, #65280	; 0xff00
         * bit 0 - Receive Data Available Interrupt
         * bit 1 - Transmitter Holding  Register Empty Interrupt
         * bit 2 - Receiver Line Status Interrupt
         * bit 3 - Modem Status Interrupt
         */
        this_uart->hw_reg->IER &= ((uint8_t)(~((uint32_t)irq_mask & (uint32_t)IIRF_MASK)));
    45ae:	ea22 0204 	bic.w	r2, r2, r4
    45b2:	711a      	strb	r2, [r3, #4]
         * bit 5 - NACK / ERR signal interrupt
         * bit 6 - PID parity error interrupt 
         * bit 7 - LIN break detection interrupt
         * bit 8 - LIN Sync detection interrupt
         */
        this_uart->hw_reg->IEM |= (uint8_t)(~(((uint32_t)irq_mask & ~((uint32_t)IIRF_MASK)) >> 8u));
    45b4:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
    45b8:	ea42 221c 	orr.w	r2, r2, ip, lsr #8
    45bc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    45c0:	7902      	ldrb	r2, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    45c2:	f04f 0c01 	mov.w	ip, #1
    45c6:	f002 001f 	and.w	r0, r2, #31
    45ca:	fa0c f000 	lsl.w	r0, ip, r0
    45ce:	b252      	sxtb	r2, r2
    45d0:	0952      	lsrs	r2, r2, #5
    45d2:	f24e 1300 	movw	r3, #57600	; 0xe100
    45d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    45da:	f102 0c60 	add.w	ip, r2, #96	; 0x60

        if(irq_mask == IIRF_MASK)
    45de:	290f      	cmp	r1, #15
    45e0:	f843 002c 	str.w	r0, [r3, ip, lsl #2]
    45e4:	d1db      	bne.n	459e <MSS_UART_disable_irq+0x1a>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    45e6:	3220      	adds	r2, #32
    45e8:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
    45ec:	e7d7      	b.n	459e <MSS_UART_disable_irq+0x1a>
    45ee:	bf00      	nop

000045f0 <MSS_UART_set_rx_handler>:
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER );
    ASSERT(trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    45f0:	f640 4324 	movw	r3, #3108	; 0xc24
    45f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    45f8:	4298      	cmp	r0, r3
(
    mss_uart_instance_t *       this_uart,
    mss_uart_irq_handler_t      handler,
    mss_uart_rx_trig_level_t    trigger_level
)
{
    45fa:	b430      	push	{r4, r5}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER );
    ASSERT(trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    45fc:	d007      	beq.n	460e <MSS_UART_set_rx_handler+0x1e>
    45fe:	f640 3ce4 	movw	ip, #3044	; 0xbe4
    4602:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    4606:	4560      	cmp	r0, ip
    4608:	d001      	beq.n	460e <MSS_UART_set_rx_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IER,ERBFI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    460a:	bc30      	pop	{r4, r5}
    460c:	4770      	bx	lr
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER );
    ASSERT(trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    460e:	1e0b      	subs	r3, r1, #0
    4610:	bf18      	it	ne
    4612:	2301      	movne	r3, #1
    4614:	2ac0      	cmp	r2, #192	; 0xc0
    4616:	bf8c      	ite	hi
    4618:	2300      	movhi	r3, #0
    461a:	f003 0301 	andls.w	r3, r3, #1
    461e:	2b00      	cmp	r3, #0
    4620:	d0f3      	beq.n	460a <MSS_UART_set_rx_handler+0x1a>
       (trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL))
    {
        this_uart->rx_handler = handler;

        /* Set the receive interrupt trigger level. */
        this_uart->hw_reg->FCR = (this_uart->hw_reg->FCR &
    4622:	6805      	ldr	r5, [r0, #0]

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER) &&
       (trigger_level < MSS_UART_FIFO_INVALID_TRIG_LEVEL))
    {
        this_uart->rx_handler = handler;
    4624:	6201      	str	r1, [r0, #32]

        /* Set the receive interrupt trigger level. */
        this_uart->hw_reg->FCR = (this_uart->hw_reg->FCR &
    4626:	f895 c008 	ldrb.w	ip, [r5, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    462a:	2401      	movs	r4, #1
    462c:	f00c 033f 	and.w	r3, ip, #63	; 0x3f
    4630:	431a      	orrs	r2, r3
    4632:	722a      	strb	r2, [r5, #8]
                                 (uint8_t)(~((uint8_t)FCR_TRIG_LEVEL_MASK))) |
                                 (uint8_t)trigger_level;
        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    4634:	7902      	ldrb	r2, [r0, #4]

        /* Enable receive interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IER,ERBFI);
    4636:	f105 0c04 	add.w	ip, r5, #4
    463a:	f002 001f 	and.w	r0, r2, #31
    463e:	fa14 f000 	lsls.w	r0, r4, r0
    4642:	f02c 437f 	bic.w	r3, ip, #4278190080	; 0xff000000
    4646:	b251      	sxtb	r1, r2
    4648:	f423 0570 	bic.w	r5, r3, #15728640	; 0xf00000
    464c:	0949      	lsrs	r1, r1, #5
    464e:	f24e 1300 	movw	r3, #57600	; 0xe100
    4652:	f00c 4c70 	and.w	ip, ip, #4026531840	; 0xf0000000
    4656:	f2ce 0300 	movt	r3, #57344	; 0xe000
    465a:	016a      	lsls	r2, r5, #5
    465c:	f10c 7c00 	add.w	ip, ip, #33554432	; 0x2000000
    4660:	f101 0560 	add.w	r5, r1, #96	; 0x60
    4664:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
    4668:	f84c 4002 	str.w	r4, [ip, r2]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    466c:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
    4670:	e7cb      	b.n	460a <MSS_UART_set_rx_handler+0x1a>
    4672:	bf00      	nop

00004674 <MSS_UART_set_loopback>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_LOOPBACK > loopback);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) ||
    4674:	f640 4324 	movw	r3, #3108	; 0xc24
    4678:	f2c2 0300 	movt	r3, #8192	; 0x2000
    467c:	4298      	cmp	r0, r3
    467e:	d00c      	beq.n	469a <MSS_UART_set_loopback+0x26>
    4680:	f640 3ce4 	movw	ip, #3044	; 0xbe4
    4684:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    4688:	4560      	cmp	r0, ip
    468a:	bf14      	ite	ne
    468c:	2200      	movne	r2, #0
    468e:	2201      	moveq	r2, #1
    4690:	2905      	cmp	r1, #5
    4692:	bf98      	it	ls
    4694:	f042 0201 	orrls.w	r2, r2, #1
    4698:	b162      	cbz	r2, 46b4 <MSS_UART_set_loopback+0x40>
       (MSS_UART_INVALID_LOOPBACK > loopback))
    {
        switch(loopback)
    469a:	2905      	cmp	r1, #5
    469c:	d80a      	bhi.n	46b4 <MSS_UART_set_loopback+0x40>
    469e:	e8df f001 	tbb	[pc, r1]
    46a2:	190a      	.short	0x190a
    46a4:	03282e28 	.word	0x03282e28
                this_uart->hw_reg->MCR |= (1u << RLOOP);
                break;
                
            case MSS_UART_AUTO_ECHO_ON:
                /* Enable automatic echo */
                this_uart->hw_reg->MCR |= (1u << ECHO);
    46a8:	6803      	ldr	r3, [r0, #0]
    46aa:	f893 c010 	ldrb.w	ip, [r3, #16]
    46ae:	f04c 0040 	orr.w	r0, ip, #64	; 0x40
    46b2:	7418      	strb	r0, [r3, #16]
    46b4:	4770      	bx	lr
    {
        switch(loopback)
        {
            case MSS_UART_LOCAL_LOOPBACK_OFF:
                /* Disable local loopback */
                clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
    46b6:	6803      	ldr	r3, [r0, #0]
    46b8:	3310      	adds	r3, #16
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    46ba:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    46be:	f003 4170 	and.w	r1, r3, #4026531840	; 0xf0000000
    46c2:	f101 7300 	add.w	r3, r1, #33554432	; 0x2000000
    46c6:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    46ca:	3310      	adds	r3, #16
    46cc:	0150      	lsls	r0, r2, #5
    46ce:	2100      	movs	r1, #0
    46d0:	5019      	str	r1, [r3, r0]
    46d2:	4770      	bx	lr
                break;
                
            case MSS_UART_LOCAL_LOOPBACK_ON:
                /* Enable local loopback */
                set_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
    46d4:	6802      	ldr	r2, [r0, #0]
    46d6:	3210      	adds	r2, #16
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    46d8:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    46dc:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    46e0:	f42c 0070 	bic.w	r0, ip, #15728640	; 0xf00000
    46e4:	f103 7100 	add.w	r1, r3, #33554432	; 0x2000000
    46e8:	0142      	lsls	r2, r0, #5
    46ea:	3110      	adds	r1, #16
    46ec:	2001      	movs	r0, #1
    46ee:	5088      	str	r0, [r1, r2]
    46f0:	4770      	bx	lr
                break;
            
            case MSS_UART_REMOTE_LOOPBACK_OFF:
            case MSS_UART_AUTO_ECHO_OFF:
                /* Disable remote loopback & automatic echo*/
                this_uart->hw_reg->MCR &= ~RLOOP_MASK;
    46f2:	6803      	ldr	r3, [r0, #0]
    46f4:	7c18      	ldrb	r0, [r3, #16]
    46f6:	f000 01f9 	and.w	r1, r0, #249	; 0xf9
    46fa:	7419      	strb	r1, [r3, #16]
                break;
    46fc:	4770      	bx	lr
            
            case MSS_UART_REMOTE_LOOPBACK_ON:
                /* Enable remote loopback */
                this_uart->hw_reg->MCR |= (1u << RLOOP);
    46fe:	6801      	ldr	r1, [r0, #0]
    4700:	7c0a      	ldrb	r2, [r1, #16]
    4702:	f042 0c20 	orr.w	ip, r2, #32
    4706:	f881 c010 	strb.w	ip, [r1, #16]
                break;
    470a:	4770      	bx	lr

0000470c <MSS_UART_set_rxstatus_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    470c:	f640 4324 	movw	r3, #3108	; 0xc24
    4710:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4714:	4298      	cmp	r0, r3
MSS_UART_set_rxstatus_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    4716:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4718:	d007      	beq.n	472a <MSS_UART_set_rxstatus_handler+0x1e>
    471a:	f640 32e4 	movw	r2, #3044	; 0xbe4
    471e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4722:	4290      	cmp	r0, r2
    4724:	d001      	beq.n	472a <MSS_UART_set_rxstatus_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IER,ELSI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4726:	bcf0      	pop	{r4, r5, r6, r7}
    4728:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    472a:	2900      	cmp	r1, #0
    472c:	d0fb      	beq.n	4726 <MSS_UART_set_rxstatus_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->linests_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    472e:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4732:	2601      	movs	r6, #1
    4734:	f00c 051f 	and.w	r5, ip, #31
    4738:	fa16 f505 	lsls.w	r5, r6, r5

        /* Enable receiver line status interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IER,ELSI);
    473c:	6803      	ldr	r3, [r0, #0]
    473e:	fa4f f48c 	sxtb.w	r4, ip
    4742:	1d1f      	adds	r7, r3, #4
    4744:	f027 437f 	bic.w	r3, r7, #4278190080	; 0xff000000
    4748:	f007 4270 	and.w	r2, r7, #4026531840	; 0xf0000000
    474c:	0964      	lsrs	r4, r4, #5
    474e:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4752:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    4756:	f24e 1300 	movw	r3, #57600	; 0xe100
    475a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    475e:	ea4f 1c47 	mov.w	ip, r7, lsl #5
    4762:	3208      	adds	r2, #8
    4764:	f104 0760 	add.w	r7, r4, #96	; 0x60
    4768:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->linests_handler = handler;
    476c:	61c1      	str	r1, [r0, #28]
    476e:	f842 600c 	str.w	r6, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4772:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
    4776:	e7d6      	b.n	4726 <MSS_UART_set_rxstatus_handler+0x1a>

00004778 <MSS_UART_set_tx_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4778:	f640 4324 	movw	r3, #3108	; 0xc24
    477c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4780:	4298      	cmp	r0, r3
MSS_UART_set_tx_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    4782:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4786:	d008      	beq.n	479a <MSS_UART_set_tx_handler+0x22>
    4788:	f640 32e4 	movw	r2, #3044	; 0xbe4
    478c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4790:	4290      	cmp	r0, r2
    4792:	d002      	beq.n	479a <MSS_UART_set_tx_handler+0x22>
        set_bit_reg8(&this_uart->hw_reg->IER,ETBEI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4794:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
    4798:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    479a:	2900      	cmp	r1, #0
    479c:	d0fa      	beq.n	4794 <MSS_UART_set_tx_handler+0x1c>
        /* Make TX buffer info invalid */
        this_uart->tx_buffer = (const uint8_t *)0;
        this_uart->tx_buff_size = 0u;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    479e:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    47a2:	2701      	movs	r7, #1
    47a4:	f00c 061f 	and.w	r6, ip, #31
    47a8:	fa17 f606 	lsls.w	r6, r7, r6

        /* Enable transmitter holding register Empty interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
    47ac:	6802      	ldr	r2, [r0, #0]
    47ae:	fa4f f58c 	sxtb.w	r5, ip
    47b2:	1d14      	adds	r4, r2, #4
    47b4:	f004 4370 	and.w	r3, r4, #4026531840	; 0xf0000000
    47b8:	f024 487f 	bic.w	r8, r4, #4278190080	; 0xff000000
    47bc:	f428 0470 	bic.w	r4, r8, #15728640	; 0xf00000
    47c0:	096d      	lsrs	r5, r5, #5
    47c2:	f103 7200 	add.w	r2, r3, #33554432	; 0x2000000
    47c6:	f24e 1300 	movw	r3, #57600	; 0xe100
    47ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
    47ce:	ea4f 1c44 	mov.w	ip, r4, lsl #5
    47d2:	3204      	adds	r2, #4
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->tx_handler = handler;

        /* Make TX buffer info invalid */
        this_uart->tx_buffer = (const uint8_t *)0;
    47d4:	2400      	movs	r4, #0
    47d6:	f105 0860 	add.w	r8, r5, #96	; 0x60
        this_uart->tx_buff_size = 0u;
    47da:	6144      	str	r4, [r0, #20]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->tx_handler = handler;
    47dc:	6241      	str	r1, [r0, #36]	; 0x24
    47de:	f843 6028 	str.w	r6, [r3, r8, lsl #2]

        /* Make TX buffer info invalid */
        this_uart->tx_buffer = (const uint8_t *)0;
    47e2:	6104      	str	r4, [r0, #16]
    47e4:	f842 700c 	str.w	r7, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    47e8:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
    47ec:	e7d2      	b.n	4794 <MSS_UART_set_tx_handler+0x1c>
    47ee:	bf00      	nop

000047f0 <MSS_UART_set_modemstatus_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    47f0:	f640 4324 	movw	r3, #3108	; 0xc24
    47f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    47f8:	4298      	cmp	r0, r3
MSS_UART_set_modemstatus_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    47fa:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    47fc:	d007      	beq.n	480e <MSS_UART_set_modemstatus_handler+0x1e>
    47fe:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4802:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4806:	4290      	cmp	r0, r2
    4808:	d001      	beq.n	480e <MSS_UART_set_modemstatus_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IER,EDSSI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    480a:	bcf0      	pop	{r4, r5, r6, r7}
    480c:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    480e:	2900      	cmp	r1, #0
    4810:	d0fb      	beq.n	480a <MSS_UART_set_modemstatus_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->modemsts_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ(this_uart->irqn);
    4812:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4816:	2601      	movs	r6, #1
    4818:	f00c 051f 	and.w	r5, ip, #31
    481c:	fa16 f505 	lsls.w	r5, r6, r5

        /* Enable modem status interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IER,EDSSI);
    4820:	6803      	ldr	r3, [r0, #0]
    4822:	fa4f f48c 	sxtb.w	r4, ip
    4826:	1d1f      	adds	r7, r3, #4
    4828:	f027 437f 	bic.w	r3, r7, #4278190080	; 0xff000000
    482c:	f007 4270 	and.w	r2, r7, #4026531840	; 0xf0000000
    4830:	0964      	lsrs	r4, r4, #5
    4832:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4836:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    483a:	f24e 1300 	movw	r3, #57600	; 0xe100
    483e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4842:	ea4f 1c47 	mov.w	ip, r7, lsl #5
    4846:	320c      	adds	r2, #12
    4848:	f104 0760 	add.w	r7, r4, #96	; 0x60
    484c:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->modemsts_handler = handler;
    4850:	6281      	str	r1, [r0, #40]	; 0x28
    4852:	f842 600c 	str.w	r6, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4856:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
    485a:	e7d6      	b.n	480a <MSS_UART_set_modemstatus_handler+0x1a>

0000485c <MSS_UART_fill_tx_fifo>:
    ASSERT(tx_buffer != ( (uint8_t *)0));
    ASSERT(tx_size > 0);

    /* Fill the UART's Tx FIFO until the FIFO is full or the complete input
     * buffer has been written. */
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    485c:	f640 4324 	movw	r3, #3108	; 0xc24
    4860:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4864:	4298      	cmp	r0, r3
(
    mss_uart_instance_t * this_uart,
    const uint8_t * tx_buffer,
    size_t tx_size
)
{
    4866:	b410      	push	{r4}
    ASSERT(tx_buffer != ( (uint8_t *)0));
    ASSERT(tx_size > 0);

    /* Fill the UART's Tx FIFO until the FIFO is full or the complete input
     * buffer has been written. */
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4868:	d008      	beq.n	487c <MSS_UART_fill_tx_fifo+0x20>
    486a:	f640 3ce4 	movw	ip, #3044	; 0xbe4
    486e:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    4872:	4560      	cmp	r0, ip
    4874:	d002      	beq.n	487c <MSS_UART_fill_tx_fifo+0x20>
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    4876:	2000      	movs	r0, #0
                this_uart->hw_reg->THR = tx_buffer[size_sent];
            }
        }
    }
    return size_sent;
}
    4878:	bc10      	pop	{r4}
    487a:	4770      	bx	lr
    ASSERT(tx_buffer != ( (uint8_t *)0));
    ASSERT(tx_size > 0);

    /* Fill the UART's Tx FIFO until the FIFO is full or the complete input
     * buffer has been written. */
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    487c:	1e0b      	subs	r3, r1, #0
    487e:	bf18      	it	ne
    4880:	2301      	movne	r3, #1
    4882:	2a00      	cmp	r2, #0
    4884:	bf0c      	ite	eq
    4886:	2300      	moveq	r3, #0
    4888:	f003 0301 	andne.w	r3, r3, #1
    488c:	2b00      	cmp	r3, #0
    488e:	d0f2      	beq.n	4876 <MSS_UART_fill_tx_fifo+0x1a>
       (tx_buffer != ((uint8_t *)0))   &&
       (tx_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
    4890:	6803      	ldr	r3, [r0, #0]
        this_uart->status |= status;
    4892:	7b44      	ldrb	r4, [r0, #13]
     * buffer has been written. */
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (tx_buffer != ((uint8_t *)0))   &&
       (tx_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
    4894:	f893 c014 	ldrb.w	ip, [r3, #20]
        this_uart->status |= status;
    4898:	ea4c 0404 	orr.w	r4, ip, r4

        if(status & MSS_UART_THRE)
    489c:	f01c 0f20 	tst.w	ip, #32
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (tx_buffer != ((uint8_t *)0))   &&
       (tx_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;
    48a0:	7344      	strb	r4, [r0, #13]

        if(status & MSS_UART_THRE)
    48a2:	d0e8      	beq.n	4876 <MSS_UART_fill_tx_fifo+0x1a>
        {
            uint32_t fill_size = TX_FIFO_SIZE;

            if(tx_size < TX_FIFO_SIZE)
    48a4:	2a0f      	cmp	r2, #15
    48a6:	bf88      	it	hi
    48a8:	2210      	movhi	r2, #16
    48aa:	1e50      	subs	r0, r2, #1
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48ac:	f891 c000 	ldrb.w	ip, [r1]
    48b0:	f000 0401 	and.w	r4, r0, #1
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48b4:	2001      	movs	r0, #1
    48b6:	4282      	cmp	r2, r0
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48b8:	f883 c000 	strb.w	ip, [r3]
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48bc:	d9dc      	bls.n	4878 <MSS_UART_fill_tx_fifo+0x1c>
    48be:	b134      	cbz	r4, 48ce <MSS_UART_fill_tx_fifo+0x72>
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48c0:	f891 c001 	ldrb.w	ip, [r1, #1]
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48c4:	2002      	movs	r0, #2
    48c6:	4282      	cmp	r2, r0
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48c8:	f883 c000 	strb.w	ip, [r3]
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48cc:	d9d4      	bls.n	4878 <MSS_UART_fill_tx_fifo+0x1c>
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48ce:	f811 c000 	ldrb.w	ip, [r1, r0]
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48d2:	3001      	adds	r0, #1
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48d4:	f883 c000 	strb.w	ip, [r3]
    48d8:	f811 c000 	ldrb.w	ip, [r1, r0]
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48dc:	3001      	adds	r0, #1
    48de:	4282      	cmp	r2, r0
            {

                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = tx_buffer[size_sent];
    48e0:	f883 c000 	strb.w	ip, [r3]
            if(tx_size < TX_FIFO_SIZE)
            {
                fill_size = tx_size;
            }
            /* Fill up FIFO */
            for(size_sent = 0u; size_sent < fill_size; ++size_sent)
    48e4:	d8f3      	bhi.n	48ce <MSS_UART_fill_tx_fifo+0x72>
    48e6:	e7c7      	b.n	4878 <MSS_UART_fill_tx_fifo+0x1c>

000048e8 <MSS_UART_get_rx_status>:
{
    uint8_t status = MSS_UART_INVALID_PARAM;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    48e8:	f640 4324 	movw	r3, #3108	; 0xc24
    48ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
    48f0:	4298      	cmp	r0, r3
    48f2:	d007      	beq.n	4904 <MSS_UART_get_rx_status+0x1c>
    48f4:	f640 31e4 	movw	r1, #3044	; 0xbe4
    48f8:	f2c2 0100 	movt	r1, #8192	; 0x2000
    48fc:	4288      	cmp	r0, r1
    48fe:	d001      	beq.n	4904 <MSS_UART_get_rx_status+0x1c>
    4900:	20ff      	movs	r0, #255	; 0xff
    4902:	4770      	bx	lr
         * Bit 2 - Parity error status
         * Bit 3 - Frame error status
         * Bit 4 - Break interrupt indicator
         * Bit 7 - FIFO data error status
         */
        this_uart->status |= (this_uart->hw_reg->LSR);
    4904:	6802      	ldr	r2, [r0, #0]
        status = (this_uart->status & STATUS_ERROR_MASK);
    4906:	7b43      	ldrb	r3, [r0, #13]
         * Bit 2 - Parity error status
         * Bit 3 - Frame error status
         * Bit 4 - Break interrupt indicator
         * Bit 7 - FIFO data error status
         */
        this_uart->status |= (this_uart->hw_reg->LSR);
    4908:	7d11      	ldrb	r1, [r2, #20]
        status = (this_uart->status & STATUS_ERROR_MASK);
        /* Clear the sticky status after reading */
        this_uart->status = 0u;
    490a:	2200      	movs	r2, #0
         * Bit 3 - Frame error status
         * Bit 4 - Break interrupt indicator
         * Bit 7 - FIFO data error status
         */
        this_uart->status |= (this_uart->hw_reg->LSR);
        status = (this_uart->status & STATUS_ERROR_MASK);
    490c:	ea41 0c03 	orr.w	ip, r1, r3
        /* Clear the sticky status after reading */
        this_uart->status = 0u;
    4910:	7342      	strb	r2, [r0, #13]
         * Bit 3 - Frame error status
         * Bit 4 - Break interrupt indicator
         * Bit 7 - FIFO data error status
         */
        this_uart->status |= (this_uart->hw_reg->LSR);
        status = (this_uart->status & STATUS_ERROR_MASK);
    4912:	f00c 009e 	and.w	r0, ip, #158	; 0x9e
        /* Clear the sticky status after reading */
        this_uart->status = 0u;
    }
    return status;
}
    4916:	4770      	bx	lr

00004918 <MSS_UART_get_modem_status>:
{
    uint8_t status = MSS_UART_INVALID_PARAM;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4918:	f640 4324 	movw	r3, #3108	; 0xc24
    491c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4920:	4298      	cmp	r0, r3
    4922:	d007      	beq.n	4934 <MSS_UART_get_modem_status+0x1c>
    4924:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4928:	f2c2 0100 	movt	r1, #8192	; 0x2000
    492c:	4288      	cmp	r0, r1
    492e:	d001      	beq.n	4934 <MSS_UART_get_modem_status+0x1c>
    4930:	20ff      	movs	r0, #255	; 0xff
    4932:	4770      	bx	lr
         * Bit 4 - Clear To Send
         * Bit 5 - Data Set Ready
         * Bit 6 - Ring Indicator
         * Bit 7 - Data Carrier Detect
         */
        status = this_uart->hw_reg->MSR;
    4934:	6802      	ldr	r2, [r0, #0]
    4936:	7e10      	ldrb	r0, [r2, #24]
    }
    return status;
}
    4938:	4770      	bx	lr
    493a:	bf00      	nop

0000493c <MSS_UART_get_tx_status>:
{
    uint8_t status = MSS_UART_TX_BUSY;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    493c:	f640 4324 	movw	r3, #3108	; 0xc24
    4940:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4944:	4298      	cmp	r0, r3
    4946:	d007      	beq.n	4958 <MSS_UART_get_tx_status+0x1c>
    4948:	f640 31e4 	movw	r1, #3044	; 0xbe4
    494c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4950:	4288      	cmp	r0, r1
    4952:	d001      	beq.n	4958 <MSS_UART_get_tx_status+0x1c>
    4954:	2000      	movs	r0, #0
    4956:	4770      	bx	lr
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    4958:	6803      	ldr	r3, [r0, #0]
        this_uart->status |= status;
    495a:	7b41      	ldrb	r1, [r0, #13]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    495c:	f893 c014 	ldrb.w	ip, [r3, #20]
        this_uart->status |= status;
    4960:	ea4c 0201 	orr.w	r2, ip, r1
    4964:	7342      	strb	r2, [r0, #13]
        /*
         * Extract the transmit status bits from the UART's Line Status Register.
         * Bit 5 - Transmitter Holding Register/FIFO Empty (THRE) status. (If = 1, TX FIFO is empty)
         * Bit 6 - Transmitter Empty (TEMT) status. (If = 1, both TX FIFO and shift register are empty)
         */
        status &= (MSS_UART_THRE | MSS_UART_TEMT);
    4966:	f00c 0060 	and.w	r0, ip, #96	; 0x60
    }
    return status;
}
    496a:	4770      	bx	lr

0000496c <MSS_UART_set_break>:
(
    mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    496c:	f640 4324 	movw	r3, #3108	; 0xc24
    4970:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4974:	4298      	cmp	r0, r3
    4976:	d006      	beq.n	4986 <MSS_UART_set_break+0x1a>
    4978:	f640 31e4 	movw	r1, #3044	; 0xbe4
    497c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4980:	4288      	cmp	r0, r1
    4982:	d000      	beq.n	4986 <MSS_UART_set_break+0x1a>
    4984:	4770      	bx	lr
    {
        /* set break charecter on Tx line */
        set_bit_reg8(&this_uart->hw_reg->LCR,SB);
    4986:	6802      	ldr	r2, [r0, #0]
    4988:	320c      	adds	r2, #12
    498a:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    498e:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4992:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4996:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    499a:	3318      	adds	r3, #24
    499c:	014a      	lsls	r2, r1, #5
    499e:	2001      	movs	r0, #1
    49a0:	5098      	str	r0, [r3, r2]
    49a2:	4770      	bx	lr

000049a4 <MSS_UART_clear_break>:
(
    mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    49a4:	f640 4324 	movw	r3, #3108	; 0xc24
    49a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49ac:	4298      	cmp	r0, r3
    49ae:	d006      	beq.n	49be <MSS_UART_clear_break+0x1a>
    49b0:	f640 31e4 	movw	r1, #3044	; 0xbe4
    49b4:	f2c2 0100 	movt	r1, #8192	; 0x2000
    49b8:	4288      	cmp	r0, r1
    49ba:	d000      	beq.n	49be <MSS_UART_clear_break+0x1a>
    49bc:	4770      	bx	lr
    {
        /* remove break charecter from Tx line */
        clear_bit_reg8(&this_uart->hw_reg->LCR,SB);
    49be:	6802      	ldr	r2, [r0, #0]
    49c0:	320c      	adds	r2, #12
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    49c2:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    49c6:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    49ca:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    49ce:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    49d2:	3318      	adds	r3, #24
    49d4:	014a      	lsls	r2, r1, #5
    49d6:	2000      	movs	r0, #0
    49d8:	5098      	str	r0, [r3, r2]
    49da:	4770      	bx	lr

000049dc <MSS_UART_set_pidpei_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    49dc:	f640 4324 	movw	r3, #3108	; 0xc24
    49e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    49e4:	4298      	cmp	r0, r3
MSS_UART_set_pidpei_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    49e6:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    49e8:	d007      	beq.n	49fa <MSS_UART_set_pidpei_handler+0x1e>
    49ea:	f640 32e4 	movw	r2, #3044	; 0xbe4
    49ee:	f2c2 0200 	movt	r2, #8192	; 0x2000
    49f2:	4290      	cmp	r0, r2
    49f4:	d001      	beq.n	49fa <MSS_UART_set_pidpei_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IEM,EPID_PEI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    49f6:	bcf0      	pop	{r4, r5, r6, r7}
    49f8:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    49fa:	2900      	cmp	r1, #0
    49fc:	d0fb      	beq.n	49f6 <MSS_UART_set_pidpei_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->pid_pei_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    49fe:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4a02:	2601      	movs	r6, #1
    4a04:	f00c 051f 	and.w	r5, ip, #31
    4a08:	fa16 f505 	lsls.w	r5, r6, r5

        /* Enable PID parity error interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IEM,EPID_PEI);
    4a0c:	6807      	ldr	r7, [r0, #0]
    4a0e:	fa4f f48c 	sxtb.w	r4, ip
    4a12:	3724      	adds	r7, #36	; 0x24
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4a14:	f027 437f 	bic.w	r3, r7, #4278190080	; 0xff000000
    4a18:	f007 4270 	and.w	r2, r7, #4026531840	; 0xf0000000
    4a1c:	0964      	lsrs	r4, r4, #5
    4a1e:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4a22:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    4a26:	f24e 1300 	movw	r3, #57600	; 0xe100
    4a2a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4a2e:	ea4f 1c47 	mov.w	ip, r7, lsl #5
    4a32:	3208      	adds	r2, #8
    4a34:	f104 0760 	add.w	r7, r4, #96	; 0x60
    4a38:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->pid_pei_handler = handler;
    4a3c:	6341      	str	r1, [r0, #52]	; 0x34
    4a3e:	f842 600c 	str.w	r6, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4a42:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
    4a46:	e7d6      	b.n	49f6 <MSS_UART_set_pidpei_handler+0x1a>

00004a48 <MSS_UART_set_linbreak_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4a48:	f640 4324 	movw	r3, #3108	; 0xc24
    4a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4a50:	4298      	cmp	r0, r3
MSS_UART_set_linbreak_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    4a52:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4a54:	d007      	beq.n	4a66 <MSS_UART_set_linbreak_handler+0x1e>
    4a56:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4a5a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4a5e:	4290      	cmp	r0, r2
    4a60:	d001      	beq.n	4a66 <MSS_UART_set_linbreak_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IEM,ELINBI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4a62:	bcf0      	pop	{r4, r5, r6, r7}
    4a64:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4a66:	2900      	cmp	r1, #0
    4a68:	d0fb      	beq.n	4a62 <MSS_UART_set_linbreak_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->break_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    4a6a:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4a6e:	2601      	movs	r6, #1
    4a70:	f00c 051f 	and.w	r5, ip, #31
    4a74:	fa16 f505 	lsls.w	r5, r6, r5

        /* Enable LIN break detection interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IEM,ELINBI);
    4a78:	6807      	ldr	r7, [r0, #0]
    4a7a:	fa4f f48c 	sxtb.w	r4, ip
    4a7e:	3724      	adds	r7, #36	; 0x24
    4a80:	f027 437f 	bic.w	r3, r7, #4278190080	; 0xff000000
    4a84:	f007 4270 	and.w	r2, r7, #4026531840	; 0xf0000000
    4a88:	0964      	lsrs	r4, r4, #5
    4a8a:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4a8e:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    4a92:	f24e 1300 	movw	r3, #57600	; 0xe100
    4a96:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4a9a:	ea4f 1c47 	mov.w	ip, r7, lsl #5
    4a9e:	320c      	adds	r2, #12
    4aa0:	f104 0760 	add.w	r7, r4, #96	; 0x60
    4aa4:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->break_handler = handler;
    4aa8:	6381      	str	r1, [r0, #56]	; 0x38
    4aaa:	f842 600c 	str.w	r6, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4aae:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
    4ab2:	e7d6      	b.n	4a62 <MSS_UART_set_linbreak_handler+0x1a>

00004ab4 <MSS_UART_set_linsync_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4ab4:	f640 4324 	movw	r3, #3108	; 0xc24
    4ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4abc:	4298      	cmp	r0, r3
MSS_UART_set_linsync_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    4abe:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4ac0:	d007      	beq.n	4ad2 <MSS_UART_set_linsync_handler+0x1e>
    4ac2:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4ac6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4aca:	4290      	cmp	r0, r2
    4acc:	d001      	beq.n	4ad2 <MSS_UART_set_linsync_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IEM,ELINSI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4ace:	bcf0      	pop	{r4, r5, r6, r7}
    4ad0:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4ad2:	2900      	cmp	r1, #0
    4ad4:	d0fb      	beq.n	4ace <MSS_UART_set_linsync_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->sync_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    4ad6:	f890 c004 	ldrb.w	ip, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4ada:	2601      	movs	r6, #1
    4adc:	f00c 051f 	and.w	r5, ip, #31
    4ae0:	fa16 f505 	lsls.w	r5, r6, r5

        /* Enable LIN sync detection interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IEM,ELINSI);
    4ae4:	6807      	ldr	r7, [r0, #0]
    4ae6:	fa4f f48c 	sxtb.w	r4, ip
    4aea:	3724      	adds	r7, #36	; 0x24
    4aec:	f027 437f 	bic.w	r3, r7, #4278190080	; 0xff000000
    4af0:	f007 4270 	and.w	r2, r7, #4026531840	; 0xf0000000
    4af4:	0964      	lsrs	r4, r4, #5
    4af6:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4afa:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    4afe:	f24e 1300 	movw	r3, #57600	; 0xe100
    4b02:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4b06:	ea4f 1c47 	mov.w	ip, r7, lsl #5
    4b0a:	3210      	adds	r2, #16
    4b0c:	f104 0760 	add.w	r7, r4, #96	; 0x60
    4b10:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->sync_handler = handler;
    4b14:	63c1      	str	r1, [r0, #60]	; 0x3c
    4b16:	f842 600c 	str.w	r6, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4b1a:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
    4b1e:	e7d6      	b.n	4ace <MSS_UART_set_linsync_handler+0x1a>

00004b20 <MSS_UART_set_nack_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4b20:	f640 4324 	movw	r3, #3108	; 0xc24
    4b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b28:	4298      	cmp	r0, r3
MSS_UART_set_nack_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    4b2a:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4b2c:	d007      	beq.n	4b3e <MSS_UART_set_nack_handler+0x1e>
    4b2e:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4b32:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4b36:	4290      	cmp	r0, r2
    4b38:	d001      	beq.n	4b3e <MSS_UART_set_nack_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IEM,ENACKI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4b3a:	bcf0      	pop	{r4, r5, r6, r7}
    4b3c:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4b3e:	2900      	cmp	r1, #0
    4b40:	d0fb      	beq.n	4b3a <MSS_UART_set_nack_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->nack_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    4b42:	7902      	ldrb	r2, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4b44:	2601      	movs	r6, #1
    4b46:	f002 051f 	and.w	r5, r2, #31
    4b4a:	fa16 f505 	lsls.w	r5, r6, r5

        /* Enable LIN sync detection interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IEM,ENACKI);
    4b4e:	6807      	ldr	r7, [r0, #0]
    4b50:	b254      	sxtb	r4, r2
    4b52:	3724      	adds	r7, #36	; 0x24
    4b54:	f007 4c70 	and.w	ip, r7, #4026531840	; 0xf0000000
    4b58:	f027 437f 	bic.w	r3, r7, #4278190080	; 0xff000000
    4b5c:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4b60:	0964      	lsrs	r4, r4, #5
    4b62:	f10c 7200 	add.w	r2, ip, #33554432	; 0x2000000
    4b66:	f24e 1300 	movw	r3, #57600	; 0xe100
    4b6a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4b6e:	ea4f 1c47 	mov.w	ip, r7, lsl #5
    4b72:	3204      	adds	r2, #4
    4b74:	f104 0760 	add.w	r7, r4, #96	; 0x60
    4b78:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->nack_handler = handler;
    4b7c:	6301      	str	r1, [r0, #48]	; 0x30
    4b7e:	f842 600c 	str.w	r6, [r2, ip]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4b82:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
    4b86:	e7d8      	b.n	4b3a <MSS_UART_set_nack_handler+0x1a>

00004b88 <MSS_UART_set_rx_timeout_handler>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4b88:	f640 4324 	movw	r3, #3108	; 0xc24
    4b8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4b90:	4298      	cmp	r0, r3
MSS_UART_set_rx_timeout_handler
(
    mss_uart_instance_t * this_uart,
    mss_uart_irq_handler_t handler
)
{
    4b92:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4b94:	d007      	beq.n	4ba6 <MSS_UART_set_rx_timeout_handler+0x1e>
    4b96:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4b9a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4b9e:	4290      	cmp	r0, r2
    4ba0:	d001      	beq.n	4ba6 <MSS_UART_set_rx_timeout_handler+0x1e>
        set_bit_reg8(&this_uart->hw_reg->IEM,ERTOI);

        /* Enable UART instance interrupt in Cortex-M3 NVIC. */
        NVIC_EnableIRQ(this_uart->irqn);
    }
}
    4ba2:	bcf0      	pop	{r4, r5, r6, r7}
    4ba4:	4770      	bx	lr
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4ba6:	2900      	cmp	r1, #0
    4ba8:	d0fb      	beq.n	4ba2 <MSS_UART_set_rx_timeout_handler+0x1a>
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->rto_handler = handler;

        /* Clear any previously pended interrupts */
        NVIC_ClearPendingIRQ( this_uart->irqn );
    4baa:	7902      	ldrb	r2, [r0, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    4bac:	2501      	movs	r5, #1
    4bae:	f002 041f 	and.w	r4, r2, #31
    4bb2:	fa15 f404 	lsls.w	r4, r5, r4

        /* Enable receiver timeout interrupt. */
        set_bit_reg8(&this_uart->hw_reg->IEM,ERTOI);
    4bb6:	6806      	ldr	r6, [r0, #0]
    4bb8:	fa4f fc82 	sxtb.w	ip, r2
    4bbc:	3624      	adds	r6, #36	; 0x24
    4bbe:	f026 437f 	bic.w	r3, r6, #4278190080	; 0xff000000
    4bc2:	f423 0770 	bic.w	r7, r3, #15728640	; 0xf00000
    4bc6:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    4bca:	f24e 1300 	movw	r3, #57600	; 0xe100
    4bce:	f006 4670 	and.w	r6, r6, #4026531840	; 0xf0000000
    4bd2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    4bd6:	017a      	lsls	r2, r7, #5
    4bd8:	f106 7600 	add.w	r6, r6, #33554432	; 0x2000000
    4bdc:	f10c 0760 	add.w	r7, ip, #96	; 0x60
    4be0:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
    ASSERT(handler != INVALID_IRQ_HANDLER);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (handler != INVALID_IRQ_HANDLER))
    {
        this_uart->rto_handler = handler;
    4be4:	62c1      	str	r1, [r0, #44]	; 0x2c
    4be6:	50b5      	str	r5, [r6, r2]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    4be8:	f843 402c 	str.w	r4, [r3, ip, lsl #2]
    4bec:	e7d9      	b.n	4ba2 <MSS_UART_set_rx_timeout_handler+0x1a>
    4bee:	bf00      	nop

00004bf0 <MSS_UART_enable_half_duplex>:
(
    mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4bf0:	f640 4324 	movw	r3, #3108	; 0xc24
    4bf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4bf8:	4298      	cmp	r0, r3
    4bfa:	d006      	beq.n	4c0a <MSS_UART_enable_half_duplex+0x1a>
    4bfc:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4c00:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4c04:	4288      	cmp	r0, r1
    4c06:	d000      	beq.n	4c0a <MSS_UART_enable_half_duplex+0x1a>
    4c08:	4770      	bx	lr
    {
        /* enable single wire half-duplex mode */
        set_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
    4c0a:	6802      	ldr	r2, [r0, #0]
    4c0c:	3238      	adds	r2, #56	; 0x38
    4c0e:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    4c12:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4c16:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4c1a:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4c1e:	330c      	adds	r3, #12
    4c20:	014a      	lsls	r2, r1, #5
    4c22:	2001      	movs	r0, #1
    4c24:	5098      	str	r0, [r3, r2]
    4c26:	4770      	bx	lr

00004c28 <MSS_UART_disable_half_duplex>:
(
    mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4c28:	f640 4324 	movw	r3, #3108	; 0xc24
    4c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c30:	4298      	cmp	r0, r3
    4c32:	d006      	beq.n	4c42 <MSS_UART_disable_half_duplex+0x1a>
    4c34:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4c38:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4c3c:	4288      	cmp	r0, r1
    4c3e:	d000      	beq.n	4c42 <MSS_UART_disable_half_duplex+0x1a>
    4c40:	4770      	bx	lr
    {
        /* enable single wire half-duplex mode */
        clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
    4c42:	6802      	ldr	r2, [r0, #0]
    4c44:	3238      	adds	r2, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4c46:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    4c4a:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4c4e:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4c52:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4c56:	330c      	adds	r3, #12
    4c58:	014a      	lsls	r2, r1, #5
    4c5a:	2000      	movs	r0, #0
    4c5c:	5098      	str	r0, [r3, r2]
    4c5e:	4770      	bx	lr

00004c60 <MSS_UART_set_rx_endian>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_ENDIAN > endian);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
    4c60:	f640 4324 	movw	r3, #3108	; 0xc24
    4c64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4c68:	4298      	cmp	r0, r3
    4c6a:	d006      	beq.n	4c7a <MSS_UART_set_rx_endian+0x1a>
    4c6c:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4c70:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4c74:	4290      	cmp	r0, r2
    4c76:	d000      	beq.n	4c7a <MSS_UART_set_rx_endian+0x1a>
    4c78:	4770      	bx	lr
    4c7a:	2901      	cmp	r1, #1
    4c7c:	d8fc      	bhi.n	4c78 <MSS_UART_set_rx_endian+0x18>
       (MSS_UART_INVALID_ENDIAN > endian))
    {
        /* Configure MSB first / LSB first for receiver */
        ((MSS_UART_LITTLEEND == endian) ? (clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX)) :
    4c7e:	b171      	cbz	r1, 4c9e <MSS_UART_set_rx_endian+0x3e>
                                          (set_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX)));
    4c80:	6801      	ldr	r1, [r0, #0]
    4c82:	3134      	adds	r1, #52	; 0x34
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4c84:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
    4c88:	f42c 0070 	bic.w	r0, ip, #15728640	; 0xf00000
    4c8c:	f001 4270 	and.w	r2, r1, #4026531840	; 0xf0000000
    4c90:	f102 7c00 	add.w	ip, r2, #33554432	; 0x2000000
    4c94:	0143      	lsls	r3, r0, #5
    4c96:	2101      	movs	r1, #1
    4c98:	f84c 1003 	str.w	r1, [ip, r3]
    4c9c:	e7ec      	b.n	4c78 <MSS_UART_set_rx_endian+0x18>

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
       (MSS_UART_INVALID_ENDIAN > endian))
    {
        /* Configure MSB first / LSB first for receiver */
        ((MSS_UART_LITTLEEND == endian) ? (clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX)) :
    4c9e:	6802      	ldr	r2, [r0, #0]
    4ca0:	3234      	adds	r2, #52	; 0x34
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4ca2:	f022 407f 	bic.w	r0, r2, #4278190080	; 0xff000000
    4ca6:	f420 0370 	bic.w	r3, r0, #15728640	; 0xf00000
    4caa:	f002 4c70 	and.w	ip, r2, #4026531840	; 0xf0000000
    4cae:	f10c 7000 	add.w	r0, ip, #33554432	; 0x2000000
    4cb2:	015b      	lsls	r3, r3, #5
    4cb4:	50c1      	str	r1, [r0, r3]
    4cb6:	4770      	bx	lr

00004cb8 <MSS_UART_set_tx_endian>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_ENDIAN > endian);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
    4cb8:	f640 4324 	movw	r3, #3108	; 0xc24
    4cbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4cc0:	4298      	cmp	r0, r3
    4cc2:	d006      	beq.n	4cd2 <MSS_UART_set_tx_endian+0x1a>
    4cc4:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4cc8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4ccc:	4290      	cmp	r0, r2
    4cce:	d000      	beq.n	4cd2 <MSS_UART_set_tx_endian+0x1a>
    4cd0:	4770      	bx	lr
    4cd2:	2901      	cmp	r1, #1
    4cd4:	d8fc      	bhi.n	4cd0 <MSS_UART_set_tx_endian+0x18>
       (MSS_UART_INVALID_ENDIAN > endian))
    {
        /* Configure MSB first / LSB first for transmitter */
        ((MSS_UART_LITTLEEND == endian) ? (clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX)) :
    4cd6:	b171      	cbz	r1, 4cf6 <MSS_UART_set_tx_endian+0x3e>
                                          (set_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX)) ) ;
    4cd8:	6803      	ldr	r3, [r0, #0]
    4cda:	3334      	adds	r3, #52	; 0x34
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4cdc:	f003 4070 	and.w	r0, r3, #4026531840	; 0xf0000000
    4ce0:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    4ce4:	f100 7100 	add.w	r1, r0, #33554432	; 0x2000000
    4ce8:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    4cec:	1d0b      	adds	r3, r1, #4
    4cee:	0150      	lsls	r0, r2, #5
    4cf0:	2101      	movs	r1, #1
    4cf2:	5019      	str	r1, [r3, r0]
    4cf4:	e7ec      	b.n	4cd0 <MSS_UART_set_tx_endian+0x18>

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
       (MSS_UART_INVALID_ENDIAN > endian))
    {
        /* Configure MSB first / LSB first for transmitter */
        ((MSS_UART_LITTLEEND == endian) ? (clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX)) :
    4cf6:	6802      	ldr	r2, [r0, #0]
    4cf8:	3234      	adds	r2, #52	; 0x34
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4cfa:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    4cfe:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4d02:	f103 7000 	add.w	r0, r3, #33554432	; 0x2000000
    4d06:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    4d0a:	1d03      	adds	r3, r0, #4
    4d0c:	0150      	lsls	r0, r2, #5
    4d0e:	5019      	str	r1, [r3, r0]
    4d10:	4770      	bx	lr
    4d12:	bf00      	nop

00004d14 <MSS_UART_set_filter_length>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_FILTER_LENGTH > length);
    
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) && 
    4d14:	f640 4324 	movw	r3, #3108	; 0xc24
    4d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d1c:	4298      	cmp	r0, r3
    4d1e:	d006      	beq.n	4d2e <MSS_UART_set_filter_length+0x1a>
    4d20:	f640 33e4 	movw	r3, #3044	; 0xbe4
    4d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d28:	4298      	cmp	r0, r3
    4d2a:	d000      	beq.n	4d2e <MSS_UART_set_filter_length+0x1a>
    4d2c:	4770      	bx	lr
    4d2e:	2907      	cmp	r1, #7
       (MSS_UART_INVALID_FILTER_LENGTH > length))
    {
        /* Configure glitch filter length */
        this_uart->hw_reg->GFR = (uint8_t)length;
    4d30:	bf9c      	itt	ls
    4d32:	6803      	ldrls	r3, [r0, #0]
    4d34:	f883 1044 	strbls.w	r1, [r3, #68]	; 0x44
    4d38:	4770      	bx	lr
    4d3a:	bf00      	nop

00004d3c <MSS_UART_enable_afm>:
     mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4d3c:	f640 4324 	movw	r3, #3108	; 0xc24
    4d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d44:	4298      	cmp	r0, r3
    4d46:	d006      	beq.n	4d56 <MSS_UART_enable_afm+0x1a>
    4d48:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4d4c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4d50:	4288      	cmp	r0, r1
    4d52:	d000      	beq.n	4d56 <MSS_UART_enable_afm+0x1a>
    4d54:	4770      	bx	lr
    {
        /* Disable RX FIFO till address flag with correct address is received */
        set_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
    4d56:	6803      	ldr	r3, [r0, #0]
    4d58:	3338      	adds	r3, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4d5a:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
    4d5e:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    4d62:	f102 7000 	add.w	r0, r2, #33554432	; 0x2000000
    4d66:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4d6a:	1d03      	adds	r3, r0, #4
    4d6c:	014a      	lsls	r2, r1, #5
    4d6e:	2001      	movs	r0, #1
    4d70:	5098      	str	r0, [r3, r2]
    4d72:	4770      	bx	lr

00004d74 <MSS_UART_disable_afm>:
     mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4d74:	f640 4324 	movw	r3, #3108	; 0xc24
    4d78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4d7c:	4298      	cmp	r0, r3
    4d7e:	d006      	beq.n	4d8e <MSS_UART_disable_afm+0x1a>
    4d80:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4d84:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4d88:	4288      	cmp	r0, r1
    4d8a:	d000      	beq.n	4d8e <MSS_UART_disable_afm+0x1a>
    4d8c:	4770      	bx	lr
    {
        /* Enable RX FIFO irrespective of address flag and
           correct address is received */
        clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
    4d8e:	6803      	ldr	r3, [r0, #0]
    4d90:	3338      	adds	r3, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4d92:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
    4d96:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    4d9a:	f102 7000 	add.w	r0, r2, #33554432	; 0x2000000
    4d9e:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4da2:	1d03      	adds	r3, r0, #4
    4da4:	014a      	lsls	r2, r1, #5
    4da6:	2000      	movs	r0, #0
    4da8:	5098      	str	r0, [r3, r2]
    4daa:	4770      	bx	lr

00004dac <MSS_UART_enable_afclear>:
     mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4dac:	f640 4324 	movw	r3, #3108	; 0xc24
    4db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4db4:	4298      	cmp	r0, r3
    4db6:	d006      	beq.n	4dc6 <MSS_UART_enable_afclear+0x1a>
    4db8:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4dbc:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4dc0:	4288      	cmp	r0, r1
    4dc2:	d000      	beq.n	4dc6 <MSS_UART_enable_afclear+0x1a>
    4dc4:	4770      	bx	lr
    {
        /* Enable address flag clearing */
        /* Disable RX FIFO till another address flag with 
           correct address is received */
        set_bit_reg8(&this_uart->hw_reg->MM2,EAFC);
    4dc6:	6802      	ldr	r2, [r0, #0]
    4dc8:	3238      	adds	r2, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4dca:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    4dce:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4dd2:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4dd6:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4dda:	3308      	adds	r3, #8
    4ddc:	014a      	lsls	r2, r1, #5
    4dde:	2001      	movs	r0, #1
    4de0:	5098      	str	r0, [r3, r2]
    4de2:	4770      	bx	lr

00004de4 <MSS_UART_disable_afclear>:
     mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4de4:	f640 4324 	movw	r3, #3108	; 0xc24
    4de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4dec:	4298      	cmp	r0, r3
    4dee:	d006      	beq.n	4dfe <MSS_UART_disable_afclear+0x1a>
    4df0:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4df4:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4df8:	4288      	cmp	r0, r1
    4dfa:	d000      	beq.n	4dfe <MSS_UART_disable_afclear+0x1a>
    4dfc:	4770      	bx	lr
    {
        /* Disable address flag clearing */
        clear_bit_reg8(&this_uart->hw_reg->MM2,EAFC);
    4dfe:	6802      	ldr	r2, [r0, #0]
    4e00:	3238      	adds	r2, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4e02:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    4e06:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4e0a:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4e0e:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4e12:	3308      	adds	r3, #8
    4e14:	014a      	lsls	r2, r1, #5
    4e16:	2000      	movs	r0, #0
    4e18:	5098      	str	r0, [r3, r2]
    4e1a:	4770      	bx	lr

00004e1c <MSS_UART_enable_rx_timeout>:
    uint8_t timeout
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4e1c:	f640 4324 	movw	r3, #3108	; 0xc24
    4e20:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e24:	4298      	cmp	r0, r3
    4e26:	d006      	beq.n	4e36 <MSS_UART_enable_rx_timeout+0x1a>
    4e28:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4e2c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4e30:	4290      	cmp	r0, r2
    4e32:	d000      	beq.n	4e36 <MSS_UART_enable_rx_timeout+0x1a>
    4e34:	4770      	bx	lr
    {
        /* Load the receive timeout value */
        this_uart->hw_reg->RTO = timeout;
    4e36:	6800      	ldr	r0, [r0, #0]
        /*Enable receiver time-out */
        set_bit_reg8(&this_uart->hw_reg->MM0,ERTO);
    4e38:	f100 0230 	add.w	r2, r0, #48	; 0x30
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4e3c:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    4e40:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4e44:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    4e48:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    {
        /* Load the receive timeout value */
        this_uart->hw_reg->RTO = timeout;
    4e4c:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
    4e50:	3318      	adds	r3, #24
    4e52:	0152      	lsls	r2, r2, #5
    4e54:	2101      	movs	r1, #1
    4e56:	5099      	str	r1, [r3, r2]
    4e58:	4770      	bx	lr
    4e5a:	bf00      	nop

00004e5c <MSS_UART_disable_rx_timeout>:
    mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4e5c:	f640 4324 	movw	r3, #3108	; 0xc24
    4e60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e64:	4298      	cmp	r0, r3
    4e66:	d006      	beq.n	4e76 <MSS_UART_disable_rx_timeout+0x1a>
    4e68:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4e6c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4e70:	4288      	cmp	r0, r1
    4e72:	d000      	beq.n	4e76 <MSS_UART_disable_rx_timeout+0x1a>
    4e74:	4770      	bx	lr
    {
        /*Disable receiver time-out */
        clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO);
    4e76:	6802      	ldr	r2, [r0, #0]
    4e78:	3230      	adds	r2, #48	; 0x30
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4e7a:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    4e7e:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4e82:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4e86:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4e8a:	3318      	adds	r3, #24
    4e8c:	014a      	lsls	r2, r1, #5
    4e8e:	2000      	movs	r0, #0
    4e90:	5098      	str	r0, [r3, r2]
    4e92:	4770      	bx	lr

00004e94 <MSS_UART_enable_tx_time_guard>:
    uint8_t timeguard
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4e94:	f640 4324 	movw	r3, #3108	; 0xc24
    4e98:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4e9c:	4298      	cmp	r0, r3
    4e9e:	d006      	beq.n	4eae <MSS_UART_enable_tx_time_guard+0x1a>
    4ea0:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4ea4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4ea8:	4290      	cmp	r0, r2
    4eaa:	d000      	beq.n	4eae <MSS_UART_enable_tx_time_guard+0x1a>
    4eac:	4770      	bx	lr
    {
        /* Load the transmitter time guard value */
        this_uart->hw_reg->TTG = timeguard;
    4eae:	6800      	ldr	r0, [r0, #0]
        /*Enable transmitter time guard */
        set_bit_reg8(&this_uart->hw_reg->MM0,ETTG);
    4eb0:	f100 0230 	add.w	r2, r0, #48	; 0x30
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4eb4:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    4eb8:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4ebc:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    4ec0:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    {
        /* Load the transmitter time guard value */
        this_uart->hw_reg->TTG = timeguard;
    4ec4:	f880 1048 	strb.w	r1, [r0, #72]	; 0x48
    4ec8:	3314      	adds	r3, #20
    4eca:	0152      	lsls	r2, r2, #5
    4ecc:	2101      	movs	r1, #1
    4ece:	5099      	str	r1, [r3, r2]
    4ed0:	4770      	bx	lr
    4ed2:	bf00      	nop

00004ed4 <MSS_UART_disable_tx_time_guard>:
    mss_uart_instance_t * this_uart
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4ed4:	f640 4324 	movw	r3, #3108	; 0xc24
    4ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4edc:	4298      	cmp	r0, r3
    4ede:	d006      	beq.n	4eee <MSS_UART_disable_tx_time_guard+0x1a>
    4ee0:	f640 31e4 	movw	r1, #3044	; 0xbe4
    4ee4:	f2c2 0100 	movt	r1, #8192	; 0x2000
    4ee8:	4288      	cmp	r0, r1
    4eea:	d000      	beq.n	4eee <MSS_UART_disable_tx_time_guard+0x1a>
    4eec:	4770      	bx	lr
    {
        /*Disable transmitter time guard */
        clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG);
    4eee:	6802      	ldr	r2, [r0, #0]
    4ef0:	3230      	adds	r2, #48	; 0x30
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4ef2:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    4ef6:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4efa:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4efe:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4f02:	3314      	adds	r3, #20
    4f04:	014a      	lsls	r2, r1, #5
    4f06:	2000      	movs	r0, #0
    4f08:	5098      	str	r0, [r3, r2]
    4f0a:	4770      	bx	lr

00004f0c <MSS_UART_set_address>:
    uint8_t address
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4f0c:	f640 4324 	movw	r3, #3108	; 0xc24
    4f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f14:	4298      	cmp	r0, r3
    4f16:	d006      	beq.n	4f26 <MSS_UART_set_address+0x1a>
    4f18:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4f1c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4f20:	4290      	cmp	r0, r2
    4f22:	d000      	beq.n	4f26 <MSS_UART_set_address+0x1a>
    4f24:	4770      	bx	lr
    {
        this_uart->hw_reg->ADR = address;
    4f26:	6803      	ldr	r3, [r0, #0]
    4f28:	f883 1050 	strb.w	r1, [r3, #80]	; 0x50
    4f2c:	4770      	bx	lr
    4f2e:	bf00      	nop

00004f30 <MSS_UART_set_ready_mode>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_READY_MODE > mode);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4f30:	f640 4324 	movw	r3, #3108	; 0xc24
    4f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f38:	4298      	cmp	r0, r3
    4f3a:	d006      	beq.n	4f4a <MSS_UART_set_ready_mode+0x1a>
    4f3c:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4f40:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4f44:	4290      	cmp	r0, r2
    4f46:	d000      	beq.n	4f4a <MSS_UART_set_ready_mode+0x1a>
    4f48:	4770      	bx	lr
    4f4a:	2901      	cmp	r1, #1
    4f4c:	d8fc      	bhi.n	4f48 <MSS_UART_set_ready_mode+0x18>
       (MSS_UART_INVALID_READY_MODE > mode ) )
    {
        /* Configure mode 0 or mode 1 for TXRDY and RXRDY */
        ((MSS_UART_READY_MODE0 == mode) ? clear_bit_reg8(&this_uart->hw_reg->FCR,RDYMODE) :
    4f4e:	b171      	cbz	r1, 4f6e <MSS_UART_set_ready_mode+0x3e>
                                 set_bit_reg8(&this_uart->hw_reg->FCR,RDYMODE) );    
    4f50:	6802      	ldr	r2, [r0, #0]
    4f52:	3208      	adds	r2, #8
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    4f54:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    4f58:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    4f5c:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    4f60:	f103 7000 	add.w	r0, r3, #33554432	; 0x2000000
    4f64:	014a      	lsls	r2, r1, #5
    4f66:	300c      	adds	r0, #12
    4f68:	2101      	movs	r1, #1
    4f6a:	5081      	str	r1, [r0, r2]
    4f6c:	e7ec      	b.n	4f48 <MSS_UART_set_ready_mode+0x18>

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (MSS_UART_INVALID_READY_MODE > mode ) )
    {
        /* Configure mode 0 or mode 1 for TXRDY and RXRDY */
        ((MSS_UART_READY_MODE0 == mode) ? clear_bit_reg8(&this_uart->hw_reg->FCR,RDYMODE) :
    4f6e:	6803      	ldr	r3, [r0, #0]
    4f70:	3308      	adds	r3, #8
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    4f72:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    4f76:	f003 4070 	and.w	r0, r3, #4026531840	; 0xf0000000
    4f7a:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    4f7e:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    4f82:	330c      	adds	r3, #12
    4f84:	0150      	lsls	r0, r2, #5
    4f86:	5019      	str	r1, [r3, r0]
    4f88:	4770      	bx	lr
    4f8a:	bf00      	nop

00004f8c <MSS_UART_set_usart_mode>:
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(MSS_UART_INVALID_SYNC_MODE > mode);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    4f8c:	f640 4324 	movw	r3, #3108	; 0xc24
    4f90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4f94:	4298      	cmp	r0, r3
    4f96:	d006      	beq.n	4fa6 <MSS_UART_set_usart_mode+0x1a>
    4f98:	f640 32e4 	movw	r2, #3044	; 0xbe4
    4f9c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    4fa0:	4290      	cmp	r0, r2
    4fa2:	d000      	beq.n	4fa6 <MSS_UART_set_usart_mode+0x1a>
    4fa4:	4770      	bx	lr
    4fa6:	2904      	cmp	r1, #4
    4fa8:	d8fc      	bhi.n	4fa4 <MSS_UART_set_usart_mode+0x18>
       (MSS_UART_INVALID_SYNC_MODE > mode))
    {
        /* Nothing to do for the baudrate: operates at PCLK / 2 + glitch filter length */
        /* Clear the ESYN bits 2:0 */
        this_uart->hw_reg->MM0 &= ~SYNC_ASYNC_MODE_MASK;
    4faa:	6803      	ldr	r3, [r0, #0]
    4fac:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
    4fb0:	f002 0cf8 	and.w	ip, r2, #248	; 0xf8
    4fb4:	f883 c030 	strb.w	ip, [r3, #48]	; 0x30
        this_uart->hw_reg->MM0 |= (uint8_t)mode;
    4fb8:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
    4fbc:	4301      	orrs	r1, r0
    4fbe:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
    4fc2:	4770      	bx	lr

00004fc4 <MSS_UART_isr>:
{
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4fc4:	f640 4324 	movw	r3, #3108	; 0xc24
    4fc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    4fcc:	4298      	cmp	r0, r3
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
    4fce:	b510      	push	{r4, lr}
    4fd0:	4604      	mov	r4, r0
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    4fd2:	d006      	beq.n	4fe2 <MSS_UART_isr+0x1e>
    4fd4:	f640 30e4 	movw	r0, #3044	; 0xbe4
    4fd8:	f2c2 0000 	movt	r0, #8192	; 0x2000
    4fdc:	4284      	cmp	r4, r0
    4fde:	d000      	beq.n	4fe2 <MSS_UART_isr+0x1e>
    4fe0:	bd10      	pop	{r4, pc}
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
    4fe2:	6822      	ldr	r2, [r4, #0]
    4fe4:	7a11      	ldrb	r1, [r2, #8]

        switch (iirf)
    4fe6:	f001 0c0f 	and.w	ip, r1, #15
    4fea:	f1bc 0f0c 	cmp.w	ip, #12
    4fee:	d8f7      	bhi.n	4fe0 <MSS_UART_isr+0x1c>
    4ff0:	a101      	add	r1, pc, #4	; (adr r1, 4ff8 <MSS_UART_isr+0x34>)
    4ff2:	f851 f02c 	ldr.w	pc, [r1, ip, lsl #2]
    4ff6:	bf00      	nop
    4ff8:	00005049 	.word	0x00005049
    4ffc:	00004fe1 	.word	0x00004fe1
    5000:	00005041 	.word	0x00005041
    5004:	00005051 	.word	0x00005051
    5008:	00005039 	.word	0x00005039
    500c:	00004fe1 	.word	0x00004fe1
    5010:	0000502d 	.word	0x0000502d
    5014:	00004fe1 	.word	0x00004fe1
    5018:	00004fe1 	.word	0x00004fe1
    501c:	00004fe1 	.word	0x00004fe1
    5020:	00004fe1 	.word	0x00004fe1
    5024:	00004fe1 	.word	0x00004fe1
    5028:	00005039 	.word	0x00005039
            break;

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
                if(NULL_HANDLER != this_uart->linests_handler)
    502c:	69e3      	ldr	r3, [r4, #28]
    502e:	2b00      	cmp	r3, #0
    5030:	d0d6      	beq.n	4fe0 <MSS_UART_isr+0x1c>
                {
                   (*(this_uart->linests_handler))(this_uart);
    5032:	4620      	mov	r0, r4
    5034:	4798      	blx	r3
    5036:	bd10      	pop	{r4, pc}

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
                if(NULL_HANDLER != this_uart->rx_handler)
    5038:	6a23      	ldr	r3, [r4, #32]
    503a:	2b00      	cmp	r3, #0
    503c:	d1f9      	bne.n	5032 <MSS_UART_isr+0x6e>
    503e:	e7cf      	b.n	4fe0 <MSS_UART_isr+0x1c>
            break;

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
                if(NULL_HANDLER != this_uart->tx_handler)
    5040:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5042:	2b00      	cmp	r3, #0
    5044:	d1f5      	bne.n	5032 <MSS_UART_isr+0x6e>
    5046:	e7cb      	b.n	4fe0 <MSS_UART_isr+0x1c>
        switch (iirf)
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
                if(NULL_HANDLER != this_uart->modemsts_handler)
    5048:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    504a:	2b00      	cmp	r3, #0
    504c:	d1f1      	bne.n	5032 <MSS_UART_isr+0x6e>
    504e:	e7c7      	b.n	4fe0 <MSS_UART_isr+0x1c>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
    5050:	3228      	adds	r2, #40	; 0x28
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
    5052:	f022 407f 	bic.w	r0, r2, #4278190080	; 0xff000000
    5056:	f420 0370 	bic.w	r3, r0, #15728640	; 0xf00000
    505a:	f002 4170 	and.w	r1, r2, #4026531840	; 0xf0000000
    505e:	0158      	lsls	r0, r3, #5
    5060:	f101 7c00 	add.w	ip, r1, #33554432	; 0x2000000
    5064:	f85c 3000 	ldr.w	r3, [ip, r0]
    5068:	f013 0fff 	tst.w	r3, #255	; 0xff
    506c:	d005      	beq.n	507a <MSS_UART_isr+0xb6>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
                    if(NULL_HANDLER != this_uart->rto_handler)
    506e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5070:	b11b      	cbz	r3, 507a <MSS_UART_isr+0xb6>
                    {
                        (*(this_uart->rto_handler))(this_uart);
    5072:	4620      	mov	r0, r4
    5074:	4798      	blx	r3
    5076:	6822      	ldr	r2, [r4, #0]
    5078:	3228      	adds	r2, #40	; 0x28
    507a:	f002 4070 	and.w	r0, r2, #4026531840	; 0xf0000000
    507e:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    5082:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
    5086:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    508a:	1d18      	adds	r0, r3, #4
    508c:	0149      	lsls	r1, r1, #5
    508e:	5843      	ldr	r3, [r0, r1]
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
    5090:	f013 0fff 	tst.w	r3, #255	; 0xff
    5094:	d005      	beq.n	50a2 <MSS_UART_isr+0xde>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
                    if(NULL_HANDLER != this_uart->nack_handler)
    5096:	6b23      	ldr	r3, [r4, #48]	; 0x30
    5098:	b11b      	cbz	r3, 50a2 <MSS_UART_isr+0xde>
                    {
                        (*(this_uart->nack_handler))(this_uart);
    509a:	4620      	mov	r0, r4
    509c:	4798      	blx	r3
    509e:	6822      	ldr	r2, [r4, #0]
    50a0:	3228      	adds	r2, #40	; 0x28
    50a2:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    50a6:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    50aa:	f103 7000 	add.w	r0, r3, #33554432	; 0x2000000
    50ae:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    50b2:	3008      	adds	r0, #8
    50b4:	0149      	lsls	r1, r1, #5
    50b6:	5843      	ldr	r3, [r0, r1]
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
    50b8:	f013 0fff 	tst.w	r3, #255	; 0xff
    50bc:	d005      	beq.n	50ca <MSS_UART_isr+0x106>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
    50be:	6b63      	ldr	r3, [r4, #52]	; 0x34
    50c0:	b11b      	cbz	r3, 50ca <MSS_UART_isr+0x106>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
    50c2:	4620      	mov	r0, r4
    50c4:	4798      	blx	r3
    50c6:	6822      	ldr	r2, [r4, #0]
    50c8:	3228      	adds	r2, #40	; 0x28
    50ca:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    50ce:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    50d2:	f42c 0070 	bic.w	r0, ip, #15728640	; 0xf00000
    50d6:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    50da:	330c      	adds	r3, #12
    50dc:	0141      	lsls	r1, r0, #5
    50de:	5858      	ldr	r0, [r3, r1]
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
    50e0:	f010 0fff 	tst.w	r0, #255	; 0xff
    50e4:	d005      	beq.n	50f2 <MSS_UART_isr+0x12e>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
                    if(NULL_HANDLER != this_uart->break_handler)
    50e6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    50e8:	b11b      	cbz	r3, 50f2 <MSS_UART_isr+0x12e>
                    {
                        (*(this_uart->break_handler))(this_uart);
    50ea:	4620      	mov	r0, r4
    50ec:	4798      	blx	r3
    50ee:	6822      	ldr	r2, [r4, #0]
    50f0:	3228      	adds	r2, #40	; 0x28
    50f2:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    50f6:	f002 4170 	and.w	r1, r2, #4026531840	; 0xf0000000
    50fa:	f101 7200 	add.w	r2, r1, #33554432	; 0x2000000
    50fe:	f42c 0370 	bic.w	r3, ip, #15728640	; 0xf00000
    5102:	3210      	adds	r2, #16
    5104:	0158      	lsls	r0, r3, #5
    5106:	5811      	ldr	r1, [r2, r0]
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
    5108:	f011 0fff 	tst.w	r1, #255	; 0xff
    510c:	f43f af68 	beq.w	4fe0 <MSS_UART_isr+0x1c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
                    if(NULL_HANDLER != this_uart->sync_handler)
    5110:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    5112:	2b00      	cmp	r3, #0
    5114:	f43f af64 	beq.w	4fe0 <MSS_UART_isr+0x1c>
                    {
                        (*(this_uart->sync_handler))(this_uart);
    5118:	4620      	mov	r0, r4
    511a:	4798      	blx	r3
    511c:	e760      	b.n	4fe0 <MSS_UART_isr+0x1c>
    511e:	bf00      	nop

00005120 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
    5120:	4668      	mov	r0, sp
    5122:	f020 0107 	bic.w	r1, r0, #7
    5126:	468d      	mov	sp, r1
    5128:	b501      	push	{r0, lr}
    MSS_UART_isr(&g_mss_uart1);
    512a:	f640 30e4 	movw	r0, #3044	; 0xbe4
    512e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5132:	f7ff ff47 	bl	4fc4 <MSS_UART_isr>
}
    5136:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    513a:	4685      	mov	sp, r0
    513c:	4770      	bx	lr
    513e:	bf00      	nop

00005140 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
    5140:	4668      	mov	r0, sp
    5142:	f020 0107 	bic.w	r1, r0, #7
    5146:	468d      	mov	sp, r1
    5148:	b501      	push	{r0, lr}
    MSS_UART_isr(&g_mss_uart0);
    514a:	f640 4024 	movw	r0, #3108	; 0xc24
    514e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    5152:	f7ff ff37 	bl	4fc4 <MSS_UART_isr>
}
    5156:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    515a:	4685      	mov	sp, r0
    515c:	4770      	bx	lr
    515e:	bf00      	nop

00005160 <default_tx_handler>:

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    5160:	f640 4324 	movw	r3, #3108	; 0xc24
    5164:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5168:	4298      	cmp	r0, r3
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
    516a:	b470      	push	{r4, r5, r6}

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
    516c:	d007      	beq.n	517e <default_tx_handler+0x1e>
    516e:	f640 31e4 	movw	r1, #3044	; 0xbe4
    5172:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5176:	4288      	cmp	r0, r1
    5178:	d001      	beq.n	517e <default_tx_handler+0x1e>
            this_uart->tx_buff_size = TX_COMPLETE;
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
        }
    }
}
    517a:	bc70      	pop	{r4, r5, r6}
    517c:	4770      	bx	lr
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
    517e:	6904      	ldr	r4, [r0, #16]
    5180:	2c00      	cmp	r4, #0
    5182:	d0fa      	beq.n	517a <default_tx_handler+0x1a>
       (0u < this_uart->tx_buff_size))
    5184:	6943      	ldr	r3, [r0, #20]
    5186:	2b00      	cmp	r3, #0
    5188:	d0f7      	beq.n	517a <default_tx_handler+0x1a>
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    518a:	6801      	ldr	r1, [r0, #0]
        this_uart->status |= status;
    518c:	f890 c00d 	ldrb.w	ip, [r0, #13]
    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
    5190:	7d0a      	ldrb	r2, [r1, #20]
        this_uart->status |= status;
    5192:	ea42 0c0c 	orr.w	ip, r2, ip

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
    5196:	f012 0f20 	tst.w	r2, #32
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;
    519a:	f880 c00d 	strb.w	ip, [r0, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
    519e:	6982      	ldr	r2, [r0, #24]
    51a0:	d029      	beq.n	51f6 <default_tx_handler+0x96>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
    51a2:	1a9d      	subs	r5, r3, r2

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
    51a4:	2d0f      	cmp	r5, #15
    51a6:	d938      	bls.n	521a <default_tx_handler+0xba>
    51a8:	2510      	movs	r5, #16
    51aa:	18a4      	adds	r4, r4, r2

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51ac:	7826      	ldrb	r6, [r4, #0]
    51ae:	1e6b      	subs	r3, r5, #1
    51b0:	700e      	strb	r6, [r1, #0]
    51b2:	f003 0601 	and.w	r6, r3, #1
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51b6:	2301      	movs	r3, #1
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
                ++this_uart->tx_idx;
    51b8:	3201      	adds	r2, #1
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51ba:	429d      	cmp	r5, r3
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
                ++this_uart->tx_idx;
    51bc:	6182      	str	r2, [r0, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51be:	d919      	bls.n	51f4 <default_tx_handler+0x94>
    51c0:	b146      	cbz	r6, 51d4 <default_tx_handler+0x74>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51c2:	f894 c001 	ldrb.w	ip, [r4, #1]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51c6:	2302      	movs	r3, #2
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
                ++this_uart->tx_idx;
    51c8:	3201      	adds	r2, #1
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51ca:	429d      	cmp	r5, r3
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51cc:	f881 c000 	strb.w	ip, [r1]
                ++this_uart->tx_idx;
    51d0:	6182      	str	r2, [r0, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51d2:	d90f      	bls.n	51f4 <default_tx_handler+0x94>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51d4:	f814 c003 	ldrb.w	ip, [r4, r3]
                ++this_uart->tx_idx;
    51d8:	3201      	adds	r2, #1

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51da:	f881 c000 	strb.w	ip, [r1]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51de:	3301      	adds	r3, #1
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
                ++this_uart->tx_idx;
    51e0:	6182      	str	r2, [r0, #24]

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51e2:	f814 c003 	ldrb.w	ip, [r4, r3]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51e6:	3301      	adds	r3, #1
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
                ++this_uart->tx_idx;
    51e8:	3201      	adds	r2, #1
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51ea:	429d      	cmp	r5, r3
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
    51ec:	f881 c000 	strb.w	ip, [r1]
                ++this_uart->tx_idx;
    51f0:	6182      	str	r2, [r0, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    51f2:	d8ef      	bhi.n	51d4 <default_tx_handler+0x74>
    51f4:	6943      	ldr	r3, [r0, #20]
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
    51f6:	429a      	cmp	r2, r3
    51f8:	d1bf      	bne.n	517a <default_tx_handler+0x1a>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
    51fa:	6802      	ldr	r2, [r0, #0]
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
        {
            this_uart->tx_buff_size = TX_COMPLETE;
    51fc:	2100      	movs	r1, #0
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
    51fe:	1d13      	adds	r3, r2, #4
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5200:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    5204:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
    5208:	f102 7300 	add.w	r3, r2, #33554432	; 0x2000000
    520c:	f42c 0270 	bic.w	r2, ip, #15728640	; 0xf00000
    5210:	3304      	adds	r3, #4
    5212:	0152      	lsls	r2, r2, #5
    5214:	5099      	str	r1, [r3, r2]
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
        {
            this_uart->tx_buff_size = TX_COMPLETE;
    5216:	6141      	str	r1, [r0, #20]
    5218:	e7af      	b.n	517a <default_tx_handler+0x1a>
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
    521a:	2d00      	cmp	r5, #0
    521c:	d1c5      	bne.n	51aa <default_tx_handler+0x4a>
    521e:	e7ea      	b.n	51f6 <default_tx_handler+0x96>

00005220 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    5220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    5224:	f640 4324 	movw	r3, #3108	; 0xc24
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    5228:	b08f      	sub	sp, #60	; 0x3c
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    522a:	f2c2 0300 	movt	r3, #8192	; 0x2000
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    522e:	920b      	str	r2, [sp, #44]	; 0x2c
    if(this_uart == &g_mss_uart0)
    {
        this_uart->hw_reg = UART0;
        this_uart->irqn = UART0_IRQn;
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
    5230:	f248 0200 	movw	r2, #32768	; 0x8000
{
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    5234:	4298      	cmp	r0, r3
    {
        this_uart->hw_reg = UART0;
        this_uart->irqn = UART0_IRQn;
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
    5236:	f2c4 0203 	movt	r2, #16387	; 0x4003
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
    523a:	4604      	mov	r4, r0
    523c:	910d      	str	r1, [sp, #52]	; 0x34
    if(this_uart == &g_mss_uart0)
    {
        this_uart->hw_reg = UART0;
        this_uart->irqn = UART0_IRQn;
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
    523e:	6c90      	ldr	r0, [r2, #72]	; 0x48

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    5240:	f24e 1100 	movw	r1, #57600	; 0xe100
{
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    5244:	f000 8129 	beq.w	549a <global_init+0x27a>
    else
    {
        this_uart->hw_reg = UART1;
        this_uart->irqn = UART1_IRQn;
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
    5248:	f440 7780 	orr.w	r7, r0, #256	; 0x100
    524c:	f2ce 0100 	movt	r1, #57344	; 0xe000
    5250:	f44f 6600 	mov.w	r6, #2048	; 0x800
    5254:	6497      	str	r7, [r2, #72]	; 0x48
    5256:	f8c1 6180 	str.w	r6, [r1, #384]	; 0x180
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
    525a:	6c95      	ldr	r5, [r2, #72]	; 0x48
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    }
    else
    {
        this_uart->hw_reg = UART1;
    525c:	f240 0100 	movw	r1, #0
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
    5260:	f425 7080 	bic.w	r0, r5, #256	; 0x100
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    }
    else
    {
        this_uart->hw_reg = UART1;
    5264:	f2c4 0101 	movt	r1, #16385	; 0x4001
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
    5268:	6490      	str	r0, [r2, #72]	; 0x48
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    }
    else
    {
        this_uart->hw_reg = UART1;
        this_uart->irqn = UART1_IRQn;
    526a:	220b      	movs	r2, #11
    526c:	7122      	strb	r2, [r4, #4]
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    }
    else
    {
        this_uart->hw_reg = UART1;
    526e:	6021      	str	r1, [r4, #0]
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
    5270:	2200      	movs	r2, #0

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
    5272:	460d      	mov	r5, r1
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
    5274:	710a      	strb	r2, [r1, #4]
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
    5276:	f101 0610 	add.w	r6, r1, #16

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
    527a:	f805 2f08 	strb.w	r2, [r5, #8]!
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
    527e:	f101 0a38 	add.w	sl, r1, #56	; 0x38
    5282:	f02a 4b7f 	bic.w	fp, sl, #4278190080	; 0xff000000
    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
    5286:	f101 0934 	add.w	r9, r1, #52	; 0x34
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    528a:	f025 477f 	bic.w	r7, r5, #4278190080	; 0xff000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    528e:	f026 487f 	bic.w	r8, r6, #4278190080	; 0xff000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5292:	f005 4570 	and.w	r5, r5, #4026531840	; 0xf0000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5296:	f006 4670 	and.w	r6, r6, #4026531840	; 0xf0000000
    529a:	f00a 4a70 	and.w	sl, sl, #4026531840	; 0xf0000000
    529e:	f8cd a010 	str.w	sl, [sp, #16]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52a2:	9506      	str	r5, [sp, #24]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52a4:	f029 407f 	bic.w	r0, r9, #4278190080	; 0xff000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52a8:	f106 7500 	add.w	r5, r6, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52ac:	9003      	str	r0, [sp, #12]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52ae:	9501      	str	r5, [sp, #4]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52b0:	f009 4970 	and.w	r9, r9, #4026531840	; 0xf0000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52b4:	9d04      	ldr	r5, [sp, #16]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52b6:	f8cd 901c 	str.w	r9, [sp, #28]
    52ba:	f8dd 900c 	ldr.w	r9, [sp, #12]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52be:	f105 7500 	add.w	r5, r5, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52c2:	f429 0a70 	bic.w	sl, r9, #15728640	; 0xf00000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52c6:	950a      	str	r5, [sp, #40]	; 0x28
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52c8:	f42b 0970 	bic.w	r9, fp, #15728640	; 0xf00000
    52cc:	9d07      	ldr	r5, [sp, #28]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52ce:	f8dd b018 	ldr.w	fp, [sp, #24]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52d2:	f8cd 9014 	str.w	r9, [sp, #20]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52d6:	f10b 7900 	add.w	r9, fp, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    52da:	f105 7b00 	add.w	fp, r5, #33554432	; 0x2000000
    52de:	9d04      	ldr	r5, [sp, #16]

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
    52e0:	f101 0c30 	add.w	ip, r1, #48	; 0x30
    52e4:	f02c 407f 	bic.w	r0, ip, #4278190080	; 0xff000000
    52e8:	f105 7500 	add.w	r5, r5, #33554432	; 0x2000000
    52ec:	f00c 4c70 	and.w	ip, ip, #4026531840	; 0xf0000000
    52f0:	f8cd a00c 	str.w	sl, [sp, #12]
    52f4:	9504      	str	r5, [sp, #16]
    52f6:	f10c 7500 	add.w	r5, ip, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    52fa:	f10c 7a00 	add.w	sl, ip, #33554432	; 0x2000000
    52fe:	46ac      	mov	ip, r5
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5300:	9d03      	ldr	r5, [sp, #12]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5302:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5306:	016d      	lsls	r5, r5, #5
    5308:	9503      	str	r5, [sp, #12]
    530a:	9d05      	ldr	r5, [sp, #20]
    530c:	f428 0870 	bic.w	r8, r8, #15728640	; 0xf00000
    5310:	016d      	lsls	r5, r5, #5
    5312:	9505      	str	r5, [sp, #20]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5314:	9d06      	ldr	r5, [sp, #24]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5316:	46ca      	mov	sl, r9
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5318:	f105 7500 	add.w	r5, r5, #33554432	; 0x2000000
    531c:	9506      	str	r5, [sp, #24]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    531e:	9d01      	ldr	r5, [sp, #4]
    5320:	ea4f 1848 	mov.w	r8, r8, lsl #5
    5324:	3514      	adds	r5, #20
    5326:	9501      	str	r5, [sp, #4]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5328:	9d07      	ldr	r5, [sp, #28]
    532a:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    532e:	f105 7500 	add.w	r5, r5, #33554432	; 0x2000000
    5332:	9507      	str	r5, [sp, #28]
    5334:	9d04      	ldr	r5, [sp, #16]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5336:	017f      	lsls	r7, r7, #5
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5338:	3504      	adds	r5, #4
    533a:	9504      	str	r5, [sp, #16]
    533c:	4665      	mov	r5, ip
    533e:	3514      	adds	r5, #20
    5340:	9508      	str	r5, [sp, #32]
    5342:	9d09      	ldr	r5, [sp, #36]	; 0x24
    5344:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
    5348:	351c      	adds	r5, #28
    534a:	9509      	str	r5, [sp, #36]	; 0x24
    534c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    534e:	f04f 0801 	mov.w	r8, #1
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5352:	350c      	adds	r5, #12
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5354:	f10a 0a08 	add.w	sl, sl, #8
    5358:	f109 0904 	add.w	r9, r9, #4
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    535c:	950a      	str	r5, [sp, #40]	; 0x28
    535e:	f106 7600 	add.w	r6, r6, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5362:	f849 8007 	str.w	r8, [r9, r7]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5366:	9d0c      	ldr	r5, [sp, #48]	; 0x30
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5368:	f84a 8007 	str.w	r8, [sl, r7]
    536c:	f8dd a018 	ldr.w	sl, [sp, #24]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5370:	3610      	adds	r6, #16
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5372:	f84a 8007 	str.w	r8, [sl, r7]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5376:	5172      	str	r2, [r6, r5]
    5378:	f8dd a00c 	ldr.w	sl, [sp, #12]
    537c:	9e01      	ldr	r6, [sp, #4]
    537e:	f10b 0b04 	add.w	fp, fp, #4
    5382:	5172      	str	r2, [r6, r5]
    5384:	f84b 200a 	str.w	r2, [fp, sl]
    5388:	f8dd b01c 	ldr.w	fp, [sp, #28]
    538c:	9d05      	ldr	r5, [sp, #20]
    538e:	f84b 200a 	str.w	r2, [fp, sl]
    5392:	9e04      	ldr	r6, [sp, #16]
    5394:	f8dd a020 	ldr.w	sl, [sp, #32]
    5398:	f420 0070 	bic.w	r0, r0, #15728640	; 0xf00000
    539c:	0140      	lsls	r0, r0, #5
    539e:	f10c 0c18 	add.w	ip, ip, #24
    53a2:	5172      	str	r2, [r6, r5]
    53a4:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    53a8:	f84a 2000 	str.w	r2, [sl, r0]
    53ac:	f84c 2000 	str.w	r2, [ip, r0]
    53b0:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    uint32_t baudrate    
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    53b4:	429c      	cmp	r4, r3
    53b6:	f84b 2000 	str.w	r2, [fp, r0]
    53ba:	f84c 2005 	str.w	r2, [ip, r5]

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
    53be:	f881 2044 	strb.w	r2, [r1, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
    53c2:	f881 2048 	strb.w	r2, [r1, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
    53c6:	f881 204c 	strb.w	r2, [r1, #76]	; 0x4c
    uint32_t baudrate    
)
{
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
    53ca:	d079      	beq.n	54c0 <global_init+0x2a0>
    53cc:	f640 33e4 	movw	r3, #3044	; 0xbe4
    53d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    53d4:	429c      	cmp	r4, r3
    53d6:	d015      	beq.n	5404 <global_init+0x1e4>
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
    53d8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c

    /* Instance setup */
    this_uart->baudrate = baud_rate;
    this_uart->lineconfig = line_config;
    this_uart->tx_buff_size = TX_COMPLETE;
    53da:	2000      	movs	r0, #0
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
    53dc:	730d      	strb	r5, [r1, #12]
    this_uart->pid_pei_handler  = NULL_HANDLER;
    this_uart->break_handler    = NULL_HANDLER;    
    this_uart->sync_handler     = NULL_HANDLER;   

    /* Initialize the sticky status */
    this_uart->status = 0u;
    53de:	7360      	strb	r0, [r4, #13]

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;

    /* Instance setup */
    this_uart->baudrate = baud_rate;
    53e0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    this_uart->lineconfig = line_config;
    this_uart->tx_buff_size = TX_COMPLETE;
    53e2:	6160      	str	r0, [r4, #20]

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;

    /* Instance setup */
    this_uart->baudrate = baud_rate;
    53e4:	60a6      	str	r6, [r4, #8]
    this_uart->lineconfig = line_config;
    53e6:	7325      	strb	r5, [r4, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
    this_uart->tx_buffer = (const uint8_t *)0;
    53e8:	6120      	str	r0, [r4, #16]
    this_uart->tx_idx = 0u;
    53ea:	61a0      	str	r0, [r4, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
    53ec:	6220      	str	r0, [r4, #32]
    this_uart->tx_handler       = NULL_HANDLER;
    53ee:	6260      	str	r0, [r4, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
    53f0:	61e0      	str	r0, [r4, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
    53f2:	62a0      	str	r0, [r4, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
    53f4:	62e0      	str	r0, [r4, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
    53f6:	6320      	str	r0, [r4, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
    53f8:	6360      	str	r0, [r4, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
    53fa:	63a0      	str	r0, [r4, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
    53fc:	63e0      	str	r0, [r4, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
}
    53fe:	b00f      	add	sp, #60	; 0x3c
    5400:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
    5404:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    5406:	60a7      	str	r7, [r4, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
    5408:	f003 faca 	bl	89a0 <SystemCoreClockUpdate>
        {
            pclk_freq = g_FrequencyPCLK0;
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
    540c:	f240 41c4 	movw	r1, #1220	; 0x4c4
    5410:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5414:	680a      	ldr	r2, [r1, #0]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
    5416:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    5418:	00d7      	lsls	r7, r2, #3
    541a:	fbb7 f2f6 	udiv	r2, r7, r6
        baud_value_by_64 = baud_value_by_128 / 2u;
        baud_value = baud_value_by_64 / 64u;
    541e:	09d3      	lsrs	r3, r2, #7
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
        baud_value_by_64 = baud_value_by_128 / 2u;
    5420:	0857      	lsrs	r7, r2, #1
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
    
        if(baud_value <= (uint32_t)UINT16_MAX)
    5422:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    5426:	bf28      	it	cs
    5428:	6821      	ldrcs	r1, [r4, #0]
    542a:	d2d5      	bcs.n	53d8 <global_init+0x1b8>
        {
            if(baud_value > 1u)
    542c:	2b01      	cmp	r3, #1
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    542e:	6821      	ldr	r1, [r4, #0]
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
    
        if(baud_value <= (uint32_t)UINT16_MAX)
        {
            if(baud_value > 1u)
    5430:	d950      	bls.n	54d4 <global_init+0x2b4>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    5432:	f101 000c 	add.w	r0, r1, #12
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5436:	f020 4c7f 	bic.w	ip, r0, #4278190080	; 0xff000000
    543a:	f000 4670 	and.w	r6, r0, #4026531840	; 0xf0000000
    543e:	f106 7000 	add.w	r0, r6, #33554432	; 0x2000000
    5442:	f42c 0a70 	bic.w	sl, ip, #15728640	; 0xf00000
    5446:	ea4f 1e4a 	mov.w	lr, sl, lsl #5
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    544a:	460d      	mov	r5, r1
    544c:	fa5f f883 	uxtb.w	r8, r3
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
        baud_value_by_64 = baud_value_by_128 / 2u;
        baud_value = baud_value_by_64 / 64u;
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
    5450:	eba7 1783 	sub.w	r7, r7, r3, lsl #6
    5454:	301c      	adds	r0, #28
    5456:	2601      	movs	r6, #1
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
    5458:	f3c2 3ac7 	ubfx	sl, r2, #15, #8
    545c:	f840 600e 	str.w	r6, [r0, lr]
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
        baud_value_by_64 = baud_value_by_128 / 2u;
        baud_value = baud_value_by_64 / 64u;
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
    5460:	eba7 13c3 	sub.w	r3, r7, r3, lsl #7
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
    5464:	f881 a004 	strb.w	sl, [r1, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    5468:	f805 8b30 	strb.w	r8, [r5], #48
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
        baud_value_by_64 = baud_value_by_128 / 2u;
        baud_value = baud_value_by_64 / 64u;
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
    546c:	189a      	adds	r2, r3, r2
    546e:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
    5472:	f005 4570 	and.w	r5, r5, #4026531840	; 0xf0000000
    5476:	f423 0870 	bic.w	r8, r3, #15728640	; 0xf00000
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
    547a:	eba2 0747 	sub.w	r7, r2, r7, lsl #1
    547e:	f105 7500 	add.w	r5, r5, #33554432	; 0x2000000
    5482:	351c      	adds	r5, #28
    5484:	ea4f 1848 	mov.w	r8, r8, lsl #5
    5488:	b2ff      	uxtb	r7, r7
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    548a:	2300      	movs	r3, #0
    548c:	f840 300e 	str.w	r3, [r0, lr]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5490:	f845 6008 	str.w	r6, [r5, r8]
    5494:	f881 703c 	strb.w	r7, [r1, #60]	; 0x3c
    5498:	e79e      	b.n	53d8 <global_init+0x1b8>
    if(this_uart == &g_mss_uart0)
    {
        this_uart->hw_reg = UART0;
        this_uart->irqn = UART0_IRQn;
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
    549a:	f040 0780 	orr.w	r7, r0, #128	; 0x80
    549e:	f2ce 0100 	movt	r1, #57344	; 0xe000
    54a2:	f44f 6680 	mov.w	r6, #1024	; 0x400
    54a6:	6497      	str	r7, [r2, #72]	; 0x48
    54a8:	f8c1 6180 	str.w	r6, [r1, #384]	; 0x180
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    54ac:	6c95      	ldr	r5, [r2, #72]	; 0x48
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    {
        this_uart->hw_reg = UART0;
    54ae:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
    54b2:	f025 0080 	bic.w	r0, r5, #128	; 0x80
    54b6:	6490      	str	r0, [r2, #72]	; 0x48
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    {
        this_uart->hw_reg = UART0;
        this_uart->irqn = UART0_IRQn;
    54b8:	220a      	movs	r2, #10
    54ba:	7122      	strb	r2, [r4, #4]
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    if(this_uart == &g_mss_uart0)
    {
        this_uart->hw_reg = UART0;
    54bc:	6021      	str	r1, [r4, #0]
    54be:	e6d7      	b.n	5270 <global_init+0x50>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
    54c0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    54c2:	60a2      	str	r2, [r4, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
    54c4:	f003 fa6c 	bl	89a0 <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
        {
            pclk_freq = g_FrequencyPCLK0;
    54c8:	f240 41c0 	movw	r1, #1216	; 0x4c0
    54cc:	f2c2 0100 	movt	r1, #8192	; 0x2000
    54d0:	680a      	ldr	r2, [r1, #0]
    54d2:	e7a0      	b.n	5416 <global_init+0x1f6>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
    54d4:	f101 0c0c 	add.w	ip, r1, #12
    54d8:	f02c 4e7f 	bic.w	lr, ip, #4278190080	; 0xff000000
    54dc:	f00c 4270 	and.w	r2, ip, #4026531840	; 0xf0000000
    54e0:	f42e 0570 	bic.w	r5, lr, #15728640	; 0xf00000
    54e4:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    54e8:	ea4f 1e45 	mov.w	lr, r5, lsl #5
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    54ec:	4608      	mov	r0, r1
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
    54ee:	2500      	movs	r5, #0
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    54f0:	b2db      	uxtb	r3, r3
    54f2:	321c      	adds	r2, #28
    54f4:	2601      	movs	r6, #1
    54f6:	f842 600e 	str.w	r6, [r2, lr]
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
    54fa:	710d      	strb	r5, [r1, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
    54fc:	f800 3b30 	strb.w	r3, [r0], #48
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5500:	f020 4c7f 	bic.w	ip, r0, #4278190080	; 0xff000000
    5504:	f000 4070 	and.w	r0, r0, #4026531840	; 0xf0000000
    5508:	f100 7600 	add.w	r6, r0, #33554432	; 0x2000000
    550c:	f42c 0370 	bic.w	r3, ip, #15728640	; 0xf00000
    5510:	361c      	adds	r6, #28
    5512:	015b      	lsls	r3, r3, #5
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
    5514:	f842 500e 	str.w	r5, [r2, lr]
    5518:	50f5      	str	r5, [r6, r3]
    551a:	e75d      	b.n	53d8 <global_init+0x1b8>

0000551c <MSS_UART_smartcard_init>:
    551c:	b570      	push	{r4, r5, r6, lr}
    551e:	4605      	mov	r5, r0
    5520:	4614      	mov	r4, r2
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
    5522:	f7ff fe7d 	bl	5220 <global_init>
    
    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    5526:	682d      	ldr	r5, [r5, #0]

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);

    /* Enable SmartCard Mode : Only when data is 8-bit and 2 stop bits*/
    if( ( MSS_UART_DATA_8_BITS | MSS_UART_TWO_STOP_BITS) == 
    5528:	f004 0407 	and.w	r4, r4, #7

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
    
    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    552c:	f105 0030 	add.w	r0, r5, #48	; 0x30

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
    5530:	f105 0334 	add.w	r3, r5, #52	; 0x34
    5534:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000

    /* Enable SmartCard Mode : Only when data is 8-bit and 2 stop bits*/
    if( ( MSS_UART_DATA_8_BITS | MSS_UART_TWO_STOP_BITS) == 
    5538:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    553c:	f000 4270 	and.w	r2, r0, #4026531840	; 0xf0000000
    5540:	f003 4170 	and.w	r1, r3, #4026531840	; 0xf0000000
    5544:	f426 0070 	bic.w	r0, r6, #15728640	; 0xf00000
    5548:	f101 7300 	add.w	r3, r1, #33554432	; 0x2000000
    554c:	f42c 0670 	bic.w	r6, ip, #15728640	; 0xf00000
    5550:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    5554:	0171      	lsls	r1, r6, #5
    5556:	320c      	adds	r2, #12
    5558:	2600      	movs	r6, #0
    555a:	0140      	lsls	r0, r0, #5
    555c:	3308      	adds	r3, #8
    555e:	2c07      	cmp	r4, #7
    5560:	5016      	str	r6, [r2, r0]
    5562:	505e      	str	r6, [r3, r1]
    5564:	d10f      	bne.n	5586 <MSS_UART_smartcard_init+0x6a>
        (line_config & (MSS_UART_DATA_8_BITS | MSS_UART_TWO_STOP_BITS)))
    {
        set_bit_reg8(&this_uart->hw_reg->MM2, EERR);    
    5566:	3538      	adds	r5, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5568:	f025 4c7f 	bic.w	ip, r5, #4278190080	; 0xff000000
    556c:	f005 4e70 	and.w	lr, r5, #4026531840	; 0xf0000000
    5570:	f42c 0070 	bic.w	r0, ip, #15728640	; 0xf00000
    uint8_t line_config,
    mss_uart_rzi_polarity_t rxpol,
    mss_uart_rzi_polarity_t txpol,
    mss_uart_rzi_pulsewidth_t pw
)
{
    5574:	f10e 7300 	add.w	r3, lr, #33554432	; 0x2000000
    5578:	0142      	lsls	r2, r0, #5
    557a:	2101      	movs	r1, #1
    557c:	330c      	adds	r3, #12
    557e:	f10e 7500 	add.w	r5, lr, #33554432	; 0x2000000
    5582:	50a9      	str	r1, [r5, r2]
    5584:	5099      	str	r1, [r3, r2]
    5586:	bd70      	pop	{r4, r5, r6, pc}

00005588 <MSS_UART_irda_init>:
    5588:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    558c:	4604      	mov	r4, r0
    558e:	461e      	mov	r6, r3
    5590:	f89d 5020 	ldrb.w	r5, [sp, #32]
    5594:	f89d 7024 	ldrb.w	r7, [sp, #36]	; 0x24
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
    5598:	f7ff fe42 	bl	5220 <global_init>

     /* Enable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    559c:	6822      	ldr	r2, [r4, #0]
    559e:	f102 0830 	add.w	r8, r2, #48	; 0x30

    /* Disable IrDA mode */
    set_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
    55a2:	f102 0334 	add.w	r3, r2, #52	; 0x34
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    55a6:	f028 4a7f 	bic.w	sl, r8, #4278190080	; 0xff000000
    55aa:	f008 4170 	and.w	r1, r8, #4026531840	; 0xf0000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    55ae:	f023 497f 	bic.w	r9, r3, #4278190080	; 0xff000000
    55b2:	f003 4870 	and.w	r8, r3, #4026531840	; 0xf0000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    55b6:	f101 7000 	add.w	r0, r1, #33554432	; 0x2000000
    55ba:	f42a 0470 	bic.w	r4, sl, #15728640	; 0xf00000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    55be:	f429 0c70 	bic.w	ip, r9, #15728640	; 0xf00000
    55c2:	f108 7100 	add.w	r1, r8, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    55c6:	ea4f 1a44 	mov.w	sl, r4, lsl #5
    55ca:	300c      	adds	r0, #12
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    55cc:	3108      	adds	r1, #8
    55ce:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
    55d2:	2401      	movs	r4, #1
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    55d4:	f04f 0900 	mov.w	r9, #0
    55d8:	f840 900a 	str.w	r9, [r0, sl]
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    55dc:	f841 400c 	str.w	r4, [r1, ip]
    ((rxpol == MSS_UART_ACTIVE_LOW) ? clear_bit_reg8(&this_uart->hw_reg->MM1,EIRX) : 
    55e0:	2e00      	cmp	r6, #0
    55e2:	d146      	bne.n	5672 <MSS_UART_irda_init+0xea>
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    55e4:	f108 7e00 	add.w	lr, r8, #33554432	; 0x2000000
    55e8:	f10e 080c 	add.w	r8, lr, #12
    55ec:	f848 600c 	str.w	r6, [r8, ip]
                                      set_bit_reg8(&this_uart->hw_reg->MM1,EIRX));
                                      
    ((txpol == MSS_UART_ACTIVE_LOW) ? clear_bit_reg8(&this_uart->hw_reg->MM1,EITX) : 
    55f0:	bb2d      	cbnz	r5, 563e <MSS_UART_irda_init+0xb6>
    55f2:	f003 4e70 	and.w	lr, r3, #4026531840	; 0xf0000000
    55f6:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    55fa:	f10e 7100 	add.w	r1, lr, #33554432	; 0x2000000
    55fe:	f42c 0070 	bic.w	r0, ip, #15728640	; 0xf00000
    5602:	3110      	adds	r1, #16
    5604:	0140      	lsls	r0, r0, #5
    5606:	500d      	str	r5, [r1, r0]
                                      set_bit_reg8(&this_uart->hw_reg->MM1,EITX));
                                      
    ((pw == MSS_UART_3_BY_16) ? clear_bit_reg8(&this_uart->hw_reg->MM1,EITP) : 
    5608:	b33f      	cbz	r7, 565a <MSS_UART_irda_init+0xd2>
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    560a:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    560e:	f003 4e70 	and.w	lr, r3, #4026531840	; 0xf0000000
    5612:	f42c 0070 	bic.w	r0, ip, #15728640	; 0xf00000
    5616:	f10e 7300 	add.w	r3, lr, #33554432	; 0x2000000
    561a:	0141      	lsls	r1, r0, #5
    561c:	3314      	adds	r3, #20
    561e:	2001      	movs	r0, #1
    5620:	5058      	str	r0, [r3, r1]
                                      set_bit_reg8(&this_uart->hw_reg->MM1,EITP));
    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
    5622:	3238      	adds	r2, #56	; 0x38
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    5624:	f022 4e7f 	bic.w	lr, r2, #4278190080	; 0xff000000
    5628:	f42e 0070 	bic.w	r0, lr, #15728640	; 0xf00000
    562c:	f002 4c70 	and.w	ip, r2, #4026531840	; 0xf0000000
    5630:	f10c 7200 	add.w	r2, ip, #33554432	; 0x2000000
    5634:	0143      	lsls	r3, r0, #5
    5636:	2100      	movs	r1, #0
    5638:	50d1      	str	r1, [r2, r3]
}
    563a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    563e:	f003 4e70 	and.w	lr, r3, #4026531840	; 0xf0000000
    5642:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    5646:	f42c 0470 	bic.w	r4, ip, #15728640	; 0xf00000
    564a:	f10e 7100 	add.w	r1, lr, #33554432	; 0x2000000
    564e:	0160      	lsls	r0, r4, #5
    5650:	3110      	adds	r1, #16
    5652:	2401      	movs	r4, #1
    5654:	500c      	str	r4, [r1, r0]
                                      set_bit_reg8(&this_uart->hw_reg->MM1,EIRX));
                                      
    ((txpol == MSS_UART_ACTIVE_LOW) ? clear_bit_reg8(&this_uart->hw_reg->MM1,EITX) : 
                                      set_bit_reg8(&this_uart->hw_reg->MM1,EITX));
                                      
    ((pw == MSS_UART_3_BY_16) ? clear_bit_reg8(&this_uart->hw_reg->MM1,EITP) : 
    5656:	2f00      	cmp	r7, #0
    5658:	d1d7      	bne.n	560a <MSS_UART_irda_init+0x82>
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    565a:	f023 4c7f 	bic.w	ip, r3, #4278190080	; 0xff000000
    565e:	f003 4e70 	and.w	lr, r3, #4026531840	; 0xf0000000
    5662:	f10e 7300 	add.w	r3, lr, #33554432	; 0x2000000
    5666:	f42c 0170 	bic.w	r1, ip, #15728640	; 0xf00000
    566a:	3314      	adds	r3, #20
    566c:	0148      	lsls	r0, r1, #5
    566e:	501f      	str	r7, [r3, r0]
    5670:	e7d7      	b.n	5622 <MSS_UART_irda_init+0x9a>
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    5672:	f108 7000 	add.w	r0, r8, #33554432	; 0x2000000
    5676:	f100 080c 	add.w	r8, r0, #12
    567a:	f848 400c 	str.w	r4, [r8, ip]
    567e:	e7b7      	b.n	55f0 <MSS_UART_irda_init+0x68>

00005680 <MSS_UART_lin_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
    5680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5682:	4607      	mov	r7, r0
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
    5684:	f7ff fdcc 	bl	5220 <global_init>

     /* Enable LIN mode */
    set_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    5688:	683d      	ldr	r5, [r7, #0]
    568a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    568e:	f105 0430 	add.w	r4, r5, #48	; 0x30

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
    5692:	f105 0c34 	add.w	ip, r5, #52	; 0x34
    5696:	f2c0 030f 	movt	r3, #15

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
    569a:	f105 0038 	add.w	r0, r5, #56	; 0x38
    569e:	f004 4170 	and.w	r1, r4, #4026531840	; 0xf0000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    56a2:	f00c 4270 	and.w	r2, ip, #4026531840	; 0xf0000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    56a6:	ea00 0503 	and.w	r5, r0, r3
    56aa:	f000 4770 	and.w	r7, r0, #4026531840	; 0xf0000000
    56ae:	401c      	ands	r4, r3
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    56b0:	ea0c 0603 	and.w	r6, ip, r3
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    56b4:	f101 7100 	add.w	r1, r1, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    56b8:	f102 7200 	add.w	r2, r2, #33554432	; 0x2000000
    56bc:	0173      	lsls	r3, r6, #5
    56be:	2000      	movs	r0, #0
    56c0:	f107 7600 	add.w	r6, r7, #33554432	; 0x2000000
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    56c4:	310c      	adds	r1, #12
    56c6:	0164      	lsls	r4, r4, #5
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    56c8:	3208      	adds	r2, #8
    56ca:	016d      	lsls	r5, r5, #5
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
    56cc:	2701      	movs	r7, #1
    56ce:	510f      	str	r7, [r1, r4]
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
    56d0:	50d0      	str	r0, [r2, r3]
    56d2:	5170      	str	r0, [r6, r5]
}
    56d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    56d6:	bf00      	nop

000056d8 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
    56d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    56da:	4604      	mov	r4, r0
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
    56dc:	f7ff fda0 	bl	5220 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    56e0:	6822      	ldr	r2, [r4, #0]
    56e2:	f64f 73ff 	movw	r3, #65535	; 0xffff

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
    56e6:	f102 0034 	add.w	r0, r2, #52	; 0x34

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
    56ea:	f102 0530 	add.w	r5, r2, #48	; 0x30
    56ee:	f2c0 030f 	movt	r3, #15
    56f2:	f005 4770 	and.w	r7, r5, #4026531840	; 0xf0000000

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
    56f6:	3238      	adds	r2, #56	; 0x38
    56f8:	f000 4170 	and.w	r1, r0, #4026531840	; 0xf0000000

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
    56fc:	ea02 0603 	and.w	r6, r2, r3
    5700:	f107 7c00 	add.w	ip, r7, #33554432	; 0x2000000
    5704:	401d      	ands	r5, r3
    5706:	ea00 0703 	and.w	r7, r0, r3
    570a:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
    570e:	f101 7100 	add.w	r1, r1, #33554432	; 0x2000000
    5712:	f245 1061 	movw	r0, #20833	; 0x5161
    5716:	017b      	lsls	r3, r7, #5
    5718:	f10c 0c0c 	add.w	ip, ip, #12
    571c:	f102 7700 	add.w	r7, r2, #33554432	; 0x2000000
    5720:	016d      	lsls	r5, r5, #5
    5722:	2200      	movs	r2, #0
    5724:	3108      	adds	r1, #8
    5726:	0176      	lsls	r6, r6, #5
    5728:	f2c0 0000 	movt	r0, #0
    572c:	f84c 2005 	str.w	r2, [ip, r5]
    5730:	6260      	str	r0, [r4, #36]	; 0x24
    5732:	50ca      	str	r2, [r1, r3]
    5734:	51ba      	str	r2, [r7, r6]
}
    5736:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00005738 <MSS_COMBLK_init>:
void MSS_COMBLK_init
(
    comblk_async_event_handler_t async_event_handler,
    uint8_t* p_response
)
{
    5738:	b470      	push	{r4, r5, r6}
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    
    g_async_event_handler = async_event_handler;
    573a:	f640 23d0 	movw	r3, #2768	; 0xad0

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    573e:	f24e 1500 	movw	r5, #57600	; 0xe100
{
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    5742:	f246 0400 	movw	r4, #24576	; 0x6000
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    
    g_async_event_handler = async_event_handler;
    5746:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    574a:	2200      	movs	r2, #0
    574c:	f2c4 0401 	movt	r4, #16385	; 0x4001
    5750:	f2ce 0500 	movt	r5, #57344	; 0xe000
    5754:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    5758:	f8c5 6080 	str.w	r6, [r5, #128]	; 0x80
    575c:	60a2      	str	r2, [r4, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    575e:	f8c5 6180 	str.w	r6, [r5, #384]	; 0x180
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    
    g_async_event_handler = async_event_handler;
    5762:	6018      	str	r0, [r3, #0]
    g_comblk_p_response = p_response;
    g_comblk_response_size = 0u;
    g_comblk_response_idx = 0u;
    g_comblk_completion_handler = 0;
    
    g_comblk_state = COMBLK_IDLE;
    5764:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    g_async_event_handler = async_event_handler;
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 0u;
    5768:	711a      	strb	r2, [r3, #4]
    g_comblk_cmd_opcode = 0u;
    576a:	715a      	strb	r2, [r3, #5]
    g_comblk_p_cmd = 0u;
    g_comblk_cmd_size = 0u;
    576c:	819a      	strh	r2, [r3, #12]
    g_comblk_p_data = 0u;
    g_comblk_data_size = 0u;
    576e:	615a      	str	r2, [r3, #20]
    g_comblk_p_response = p_response;
    g_comblk_response_size = 0u;
    g_comblk_response_idx = 0u;
    5770:	83da      	strh	r2, [r3, #30]
    /*
     * Disable loopback before enabling the MSS COMM_BLK to ensure that any
     * codes waiting in the TX FIFO of the System Controllers COMM_BLK are
     * not lost.
     */
    COMBLK->CONTROL &= ~CR_LOOPBACK_MASK;
    5772:	6820      	ldr	r0, [r4, #0]
    g_comblk_cmd_opcode = 0u;
    g_comblk_p_cmd = 0u;
    g_comblk_cmd_size = 0u;
    g_comblk_p_data = 0u;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    5774:	6199      	str	r1, [r3, #24]
    /*
     * Disable loopback before enabling the MSS COMM_BLK to ensure that any
     * codes waiting in the TX FIFO of the System Controllers COMM_BLK are
     * not lost.
     */
    COMBLK->CONTROL &= ~CR_LOOPBACK_MASK;
    5776:	f020 0120 	bic.w	r1, r0, #32
    577a:	6021      	str	r1, [r4, #0]
    COMBLK->CONTROL |= CR_ENABLE_MASK;
    577c:	6820      	ldr	r0, [r4, #0]
    g_comblk_p_data = 0u;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = 0u;
    g_comblk_response_idx = 0u;
    g_comblk_completion_handler = 0;
    577e:	621a      	str	r2, [r3, #32]
     * Disable loopback before enabling the MSS COMM_BLK to ensure that any
     * codes waiting in the TX FIFO of the System Controllers COMM_BLK are
     * not lost.
     */
    COMBLK->CONTROL &= ~CR_LOOPBACK_MASK;
    COMBLK->CONTROL |= CR_ENABLE_MASK;
    5780:	f040 0110 	orr.w	r1, r0, #16
    5784:	6021      	str	r1, [r4, #0]
    
    /*--------------------------------------------------------------------------
     * Enable receive interrupt to receive asynchronous events from the system
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5786:	68a0      	ldr	r0, [r4, #8]
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 0u;
    g_comblk_cmd_opcode = 0u;
    g_comblk_p_cmd = 0u;
    5788:	609a      	str	r2, [r3, #8]
    
    /*--------------------------------------------------------------------------
     * Enable receive interrupt to receive asynchronous events from the system
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    578a:	f020 0101 	bic.w	r1, r0, #1
    578e:	60a1      	str	r1, [r4, #8]
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    5790:	68a0      	ldr	r0, [r4, #8]
     */
    g_request_in_progress = 0u;
    g_comblk_cmd_opcode = 0u;
    g_comblk_p_cmd = 0u;
    g_comblk_cmd_size = 0u;
    g_comblk_p_data = 0u;
    5792:	611a      	str	r2, [r3, #16]
    /*--------------------------------------------------------------------------
     * Enable receive interrupt to receive asynchronous events from the system
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    5794:	f040 0102 	orr.w	r1, r0, #2
    5798:	60a1      	str	r1, [r4, #8]
    g_comblk_p_cmd = 0u;
    g_comblk_cmd_size = 0u;
    g_comblk_p_data = 0u;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = 0u;
    579a:	839a      	strh	r2, [r3, #28]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    579c:	602e      	str	r6, [r5, #0]
     * controller.
     */
    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    NVIC_EnableIRQ(ComBlk_IRQn);
}
    579e:	bc70      	pop	{r4, r5, r6}
    57a0:	4770      	bx	lr
    57a2:	bf00      	nop

000057a4 <complete_request>:
 */
static void complete_request
(
    uint16_t response_length
)
{
    57a4:	b510      	push	{r4, lr}
    if(g_comblk_completion_handler != 0)
    57a6:	f640 24d0 	movw	r4, #2768	; 0xad0
    57aa:	f2c2 0400 	movt	r4, #8192	; 0x2000
    57ae:	6a23      	ldr	r3, [r4, #32]
    57b0:	b12b      	cbz	r3, 57be <complete_request+0x1a>
    {
        g_comblk_completion_handler(g_comblk_p_response, response_length);
    57b2:	4601      	mov	r1, r0
    57b4:	69a0      	ldr	r0, [r4, #24]
    57b6:	4798      	blx	r3
        g_comblk_completion_handler = 0;
    57b8:	2300      	movs	r3, #0
        g_request_in_progress = 0u;
    57ba:	7123      	strb	r3, [r4, #4]
)
{
    if(g_comblk_completion_handler != 0)
    {
        g_comblk_completion_handler(g_comblk_p_response, response_length);
        g_comblk_completion_handler = 0;
    57bc:	6223      	str	r3, [r4, #32]
    57be:	bd10      	pop	{r4, pc}

000057c0 <abort_current_cmd>:

/*==============================================================================
 *
 */
static void abort_current_cmd(void)
{
    57c0:	b508      	push	{r3, lr}
    if(g_request_in_progress)
    57c2:	f640 23d0 	movw	r3, #2768	; 0xad0
    57c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    57ca:	791a      	ldrb	r2, [r3, #4]
    57cc:	b902      	cbnz	r2, 57d0 <abort_current_cmd+0x10>
    57ce:	bd08      	pop	{r3, pc}
        
        /*
         * Call completion handler just in case we are in a multi threaded system
         * to avoid a task lockup.
         */
        complete_request(g_comblk_response_idx);
    57d0:	f8b3 c01e 	ldrh.w	ip, [r3, #30]
    57d4:	fa1f f08c 	uxth.w	r0, ip
    57d8:	f7ff ffe4 	bl	57a4 <complete_request>
        
        /*
         * Flush the FIFOs
         */
        COMBLK->CONTROL |= CR_FLUSHOUT_MASK;
    57dc:	f246 0300 	movw	r3, #24576	; 0x6000
    57e0:	f2c4 0301 	movt	r3, #16385	; 0x4001
    57e4:	6818      	ldr	r0, [r3, #0]
        do {
            flush_in_progress = COMBLK->CONTROL & CR_FLUSHOUT_MASK;
    57e6:	461a      	mov	r2, r3
        complete_request(g_comblk_response_idx);
        
        /*
         * Flush the FIFOs
         */
        COMBLK->CONTROL |= CR_FLUSHOUT_MASK;
    57e8:	f040 0101 	orr.w	r1, r0, #1
    57ec:	6019      	str	r1, [r3, #0]
        do {
            flush_in_progress = COMBLK->CONTROL & CR_FLUSHOUT_MASK;
    57ee:	6811      	ldr	r1, [r2, #0]
        } while(flush_in_progress);
    57f0:	f011 0f01 	tst.w	r1, #1
    57f4:	d1fb      	bne.n	57ee <abort_current_cmd+0x2e>
    57f6:	bd08      	pop	{r3, pc}

000057f8 <MSS_COMBLK_send_cmd_with_ptr>:
    uint32_t cmd_params_ptr,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
    57f8:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    57fc:	f24e 1600 	movw	r6, #57600	; 0xe100
    
    /*--------------------------------------------------------------------------
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    5800:	f246 0500 	movw	r5, #24576	; 0x6000
    5804:	2400      	movs	r4, #0
    5806:	f2c4 0501 	movt	r5, #16385	; 0x4001
    580a:	f2ce 0600 	movt	r6, #57344	; 0xe000
    580e:	f44f 2700 	mov.w	r7, #524288	; 0x80000
    5812:	f8c6 7080 	str.w	r7, [r6, #128]	; 0x80
    5816:	60ac      	str	r4, [r5, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    5818:	f8c6 7180 	str.w	r7, [r6, #384]	; 0x180
    uint32_t cmd_params_ptr,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
    581c:	4698      	mov	r8, r3
    581e:	4606      	mov	r6, r0
    5820:	4617      	mov	r7, r2
    5822:	468a      	mov	sl, r1
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    
    /*--------------------------------------------------------------------------
     * Abort current command if any.
     */
    abort_current_cmd();
    5824:	f7ff ffcc 	bl	57c0 <abort_current_cmd>
    
    /*--------------------------------------------------------------------------
     * Initialize COMBLK driver state variables.
     */
    g_request_in_progress = 1u;
    5828:	f640 22d0 	movw	r2, #2768	; 0xad0
    582c:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5830:	2101      	movs	r1, #1
    5832:	7111      	strb	r1, [r2, #4]
    g_comblk_cmd_opcode = cmd_opcode;
    5834:	7156      	strb	r6, [r2, #5]
    g_comblk_p_cmd = 0u;
    g_comblk_cmd_size = 0u;
    5836:	8194      	strh	r4, [r2, #12]
    g_comblk_p_data = 0u;
    g_comblk_data_size = 0u;
    5838:	6154      	str	r4, [r2, #20]
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    583a:	83d4      	strh	r4, [r2, #30]
    g_comblk_completion_handler = completion_handler;
    
    /*--------------------------------------------------------------------------
     * Send command opcode as a single byte write to the Tx FIFO.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
    583c:	7951      	ldrb	r1, [r2, #5]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    583e:	682b      	ldr	r3, [r5, #0]
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = 0u;
    g_comblk_completion_handler = completion_handler;
    5840:	9808      	ldr	r0, [sp, #32]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5842:	f023 0304 	bic.w	r3, r3, #4
    g_comblk_cmd_opcode = cmd_opcode;
    g_comblk_p_cmd = 0u;
    g_comblk_cmd_size = 0u;
    g_comblk_p_data = 0u;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    5846:	6197      	str	r7, [r2, #24]
    g_comblk_response_size = response_size;
    5848:	f8a2 801c 	strh.w	r8, [r2, #28]
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = 0u;
    584c:	6294      	str	r4, [r2, #40]	; 0x28
    g_comblk_completion_handler = completion_handler;
    584e:	6210      	str	r0, [r2, #32]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5850:	602b      	str	r3, [r5, #0]
    /*--------------------------------------------------------------------------
     * Initialize COMBLK driver state variables.
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = cmd_opcode;
    g_comblk_p_cmd = 0u;
    5852:	6094      	str	r4, [r2, #8]
    g_comblk_cmd_size = 0u;
    g_comblk_p_data = 0u;
    5854:	6114      	str	r4, [r2, #16]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5856:	686c      	ldr	r4, [r5, #4]
    5858:	f246 0300 	movw	r3, #24576	; 0x6000
    } while(0u == tx_okay);
    585c:	f014 0f01 	tst.w	r4, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5860:	f2c4 0301 	movt	r3, #16385	; 0x4001
    } while(0u == tx_okay);
    5864:	d0f7      	beq.n	5856 <MSS_COMBLK_send_cmd_with_ptr+0x5e>
    
    /* Send command opcode. */
    COMBLK->FRAME_START8 = opcode;
    5866:	6199      	str	r1, [r3, #24]
    
    /*--------------------------------------------------------------------------
     * Send the command parameters pointer to the Tx FIFO as a single 4 bytes
     * write to the Tx FIFO.
     */
    COMBLK->CONTROL |= CR_SIZETX_MASK;
    5868:	6819      	ldr	r1, [r3, #0]
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    586a:	461c      	mov	r4, r3
    
    /*--------------------------------------------------------------------------
     * Send the command parameters pointer to the Tx FIFO as a single 4 bytes
     * write to the Tx FIFO.
     */
    COMBLK->CONTROL |= CR_SIZETX_MASK;
    586c:	f041 0004 	orr.w	r0, r1, #4
    5870:	6018      	str	r0, [r3, #0]
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5872:	6860      	ldr	r0, [r4, #4]
    5874:	f246 0300 	movw	r3, #24576	; 0x6000
    } while(0u == tx_okay);
    5878:	f010 0f01 	tst.w	r0, #1
     */
    COMBLK->CONTROL |= CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    587c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    } while(0u == tx_okay);
    5880:	d0f7      	beq.n	5872 <MSS_COMBLK_send_cmd_with_ptr+0x7a>
    
    /* Send command opcode. */
    COMBLK->DATA32 = cmd_params_ptr;
    5882:	f8c3 a014 	str.w	sl, [r3, #20]
    
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5886:	6819      	ldr	r1, [r3, #0]
    5888:	f021 0004 	bic.w	r0, r1, #4
    
    g_comblk_state = COMBLK_WAIT_RESPONSE;
    588c:	2103      	movs	r1, #3
    } while(0u == tx_okay);
    
    /* Send command opcode. */
    COMBLK->DATA32 = cmd_params_ptr;
    
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    588e:	6018      	str	r0, [r3, #0]
    
    g_comblk_state = COMBLK_WAIT_RESPONSE;
    5890:	f882 1024 	strb.w	r1, [r2, #36]	; 0x24
    
    /*--------------------------------------------------------------------------
     * Enable interrupt.
     */
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    5894:	6898      	ldr	r0, [r3, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    5896:	f24e 1200 	movw	r2, #57600	; 0xe100
    589a:	f040 0102 	orr.w	r1, r0, #2
    589e:	6099      	str	r1, [r3, #8]
    58a0:	f2ce 0200 	movt	r2, #57344	; 0xe000
    58a4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
    58a8:	6013      	str	r3, [r2, #0]
    NVIC_EnableIRQ(ComBlk_IRQn);
}
    58aa:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
    58ae:	bf00      	nop

000058b0 <MSS_COMBLK_send_paged_cmd>:
    uint8_t * p_response,
    uint16_t response_size,
    comblk_page_handler_t page_read_handler,
    comblk_completion_handler_t completion_handler
)
{
    58b0:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    58b4:	f24e 1600 	movw	r6, #57600	; 0xe100
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    58b8:	f246 0400 	movw	r4, #24576	; 0x6000
    58bc:	2500      	movs	r5, #0
    58be:	f2c4 0401 	movt	r4, #16385	; 0x4001
    58c2:	f2ce 0600 	movt	r6, #57344	; 0xe000
    58c6:	f44f 2700 	mov.w	r7, #524288	; 0x80000
    58ca:	f8c6 7080 	str.w	r7, [r6, #128]	; 0x80
    uint8_t * p_response,
    uint16_t response_size,
    comblk_page_handler_t page_read_handler,
    comblk_completion_handler_t completion_handler
)
{
    58ce:	b083      	sub	sp, #12
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    58d0:	60a5      	str	r5, [r4, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    58d2:	f8c6 7180 	str.w	r7, [r6, #384]	; 0x180
    uint8_t * p_response,
    uint16_t response_size,
    comblk_page_handler_t page_read_handler,
    comblk_completion_handler_t completion_handler
)
{
    58d6:	4690      	mov	r8, r2
    58d8:	4606      	mov	r6, r0
    58da:	460f      	mov	r7, r1
    58dc:	469a      	mov	sl, r3
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    
    /*
     * Abort current command if any.
     */
    abort_current_cmd();
    58de:	f7ff ff6f 	bl	57c0 <abort_current_cmd>
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
    58e2:	f640 21d0 	movw	r1, #2768	; 0xad0
    58e6:	f2c2 0100 	movt	r1, #8192	; 0x2000
    58ea:	2301      	movs	r3, #1
    58ec:	710b      	strb	r3, [r1, #4]
    g_comblk_cmd_opcode = p_cmd[0];
    58ee:	f896 c000 	ldrb.w	ip, [r6]
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    g_comblk_p_data = 0;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    58f2:	f8c1 8018 	str.w	r8, [r1, #24]
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = p_cmd[0];
    58f6:	f881 c005 	strb.w	ip, [r1, #5]
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    58fa:	818f      	strh	r7, [r1, #12]
    g_comblk_p_data = 0;
    g_comblk_data_size = 0u;
    58fc:	614d      	str	r5, [r1, #20]
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    58fe:	83cd      	strh	r5, [r1, #30]
    g_comblk_completion_handler = completion_handler;
    
    /*
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
    5900:	7948      	ldrb	r0, [r1, #5]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5902:	6822      	ldr	r2, [r4, #0]
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    g_comblk_p_data = 0;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    5904:	f8a1 a01c 	strh.w	sl, [r1, #28]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5908:	f022 0304 	bic.w	r3, r2, #4
    g_comblk_p_data = 0;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = page_read_handler;
    590c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    590e:	6023      	str	r3, [r4, #0]
    g_comblk_p_data = 0;
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = page_read_handler;
    5910:	628a      	str	r2, [r1, #40]	; 0x28
    g_comblk_completion_handler = completion_handler;
    5912:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = p_cmd[0];
    g_comblk_p_cmd = p_cmd;
    5914:	608e      	str	r6, [r1, #8]
    g_comblk_data_size = 0u;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = page_read_handler;
    g_comblk_completion_handler = completion_handler;
    5916:	620a      	str	r2, [r1, #32]
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = p_cmd[0];
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    g_comblk_p_data = 0;
    5918:	610d      	str	r5, [r1, #16]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    591a:	6862      	ldr	r2, [r4, #4]
    591c:	f246 0300 	movw	r3, #24576	; 0x6000
    } while(0u == tx_okay);
    5920:	f012 0f01 	tst.w	r2, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5924:	f2c4 0301 	movt	r3, #16385	; 0x4001
    } while(0u == tx_okay);
    5928:	d0f7      	beq.n	591a <MSS_COMBLK_send_paged_cmd+0x6a>
    
    /* Send command opcode. */
    COMBLK->FRAME_START8 = opcode;
    592a:	6198      	str	r0, [r3, #24]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    592c:	6818      	ldr	r0, [r3, #0]
    592e:	f020 0204 	bic.w	r2, r0, #4
    5932:	601a      	str	r2, [r3, #0]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5934:	6858      	ldr	r0, [r3, #4]
    5936:	f000 0201 	and.w	r2, r0, #1
    593a:	9201      	str	r2, [sp, #4]
    while((tx_okay != 0u) && (size_sent < cmd_size))
    593c:	9801      	ldr	r0, [sp, #4]
    593e:	2800      	cmp	r0, #0
    5940:	d056      	beq.n	59f0 <MSS_COMBLK_send_paged_cmd+0x140>
    5942:	f1b7 0c01 	subs.w	ip, r7, #1
    5946:	d053      	beq.n	59f0 <MSS_COMBLK_send_paged_cmd+0x140>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5948:	7870      	ldrb	r0, [r6, #1]
    594a:	461a      	mov	r2, r3
    594c:	6118      	str	r0, [r3, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    594e:	685b      	ldr	r3, [r3, #4]
    5950:	f10c 3eff 	add.w	lr, ip, #4294967295
    5954:	f003 0401 	and.w	r4, r3, #1
    5958:	9401      	str	r4, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    595a:	9801      	ldr	r0, [sp, #4]
    595c:	f00e 0401 	and.w	r4, lr, #1
    {
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
    5960:	2301      	movs	r3, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5962:	b1e8      	cbz	r0, 59a0 <MSS_COMBLK_send_paged_cmd+0xf0>
    5964:	f1bc 0f01 	cmp.w	ip, #1
    5968:	d91a      	bls.n	59a0 <MSS_COMBLK_send_paged_cmd+0xf0>
    596a:	b124      	cbz	r4, 5976 <MSS_COMBLK_send_paged_cmd+0xc6>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    596c:	78b0      	ldrb	r0, [r6, #2]
        ++size_sent;
    596e:	2302      	movs	r3, #2
    5970:	e00e      	b.n	5990 <MSS_COMBLK_send_paged_cmd+0xe0>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5972:	459c      	cmp	ip, r3
    5974:	d914      	bls.n	59a0 <MSS_COMBLK_send_paged_cmd+0xf0>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5976:	18f4      	adds	r4, r6, r3
    5978:	7860      	ldrb	r0, [r4, #1]
        ++size_sent;
    597a:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    597c:	6110      	str	r0, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    597e:	6850      	ldr	r0, [r2, #4]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5980:	18f4      	adds	r4, r6, r3
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5982:	f000 0001 	and.w	r0, r0, #1
    5986:	9001      	str	r0, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5988:	9801      	ldr	r0, [sp, #4]
    598a:	b148      	cbz	r0, 59a0 <MSS_COMBLK_send_paged_cmd+0xf0>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    598c:	7860      	ldrb	r0, [r4, #1]
        ++size_sent;
    598e:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5990:	6110      	str	r0, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5992:	6850      	ldr	r0, [r2, #4]
    5994:	f000 0001 	and.w	r0, r0, #1
    5998:	9001      	str	r0, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    599a:	9801      	ldr	r0, [sp, #4]
    599c:	2800      	cmp	r0, #0
    599e:	d1e8      	bne.n	5972 <MSS_COMBLK_send_paged_cmd+0xc2>
    59a0:	3301      	adds	r3, #1
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    59a2:	429f      	cmp	r7, r3
    59a4:	d818      	bhi.n	59d8 <MSS_COMBLK_send_paged_cmd+0x128>
        irq_enable = TXTOKAY_MASK | RCVOKAY_MASK;
    }
    else
    {
        g_comblk_cmd_size = 0u;
        g_comblk_state = COMBLK_TX_PAGED_DATA;
    59a6:	2205      	movs	r2, #5
        g_comblk_state = COMBLK_TX_CMD;
        irq_enable = TXTOKAY_MASK | RCVOKAY_MASK;
    }
    else
    {
        g_comblk_cmd_size = 0u;
    59a8:	f04f 0e00 	mov.w	lr, #0
        g_comblk_state = COMBLK_TX_PAGED_DATA;
    59ac:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
        g_comblk_state = COMBLK_TX_CMD;
        irq_enable = TXTOKAY_MASK | RCVOKAY_MASK;
    }
    else
    {
        g_comblk_cmd_size = 0u;
    59b0:	f8a1 e00c 	strh.w	lr, [r1, #12]
    }

    /*
     * Enable interrupt.
     */
    COMBLK->INT_ENABLE |= irq_enable;
    59b4:	f246 0300 	movw	r3, #24576	; 0x6000
    59b8:	f2c4 0301 	movt	r3, #16385	; 0x4001
    59bc:	6899      	ldr	r1, [r3, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    59be:	f24e 1000 	movw	r0, #57600	; 0xe100
    59c2:	f041 0203 	orr.w	r2, r1, #3
    59c6:	f2ce 0000 	movt	r0, #57344	; 0xe000
    59ca:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    59ce:	609a      	str	r2, [r3, #8]
    59d0:	6001      	str	r1, [r0, #0]
    NVIC_EnableIRQ(ComBlk_IRQn);
}
    59d2:	b003      	add	sp, #12
    59d4:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    59d8:	8988      	ldrh	r0, [r1, #12]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    59da:	18f6      	adds	r6, r6, r3
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    59dc:	1ac3      	subs	r3, r0, r3
    59de:	fa1f fc83 	uxth.w	ip, r3
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
        
        g_comblk_state = COMBLK_TX_CMD;
    59e2:	2201      	movs	r2, #1
    59e4:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    59e8:	f8a1 c00c 	strh.w	ip, [r1, #12]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    59ec:	608e      	str	r6, [r1, #8]
    59ee:	e7e1      	b.n	59b4 <MSS_COMBLK_send_paged_cmd+0x104>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    59f0:	2301      	movs	r3, #1
    59f2:	e7d6      	b.n	59a2 <MSS_COMBLK_send_paged_cmd+0xf2>

000059f4 <MSS_COMBLK_send_cmd>:
    uint32_t data_size,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
    59f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    59f8:	f24e 1600 	movw	r6, #57600	; 0xe100
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    59fc:	f246 0400 	movw	r4, #24576	; 0x6000
    5a00:	f2c4 0401 	movt	r4, #16385	; 0x4001
    5a04:	f2ce 0600 	movt	r6, #57344	; 0xe000
    5a08:	2500      	movs	r5, #0
    5a0a:	f44f 2700 	mov.w	r7, #524288	; 0x80000
    5a0e:	f8c6 7080 	str.w	r7, [r6, #128]	; 0x80
    uint32_t data_size,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
    5a12:	b082      	sub	sp, #8
    
    /*
     * Disable and clear previous interrupts.
     */
    NVIC_DisableIRQ(ComBlk_IRQn);
    COMBLK->INT_ENABLE = 0u;
    5a14:	60a5      	str	r5, [r4, #8]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    5a16:	f8c6 7180 	str.w	r7, [r6, #384]	; 0x180
    uint32_t data_size,
    uint8_t * p_response,
    uint16_t response_size,
    comblk_completion_handler_t completion_handler
)
{
    5a1a:	4690      	mov	r8, r2
    5a1c:	4606      	mov	r6, r0
    5a1e:	460f      	mov	r7, r1
    5a20:	4699      	mov	r9, r3
    5a22:	f8bd a02c 	ldrh.w	sl, [sp, #44]	; 0x2c
    NVIC_ClearPendingIRQ(ComBlk_IRQn);
    
    /*
     * Abort current command if any.
     */
    abort_current_cmd();
    5a26:	f7ff fecb 	bl	57c0 <abort_current_cmd>
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
    5a2a:	f640 21d0 	movw	r1, #2768	; 0xad0
    5a2e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    5a32:	2301      	movs	r3, #1
    5a34:	710b      	strb	r3, [r1, #4]
    g_comblk_cmd_opcode = p_cmd[0];
    5a36:	7830      	ldrb	r0, [r6, #0]
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    g_comblk_p_data = p_data;
    g_comblk_data_size = data_size;
    g_comblk_p_response = p_response;
    5a38:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = p_cmd[0];
    5a3a:	7148      	strb	r0, [r1, #5]
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    5a3c:	818f      	strh	r7, [r1, #12]
    g_comblk_p_data = p_data;
    g_comblk_data_size = data_size;
    5a3e:	f8c1 9014 	str.w	r9, [r1, #20]
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    5a42:	83cd      	strh	r5, [r1, #30]
    g_comblk_page_handler = 0u;
    g_comblk_completion_handler = completion_handler;
    
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    5a44:	68a3      	ldr	r3, [r4, #8]
    g_comblk_cmd_opcode = p_cmd[0];
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    g_comblk_p_data = p_data;
    g_comblk_data_size = data_size;
    g_comblk_p_response = p_response;
    5a46:	618a      	str	r2, [r1, #24]
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = 0u;
    g_comblk_completion_handler = completion_handler;
    
    COMBLK->INT_ENABLE |= RCVOKAY_MASK;
    5a48:	f043 0002 	orr.w	r0, r3, #2
    5a4c:	60a0      	str	r0, [r4, #8]

    /*
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
    5a4e:	7948      	ldrb	r0, [r1, #5]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5a50:	6823      	ldr	r3, [r4, #0]
    g_comblk_data_size = data_size;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = 0u;
    g_comblk_completion_handler = completion_handler;
    5a52:	9a0c      	ldr	r2, [sp, #48]	; 0x30
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5a54:	f023 0304 	bic.w	r3, r3, #4
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = p_cmd[0];
    g_comblk_p_cmd = p_cmd;
    g_comblk_cmd_size = cmd_size;
    g_comblk_p_data = p_data;
    5a58:	f8c1 8010 	str.w	r8, [r1, #16]
    g_comblk_data_size = data_size;
    g_comblk_p_response = p_response;
    g_comblk_response_size = response_size;
    5a5c:	f8a1 a01c 	strh.w	sl, [r1, #28]
    g_comblk_response_idx = 0u;
    g_comblk_page_handler = 0u;
    5a60:	628d      	str	r5, [r1, #40]	; 0x28
    g_comblk_completion_handler = completion_handler;
    5a62:	620a      	str	r2, [r1, #32]
)
{
    uint32_t tx_okay;
    
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5a64:	6023      	str	r3, [r4, #0]
    /*
     * Initialize COMBLK driver state variables:
     */
    g_request_in_progress = 1u;
    g_comblk_cmd_opcode = p_cmd[0];
    g_comblk_p_cmd = p_cmd;
    5a66:	608e      	str	r6, [r1, #8]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5a68:	6862      	ldr	r2, [r4, #4]
    5a6a:	f246 0300 	movw	r3, #24576	; 0x6000
    } while(0u == tx_okay);
    5a6e:	f012 0f01 	tst.w	r2, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    /* Wait for space to become available in Tx FIFO. */
    do {
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5a72:	f2c4 0301 	movt	r3, #16385	; 0x4001
    } while(0u == tx_okay);
    5a76:	d0f7      	beq.n	5a68 <MSS_COMBLK_send_cmd+0x74>
    
    /* Send command opcode. */
    COMBLK->FRAME_START8 = opcode;
    5a78:	6198      	str	r0, [r3, #24]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5a7a:	6818      	ldr	r0, [r3, #0]
    5a7c:	f020 0204 	bic.w	r2, r0, #4
    5a80:	601a      	str	r2, [r3, #0]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5a82:	6858      	ldr	r0, [r3, #4]
    5a84:	f000 0201 	and.w	r2, r0, #1
    5a88:	9201      	str	r2, [sp, #4]
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5a8a:	9801      	ldr	r0, [sp, #4]
    5a8c:	2800      	cmp	r0, #0
    5a8e:	d058      	beq.n	5b42 <MSS_COMBLK_send_cmd+0x14e>
    5a90:	f1b7 0c01 	subs.w	ip, r7, #1
    5a94:	d055      	beq.n	5b42 <MSS_COMBLK_send_cmd+0x14e>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5a96:	7870      	ldrb	r0, [r6, #1]
    5a98:	461a      	mov	r2, r3
    5a9a:	6118      	str	r0, [r3, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5a9c:	685b      	ldr	r3, [r3, #4]
    5a9e:	f10c 3eff 	add.w	lr, ip, #4294967295
    5aa2:	f003 0401 	and.w	r4, r3, #1
    5aa6:	9401      	str	r4, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5aa8:	9801      	ldr	r0, [sp, #4]
    5aaa:	f00e 0401 	and.w	r4, lr, #1
    {
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
    5aae:	2301      	movs	r3, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5ab0:	b1e8      	cbz	r0, 5aee <MSS_COMBLK_send_cmd+0xfa>
    5ab2:	f1bc 0f01 	cmp.w	ip, #1
    5ab6:	d91a      	bls.n	5aee <MSS_COMBLK_send_cmd+0xfa>
    5ab8:	b124      	cbz	r4, 5ac4 <MSS_COMBLK_send_cmd+0xd0>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5aba:	78b0      	ldrb	r0, [r6, #2]
        ++size_sent;
    5abc:	2302      	movs	r3, #2
    5abe:	e00e      	b.n	5ade <MSS_COMBLK_send_cmd+0xea>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5ac0:	459c      	cmp	ip, r3
    5ac2:	d914      	bls.n	5aee <MSS_COMBLK_send_cmd+0xfa>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5ac4:	18f4      	adds	r4, r6, r3
    5ac6:	7860      	ldrb	r0, [r4, #1]
        ++size_sent;
    5ac8:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5aca:	6110      	str	r0, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5acc:	6850      	ldr	r0, [r2, #4]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5ace:	18f4      	adds	r4, r6, r3
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5ad0:	f000 0001 	and.w	r0, r0, #1
    5ad4:	9001      	str	r0, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5ad6:	9801      	ldr	r0, [sp, #4]
    5ad8:	b148      	cbz	r0, 5aee <MSS_COMBLK_send_cmd+0xfa>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5ada:	7860      	ldrb	r0, [r4, #1]
        ++size_sent;
    5adc:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5ade:	6110      	str	r0, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5ae0:	6850      	ldr	r0, [r2, #4]
    5ae2:	f000 0001 	and.w	r0, r0, #1
    5ae6:	9001      	str	r0, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5ae8:	9801      	ldr	r0, [sp, #4]
    5aea:	2800      	cmp	r0, #0
    5aec:	d1e8      	bne.n	5ac0 <MSS_COMBLK_send_cmd+0xcc>
    5aee:	3301      	adds	r3, #1
     * Fill FIFO with command.
     */
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    5af0:	429f      	cmp	r7, r3
    5af2:	d81a      	bhi.n	5b2a <MSS_COMBLK_send_cmd+0x136>
        
        g_comblk_state = COMBLK_TX_CMD;
    }
    else
    {
        g_comblk_cmd_size = 0u;
    5af4:	f04f 0e00 	mov.w	lr, #0
    5af8:	f8a1 e00c 	strh.w	lr, [r1, #12]
        if(g_comblk_data_size > 0u)
    5afc:	694a      	ldr	r2, [r1, #20]
        
        g_comblk_state = COMBLK_TX_CMD;
    }
    else
    {
        g_comblk_cmd_size = 0u;
    5afe:	f640 23d0 	movw	r3, #2768	; 0xad0
    5b02:	f2c2 0300 	movt	r3, #8192	; 0x2000
        if(g_comblk_data_size > 0u)
    5b06:	b962      	cbnz	r2, 5b22 <MSS_COMBLK_send_cmd+0x12e>
        {
            g_comblk_state = COMBLK_TX_DATA;
        }
        else
        {
            g_comblk_state = COMBLK_WAIT_RESPONSE;
    5b08:	2003      	movs	r0, #3
    5b0a:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    5b0e:	f24e 1300 	movw	r3, #57600	; 0xe100
    5b12:	f2ce 0300 	movt	r3, #57344	; 0xe000
    5b16:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    5b1a:	601a      	str	r2, [r3, #0]

    /*
     * Enable interrupt.
     */
    NVIC_EnableIRQ(ComBlk_IRQn);
}
    5b1c:	b002      	add	sp, #8
    5b1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else
    {
        g_comblk_cmd_size = 0u;
        if(g_comblk_data_size > 0u)
        {
            g_comblk_state = COMBLK_TX_DATA;
    5b22:	2102      	movs	r1, #2
    5b24:	f883 1024 	strb.w	r1, [r3, #36]	; 0x24
    5b28:	e7f1      	b.n	5b0e <MSS_COMBLK_send_cmd+0x11a>
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    5b2a:	8988      	ldrh	r0, [r1, #12]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    5b2c:	18f6      	adds	r6, r6, r3
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    5b2e:	1ac3      	subs	r3, r0, r3
    5b30:	fa1f fc83 	uxth.w	ip, r3
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
        
        g_comblk_state = COMBLK_TX_CMD;
    5b34:	2201      	movs	r2, #1
    5b36:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
    send_cmd_opcode(g_comblk_cmd_opcode);
    size_sent = fill_tx_fifo(&p_cmd[1], cmd_size - 1u);
    ++size_sent;    /* Adjust for opcode byte sent. */
    if(size_sent < cmd_size)
    {
        g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    5b3a:	f8a1 c00c 	strh.w	ip, [r1, #12]
        g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    5b3e:	608e      	str	r6, [r1, #8]
    5b40:	e7e5      	b.n	5b0e <MSS_COMBLK_send_cmd+0x11a>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5b42:	2301      	movs	r3, #1
    5b44:	e7d4      	b.n	5af0 <MSS_COMBLK_send_cmd+0xfc>
    5b46:	bf00      	nop

00005b48 <process_sys_ctrl_command>:

/*==============================================================================
 *
 */
static void process_sys_ctrl_command(uint8_t cmd_opcode)
{
    5b48:	b508      	push	{r3, lr}
    if(g_async_event_handler != 0)
    5b4a:	f640 23d0 	movw	r3, #2768	; 0xad0
    5b4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5b52:	681a      	ldr	r2, [r3, #0]
    5b54:	b10a      	cbz	r2, 5b5a <process_sys_ctrl_command+0x12>
    {
        g_async_event_handler(cmd_opcode);
    5b56:	681b      	ldr	r3, [r3, #0]
    5b58:	4798      	blx	r3
    5b5a:	bd08      	pop	{r3, pc}

00005b5c <ComBlk_IRQHandler>:
{
    uint8_t status;
    uint8_t tx_okay;
    uint8_t rcv_okay;
    
    status = (uint8_t)COMBLK->STATUS;
    5b5c:	f246 0300 	movw	r3, #24576	; 0x6000
    5b60:	f2c4 0301 	movt	r3, #16385	; 0x4001

/*==============================================================================
 * COMBLK interrupt handler.
 */
void ComBlk_IRQHandler(void)
{
    5b64:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t status;
    uint8_t tx_okay;
    uint8_t rcv_okay;
    
    status = (uint8_t)COMBLK->STATUS;
    5b66:	685c      	ldr	r4, [r3, #4]
    
    /* Mask off interrupt that are not enabled.*/
    status &= COMBLK->INT_ENABLE;
    5b68:	689a      	ldr	r2, [r3, #8]
{
    uint8_t status;
    uint8_t tx_okay;
    uint8_t rcv_okay;
    
    status = (uint8_t)COMBLK->STATUS;
    5b6a:	b2e4      	uxtb	r4, r4
    
    /* Mask off interrupt that are not enabled.*/
    status &= COMBLK->INT_ENABLE;
    5b6c:	4014      	ands	r4, r2
    
    rcv_okay = status & RCVOKAY_MASK;
    
    if(rcv_okay)
    5b6e:	f014 0f02 	tst.w	r4, #2

/*==============================================================================
 * COMBLK interrupt handler.
 */
void ComBlk_IRQHandler(void)
{
    5b72:	b083      	sub	sp, #12
    /* Mask off interrupt that are not enabled.*/
    status &= COMBLK->INT_ENABLE;
    
    rcv_okay = status & RCVOKAY_MASK;
    
    if(rcv_okay)
    5b74:	d120      	bne.n	5bb8 <ComBlk_IRQHandler+0x5c>
    {
        handle_rx_okay_irq();
    }
        
    tx_okay = status & TXTOKAY_MASK;
    if(tx_okay)
    5b76:	f014 0f01 	tst.w	r4, #1
    5b7a:	d101      	bne.n	5b80 <ComBlk_IRQHandler+0x24>
    {
        handle_tx_okay_irq();
    }
}
    5b7c:	b003      	add	sp, #12
    5b7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
/*==============================================================================
 *
 */
static void handle_tx_okay_irq(void)
{
    switch(g_comblk_state)
    5b80:	f640 24d0 	movw	r4, #2768	; 0xad0
    5b84:	f2c2 0400 	movt	r4, #8192	; 0x2000
    5b88:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
    5b8c:	2902      	cmp	r1, #2
    5b8e:	d077      	beq.n	5c80 <ComBlk_IRQHandler+0x124>
    5b90:	2905      	cmp	r1, #5
    5b92:	d027      	beq.n	5be4 <ComBlk_IRQHandler+0x88>
    5b94:	2901      	cmp	r1, #1
    5b96:	f000 80c8 	beq.w	5d2a <ComBlk_IRQHandler+0x1ce>
        case COMBLK_WAIT_RESPONSE:
            /* Fall through */
        case COMBLK_RX_RESPONSE:
            /* Fall through */
        default:
            COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5b9a:	f246 0300 	movw	r3, #24576	; 0x6000
    5b9e:	f2c4 0301 	movt	r3, #16385	; 0x4001
    5ba2:	689a      	ldr	r2, [r3, #8]
            complete_request(0u);
    5ba4:	2000      	movs	r0, #0
        case COMBLK_WAIT_RESPONSE:
            /* Fall through */
        case COMBLK_RX_RESPONSE:
            /* Fall through */
        default:
            COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5ba6:	f022 0101 	bic.w	r1, r2, #1
    5baa:	6099      	str	r1, [r3, #8]
            complete_request(0u);
    5bac:	f7ff fdfa 	bl	57a4 <complete_request>
            g_comblk_state = COMBLK_IDLE;
    5bb0:	2000      	movs	r0, #0
    5bb2:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
    5bb6:	e7e1      	b.n	5b7c <ComBlk_IRQHandler+0x20>
    
    data16 = (uint16_t)COMBLK->DATA8;
    is_command = data16 & DATA8_COMMAND_MASK;
    data8 = (uint8_t)data16;
            
    switch(g_comblk_state)
    5bb8:	f640 25d0 	movw	r5, #2768	; 0xad0
{
    uint16_t data16;
    uint16_t is_command;
    uint8_t data8;
    
    data16 = (uint16_t)COMBLK->DATA8;
    5bbc:	6919      	ldr	r1, [r3, #16]
    is_command = data16 & DATA8_COMMAND_MASK;
    data8 = (uint8_t)data16;
            
    switch(g_comblk_state)
    5bbe:	f2c2 0500 	movt	r5, #8192	; 0x2000
    5bc2:	f895 0024 	ldrb.w	r0, [r5, #36]	; 0x24
{
    uint16_t data16;
    uint16_t is_command;
    uint8_t data8;
    
    data16 = (uint16_t)COMBLK->DATA8;
    5bc6:	b28e      	uxth	r6, r1
    is_command = data16 & DATA8_COMMAND_MASK;
    data8 = (uint8_t)data16;
    5bc8:	b2f3      	uxtb	r3, r6
    uint16_t data16;
    uint16_t is_command;
    uint8_t data8;
    
    data16 = (uint16_t)COMBLK->DATA8;
    is_command = data16 & DATA8_COMMAND_MASK;
    5bca:	f406 4600 	and.w	r6, r6, #32768	; 0x8000
    data8 = (uint8_t)data16;
            
    switch(g_comblk_state)
    5bce:	2805      	cmp	r0, #5
    5bd0:	f200 8194 	bhi.w	5efc <ComBlk_IRQHandler+0x3a0>
    5bd4:	e8df f010 	tbh	[pc, r0, lsl #1]
    5bd8:	0117011e 	.word	0x0117011e
    5bdc:	01760117 	.word	0x01760117
    5be0:	016c013a 	.word	0x016c013a
           
        case COMBLK_TX_PAGED_DATA:
            /*
             * Read a page of data if required.
             */
            if(0u == g_comblk_data_size)
    5be4:	6962      	ldr	r2, [r4, #20]
    5be6:	2a00      	cmp	r2, #0
    5be8:	f000 80f5 	beq.w	5dd6 <ComBlk_IRQHandler+0x27a>
            /*
             * Transmit the page data or move to COMBLK_WAIT_RESPONSE state if
             * no further page data could be obtained by the call to the page
             * handler above.
             */
            if(0u == g_comblk_data_size)
    5bec:	6961      	ldr	r1, [r4, #20]
    5bee:	f640 23d0 	movw	r3, #2768	; 0xad0
    5bf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    5bf6:	2900      	cmp	r1, #0
    5bf8:	f000 8198 	beq.w	5f2c <ComBlk_IRQHandler+0x3d0>
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5bfc:	f246 0200 	movw	r2, #24576	; 0x6000
    5c00:	f2c4 0201 	movt	r2, #16385	; 0x4001
                g_comblk_state = COMBLK_WAIT_RESPONSE;
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
    5c04:	695d      	ldr	r5, [r3, #20]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5c06:	6810      	ldr	r0, [r2, #0]
                g_comblk_state = COMBLK_WAIT_RESPONSE;
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
    5c08:	6919      	ldr	r1, [r3, #16]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5c0a:	f020 0304 	bic.w	r3, r0, #4
    5c0e:	6013      	str	r3, [r2, #0]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5c10:	6853      	ldr	r3, [r2, #4]
    5c12:	f003 0001 	and.w	r0, r3, #1
    5c16:	9001      	str	r0, [sp, #4]
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5c18:	9b01      	ldr	r3, [sp, #4]
    5c1a:	2b00      	cmp	r3, #0
    5c1c:	f000 8199 	beq.w	5f52 <ComBlk_IRQHandler+0x3f6>
    5c20:	2d00      	cmp	r5, #0
    5c22:	f000 8196 	beq.w	5f52 <ComBlk_IRQHandler+0x3f6>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5c26:	780b      	ldrb	r3, [r1, #0]
    5c28:	6113      	str	r3, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5c2a:	6850      	ldr	r0, [r2, #4]
    5c2c:	1e6b      	subs	r3, r5, #1
    5c2e:	f000 0601 	and.w	r6, r0, #1
    5c32:	9601      	str	r6, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5c34:	9801      	ldr	r0, [sp, #4]
    5c36:	f003 0601 	and.w	r6, r3, #1
    {
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
    5c3a:	2301      	movs	r3, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5c3c:	b1d0      	cbz	r0, 5c74 <ComBlk_IRQHandler+0x118>
    5c3e:	2d01      	cmp	r5, #1
    5c40:	d918      	bls.n	5c74 <ComBlk_IRQHandler+0x118>
    5c42:	b126      	cbz	r6, 5c4e <ComBlk_IRQHandler+0xf2>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5c44:	7848      	ldrb	r0, [r1, #1]
        ++size_sent;
    5c46:	2302      	movs	r3, #2
    5c48:	e00c      	b.n	5c64 <ComBlk_IRQHandler+0x108>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5c4a:	429d      	cmp	r5, r3
    5c4c:	d912      	bls.n	5c74 <ComBlk_IRQHandler+0x118>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5c4e:	5cc8      	ldrb	r0, [r1, r3]
        ++size_sent;
    5c50:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5c52:	6110      	str	r0, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5c54:	6850      	ldr	r0, [r2, #4]
    5c56:	f000 0001 	and.w	r0, r0, #1
    5c5a:	9001      	str	r0, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5c5c:	9801      	ldr	r0, [sp, #4]
    5c5e:	b148      	cbz	r0, 5c74 <ComBlk_IRQHandler+0x118>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5c60:	5cc8      	ldrb	r0, [r1, r3]
        ++size_sent;
    5c62:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5c64:	6110      	str	r0, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5c66:	6850      	ldr	r0, [r2, #4]
    5c68:	f000 0001 	and.w	r0, r0, #1
    5c6c:	9001      	str	r0, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5c6e:	9801      	ldr	r0, [sp, #4]
    5c70:	2800      	cmp	r0, #0
    5c72:	d1ea      	bne.n	5c4a <ComBlk_IRQHandler+0xee>
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                g_comblk_data_size = g_comblk_data_size - size_sent;
    5c74:	6962      	ldr	r2, [r4, #20]
                g_comblk_p_data = &g_comblk_p_data[size_sent];
    5c76:	18c9      	adds	r1, r1, r3
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                g_comblk_data_size = g_comblk_data_size - size_sent;
    5c78:	1ad3      	subs	r3, r2, r3
                g_comblk_p_data = &g_comblk_p_data[size_sent];
    5c7a:	6121      	str	r1, [r4, #16]
            }
            else
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                g_comblk_data_size = g_comblk_data_size - size_sent;
    5c7c:	6163      	str	r3, [r4, #20]
    5c7e:	e77d      	b.n	5b7c <ComBlk_IRQHandler+0x20>
                abort_current_cmd();
            }
        break;
            
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
    5c80:	6962      	ldr	r2, [r4, #20]
    5c82:	2a00      	cmp	r2, #0
    5c84:	f000 814e 	beq.w	5f24 <ComBlk_IRQHandler+0x3c8>
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5c88:	f246 0200 	movw	r2, #24576	; 0x6000
    5c8c:	f2c4 0201 	movt	r2, #16385	; 0x4001
            
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
    5c90:	6965      	ldr	r5, [r4, #20]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5c92:	6813      	ldr	r3, [r2, #0]
            
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
    5c94:	6920      	ldr	r0, [r4, #16]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5c96:	f023 0304 	bic.w	r3, r3, #4
    5c9a:	6013      	str	r3, [r2, #0]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5c9c:	6853      	ldr	r3, [r2, #4]
    5c9e:	f003 0301 	and.w	r3, r3, #1
    5ca2:	9301      	str	r3, [sp, #4]
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5ca4:	9b01      	ldr	r3, [sp, #4]
    5ca6:	2b00      	cmp	r3, #0
    5ca8:	f000 8151 	beq.w	5f4e <ComBlk_IRQHandler+0x3f2>
    5cac:	2d00      	cmp	r5, #0
    5cae:	f000 814e 	beq.w	5f4e <ComBlk_IRQHandler+0x3f2>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5cb2:	7803      	ldrb	r3, [r0, #0]
    5cb4:	6113      	str	r3, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5cb6:	6857      	ldr	r7, [r2, #4]
    5cb8:	1e6b      	subs	r3, r5, #1
    5cba:	f007 0601 	and.w	r6, r7, #1
    5cbe:	9601      	str	r6, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5cc0:	9e01      	ldr	r6, [sp, #4]
    5cc2:	f003 0701 	and.w	r7, r3, #1
    {
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
    5cc6:	2301      	movs	r3, #1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5cc8:	b1de      	cbz	r6, 5d02 <ComBlk_IRQHandler+0x1a6>
    5cca:	2d01      	cmp	r5, #1
    5ccc:	d919      	bls.n	5d02 <ComBlk_IRQHandler+0x1a6>
    5cce:	b12f      	cbz	r7, 5cdc <ComBlk_IRQHandler+0x180>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5cd0:	7846      	ldrb	r6, [r0, #1]
        ++size_sent;
    5cd2:	460b      	mov	r3, r1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5cd4:	6116      	str	r6, [r2, #16]
    5cd6:	e00d      	b.n	5cf4 <ComBlk_IRQHandler+0x198>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5cd8:	429d      	cmp	r5, r3
    5cda:	d912      	bls.n	5d02 <ComBlk_IRQHandler+0x1a6>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5cdc:	5cc1      	ldrb	r1, [r0, r3]
        ++size_sent;
    5cde:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5ce0:	6111      	str	r1, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5ce2:	6851      	ldr	r1, [r2, #4]
    5ce4:	f001 0101 	and.w	r1, r1, #1
    5ce8:	9101      	str	r1, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5cea:	9901      	ldr	r1, [sp, #4]
    5cec:	b149      	cbz	r1, 5d02 <ComBlk_IRQHandler+0x1a6>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5cee:	5cc1      	ldrb	r1, [r0, r3]
        ++size_sent;
    5cf0:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5cf2:	6111      	str	r1, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5cf4:	6851      	ldr	r1, [r2, #4]
    5cf6:	f001 0101 	and.w	r1, r1, #1
    5cfa:	9101      	str	r1, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5cfc:	9901      	ldr	r1, [sp, #4]
    5cfe:	2900      	cmp	r1, #0
    5d00:	d1ea      	bne.n	5cd8 <ComBlk_IRQHandler+0x17c>
        case COMBLK_TX_DATA:
            if(g_comblk_data_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                if(size_sent < g_comblk_data_size)
    5d02:	6961      	ldr	r1, [r4, #20]
    5d04:	f640 22d0 	movw	r2, #2768	; 0xad0
    5d08:	4299      	cmp	r1, r3
    5d0a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5d0e:	f200 80fc 	bhi.w	5f0a <ComBlk_IRQHandler+0x3ae>
                    g_comblk_data_size = g_comblk_data_size - size_sent;
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
                }
                else
                {
                    COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5d12:	f246 0300 	movw	r3, #24576	; 0x6000
    5d16:	f2c4 0301 	movt	r3, #16385	; 0x4001
    5d1a:	6899      	ldr	r1, [r3, #8]
    5d1c:	f021 0001 	bic.w	r0, r1, #1
    5d20:	6098      	str	r0, [r3, #8]
                    g_comblk_state = COMBLK_WAIT_RESPONSE;
    5d22:	2003      	movs	r0, #3
    5d24:	f882 0024 	strb.w	r0, [r2, #36]	; 0x24
    5d28:	e728      	b.n	5b7c <ComBlk_IRQHandler+0x20>
        /*----------------------------------------------------------------------
         * The TX_OKAY interrupt should only be enabled for states COMBLK_TX_CMD
         * and COMBLK_TX_DATA.
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
    5d2a:	89a3      	ldrh	r3, [r4, #12]
    5d2c:	2b00      	cmp	r3, #0
    5d2e:	f000 80f9 	beq.w	5f24 <ComBlk_IRQHandler+0x3c8>
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5d32:	f246 0200 	movw	r2, #24576	; 0x6000
    5d36:	f2c4 0201 	movt	r2, #16385	; 0x4001
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
    5d3a:	89a5      	ldrh	r5, [r4, #12]
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5d3c:	6813      	ldr	r3, [r2, #0]
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
    5d3e:	b2ad      	uxth	r5, r5
{
    volatile uint32_t tx_okay;
    uint32_t size_sent;

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    5d40:	f023 0004 	bic.w	r0, r3, #4
    5d44:	6010      	str	r0, [r2, #0]
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5d46:	6853      	ldr	r3, [r2, #4]
         */
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
    5d48:	68a0      	ldr	r0, [r4, #8]

    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5d4a:	f003 0301 	and.w	r3, r3, #1
    5d4e:	9301      	str	r3, [sp, #4]
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5d50:	9b01      	ldr	r3, [sp, #4]
    5d52:	2b00      	cmp	r3, #0
    5d54:	f000 80f9 	beq.w	5f4a <ComBlk_IRQHandler+0x3ee>
    5d58:	2d00      	cmp	r5, #0
    5d5a:	f000 80f6 	beq.w	5f4a <ComBlk_IRQHandler+0x3ee>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5d5e:	7803      	ldrb	r3, [r0, #0]
    5d60:	6113      	str	r3, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5d62:	6857      	ldr	r7, [r2, #4]
    5d64:	1e6b      	subs	r3, r5, #1
    5d66:	f007 0601 	and.w	r6, r7, #1
    5d6a:	9601      	str	r6, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5d6c:	9e01      	ldr	r6, [sp, #4]
    5d6e:	f003 0701 	and.w	r7, r3, #1
    {
        COMBLK->DATA8 = p_cmd[size_sent];
        ++size_sent;
    5d72:	460b      	mov	r3, r1
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5d74:	b1d6      	cbz	r6, 5dac <ComBlk_IRQHandler+0x250>
    5d76:	2d01      	cmp	r5, #1
    5d78:	d918      	bls.n	5dac <ComBlk_IRQHandler+0x250>
    5d7a:	b127      	cbz	r7, 5d86 <ComBlk_IRQHandler+0x22a>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5d7c:	7841      	ldrb	r1, [r0, #1]
        ++size_sent;
    5d7e:	2302      	movs	r3, #2
    5d80:	e00c      	b.n	5d9c <ComBlk_IRQHandler+0x240>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5d82:	429d      	cmp	r5, r3
    5d84:	d912      	bls.n	5dac <ComBlk_IRQHandler+0x250>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5d86:	5cc1      	ldrb	r1, [r0, r3]
        ++size_sent;
    5d88:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5d8a:	6111      	str	r1, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5d8c:	6851      	ldr	r1, [r2, #4]
    5d8e:	f001 0101 	and.w	r1, r1, #1
    5d92:	9101      	str	r1, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5d94:	9901      	ldr	r1, [sp, #4]
    5d96:	b149      	cbz	r1, 5dac <ComBlk_IRQHandler+0x250>
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5d98:	5cc1      	ldrb	r1, [r0, r3]
        ++size_sent;
    5d9a:	3301      	adds	r3, #1
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    {
        COMBLK->DATA8 = p_cmd[size_sent];
    5d9c:	6111      	str	r1, [r2, #16]
        ++size_sent;
        tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    5d9e:	6851      	ldr	r1, [r2, #4]
    5da0:	f001 0101 	and.w	r1, r1, #1
    5da4:	9101      	str	r1, [sp, #4]
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5da6:	9901      	ldr	r1, [sp, #4]
    5da8:	2900      	cmp	r1, #0
    5daa:	d1ea      	bne.n	5d82 <ComBlk_IRQHandler+0x226>
        case COMBLK_TX_CMD:
            if(g_comblk_cmd_size > 0u)
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
                if(size_sent < g_comblk_cmd_size)
    5dac:	89a1      	ldrh	r1, [r4, #12]
    5dae:	f640 22d0 	movw	r2, #2768	; 0xad0
    5db2:	fa1f fc81 	uxth.w	ip, r1
    5db6:	459c      	cmp	ip, r3
    5db8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5dbc:	f200 80ab 	bhi.w	5f16 <ComBlk_IRQHandler+0x3ba>
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
                }
                else
                {
                    g_comblk_cmd_size = 0u;
    5dc0:	f04f 0c00 	mov.w	ip, #0
    5dc4:	f8a2 c00c 	strh.w	ip, [r2, #12]
                    if(g_comblk_data_size > 0u)
    5dc8:	6950      	ldr	r0, [r2, #20]
    5dca:	2800      	cmp	r0, #0
    5dcc:	d0a9      	beq.n	5d22 <ComBlk_IRQHandler+0x1c6>
                    {
                        g_comblk_state = COMBLK_TX_DATA;
    5dce:	2302      	movs	r3, #2
    5dd0:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    5dd4:	e6d2      	b.n	5b7c <ComBlk_IRQHandler+0x20>
            /*
             * Read a page of data if required.
             */
            if(0u == g_comblk_data_size)
            {
                if(g_comblk_page_handler != 0)
    5dd6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    5dd8:	2b00      	cmp	r3, #0
    5dda:	f000 80b3 	beq.w	5f44 <ComBlk_IRQHandler+0x3e8>
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
    5dde:	f104 0010 	add.w	r0, r4, #16
    5de2:	4798      	blx	r3
    5de4:	6160      	str	r0, [r4, #20]
                    if(0u == g_comblk_data_size)
    5de6:	6963      	ldr	r3, [r4, #20]
    5de8:	2b00      	cmp	r3, #0
    5dea:	f47f aeff 	bne.w	5bec <ComBlk_IRQHandler+0x90>
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5dee:	f246 0300 	movw	r3, #24576	; 0x6000
    5df2:	f2c4 0301 	movt	r3, #16385	; 0x4001
    5df6:	689a      	ldr	r2, [r3, #8]
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
    5df8:	2103      	movs	r1, #3
                if(g_comblk_page_handler != 0)
                {
                    g_comblk_data_size = g_comblk_page_handler(&g_comblk_p_data);
                    if(0u == g_comblk_data_size)
                    {
                        COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5dfa:	f022 0001 	bic.w	r0, r2, #1
    5dfe:	6098      	str	r0, [r3, #8]
                        g_comblk_state = COMBLK_WAIT_RESPONSE;
    5e00:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
    5e04:	e6f2      	b.n	5bec <ComBlk_IRQHandler+0x90>
        
        case COMBLK_TX_CMD:
            /* Fall through */
        case COMBLK_TX_DATA:
            /* Fall through */
            if(is_command)
    5e06:	2e00      	cmp	r6, #0
    5e08:	f43f aeb5 	beq.w	5b76 <ComBlk_IRQHandler+0x1a>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
    5e0c:	4618      	mov	r0, r3
    5e0e:	f7ff fe9b 	bl	5b48 <process_sys_ctrl_command>
    5e12:	e6b0      	b.n	5b76 <ComBlk_IRQHandler+0x1a>
        * MSS_COMBLK_init() enables the RCV_OKAY interrupt for the COMBLK_IDLE
        * state to receive the asynchronous power-on-reset from the system
        * controller.
        */
        case COMBLK_IDLE:
            if(is_command)
    5e14:	2e00      	cmp	r6, #0
    5e16:	f43f aeae 	beq.w	5b76 <ComBlk_IRQHandler+0x1a>
            {
                if(data8 != POR_DIGEST_ERROR_OPCODE)
    5e1a:	2bf1      	cmp	r3, #241	; 0xf1
    5e1c:	d1f6      	bne.n	5e0c <ComBlk_IRQHandler+0x2b0>
                    rxed_opcode = data8;
                    process_sys_ctrl_command(rxed_opcode);
                }
                else
                {  
                    g_comblk_response_idx = 0;
    5e1e:	f04f 0200 	mov.w	r2, #0
    5e22:	83ea      	strh	r2, [r5, #30]
                    g_comblk_p_response[g_comblk_response_idx] = data8;
    5e24:	8be9      	ldrh	r1, [r5, #30]
    5e26:	69ab      	ldr	r3, [r5, #24]
    5e28:	b288      	uxth	r0, r1
    5e2a:	f06f 0c0e 	mvn.w	ip, #14
    5e2e:	f803 c000 	strb.w	ip, [r3, r0]
                    g_comblk_response_idx++;
    5e32:	8be9      	ldrh	r1, [r5, #30]
    5e34:	1c48      	adds	r0, r1, #1
    5e36:	b281      	uxth	r1, r0
    5e38:	83e9      	strh	r1, [r5, #30]
                    g_comblk_p_response[g_comblk_response_idx] = 0x00u;                
    5e3a:	8be8      	ldrh	r0, [r5, #30]
    5e3c:	fa1f fc80 	uxth.w	ip, r0
    5e40:	f803 200c 	strb.w	r2, [r3, ip]
                    g_comblk_state = COMBLK_RX_RESPONSE;
    5e44:	2304      	movs	r3, #4
    5e46:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    5e4a:	e694      	b.n	5b76 <ComBlk_IRQHandler+0x1a>
                }
            }
        break;
            
        case COMBLK_RX_RESPONSE:
            if(is_command)
    5e4c:	2e00      	cmp	r6, #0
    5e4e:	d1dd      	bne.n	5e0c <ComBlk_IRQHandler+0x2b0>
                rxed_opcode = data8;
                process_sys_ctrl_command(rxed_opcode);
            }
            else
            {
                if( g_comblk_p_response[g_comblk_response_idx-1] == POR_DIGEST_ERROR_OPCODE)
    5e50:	f8b5 c01e 	ldrh.w	ip, [r5, #30]
    5e54:	69a9      	ldr	r1, [r5, #24]
    5e56:	fa1f f08c 	uxth.w	r0, ip
    5e5a:	180f      	adds	r7, r1, r0
    5e5c:	f817 2c01 	ldrb.w	r2, [r7, #-1]
    5e60:	f640 27d0 	movw	r7, #2768	; 0xad0
    5e64:	2af1      	cmp	r2, #241	; 0xf1
    5e66:	f2c2 0700 	movt	r7, #8192	; 0x2000
    5e6a:	d074      	beq.n	5f56 <ComBlk_IRQHandler+0x3fa>
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
                    g_comblk_state = COMBLK_IDLE;
                }
                else
                {
                    if(g_comblk_response_idx < g_comblk_response_size)
    5e6c:	8bf8      	ldrh	r0, [r7, #30]
    5e6e:	8bba      	ldrh	r2, [r7, #28]
    5e70:	fa1f fc80 	uxth.w	ip, r0
    5e74:	4594      	cmp	ip, r2
    5e76:	d208      	bcs.n	5e8a <ComBlk_IRQHandler+0x32e>
                    {
                        uint8_t rxed_data;
                        
                        rxed_data = data8;
                        g_comblk_p_response[g_comblk_response_idx] = rxed_data;
    5e78:	8bf8      	ldrh	r0, [r7, #30]
    5e7a:	fa1f fc80 	uxth.w	ip, r0
    5e7e:	f801 300c 	strb.w	r3, [r1, ip]
                        ++g_comblk_response_idx;
    5e82:	8bf8      	ldrh	r0, [r7, #30]
    5e84:	1c43      	adds	r3, r0, #1
    5e86:	b299      	uxth	r1, r3
    5e88:	83f9      	strh	r1, [r7, #30]
                    }
                    
                    if(g_comblk_response_idx == g_comblk_response_size)
    5e8a:	8beb      	ldrh	r3, [r5, #30]
    5e8c:	f640 25d0 	movw	r5, #2768	; 0xad0
    5e90:	b299      	uxth	r1, r3
    5e92:	428a      	cmp	r2, r1
    5e94:	f2c2 0500 	movt	r5, #8192	; 0x2000
    5e98:	f47f ae6d 	bne.w	5b76 <ComBlk_IRQHandler+0x1a>
                    {
                        complete_request(g_comblk_response_idx);
    5e9c:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
    5ea0:	fa1f f08e 	uxth.w	r0, lr
    5ea4:	f7ff fc7e 	bl	57a4 <complete_request>
                        g_comblk_state = COMBLK_IDLE;
    5ea8:	2200      	movs	r2, #0
    5eaa:	f885 2024 	strb.w	r2, [r5, #36]	; 0x24
    5eae:	e662      	b.n	5b76 <ComBlk_IRQHandler+0x1a>
         * The RCV_OKAY interrupt should NOT be enabled for states
         * COMBLK_IDLE, COMBLK_TX_CMD and COMBLK_TX_DATA.
         */
        case COMBLK_TX_PAGED_DATA:
            /* This is needed because when there is an error, we need to terminate loading the data */
            if(!is_command)
    5eb0:	2e00      	cmp	r6, #0
    5eb2:	d1ab      	bne.n	5e0c <ComBlk_IRQHandler+0x2b0>
            {
                g_comblk_p_response[1] = data8;
    5eb4:	69a9      	ldr	r1, [r5, #24]
                complete_request(2u);
    5eb6:	2002      	movs	r0, #2
         */
        case COMBLK_TX_PAGED_DATA:
            /* This is needed because when there is an error, we need to terminate loading the data */
            if(!is_command)
            {
                g_comblk_p_response[1] = data8;
    5eb8:	704b      	strb	r3, [r1, #1]
                complete_request(2u);
    5eba:	f7ff fc73 	bl	57a4 <complete_request>
                g_comblk_state = COMBLK_IDLE;
    5ebe:	f885 6024 	strb.w	r6, [r5, #36]	; 0x24
    5ec2:	e658      	b.n	5b76 <ComBlk_IRQHandler+0x1a>
        /*----------------------------------------------------------------------
         * The RCV_OKAY interrupt should only be enabled for states
         * COMBLK_WAIT_RESPONSE and COMBLK_RX_RESPONSE. 
         */
        case COMBLK_WAIT_RESPONSE:
            if(is_command)
    5ec4:	2e00      	cmp	r6, #0
    5ec6:	f43f ae56 	beq.w	5b76 <ComBlk_IRQHandler+0x1a>
            {
                uint8_t rxed_opcode;
                rxed_opcode = data8;
                if(rxed_opcode == g_comblk_cmd_opcode)
    5eca:	f895 c005 	ldrb.w	ip, [r5, #5]
    5ece:	f640 22d0 	movw	r2, #2768	; 0xad0
    5ed2:	4563      	cmp	r3, ip
    5ed4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    5ed8:	d198      	bne.n	5e0c <ComBlk_IRQHandler+0x2b0>
                {
                    g_comblk_response_idx = 0u;
    5eda:	f04f 0000 	mov.w	r0, #0
    5ede:	83d0      	strh	r0, [r2, #30]
                    g_comblk_p_response[g_comblk_response_idx] = rxed_opcode;
    5ee0:	8bd1      	ldrh	r1, [r2, #30]
    5ee2:	6990      	ldr	r0, [r2, #24]
    5ee4:	fa1f fc81 	uxth.w	ip, r1
    5ee8:	f800 300c 	strb.w	r3, [r0, ip]
                    ++g_comblk_response_idx;
    5eec:	8bd3      	ldrh	r3, [r2, #30]
                    g_comblk_state = COMBLK_RX_RESPONSE;
    5eee:	2004      	movs	r0, #4
                rxed_opcode = data8;
                if(rxed_opcode == g_comblk_cmd_opcode)
                {
                    g_comblk_response_idx = 0u;
                    g_comblk_p_response[g_comblk_response_idx] = rxed_opcode;
                    ++g_comblk_response_idx;
    5ef0:	1c59      	adds	r1, r3, #1
    5ef2:	b28b      	uxth	r3, r1
                    g_comblk_state = COMBLK_RX_RESPONSE;
    5ef4:	f882 0024 	strb.w	r0, [r2, #36]	; 0x24
                rxed_opcode = data8;
                if(rxed_opcode == g_comblk_cmd_opcode)
                {
                    g_comblk_response_idx = 0u;
                    g_comblk_p_response[g_comblk_response_idx] = rxed_opcode;
                    ++g_comblk_response_idx;
    5ef8:	83d3      	strh	r3, [r2, #30]
    5efa:	e63c      	b.n	5b76 <ComBlk_IRQHandler+0x1a>
                process_sys_ctrl_command(rxed_opcode);
            }
        break;
        
        default:
            complete_request(0u);
    5efc:	2000      	movs	r0, #0
    5efe:	f7ff fc51 	bl	57a4 <complete_request>
            g_comblk_state = COMBLK_IDLE;
    5f02:	2000      	movs	r0, #0
    5f04:	f885 0024 	strb.w	r0, [r5, #36]	; 0x24
    5f08:	e635      	b.n	5b76 <ComBlk_IRQHandler+0x1a>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                if(size_sent < g_comblk_data_size)
                {
                    g_comblk_data_size = g_comblk_data_size - size_sent;
    5f0a:	6951      	ldr	r1, [r2, #20]
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
    5f0c:	18c0      	adds	r0, r0, r3
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                if(size_sent < g_comblk_data_size)
                {
                    g_comblk_data_size = g_comblk_data_size - size_sent;
    5f0e:	1acb      	subs	r3, r1, r3
                    g_comblk_p_data = &g_comblk_p_data[size_sent];
    5f10:	6110      	str	r0, [r2, #16]
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_data, g_comblk_data_size);
                if(size_sent < g_comblk_data_size)
                {
                    g_comblk_data_size = g_comblk_data_size - size_sent;
    5f12:	6153      	str	r3, [r2, #20]
    5f14:	e632      	b.n	5b7c <ComBlk_IRQHandler+0x20>
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
                if(size_sent < g_comblk_cmd_size)
                {
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    5f16:	8991      	ldrh	r1, [r2, #12]
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    5f18:	18c0      	adds	r0, r0, r3
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
                if(size_sent < g_comblk_cmd_size)
                {
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    5f1a:	1acb      	subs	r3, r1, r3
    5f1c:	b29b      	uxth	r3, r3
                    g_comblk_p_cmd = &g_comblk_p_cmd[size_sent];
    5f1e:	6090      	str	r0, [r2, #8]
            {
                uint32_t size_sent;
                size_sent = fill_tx_fifo(g_comblk_p_cmd, g_comblk_cmd_size);
                if(size_sent < g_comblk_cmd_size)
                {
                    g_comblk_cmd_size = g_comblk_cmd_size - (uint16_t)size_sent;
    5f20:	8193      	strh	r3, [r2, #12]
    5f22:	e62b      	b.n	5b7c <ComBlk_IRQHandler+0x20>
    tx_okay = status & TXTOKAY_MASK;
    if(tx_okay)
    {
        handle_tx_okay_irq();
    }
}
    5f24:	b003      	add	sp, #12
    5f26:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                /*
                 * This is an invalid situation indicating a bug in the driver
                 * or corrupted memory.
                 */
                ASSERT(0);
                abort_current_cmd();
    5f2a:	e449      	b.n	57c0 <abort_current_cmd>
             * no further page data could be obtained by the call to the page
             * handler above.
             */
            if(0u == g_comblk_data_size)
            {
                COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5f2c:	f246 0200 	movw	r2, #24576	; 0x6000
    5f30:	f2c4 0201 	movt	r2, #16385	; 0x4001
    5f34:	6890      	ldr	r0, [r2, #8]
    5f36:	f020 0101 	bic.w	r1, r0, #1
                g_comblk_state = COMBLK_WAIT_RESPONSE;
    5f3a:	2003      	movs	r0, #3
             * no further page data could be obtained by the call to the page
             * handler above.
             */
            if(0u == g_comblk_data_size)
            {
                COMBLK->INT_ENABLE &= ~TXTOKAY_MASK;
    5f3c:	6091      	str	r1, [r2, #8]
                g_comblk_state = COMBLK_WAIT_RESPONSE;
    5f3e:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
    5f42:	e61b      	b.n	5b7c <ComBlk_IRQHandler+0x20>
                    }
                }
                else
                {
                    ASSERT(0);
                    abort_current_cmd();
    5f44:	f7ff fc3c 	bl	57c0 <abort_current_cmd>
    5f48:	e650      	b.n	5bec <ComBlk_IRQHandler+0x90>
    /* Set transmit FIFO to transfer bytes. */
    COMBLK->CONTROL &= ~CR_SIZETX_MASK;
    
    size_sent = 0u;
    tx_okay = COMBLK->STATUS & TXTOKAY_MASK;
    while((tx_okay != 0u) && (size_sent < cmd_size))
    5f4a:	2300      	movs	r3, #0
    5f4c:	e72e      	b.n	5dac <ComBlk_IRQHandler+0x250>
    5f4e:	2300      	movs	r3, #0
    5f50:	e6d7      	b.n	5d02 <ComBlk_IRQHandler+0x1a6>
    5f52:	2300      	movs	r3, #0
    5f54:	e68e      	b.n	5c74 <ComBlk_IRQHandler+0x118>
            }
            else
            {
                if( g_comblk_p_response[g_comblk_response_idx-1] == POR_DIGEST_ERROR_OPCODE)
                {
                    g_comblk_p_response[g_comblk_response_idx] = data8;
    5f56:	8bf8      	ldrh	r0, [r7, #30]
    5f58:	b282      	uxth	r2, r0
    5f5a:	548b      	strb	r3, [r1, r2]
                    process_sys_ctrl_command(g_comblk_p_response[g_comblk_response_idx-1]);
    5f5c:	f8b7 e01e 	ldrh.w	lr, [r7, #30]
    5f60:	fa1f f38e 	uxth.w	r3, lr
    5f64:	18c9      	adds	r1, r1, r3
    5f66:	f811 0c01 	ldrb.w	r0, [r1, #-1]
    5f6a:	f7ff fded 	bl	5b48 <process_sys_ctrl_command>
                    g_comblk_state = COMBLK_IDLE;
    5f6e:	f887 6024 	strb.w	r6, [r7, #36]	; 0x24
    5f72:	e600      	b.n	5b76 <ComBlk_IRQHandler+0x1a>

00005f74 <determine_seq>:

static uint8_t* determine_seq(uint8_t val, uint8_t* len)
{
    uint8_t*seq;
    
    switch(val)
    5f74:	2806      	cmp	r0, #6
    5f76:	d809      	bhi.n	5f8c <determine_seq+0x18>
    5f78:	e8df f000 	tbb	[pc, r0]
    5f7c:	0816120b 	.word	0x0816120b
    5f80:	1e1a      	.short	0x1e1a
    5f82:	04          	.byte	0x04
    5f83:	00          	.byte	0x00
                *len = 2;
            break;

        case 6:
                seq = &div32_seq[0];
                *len = 2;
    5f84:	2202      	movs	r2, #2
    5f86:	700a      	strb	r2, [r1, #0]
    5f88:	480d      	ldr	r0, [pc, #52]	; (5fc0 <determine_seq+0x4c>)
            break;
    5f8a:	4770      	bx	lr

        default:
                *len = 0;
    5f8c:	2000      	movs	r0, #0
    5f8e:	7008      	strb	r0, [r1, #0]
                seq = NULL;
            break;
    }
    
    return seq;
}
    5f90:	4770      	bx	lr
    
    switch(val)
    {
        case 0:
                seq = &div1_seq[0];
                *len = 4;
    5f92:	f240 409c 	movw	r0, #1180	; 0x49c
    5f96:	2304      	movs	r3, #4
    5f98:	700b      	strb	r3, [r1, #0]
    5f9a:	f2c2 0000 	movt	r0, #8192	; 0x2000
            break;
    5f9e:	4770      	bx	lr

        case 1:
                seq = &div2_seq[0];
                *len = 3;
    5fa0:	2003      	movs	r0, #3
    5fa2:	7008      	strb	r0, [r1, #0]
    5fa4:	4807      	ldr	r0, [pc, #28]	; (5fc4 <determine_seq+0x50>)
            break;
    5fa6:	4770      	bx	lr

        case 2:
                seq = &div4_seq[0];
                *len = 5;
    5fa8:	2205      	movs	r2, #5
    5faa:	700a      	strb	r2, [r1, #0]
    5fac:	4806      	ldr	r0, [pc, #24]	; (5fc8 <determine_seq+0x54>)
            break;
    5fae:	4770      	bx	lr

        case 4:
                seq = &div8_seq[0];
                *len = 3;
    5fb0:	2303      	movs	r3, #3
    5fb2:	700b      	strb	r3, [r1, #0]
    5fb4:	4805      	ldr	r0, [pc, #20]	; (5fcc <determine_seq+0x58>)
            break;
    5fb6:	4770      	bx	lr

        case 5:
                seq = &div16_seq[0];
                *len = 2;
    5fb8:	2002      	movs	r0, #2
    5fba:	7008      	strb	r0, [r1, #0]
    5fbc:	4804      	ldr	r0, [pc, #16]	; (5fd0 <determine_seq+0x5c>)
            break;
    5fbe:	4770      	bx	lr
    5fc0:	200004b4 	.word	0x200004b4
    5fc4:	200004a0 	.word	0x200004a0
    5fc8:	200004a4 	.word	0x200004a4
    5fcc:	200004ac 	.word	0x200004ac
    5fd0:	200004b0 	.word	0x200004b0

00005fd4 <clk_switching_fix>:
 * divisor values of fclk, pclk0, pclk1 and clk_fic64, and if the divisor 
 * values are equal to each other, then firmware will send requested command to 
 * system controller otherwise return CLOCK_SWITCHING_ERROR error.
 */
static uint8_t clk_switching_fix(void)
{
    5fd4:	b570      	push	{r4, r5, r6, lr}
    uint8_t* sequence;
    uint8_t len;
    volatile uint32_t g_mssddr_facc1_cr =  SYSREG->MSSDDR_FACC1_CR;
    5fd6:	f248 0400 	movw	r4, #32768	; 0x8000
    5fda:	f2c4 0403 	movt	r4, #16387	; 0x4003
    5fde:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
 * divisor values of fclk, pclk0, pclk1 and clk_fic64, and if the divisor 
 * values are equal to each other, then firmware will send requested command to 
 * system controller otherwise return CLOCK_SWITCHING_ERROR error.
 */
static uint8_t clk_switching_fix(void)
{
    5fe2:	b082      	sub	sp, #8
    uint8_t* sequence;
    uint8_t len;
    volatile uint32_t g_mssddr_facc1_cr =  SYSREG->MSSDDR_FACC1_CR;
    5fe4:	9100      	str	r1, [sp, #0]
    uint32_t var = 0;
    uint32_t temp = 0;
    uint32_t device_version;
    uint8_t status = CLOCK_SWITCHING_SUCCESS;
    
    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    5fe6:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c

    /* For 10/25/50/90/150 devices */
    if((0xF802u == device_version) || \
    5fea:	f64f 0c07 	movw	ip, #63495	; 0xf807
    uint32_t var = 0;
    uint32_t temp = 0;
    uint32_t device_version;
    uint8_t status = CLOCK_SWITCHING_SUCCESS;
    
    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    5fee:	b29b      	uxth	r3, r3

    /* For 10/25/50/90/150 devices */
    if((0xF802u == device_version) || \
    5ff0:	f5a3 4278 	sub.w	r2, r3, #63488	; 0xf800
    5ff4:	3a02      	subs	r2, #2
    5ff6:	4563      	cmp	r3, ip
    5ff8:	bf14      	ite	ne
    5ffa:	2100      	movne	r1, #0
    5ffc:	2101      	moveq	r1, #1
    5ffe:	2a02      	cmp	r2, #2
    6000:	bf8c      	ite	hi
    6002:	460a      	movhi	r2, r1
    6004:	f041 0201 	orrls.w	r2, r1, #1
    6008:	2a00      	cmp	r2, #0
    600a:	d12e      	bne.n	606a <clk_switching_fix+0x96>
    600c:	f64f 0c06 	movw	ip, #63494	; 0xf806
    6010:	4563      	cmp	r3, ip
    6012:	d02a      	beq.n	606a <clk_switching_fix+0x96>
    
    /* For 05 devices
     * When modifying clock divisor settings on M2S005, it is necessary to 
     * sequence them, depending on the starting configuration.
     */
    else if(0xF805u == device_version)
    6014:	f64f 0105 	movw	r1, #63493	; 0xf805
    6018:	428b      	cmp	r3, r1
    601a:	d03d      	beq.n	6098 <clk_switching_fix+0xc4>
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR | 0x00001000u;
        
        status = CLOCK_SWITCHING_SUCCESS;
    }
    /* For 060 devices */
    else if(0xF808u == device_version)
    601c:	f64f 0c08 	movw	ip, #63496	; 0xf808
    6020:	4563      	cmp	r3, ip
    6022:	bf18      	it	ne
    6024:	4610      	movne	r0, r2
    6026:	d135      	bne.n	6094 <clk_switching_fix+0xc0>
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
    6028:	9900      	ldr	r1, [sp, #0]
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
    602a:	9c00      	ldr	r4, [sp, #0]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
    602c:	9d00      	ldr	r5, [sp, #0]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
    602e:	9800      	ldr	r0, [sp, #0]
    else if(0xF808u == device_version)
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
    6030:	f3c1 0182 	ubfx	r1, r1, #2, #3
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
    6034:	f3c4 1442 	ubfx	r4, r4, #5, #3
    else if(0xF808u == device_version)
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
    6038:	f640 23fc 	movw	r3, #2812	; 0xafc
    603c:	f2c2 0300 	movt	r3, #8192	; 0x2000
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
    6040:	f3c5 2542 	ubfx	r5, r5, #9, #3
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
    6044:	f3c0 40c2 	ubfx	r0, r0, #19, #3
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
    6048:	42a1      	cmp	r1, r4
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
    604a:	60d8      	str	r0, [r3, #12]
    else if(0xF808u == device_version)
    {
        /* The divisor setting should be such that all the divisor should be 
         * equal to each other and set to divide by 1,2,4,8, and 16 (but not 32)
         */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
    604c:	6019      	str	r1, [r3, #0]
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
    604e:	605c      	str	r4, [r3, #4]
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
    6050:	609d      	str	r5, [r3, #8]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
    6052:	f040 8142 	bne.w	62da <clk_switching_fix+0x306>
    6056:	2905      	cmp	r1, #5
    6058:	f200 813f 	bhi.w	62da <clk_switching_fix+0x306>
    605c:	42a9      	cmp	r1, r5
    605e:	f040 813c 	bne.w	62da <clk_switching_fix+0x306>
    6062:	1a08      	subs	r0, r1, r0
    6064:	bf18      	it	ne
    6066:	2001      	movne	r0, #1
    6068:	e014      	b.n	6094 <clk_switching_fix+0xc0>
    {
        /* Dynamically divides down fclk, pclk0, pclk1 and clk_fic64
         * to the divided by 32 versions and M3_CLK, PCLK0, PCLK1, 
         * CLK_FIC64 all driven from CLK_STANDBY clock.
         */
        SYSREG->MSSDDR_FACC1_CR = (SYSREG->MSSDDR_FACC1_CR & CONFIG_CLOCK_DIV_MASK) | \
    606a:	f248 0100 	movw	r1, #32768	; 0x8000
    606e:	f2c4 0103 	movt	r1, #16387	; 0x4003
    6072:	f8d1 0098 	ldr.w	r0, [r1, #152]	; 0x98
    6076:	f24e 1c03 	movw	ip, #57603	; 0xe103
    607a:	f6cf 7cc7 	movt	ip, #65479	; 0xffc7
    607e:	f641 43d8 	movw	r3, #7384	; 0x1cd8
    6082:	ea00 020c 	and.w	r2, r0, ip
    6086:	f2c0 0330 	movt	r3, #48	; 0x30
    608a:	ea42 0003 	orr.w	r0, r2, r3
    608e:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
    6092:	2000      	movs	r0, #0
    {
         /* Do Nothing. */
    }
    
    return status;
}
    6094:	b002      	add	sp, #8
    6096:	bd70      	pop	{r4, r5, r6, pc}
     * sequence them, depending on the starting configuration.
     */
    else if(0xF805u == device_version)
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
    6098:	9e00      	ldr	r6, [sp, #0]
    609a:	f640 25fc 	movw	r5, #2812	; 0xafc
    609e:	f3c6 0382 	ubfx	r3, r6, #2, #3
    60a2:	f2c2 0500 	movt	r5, #8192	; 0x2000
        sequence = determine_seq(divisor[0], &len);
    60a6:	f10d 0607 	add.w	r6, sp, #7
    60aa:	4618      	mov	r0, r3
    60ac:	4631      	mov	r1, r6
     * sequence them, depending on the starting configuration.
     */
    else if(0xF805u == device_version)
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
    60ae:	602b      	str	r3, [r5, #0]
        sequence = determine_seq(divisor[0], &len);
    60b0:	f7ff ff60 	bl	5f74 <determine_seq>

        for(var = 1; var < len; var++)
    60b4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    60b8:	2a01      	cmp	r2, #1
    60ba:	d934      	bls.n	6126 <clk_switching_fix+0x152>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    60bc:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
    60c0:	f890 e001 	ldrb.w	lr, [r0, #1]
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    60c4:	f023 0c1c 	bic.w	ip, r3, #28
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    60c8:	2302      	movs	r3, #2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
    60ca:	ea4c 018e 	orr.w	r1, ip, lr, lsl #2
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    60ce:	4293      	cmp	r3, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
    60d0:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
    60d4:	f002 0101 	and.w	r1, r2, #1
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    60d8:	d225      	bcs.n	6126 <clk_switching_fix+0x152>
    60da:	b161      	cbz	r1, 60f6 <clk_switching_fix+0x122>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    60dc:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
    60e0:	f890 e002 	ldrb.w	lr, [r0, #2]
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    60e4:	f021 031c 	bic.w	r3, r1, #28
            temp |= ((uint32_t)(sequence[var]) << 2);
    60e8:	ea43 018e 	orr.w	r1, r3, lr, lsl #2
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    60ec:	2303      	movs	r3, #3
    60ee:	4293      	cmp	r3, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
    60f0:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    60f4:	d217      	bcs.n	6126 <clk_switching_fix+0x152>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    60f6:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
    60fa:	f810 c003 	ldrb.w	ip, [r0, r3]
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    60fe:	f021 0e1c 	bic.w	lr, r1, #28
            temp |= ((uint32_t)(sequence[var]) << 2);
    6102:	ea4e 018c 	orr.w	r1, lr, ip, lsl #2
            SYSREG->MSSDDR_FACC1_CR = temp;
    6106:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    610a:	3301      	adds	r3, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    610c:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
    6110:	f810 c003 	ldrb.w	ip, [r0, r3]
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    6114:	f021 0e1c 	bic.w	lr, r1, #28
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    6118:	3301      	adds	r3, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
    611a:	ea4e 018c 	orr.w	r1, lr, ip, lsl #2
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    611e:	4293      	cmp	r3, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
    6120:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
    {
        /* For APB0_DIVISOR setting */
        divisor[0] = ((g_mssddr_facc1_cr >> 2) & 0x00000007);
        sequence = determine_seq(divisor[0], &len);

        for(var = 1; var < len; var++)
    6124:	d3e7      	bcc.n	60f6 <clk_switching_fix+0x122>
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
    6126:	9800      	ldr	r0, [sp, #0]
        sequence = determine_seq(divisor[1], &len);
    6128:	4631      	mov	r1, r6
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
    612a:	f3c0 1242 	ubfx	r2, r0, #5, #3
        sequence = determine_seq(divisor[1], &len);
    612e:	4610      	mov	r0, r2
            temp |= ((uint32_t)(sequence[var]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
    6130:	606a      	str	r2, [r5, #4]
        sequence = determine_seq(divisor[1], &len);
    6132:	f7ff ff1f 	bl	5f74 <determine_seq>

        for(var = 1; var < len; var++)
    6136:	f89d 1007 	ldrb.w	r1, [sp, #7]
    613a:	2901      	cmp	r1, #1
    613c:	d937      	bls.n	61ae <clk_switching_fix+0x1da>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    613e:	f248 0300 	movw	r3, #32768	; 0x8000
    6142:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6146:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    614a:	f890 e001 	ldrb.w	lr, [r0, #1]
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    614e:	f022 0ce0 	bic.w	ip, r2, #224	; 0xe0

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    6152:	2202      	movs	r2, #2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    6154:	ea4c 144e 	orr.w	r4, ip, lr, lsl #5

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    6158:	428a      	cmp	r2, r1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
    615a:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
    615e:	f001 0401 	and.w	r4, r1, #1

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    6162:	d224      	bcs.n	61ae <clk_switching_fix+0x1da>
    6164:	b15c      	cbz	r4, 617e <clk_switching_fix+0x1aa>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6166:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    616a:	7884      	ldrb	r4, [r0, #2]
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    616c:	f022 0ce0 	bic.w	ip, r2, #224	; 0xe0

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    6170:	2203      	movs	r2, #3
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    6172:	ea4c 1444 	orr.w	r4, ip, r4, lsl #5

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    6176:	428a      	cmp	r2, r1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
    6178:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    617c:	d217      	bcs.n	61ae <clk_switching_fix+0x1da>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    617e:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    6182:	f810 c002 	ldrb.w	ip, [r0, r2]
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    6186:	f024 0ee0 	bic.w	lr, r4, #224	; 0xe0
            temp |= ((uint32_t)(sequence[var]) << 5);
    618a:	ea4e 144c 	orr.w	r4, lr, ip, lsl #5
            SYSREG->MSSDDR_FACC1_CR = temp;
    618e:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    6192:	3201      	adds	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6194:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    6198:	f810 e002 	ldrb.w	lr, [r0, r2]
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    619c:	f024 04e0 	bic.w	r4, r4, #224	; 0xe0

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    61a0:	3201      	adds	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
    61a2:	ea44 144e 	orr.w	r4, r4, lr, lsl #5

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    61a6:	428a      	cmp	r2, r1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
    61a8:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98

        /* For APB1_DIVISOR setting */
        divisor[1] = ((g_mssddr_facc1_cr >> 5) & 0x00000007);
        sequence = determine_seq(divisor[1], &len);

        for(var = 1; var < len; var++)
    61ac:	d3e7      	bcc.n	617e <clk_switching_fix+0x1aa>
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
    61ae:	9800      	ldr	r0, [sp, #0]
        sequence = determine_seq(divisor[2], &len);
    61b0:	4631      	mov	r1, r6
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
    61b2:	f3c0 2342 	ubfx	r3, r0, #9, #3
        sequence = determine_seq(divisor[2], &len);
    61b6:	4618      	mov	r0, r3
            temp |= ((uint32_t)(sequence[var]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
    61b8:	60ab      	str	r3, [r5, #8]
        sequence = determine_seq(divisor[2], &len);
    61ba:	f7ff fedb 	bl	5f74 <determine_seq>
        
        for(var = 1; var < len; var++)
    61be:	f89d 1007 	ldrb.w	r1, [sp, #7]
    61c2:	2901      	cmp	r1, #1
    61c4:	d938      	bls.n	6238 <clk_switching_fix+0x264>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    61c6:	f248 0300 	movw	r3, #32768	; 0x8000
    61ca:	f2c4 0303 	movt	r3, #16387	; 0x4003
    61ce:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
    61d2:	f890 c001 	ldrb.w	ip, [r0, #1]
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    61d6:	f424 6e60 	bic.w	lr, r4, #3584	; 0xe00
            temp |= ((uint32_t)(sequence[var]) << 9);
    61da:	ea4e 224c 	orr.w	r2, lr, ip, lsl #9
            SYSREG->MSSDDR_FACC1_CR = temp;
    61de:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    61e2:	2202      	movs	r2, #2
    61e4:	4291      	cmp	r1, r2
    61e6:	f001 0401 	and.w	r4, r1, #1
    61ea:	d925      	bls.n	6238 <clk_switching_fix+0x264>
    61ec:	b164      	cbz	r4, 6208 <clk_switching_fix+0x234>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    61ee:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
    61f2:	f890 c002 	ldrb.w	ip, [r0, #2]
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    61f6:	f422 6e60 	bic.w	lr, r2, #3584	; 0xe00

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    61fa:	2203      	movs	r2, #3
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
    61fc:	ea4e 244c 	orr.w	r4, lr, ip, lsl #9

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    6200:	4291      	cmp	r1, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
    6202:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    6206:	d917      	bls.n	6238 <clk_switching_fix+0x264>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6208:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
    620c:	f810 c002 	ldrb.w	ip, [r0, r2]
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    6210:	f424 6e60 	bic.w	lr, r4, #3584	; 0xe00
            temp |= ((uint32_t)(sequence[var]) << 9);
    6214:	ea4e 244c 	orr.w	r4, lr, ip, lsl #9
            SYSREG->MSSDDR_FACC1_CR = temp;
    6218:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    621c:	3201      	adds	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    621e:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
    6222:	f810 c002 	ldrb.w	ip, [r0, r2]
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    6226:	f424 6e60 	bic.w	lr, r4, #3584	; 0xe00

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    622a:	3201      	adds	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
    622c:	ea4e 244c 	orr.w	r4, lr, ip, lsl #9

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    6230:	4291      	cmp	r1, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
    6232:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98

        /* For M3_CLK_DIVISOR setting */
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        sequence = determine_seq(divisor[2], &len);
        
        for(var = 1; var < len; var++)
    6236:	d8e7      	bhi.n	6208 <clk_switching_fix+0x234>
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
    6238:	9800      	ldr	r0, [sp, #0]
        sequence = determine_seq(divisor[3], &len);
    623a:	4631      	mov	r1, r6
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
    623c:	f3c0 43c2 	ubfx	r3, r0, #19, #3
        sequence = determine_seq(divisor[3], &len);
    6240:	4618      	mov	r0, r3
            temp |= ((uint32_t)(sequence[var]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
    6242:	60eb      	str	r3, [r5, #12]
        sequence = determine_seq(divisor[3], &len);
    6244:	f7ff fe96 	bl	5f74 <determine_seq>
        for(var = 1; var < len; var++)
    6248:	f89d 1007 	ldrb.w	r1, [sp, #7]
    624c:	2901      	cmp	r1, #1
    624e:	d938      	bls.n	62c2 <clk_switching_fix+0x2ee>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6250:	f248 0300 	movw	r3, #32768	; 0x8000
    6254:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6258:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
    625c:	f890 c001 	ldrb.w	ip, [r0, #1]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    6260:	f424 1e60 	bic.w	lr, r4, #3670016	; 0x380000
            temp |= ((uint32_t)(sequence[var]) << 19);
    6264:	ea4e 42cc 	orr.w	r2, lr, ip, lsl #19
            SYSREG->MSSDDR_FACC1_CR = temp;
    6268:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    626c:	2202      	movs	r2, #2
    626e:	4291      	cmp	r1, r2
    6270:	f001 0401 	and.w	r4, r1, #1
    6274:	d925      	bls.n	62c2 <clk_switching_fix+0x2ee>
    6276:	b164      	cbz	r4, 6292 <clk_switching_fix+0x2be>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6278:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
    627c:	f890 e002 	ldrb.w	lr, [r0, #2]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    6280:	f424 1260 	bic.w	r2, r4, #3670016	; 0x380000
            temp |= ((uint32_t)(sequence[var]) << 19);
    6284:	ea42 44ce 	orr.w	r4, r2, lr, lsl #19
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    6288:	2203      	movs	r2, #3
    628a:	4291      	cmp	r1, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
            SYSREG->MSSDDR_FACC1_CR = temp;
    628c:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    6290:	d917      	bls.n	62c2 <clk_switching_fix+0x2ee>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6292:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
    6296:	f810 c002 	ldrb.w	ip, [r0, r2]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    629a:	f424 1e60 	bic.w	lr, r4, #3670016	; 0x380000
            temp |= ((uint32_t)(sequence[var]) << 19);
    629e:	ea4e 44cc 	orr.w	r4, lr, ip, lsl #19
            SYSREG->MSSDDR_FACC1_CR = temp;
    62a2:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    62a6:	3201      	adds	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    62a8:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
    62ac:	f810 c002 	ldrb.w	ip, [r0, r2]
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    62b0:	f424 1e60 	bic.w	lr, r4, #3670016	; 0x380000
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    62b4:	3201      	adds	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
    62b6:	ea4e 44cc 	orr.w	r4, lr, ip, lsl #19
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    62ba:	4291      	cmp	r1, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var]) << 19);
            SYSREG->MSSDDR_FACC1_CR = temp;
    62bc:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
        }

        /* For FIC64_DIVISOR setting */
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
        sequence = determine_seq(divisor[3], &len);
        for(var = 1; var < len; var++)
    62c0:	d8e7      	bhi.n	6292 <clk_switching_fix+0x2be>

        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 1 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from CLK_STANDBY
         * clock.
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR | 0x00001000u;
    62c2:	f248 0300 	movw	r3, #32768	; 0x8000
    62c6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    62ca:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    62ce:	2000      	movs	r0, #0
    62d0:	f442 5180 	orr.w	r1, r2, #4096	; 0x1000
    62d4:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
    62d8:	e6dc      	b.n	6094 <clk_switching_fix+0xc0>
        divisor[2] = ((g_mssddr_facc1_cr >> 9) & 0x00000007);
        divisor[3] = ((g_mssddr_facc1_cr >> 19) & 0x00000007);
       
        for(var = 1; var < 4; var++)
        {
            if((divisor[var] != divisor[0]) || \
    62da:	2001      	movs	r0, #1
    62dc:	e6da      	b.n	6094 <clk_switching_fix+0xc0>
    62de:	bf00      	nop

000062e0 <asynchronous_event_handler>:
#define TAMPER_HARDWARE_MONITOR_ERROR_OPCODE_RANGE_MAX   0xB7u

#define FACC_GLMUX_SEL_MASK         0x00001000u
#define DELAY_MORE_THAN_10US        5000U
static void asynchronous_event_handler(uint8_t event_opcode)
{
    62e0:	b570      	push	{r4, r5, r6, lr}
    if (event_opcode == FLASH_FREEZE_SHUTDOWN_OPCODE)
    62e2:	28e0      	cmp	r0, #224	; 0xe0
#define TAMPER_HARDWARE_MONITOR_ERROR_OPCODE_RANGE_MAX   0xB7u

#define FACC_GLMUX_SEL_MASK         0x00001000u
#define DELAY_MORE_THAN_10US        5000U
static void asynchronous_event_handler(uint8_t event_opcode)
{
    62e4:	b082      	sub	sp, #8
    if (event_opcode == FLASH_FREEZE_SHUTDOWN_OPCODE)
    62e6:	d01f      	beq.n	6328 <asynchronous_event_handler+0x48>
        if(g_event_handler != 0)
        {
            g_event_handler(event_opcode, g_response[1]);
        }
    }
    else if (event_opcode == FLASH_FREEZE_EXIT_OPCODE)
    62e8:	28e1      	cmp	r0, #225	; 0xe1
    62ea:	d03a      	beq.n	6362 <asynchronous_event_handler+0x82>
            g_event_handler(event_opcode, g_response[1]);
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
    62ec:	f080 0c80 	eor.w	ip, r0, #128	; 0x80
    62f0:	28f1      	cmp	r0, #241	; 0xf1
    62f2:	bf14      	ite	ne
    62f4:	2100      	movne	r1, #0
    62f6:	2101      	moveq	r1, #1
    62f8:	f1bc 0f1f 	cmp.w	ip, #31
    62fc:	bf98      	it	ls
    62fe:	f041 0101 	orrls.w	r1, r1, #1
    6302:	b149      	cbz	r1, 6318 <asynchronous_event_handler+0x38>
            /* 
             * Inform to the application that new asynchronous message is received, 
             * only if application call-back function is registered during 
             * initialization. 
             */
            if(g_event_handler != 0)
    6304:	f640 22fc 	movw	r2, #2812	; 0xafc
    6308:	f2c2 0200 	movt	r2, #8192	; 0x2000
    630c:	6913      	ldr	r3, [r2, #16]
    630e:	b10b      	cbz	r3, 6314 <asynchronous_event_handler+0x34>
            {
                /* Call the user's event handler. */
                g_event_handler(event_opcode, g_response[1]);
    6310:	7d51      	ldrb	r1, [r2, #21]
    6312:	4798      	blx	r3
            }
        }
    }
}
    6314:	b002      	add	sp, #8
    6316:	bd70      	pop	{r4, r5, r6, pc}
            g_event_handler(event_opcode, g_response[1]);
        }
    }
    else
    {
        if ((event_opcode == POR_DIGEST_ERROR_OPCODE) || \
    6318:	28a0      	cmp	r0, #160	; 0xa0
    631a:	d0f3      	beq.n	6304 <asynchronous_event_handler+0x24>
    631c:	f100 024f 	add.w	r2, r0, #79	; 0x4f
    6320:	b2d3      	uxtb	r3, r2
    6322:	2b06      	cmp	r3, #6
    6324:	d9ee      	bls.n	6304 <asynchronous_event_handler+0x24>
    6326:	e7f5      	b.n	6314 <asynchronous_event_handler+0x34>
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    6328:	f248 0100 	movw	r1, #32768	; 0x8000
        /*
         * Wait for the System Controller to switch the system's clock
         * from the main clock to the  standby clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
    632c:	f241 3388 	movw	r3, #5000	; 0x1388
    6330:	9301      	str	r3, [sp, #4]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    6332:	f2c4 0103 	movt	r1, #16387	; 0x4003
    6336:	f8d1 0098 	ldr.w	r0, [r1, #152]	; 0x98
            --timeout;
    633a:	9b01      	ldr	r3, [sp, #4]
    633c:	1e5a      	subs	r2, r3, #1
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
    633e:	f410 5f80 	tst.w	r0, #4096	; 0x1000
         */
        timeout = DELAY_MORE_THAN_10US;
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
            --timeout;
    6342:	9201      	str	r2, [sp, #4]
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
    6344:	d102      	bne.n	634c <asynchronous_event_handler+0x6c>
    6346:	9801      	ldr	r0, [sp, #4]
    6348:	2800      	cmp	r0, #0
    634a:	d1f4      	bne.n	6336 <asynchronous_event_handler+0x56>

        /* Call the user's event handler. */
        if(g_event_handler != 0)
    634c:	f640 22fc 	movw	r2, #2812	; 0xafc
    6350:	f2c2 0200 	movt	r2, #8192	; 0x2000
    6354:	6913      	ldr	r3, [r2, #16]
    6356:	2b00      	cmp	r3, #0
    6358:	d0dc      	beq.n	6314 <asynchronous_event_handler+0x34>
        {
            g_event_handler(event_opcode, g_response[1]);
    635a:	7d51      	ldrb	r1, [r2, #21]
    635c:	20e0      	movs	r0, #224	; 0xe0
    635e:	4798      	blx	r3
    6360:	e7d8      	b.n	6314 <asynchronous_event_handler+0x34>
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    6362:	f248 0100 	movw	r1, #32768	; 0x8000
        /*
         * Wait for the System Controller to switch the system's clock
         * from the standby clock to the main clock. This should take place
         * within 10us of receiving the shut-down event.
         */
        timeout = DELAY_MORE_THAN_10US;
    6366:	f241 3488 	movw	r4, #5000	; 0x1388
    636a:	9400      	str	r4, [sp, #0]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    636c:	f2c4 0103 	movt	r1, #16387	; 0x4003
    6370:	f8d1 5098 	ldr.w	r5, [r1, #152]	; 0x98
            --timeout;
    6374:	9b00      	ldr	r3, [sp, #0]
    6376:	1e5a      	subs	r2, r3, #1
        }
        while ((running_on_standby_clock != 0U) && (timeout != 0U));
    6378:	f415 5f80 	tst.w	r5, #4096	; 0x1000
         */
        timeout = DELAY_MORE_THAN_10US;
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
            --timeout;
    637c:	9200      	str	r2, [sp, #0]
        }
        while ((running_on_standby_clock != 0U) && (timeout != 0U));
    637e:	d002      	beq.n	6386 <asynchronous_event_handler+0xa6>
    6380:	9800      	ldr	r0, [sp, #0]
    6382:	2800      	cmp	r0, #0
    6384:	d1f4      	bne.n	6370 <asynchronous_event_handler+0x90>
    uint8_t len;
    uint8_t var = 0;
    uint32_t temp = 0;
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    6386:	f248 0500 	movw	r5, #32768	; 0x8000
    638a:	f2c4 0503 	movt	r5, #16387	; 0x4003
    638e:	f8d5 314c 	ldr.w	r3, [r5, #332]	; 0x14c

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
    6392:	f64f 0c07 	movw	ip, #63495	; 0xf807
    uint8_t len;
    uint8_t var = 0;
    uint32_t temp = 0;
    uint32_t device_version;

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    6396:	b29b      	uxth	r3, r3

    /* Revert back values for 10/25/50/90/150 devices */
    if((0xF802u == device_version) || (0xF803u == device_version) || \
    6398:	f5a3 4078 	sub.w	r0, r3, #63488	; 0xf800
    639c:	1e82      	subs	r2, r0, #2
    639e:	4563      	cmp	r3, ip
    63a0:	bf14      	ite	ne
    63a2:	2100      	movne	r1, #0
    63a4:	2101      	moveq	r1, #1
    63a6:	2a02      	cmp	r2, #2
    63a8:	bf8c      	ite	hi
    63aa:	460c      	movhi	r4, r1
    63ac:	f041 0401 	orrls.w	r4, r1, #1
    63b0:	b9b4      	cbnz	r4, 63e0 <asynchronous_event_handler+0x100>
    63b2:	f64f 0406 	movw	r4, #63494	; 0xf806
    63b6:	42a3      	cmp	r3, r4
    63b8:	d012      	beq.n	63e0 <asynchronous_event_handler+0x100>
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
    }

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    63ba:	f64f 0c05 	movw	ip, #63493	; 0xf805
    63be:	f640 24fc 	movw	r4, #2812	; 0xafc
    63c2:	4563      	cmp	r3, ip
    63c4:	f2c2 0400 	movt	r4, #8192	; 0x2000
    63c8:	d016      	beq.n	63f8 <asynchronous_event_handler+0x118>
        while ((running_on_standby_clock != 0U) && (timeout != 0U));
        
        /* Restore the clock dividers values of FACC1 register. */
        revert_clk_config();
        
        if(g_event_handler != 0)
    63ca:	6923      	ldr	r3, [r4, #16]
    63cc:	f640 22fc 	movw	r2, #2812	; 0xafc
    63d0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    63d4:	2b00      	cmp	r3, #0
    63d6:	d09d      	beq.n	6314 <asynchronous_event_handler+0x34>
        {
            /* Call the user's event handler. */
            g_event_handler(event_opcode, g_response[1]);
    63d8:	7d51      	ldrb	r1, [r2, #21]
    63da:	20e1      	movs	r0, #225	; 0xe1
    63dc:	4798      	blx	r3
    63de:	e799      	b.n	6314 <asynchronous_event_handler+0x34>
    if((0xF802u == device_version) || (0xF803u == device_version) || \
       (0xF804u == device_version)||(0xF807u == device_version) ||   \
       (0xF806u == device_version))
    {
        /* Restore the MSS clock dividers to their normal operations value. */
        SYSREG->MSSDDR_FACC1_CR = g_initial_mssddr_facc1_cr;
    63e0:	f640 24fc 	movw	r4, #2812	; 0xafc
    63e4:	f2c2 0400 	movt	r4, #8192	; 0x2000
    63e8:	69a2      	ldr	r2, [r4, #24]
    63ea:	f248 0100 	movw	r1, #32768	; 0x8000
    63ee:	f2c4 0103 	movt	r1, #16387	; 0x4003
    63f2:	f8c1 2098 	str.w	r2, [r1, #152]	; 0x98
    63f6:	e7e8      	b.n	63ca <asynchronous_event_handler+0xea>
    }

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
    63f8:	ae01      	add	r6, sp, #4
    63fa:	7820      	ldrb	r0, [r4, #0]
    63fc:	4631      	mov	r1, r6
    63fe:	f7ff fdb9 	bl	5f74 <determine_seq>
        for(var = len; var > 0; var--)
    6402:	f89d 3004 	ldrb.w	r3, [sp, #4]
    6406:	b363      	cbz	r3, 6462 <asynchronous_event_handler+0x182>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    6408:	181a      	adds	r2, r3, r0
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    640a:	f8d5 1098 	ldr.w	r1, [r5, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    640e:	f812 cc01 	ldrb.w	ip, [r2, #-1]
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    6412:	f021 0e1c 	bic.w	lr, r1, #28
    6416:	1e5a      	subs	r2, r3, #1
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    6418:	ea4e 018c 	orr.w	r1, lr, ip, lsl #2

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    641c:	b2d3      	uxtb	r3, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
    641e:	f8c5 1098 	str.w	r1, [r5, #152]	; 0x98
    6422:	f002 0201 	and.w	r2, r2, #1

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    6426:	b1e3      	cbz	r3, 6462 <asynchronous_event_handler+0x182>
    6428:	b962      	cbnz	r2, 6444 <asynchronous_event_handler+0x164>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    642a:	f8d5 2098 	ldr.w	r2, [r5, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    642e:	1819      	adds	r1, r3, r0
    6430:	f811 cc01 	ldrb.w	ip, [r1, #-1]
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    6434:	f022 0e1c 	bic.w	lr, r2, #28
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    6438:	ea4e 028c 	orr.w	r2, lr, ip, lsl #2

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    643c:	3b01      	subs	r3, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
    643e:	f8c5 2098 	str.w	r2, [r5, #152]	; 0x98

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    6442:	b2db      	uxtb	r3, r3
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6444:	f8d5 2098 	ldr.w	r2, [r5, #152]	; 0x98
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    6448:	1819      	adds	r1, r3, r0
    644a:	f811 cc01 	ldrb.w	ip, [r1, #-1]
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
    644e:	f022 0e1c 	bic.w	lr, r2, #28

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    6452:	3b01      	subs	r3, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
    6454:	ea4e 028c 	orr.w	r2, lr, ip, lsl #2

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    6458:	b2db      	uxtb	r3, r3
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFFE3u;
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
    645a:	f8c5 2098 	str.w	r2, [r5, #152]	; 0x98

    /* Revert back values for 05 devices in reverse sequence. */
    else if(0xF805u == device_version)
    {
        sequence = determine_seq(divisor[0], &len);
        for(var = len; var > 0; var--)
    645e:	2b00      	cmp	r3, #0
    6460:	d1e3      	bne.n	642a <asynchronous_event_handler+0x14a>
            temp |= ((uint32_t)(sequence[var - 1]) << 2);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
    6462:	7920      	ldrb	r0, [r4, #4]
    6464:	4631      	mov	r1, r6
    6466:	f7ff fd85 	bl	5f74 <determine_seq>
        for(var = len; var > 0; var--)
    646a:	f89d 2004 	ldrb.w	r2, [sp, #4]
    646e:	b382      	cbz	r2, 64d2 <asynchronous_event_handler+0x1f2>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6470:	f248 0300 	movw	r3, #32768	; 0x8000
    6474:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6478:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    647c:	1815      	adds	r5, r2, r0
    647e:	f815 5c01 	ldrb.w	r5, [r5, #-1]
        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    6482:	f021 0ee0 	bic.w	lr, r1, #224	; 0xe0
    6486:	1e51      	subs	r1, r2, #1
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    6488:	ea4e 1545 	orr.w	r5, lr, r5, lsl #5
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    648c:	b2ca      	uxtb	r2, r1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
    648e:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
    6492:	f001 0101 	and.w	r1, r1, #1
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    6496:	b1e2      	cbz	r2, 64d2 <asynchronous_event_handler+0x1f2>
    6498:	b961      	cbnz	r1, 64b4 <asynchronous_event_handler+0x1d4>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    649a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    649e:	1815      	adds	r5, r2, r0
    64a0:	f815 cc01 	ldrb.w	ip, [r5, #-1]
        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    64a4:	f021 0ee0 	bic.w	lr, r1, #224	; 0xe0
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    64a8:	ea4e 114c 	orr.w	r1, lr, ip, lsl #5
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    64ac:	3a01      	subs	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
    64ae:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    64b2:	b2d2      	uxtb	r2, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    64b4:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    64b8:	1815      	adds	r5, r2, r0
    64ba:	f815 cc01 	ldrb.w	ip, [r5, #-1]
        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
    64be:	f021 0ee0 	bic.w	lr, r1, #224	; 0xe0
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    64c2:	3a01      	subs	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
    64c4:	ea4e 114c 	orr.w	r1, lr, ip, lsl #5
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    64c8:	b2d2      	uxtb	r2, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFFF1Fu;
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
    64ca:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For APB1_DIVISOR setting */
        sequence = determine_seq(divisor[1], &len);
        for(var = len; var > 0; var--)
    64ce:	2a00      	cmp	r2, #0
    64d0:	d1e3      	bne.n	649a <asynchronous_event_handler+0x1ba>
            temp |= ((uint32_t)(sequence[var - 1]) << 5);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
    64d2:	7a20      	ldrb	r0, [r4, #8]
    64d4:	4631      	mov	r1, r6
    64d6:	f7ff fd4d 	bl	5f74 <determine_seq>
        for(var = len; var > 0; var--)
    64da:	f89d 2004 	ldrb.w	r2, [sp, #4]
    64de:	b382      	cbz	r2, 6542 <asynchronous_event_handler+0x262>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    64e0:	f248 0300 	movw	r3, #32768	; 0x8000
    64e4:	f2c4 0303 	movt	r3, #16387	; 0x4003
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    64e8:	1885      	adds	r5, r0, r2

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    64ea:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    64ee:	f815 ec01 	ldrb.w	lr, [r5, #-1]
        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    64f2:	f421 6c60 	bic.w	ip, r1, #3584	; 0xe00
    64f6:	1e51      	subs	r1, r2, #1
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    64f8:	ea4c 254e 	orr.w	r5, ip, lr, lsl #9
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    64fc:	b2ca      	uxtb	r2, r1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
    64fe:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
    6502:	f001 0101 	and.w	r1, r1, #1
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    6506:	b1e2      	cbz	r2, 6542 <asynchronous_event_handler+0x262>
    6508:	b961      	cbnz	r1, 6524 <asynchronous_event_handler+0x244>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    650a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    650e:	1885      	adds	r5, r0, r2
    6510:	f815 cc01 	ldrb.w	ip, [r5, #-1]
        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    6514:	f421 6e60 	bic.w	lr, r1, #3584	; 0xe00
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    6518:	ea4e 214c 	orr.w	r1, lr, ip, lsl #9
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    651c:	3a01      	subs	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
    651e:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    6522:	b2d2      	uxtb	r2, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6524:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    6528:	1885      	adds	r5, r0, r2
    652a:	f815 cc01 	ldrb.w	ip, [r5, #-1]
        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
    652e:	f421 6e60 	bic.w	lr, r1, #3584	; 0xe00
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    6532:	3a01      	subs	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
    6534:	ea4e 214c 	orr.w	r1, lr, ip, lsl #9
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    6538:	b2d2      	uxtb	r2, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFFFF1FFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
    653a:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For M3_CLK_DIVISOR setting */
        sequence = determine_seq(divisor[2], &len);
        for(var = len; var > 0; var--)
    653e:	2a00      	cmp	r2, #0
    6540:	d1e3      	bne.n	650a <asynchronous_event_handler+0x22a>
            temp |= ((uint32_t)(sequence[var - 1]) << 9);
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
    6542:	4631      	mov	r1, r6
    6544:	7b20      	ldrb	r0, [r4, #12]
    6546:	f7ff fd15 	bl	5f74 <determine_seq>
        for(var = len; var > 0; var--)
    654a:	f89d 2004 	ldrb.w	r2, [sp, #4]
    654e:	b382      	cbz	r2, 65b2 <asynchronous_event_handler+0x2d2>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6550:	f248 0300 	movw	r3, #32768	; 0x8000
    6554:	f2c4 0303 	movt	r3, #16387	; 0x4003
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    6558:	1885      	adds	r5, r0, r2

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    655a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    655e:	f815 ec01 	ldrb.w	lr, [r5, #-1]
        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    6562:	f421 1c60 	bic.w	ip, r1, #3670016	; 0x380000
    6566:	1e51      	subs	r1, r2, #1
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    6568:	ea4c 45ce 	orr.w	r5, ip, lr, lsl #19
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    656c:	b2ca      	uxtb	r2, r1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
            SYSREG->MSSDDR_FACC1_CR = temp;
    656e:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
    6572:	f001 0101 	and.w	r1, r1, #1
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    6576:	b1e2      	cbz	r2, 65b2 <asynchronous_event_handler+0x2d2>
    6578:	b961      	cbnz	r1, 6594 <asynchronous_event_handler+0x2b4>
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    657a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    657e:	1885      	adds	r5, r0, r2
    6580:	f815 cc01 	ldrb.w	ip, [r5, #-1]
        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    6584:	f421 1e60 	bic.w	lr, r1, #3670016	; 0x380000
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    6588:	ea4e 41cc 	orr.w	r1, lr, ip, lsl #19
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    658c:	3a01      	subs	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
            SYSREG->MSSDDR_FACC1_CR = temp;
    658e:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    6592:	b2d2      	uxtb	r2, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
    6594:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    6598:	1885      	adds	r5, r0, r2
    659a:	f815 cc01 	ldrb.w	ip, [r5, #-1]
        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
    659e:	f421 1e60 	bic.w	lr, r1, #3670016	; 0x380000
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    65a2:	3a01      	subs	r2, #1
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
    65a4:	ea4e 41cc 	orr.w	r1, lr, ip, lsl #19
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    65a8:	b2d2      	uxtb	r2, r2
        {
            temp = SYSREG->MSSDDR_FACC1_CR;
            temp &= 0xFFC7FFFFu;
            temp |= ((uint32_t)(sequence[var - 1]) << 19);
            SYSREG->MSSDDR_FACC1_CR = temp;
    65aa:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
            SYSREG->MSSDDR_FACC1_CR = temp;
        }

        /* For FIC64_DIVISOR setting */
        sequence = determine_seq(divisor[3], &len);
        for(var = len; var > 0; var--)
    65ae:	2a00      	cmp	r2, #0
    65b0:	d1e3      	bne.n	657a <asynchronous_event_handler+0x29a>
        
        /* Set the value of FACC_GLMUX_SEL bitfield of FACC1 register to 0 so 
         * that M3_CLK, PCLK0, PCLK1, CLK_FIC64 all driven from stage 2 
         * dividers (from CLK_SRC).
         */
        SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & 0xFFFFEFFFu;
    65b2:	f248 0300 	movw	r3, #32768	; 0x8000
    65b6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    65ba:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    65be:	f422 5080 	bic.w	r0, r2, #4096	; 0x1000
    65c2:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
    65c6:	e700      	b.n	63ca <asynchronous_event_handler+0xea>

000065c8 <isp_page_read_handler>:

static uint32_t isp_page_read_handler
(
    uint8_t const ** pp_next_page
)
{
    65c8:	b530      	push	{r4, r5, lr}
    uint32_t remaining_length = 0;
    uint32_t running_on_standby_clock;
    volatile uint32_t timeout;
    
    if((g_mode !=  MSS_SYS_PROG_AUTHENTICATE) & (wait_for_clock_switch == 1))
    65ca:	f640 23fc 	movw	r3, #2812	; 0xafc
    65ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
    65d2:	f240 429c 	movw	r2, #1180	; 0x49c
    65d6:	f2c2 0200 	movt	r2, #8192	; 0x2000
    65da:	7f19      	ldrb	r1, [r3, #28]
    65dc:	f892 c01a 	ldrb.w	ip, [r2, #26]
    65e0:	3900      	subs	r1, #0
    65e2:	bf18      	it	ne
    65e4:	2101      	movne	r1, #1
    65e6:	f1bc 0f01 	cmp.w	ip, #1
    65ea:	bf14      	ite	ne
    65ec:	2100      	movne	r1, #0
    65ee:	f001 0101 	andeq.w	r1, r1, #1

static uint32_t isp_page_read_handler
(
    uint8_t const ** pp_next_page
)
{
    65f2:	b083      	sub	sp, #12
    uint32_t remaining_length = 0;
    uint32_t running_on_standby_clock;
    volatile uint32_t timeout;
    
    if((g_mode !=  MSS_SYS_PROG_AUTHENTICATE) & (wait_for_clock_switch == 1))
    65f4:	b199      	cbz	r1, 661e <isp_page_read_handler+0x56>
    {
        timeout = DELAY_MORE_THAN_10US;
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    65f6:	f248 0500 	movw	r5, #32768	; 0x8000
    uint32_t running_on_standby_clock;
    volatile uint32_t timeout;
    
    if((g_mode !=  MSS_SYS_PROG_AUTHENTICATE) & (wait_for_clock_switch == 1))
    {
        timeout = DELAY_MORE_THAN_10US;
    65fa:	f241 3488 	movw	r4, #5000	; 0x1388
    65fe:	9401      	str	r4, [sp, #4]
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    6600:	f2c4 0503 	movt	r5, #16387	; 0x4003
    6604:	f8d5 1098 	ldr.w	r1, [r5, #152]	; 0x98
            --timeout;
    6608:	9c01      	ldr	r4, [sp, #4]
    660a:	3c01      	subs	r4, #1
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
    660c:	f411 5f80 	tst.w	r1, #4096	; 0x1000
    {
        timeout = DELAY_MORE_THAN_10US;
        do
        {
            running_on_standby_clock = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
            --timeout;
    6610:	9401      	str	r4, [sp, #4]
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
    6612:	d102      	bne.n	661a <isp_page_read_handler+0x52>
    6614:	9901      	ldr	r1, [sp, #4]
    6616:	2900      	cmp	r1, #0
    6618:	d1f4      	bne.n	6604 <isp_page_read_handler+0x3c>
        wait_for_clock_switch = 0;
    661a:	2100      	movs	r1, #0
    661c:	7691      	strb	r1, [r2, #26]
    }
    
    if(g_isp_page_read_handler != 0)
    661e:	6a1b      	ldr	r3, [r3, #32]
    6620:	b113      	cbz	r3, 6628 <isp_page_read_handler+0x60>
    {
        remaining_length = g_isp_page_read_handler(pp_next_page);
    6622:	4798      	blx	r3
    }
    
    return remaining_length;
}
    6624:	b003      	add	sp, #12
    6626:	bd30      	pop	{r4, r5, pc}
        }
        while ((running_on_standby_clock == 0U) && (timeout != 0U));
        wait_for_clock_switch = 0;
    }
    
    if(g_isp_page_read_handler != 0)
    6628:	4618      	mov	r0, r3
    662a:	e7fb      	b.n	6624 <isp_page_read_handler+0x5c>

0000662c <isp_sys_completion_handler>:
static void isp_sys_completion_handler
(
    uint8_t * p_response, 
    uint16_t length
)
{    
    662c:	b508      	push	{r3, lr}
    if(g_mode != MSS_SYS_PROG_AUTHENTICATE)
    662e:	f640 23fc 	movw	r3, #2812	; 0xafc
    6632:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6636:	7f1a      	ldrb	r2, [r3, #28]
    6638:	b162      	cbz	r2, 6654 <isp_sys_completion_handler+0x28>
    {
        /*
         * Restore the eNVM's frequency range to the values used before ISP was
         * started.
         */
        SYSREG->ENVM_CR = g_initial_envm_cr;
    663a:	f240 429c 	movw	r2, #1180	; 0x49c
    663e:	f2c2 0200 	movt	r2, #8192	; 0x2000
    6642:	69d1      	ldr	r1, [r2, #28]
    6644:	f248 0200 	movw	r2, #32768	; 0x8000
    6648:	f2c4 0203 	movt	r2, #16387	; 0x4003
    664c:	60d1      	str	r1, [r2, #12]
      
        /*
         * Restore the MSS DDR FACC 2 configuration to the values used before ISP 
         * was started.
         */
        SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
    664e:	6a59      	ldr	r1, [r3, #36]	; 0x24
    6650:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
    }
    
    if(g_isp_completion_handler != 0)
    6654:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6656:	b10b      	cbz	r3, 665c <isp_sys_completion_handler+0x30>
    {
        g_isp_completion_handler(p_response[1]);
    6658:	7840      	ldrb	r0, [r0, #1]
    665a:	4798      	blx	r3
    665c:	bd08      	pop	{r3, pc}
    665e:	bf00      	nop

00006660 <request_completion_handler>:
(
    uint8_t * p_response,
    uint16_t response_size
)
{
    g_request_in_progress = 0u;
    6660:	f640 23fc 	movw	r3, #2812	; 0xafc
    6664:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6668:	2200      	movs	r2, #0
    666a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    g_last_response_length = response_size;
    666e:	85d9      	strh	r1, [r3, #46]	; 0x2e
}
    6670:	4770      	bx	lr
    6672:	bf00      	nop

00006674 <MSS_SYS_clear_mesh_short>:
 */
uint8_t MSS_SYS_clear_mesh_short
(
    void
)
{
    6674:	b5f0      	push	{r4, r5, r6, r7, lr}
    6676:	f640 24fc 	movw	r4, #2812	; 0xafc
    667a:	b087      	sub	sp, #28
    667c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6680:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6684:	f640 25fc 	movw	r5, #2812	; 0xafc
    6688:	f2c2 0500 	movt	r5, #8192	; 0x2000
    668c:	469c      	mov	ip, r3
    668e:	2b00      	cmp	r3, #0
    6690:	d1f6      	bne.n	6680 <MSS_SYS_clear_mesh_short+0xc>
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x20u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6692:	2702      	movs	r7, #2
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6694:	f04f 0e01 	mov.w	lr, #1
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x20u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6698:	f246 6661 	movw	r6, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    669c:	f885 e02c 	strb.w	lr, [r5, #44]	; 0x2c
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x20u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    66a0:	f2c0 0600 	movt	r6, #0
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    66a4:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    66a8:	f04f 0e1f 	mov.w	lr, #31
    tamper_control_req[1] = 0x20u;
    66ac:	f04f 0c20 	mov.w	ip, #32

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    66b0:	ad04      	add	r5, sp, #16
    66b2:	461a      	mov	r2, r3
    66b4:	4639      	mov	r1, r7
    66b6:	a805      	add	r0, sp, #20
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    66b8:	f88d e014 	strb.w	lr, [sp, #20]
    tamper_control_req[1] = 0x20u;
    66bc:	f88d c015 	strb.w	ip, [sp, #21]

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    66c0:	9500      	str	r5, [sp, #0]
    66c2:	9602      	str	r6, [sp, #8]
    66c4:	9701      	str	r7, [sp, #4]
    66c6:	f7ff f995 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    66ca:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    66ce:	f640 23fc 	movw	r3, #2812	; 0xafc
    66d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    66d6:	2a00      	cmp	r2, #0
    66d8:	d1f7      	bne.n	66ca <MSS_SYS_clear_mesh_short+0x56>
    {
        ;
    }
    
    return g_last_response_length;
    66da:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        TAMPER_CONTROL_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
    66dc:	2902      	cmp	r1, #2
    66de:	d002      	beq.n	66e6 <MSS_SYS_clear_mesh_short+0x72>
    66e0:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    66e2:	b007      	add	sp, #28
    66e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    66e6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    66ea:	2b1f      	cmp	r3, #31
    {
        status = response[1];
    66ec:	bf08      	it	eq
    66ee:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    66f2:	d1f5      	bne.n	66e0 <MSS_SYS_clear_mesh_short+0x6c>
    66f4:	e7f5      	b.n	66e2 <MSS_SYS_clear_mesh_short+0x6e>
    66f6:	bf00      	nop

000066f8 <MSS_SYS_clear_lock_parity>:
 */
uint8_t MSS_SYS_clear_lock_parity
(
    void
)
{
    66f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    66fa:	f640 24fc 	movw	r4, #2812	; 0xafc
    66fe:	b087      	sub	sp, #28
    6700:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6704:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6708:	f640 25fc 	movw	r5, #2812	; 0xafc
    670c:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6710:	469c      	mov	ip, r3
    6712:	2b00      	cmp	r3, #0
    6714:	d1f6      	bne.n	6704 <MSS_SYS_clear_lock_parity+0xc>
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6716:	f04f 0e01 	mov.w	lr, #1
    671a:	f885 e02c 	strb.w	lr, [r5, #44]	; 0x2c
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x10u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    671e:	2702      	movs	r7, #2
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6720:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x10u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6724:	f246 6661 	movw	r6, #26209	; 0x6661
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x10u;
    6728:	f04f 0c10 	mov.w	ip, #16

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    672c:	f2c0 0600 	movt	r6, #0
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    6730:	f04f 0e1f 	mov.w	lr, #31
    tamper_control_req[1] = 0x10u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6734:	eb0d 050c 	add.w	r5, sp, ip
    6738:	461a      	mov	r2, r3
    673a:	4639      	mov	r1, r7
    673c:	a805      	add	r0, sp, #20
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    673e:	f88d e014 	strb.w	lr, [sp, #20]
    tamper_control_req[1] = 0x10u;
    6742:	f88d c015 	strb.w	ip, [sp, #21]

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6746:	9500      	str	r5, [sp, #0]
    6748:	9602      	str	r6, [sp, #8]
    674a:	9701      	str	r7, [sp, #4]
    674c:	f7ff f952 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6750:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6754:	f640 23fc 	movw	r3, #2812	; 0xafc
    6758:	f2c2 0300 	movt	r3, #8192	; 0x2000
    675c:	2a00      	cmp	r2, #0
    675e:	d1f7      	bne.n	6750 <MSS_SYS_clear_lock_parity+0x58>
    {
        ;
    }
    
    return g_last_response_length;
    6760:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        TAMPER_CONTROL_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
    6762:	2902      	cmp	r1, #2
    6764:	d002      	beq.n	676c <MSS_SYS_clear_lock_parity+0x74>
    6766:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    6768:	b007      	add	sp, #28
    676a:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    676c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6770:	2b1f      	cmp	r3, #31
    {
        status = response[1];
    6772:	bf08      	it	eq
    6774:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    6778:	d1f5      	bne.n	6766 <MSS_SYS_clear_lock_parity+0x6e>
    677a:	e7f5      	b.n	6768 <MSS_SYS_clear_lock_parity+0x70>

0000677c <MSS_SYS_disable_puf_power_down>:
 */
uint8_t MSS_SYS_disable_puf_power_down
(
    void
)
{
    677c:	b5f0      	push	{r4, r5, r6, r7, lr}
    677e:	f640 24fc 	movw	r4, #2812	; 0xafc
    6782:	b087      	sub	sp, #28
    6784:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6788:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    678c:	f640 25fc 	movw	r5, #2812	; 0xafc
    6790:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6794:	469c      	mov	ip, r3
    6796:	2b00      	cmp	r3, #0
    6798:	d1f6      	bne.n	6788 <MSS_SYS_disable_puf_power_down+0xc>
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x08u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    679a:	2702      	movs	r7, #2
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    679c:	f04f 0e01 	mov.w	lr, #1
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x08u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    67a0:	f246 6661 	movw	r6, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    67a4:	f885 e02c 	strb.w	lr, [r5, #44]	; 0x2c
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x08u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    67a8:	f2c0 0600 	movt	r6, #0
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    67ac:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    67b0:	f04f 0e1f 	mov.w	lr, #31
    tamper_control_req[1] = 0x08u;
    67b4:	f04f 0c08 	mov.w	ip, #8

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    67b8:	ad04      	add	r5, sp, #16
    67ba:	461a      	mov	r2, r3
    67bc:	4639      	mov	r1, r7
    67be:	a805      	add	r0, sp, #20
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    67c0:	f88d e014 	strb.w	lr, [sp, #20]
    tamper_control_req[1] = 0x08u;
    67c4:	f88d c015 	strb.w	ip, [sp, #21]

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    67c8:	9500      	str	r5, [sp, #0]
    67ca:	9602      	str	r6, [sp, #8]
    67cc:	9701      	str	r7, [sp, #4]
    67ce:	f7ff f911 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    67d2:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    67d6:	f640 23fc 	movw	r3, #2812	; 0xafc
    67da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    67de:	2a00      	cmp	r2, #0
    67e0:	d1f7      	bne.n	67d2 <MSS_SYS_disable_puf_power_down+0x56>
    {
        ;
    }
    
    return g_last_response_length;
    67e2:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        TAMPER_CONTROL_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
    67e4:	2902      	cmp	r1, #2
    67e6:	d002      	beq.n	67ee <MSS_SYS_disable_puf_power_down+0x72>
    67e8:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    67ea:	b007      	add	sp, #28
    67ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    67ee:	f89d 3010 	ldrb.w	r3, [sp, #16]
    67f2:	2b1f      	cmp	r3, #31
    {
        status = response[1];
    67f4:	bf08      	it	eq
    67f6:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    67fa:	d1f5      	bne.n	67e8 <MSS_SYS_disable_puf_power_down+0x6c>
    67fc:	e7f5      	b.n	67ea <MSS_SYS_disable_puf_power_down+0x6e>
    67fe:	bf00      	nop

00006800 <MSS_SYS_enable_puf_power_down>:
 */
uint8_t MSS_SYS_enable_puf_power_down
(
    void
)
{
    6800:	b5f0      	push	{r4, r5, r6, r7, lr}
    6802:	f640 24fc 	movw	r4, #2812	; 0xafc
    6806:	b087      	sub	sp, #28
    6808:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    680c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6810:	f640 25fc 	movw	r5, #2812	; 0xafc
    6814:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6818:	469c      	mov	ip, r3
    681a:	2b00      	cmp	r3, #0
    681c:	d1f6      	bne.n	680c <MSS_SYS_enable_puf_power_down+0xc>
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x04u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    681e:	2702      	movs	r7, #2
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6820:	f04f 0e01 	mov.w	lr, #1
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x04u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6824:	f246 6661 	movw	r6, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6828:	f885 e02c 	strb.w	lr, [r5, #44]	; 0x2c
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x04u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    682c:	f2c0 0600 	movt	r6, #0
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6830:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    6834:	f04f 0e1f 	mov.w	lr, #31
    tamper_control_req[1] = 0x04u;
    6838:	f04f 0c04 	mov.w	ip, #4

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    683c:	ad04      	add	r5, sp, #16
    683e:	461a      	mov	r2, r3
    6840:	4639      	mov	r1, r7
    6842:	a805      	add	r0, sp, #20
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    6844:	f88d e014 	strb.w	lr, [sp, #20]
    tamper_control_req[1] = 0x04u;
    6848:	f88d c015 	strb.w	ip, [sp, #21]

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    684c:	9500      	str	r5, [sp, #0]
    684e:	9602      	str	r6, [sp, #8]
    6850:	9701      	str	r7, [sp, #4]
    6852:	f7ff f8cf 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6856:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    685a:	f640 23fc 	movw	r3, #2812	; 0xafc
    685e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6862:	2a00      	cmp	r2, #0
    6864:	d1f7      	bne.n	6856 <MSS_SYS_enable_puf_power_down+0x56>
    {
        ;
    }
    
    return g_last_response_length;
    6866:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        TAMPER_CONTROL_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
    6868:	2902      	cmp	r1, #2
    686a:	d002      	beq.n	6872 <MSS_SYS_enable_puf_power_down+0x72>
    686c:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    686e:	b007      	add	sp, #28
    6870:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    6872:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6876:	2b1f      	cmp	r3, #31
    {
        status = response[1];
    6878:	bf08      	it	eq
    687a:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    687e:	d1f5      	bne.n	686c <MSS_SYS_enable_puf_power_down+0x6c>
    6880:	e7f5      	b.n	686e <MSS_SYS_enable_puf_power_down+0x6e>
    6882:	bf00      	nop

00006884 <MSS_SYS_stop_clock_monitor>:
 */
uint8_t MSS_SYS_stop_clock_monitor
(
    void
)
{
    6884:	b5f0      	push	{r4, r5, r6, r7, lr}
    6886:	f640 24fc 	movw	r4, #2812	; 0xafc
    688a:	b087      	sub	sp, #28
    688c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6890:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6894:	f640 25fc 	movw	r5, #2812	; 0xafc
    6898:	f2c2 0500 	movt	r5, #8192	; 0x2000
    689c:	469c      	mov	ip, r3
    689e:	2b00      	cmp	r3, #0
    68a0:	d1f6      	bne.n	6890 <MSS_SYS_stop_clock_monitor+0xc>
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x02u;
    68a2:	2602      	movs	r6, #2
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    68a4:	f04f 0e01 	mov.w	lr, #1
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x02u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    68a8:	f246 6761 	movw	r7, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    68ac:	f885 e02c 	strb.w	lr, [r5, #44]	; 0x2c
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x02u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    68b0:	f2c0 0700 	movt	r7, #0
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    68b4:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    68b8:	f04f 0e1f 	mov.w	lr, #31
    tamper_control_req[1] = 0x02u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    68bc:	ad04      	add	r5, sp, #16
    68be:	461a      	mov	r2, r3
    68c0:	4631      	mov	r1, r6
    68c2:	a805      	add	r0, sp, #20
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    68c4:	f88d e014 	strb.w	lr, [sp, #20]
    tamper_control_req[1] = 0x02u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    68c8:	9500      	str	r5, [sp, #0]
    68ca:	9702      	str	r7, [sp, #8]
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x02u;
    68cc:	f88d 6015 	strb.w	r6, [sp, #21]

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    68d0:	9601      	str	r6, [sp, #4]
    68d2:	f7ff f88f 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    68d6:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    68da:	f640 23fc 	movw	r3, #2812	; 0xafc
    68de:	f2c2 0300 	movt	r3, #8192	; 0x2000
    68e2:	2a00      	cmp	r2, #0
    68e4:	d1f7      	bne.n	68d6 <MSS_SYS_stop_clock_monitor+0x52>
    {
        ;
    }
    
    return g_last_response_length;
    68e6:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        TAMPER_CONTROL_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
    68e8:	2902      	cmp	r1, #2
    68ea:	d002      	beq.n	68f2 <MSS_SYS_stop_clock_monitor+0x6e>
    68ec:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    68ee:	b007      	add	sp, #28
    68f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    68f2:	f89d c010 	ldrb.w	ip, [sp, #16]
    68f6:	f1bc 0f1f 	cmp.w	ip, #31
    {
        status = response[1];
    68fa:	bf08      	it	eq
    68fc:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    6900:	d1f4      	bne.n	68ec <MSS_SYS_stop_clock_monitor+0x68>
    6902:	e7f4      	b.n	68ee <MSS_SYS_stop_clock_monitor+0x6a>

00006904 <MSS_SYS_start_clock_monitor>:
 */
uint8_t MSS_SYS_start_clock_monitor
(
    void
)
{
    6904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6908:	f640 24fc 	movw	r4, #2812	; 0xafc
    690c:	b086      	sub	sp, #24
    690e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6912:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6916:	f640 25fc 	movw	r5, #2812	; 0xafc
    691a:	f2c2 0500 	movt	r5, #8192	; 0x2000
    691e:	469c      	mov	ip, r3
    6920:	2b00      	cmp	r3, #0
    6922:	d1f6      	bne.n	6912 <MSS_SYS_start_clock_monitor+0xe>
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x01u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6924:	2702      	movs	r7, #2
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    6926:	f04f 0e1f 	mov.w	lr, #31
    tamper_control_req[1] = 0x01u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    692a:	f246 6661 	movw	r6, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    692e:	f04f 0801 	mov.w	r8, #1
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x01u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6932:	f2c0 0600 	movt	r6, #0
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    6936:	f88d e014 	strb.w	lr, [sp, #20]
    tamper_control_req[1] = 0x01u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    693a:	461a      	mov	r2, r3
    693c:	f10d 0e10 	add.w	lr, sp, #16
    6940:	4639      	mov	r1, r7
    6942:	a805      	add	r0, sp, #20
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6944:	f885 802c 	strb.w	r8, [r5, #44]	; 0x2c
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x01u;
    6948:	f88d 8015 	strb.w	r8, [sp, #21]

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    694c:	f8cd e000 	str.w	lr, [sp]
    6950:	9602      	str	r6, [sp, #8]
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6952:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    signal_request_start();
    
    tamper_control_req[0] = TAMPER_CONTROL_REQUEST_CMD;
    tamper_control_req[1] = 0x01u;

    MSS_COMBLK_send_cmd(tamper_control_req,                 /* p_cmd */
    6956:	9701      	str	r7, [sp, #4]
    6958:	f7ff f84c 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    695c:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6960:	f640 23fc 	movw	r3, #2812	; 0xafc
    6964:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6968:	2a00      	cmp	r2, #0
    696a:	d1f7      	bne.n	695c <MSS_SYS_start_clock_monitor+0x58>
    {
        ;
    }
    
    return g_last_response_length;
    696c:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        TAMPER_CONTROL_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
    696e:	2902      	cmp	r1, #2
    6970:	d003      	beq.n	697a <MSS_SYS_start_clock_monitor+0x76>
    6972:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    6974:	b006      	add	sp, #24
    6976:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    697a:	f89d c010 	ldrb.w	ip, [sp, #16]
    697e:	f1bc 0f1f 	cmp.w	ip, #31
    {
        status = response[1];
    6982:	bf08      	it	eq
    6984:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((TAMPER_CONTROL_SERV_RESP_LENGTH == actual_response_length) &&
       (TAMPER_CONTROL_REQUEST_CMD == response[0]))
    6988:	d1f3      	bne.n	6972 <MSS_SYS_start_clock_monitor+0x6e>
    698a:	e7f3      	b.n	6974 <MSS_SYS_start_clock_monitor+0x70>

0000698c <MSS_SYS_check_digest>:
 */
uint8_t MSS_SYS_check_digest
(
    uint8_t options
)
{
    698c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    
    /* SAR 80563
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    if(MSS_SYS_DIGEST_CHECK_FABRIC == (options & 0x01u))
    6990:	f010 0f01 	tst.w	r0, #1
 */
uint8_t MSS_SYS_check_digest
(
    uint8_t options
)
{
    6994:	b086      	sub	sp, #24
    6996:	4605      	mov	r5, r0
    
    /* SAR 80563
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    if(MSS_SYS_DIGEST_CHECK_FABRIC == (options & 0x01u))
    6998:	d140      	bne.n	6a1c <MSS_SYS_check_digest+0x90>
    699a:	f640 24fc 	movw	r4, #2812	; 0xafc
    699e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    69a2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    69a6:	f640 26fc 	movw	r6, #2812	; 0xafc
    69aa:	f2c2 0600 	movt	r6, #8192	; 0x2000
    69ae:	469c      	mov	ip, r3
    69b0:	2b00      	cmp	r3, #0
    69b2:	d1f6      	bne.n	69a2 <MSS_SYS_check_digest+0x16>
        signal_request_start();

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
        digest_check_req[1] = options;

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
    69b4:	f04f 0e02 	mov.w	lr, #2
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    69b8:	f04f 0801 	mov.w	r8, #1
        signal_request_start();

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
        digest_check_req[1] = options;

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
    69bc:	f246 6761 	movw	r7, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    69c0:	f886 802c 	strb.w	r8, [r6, #44]	; 0x2c
        signal_request_start();

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
        digest_check_req[1] = options;

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
    69c4:	f2c0 0700 	movt	r7, #0
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    {
      
        signal_request_start();

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
    69c8:	f04f 0817 	mov.w	r8, #23
        digest_check_req[1] = options;
    69cc:	f88d 5015 	strb.w	r5, [sp, #21]

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
    69d0:	461a      	mov	r2, r3
    69d2:	ad04      	add	r5, sp, #16
    69d4:	4671      	mov	r1, lr
    69d6:	a805      	add	r0, sp, #20
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    {
      
        signal_request_start();

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
    69d8:	f88d 8014 	strb.w	r8, [sp, #20]
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    69dc:	f8a6 c02e 	strh.w	ip, [r6, #46]	; 0x2e
        signal_request_start();

        digest_check_req[0] = DIGEST_CHECK_REQUEST_CMD;
        digest_check_req[1] = options;

        MSS_COMBLK_send_cmd(digest_check_req,               /* p_cmd */
    69e0:	9500      	str	r5, [sp, #0]
    69e2:	9702      	str	r7, [sp, #8]
    69e4:	f8cd e004 	str.w	lr, [sp, #4]
    69e8:	f7ff f804 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    69ec:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    69f0:	f640 23fc 	movw	r3, #2812	; 0xafc
    69f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    69f8:	2a00      	cmp	r2, #0
    69fa:	d1f7      	bne.n	69ec <MSS_SYS_check_digest+0x60>
    {
        ;
    }
    
    return g_last_response_length;
    69fc:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                            DIGEST_CHECK_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
    69fe:	2902      	cmp	r1, #2
    6a00:	d003      	beq.n	6a0a <MSS_SYS_check_digest+0x7e>
    6a02:	20c8      	movs	r0, #200	; 0xc8
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
    }
    
    return status;
}
    6a04:	b006      	add	sp, #24
    6a06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
           (DIGEST_CHECK_REQUEST_CMD == response[0]))
    6a0a:	f89d c010 	ldrb.w	ip, [sp, #16]
    6a0e:	f1bc 0f17 	cmp.w	ip, #23
        {
            status = response[1];
    6a12:	bf08      	it	eq
    6a14:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();

        if((DIGEST_CHECK_SERV_RESP_LENGTH == actual_response_length) &&
           (DIGEST_CHECK_REQUEST_CMD == response[0]))
    6a18:	d1f3      	bne.n	6a02 <MSS_SYS_check_digest+0x76>
    6a1a:	e7f3      	b.n	6a04 <MSS_SYS_check_digest+0x78>
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    if(MSS_SYS_DIGEST_CHECK_FABRIC == (options & 0x01u))
    {
        clk_switch_status = clk_switching_fix();
    6a1c:	f7ff fada 	bl	5fd4 <clk_switching_fix>
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    6a20:	2800      	cmp	r0, #0
    6a22:	d0ba      	beq.n	699a <MSS_SYS_check_digest+0xe>
    6a24:	20c9      	movs	r0, #201	; 0xc9
    6a26:	e7ed      	b.n	6a04 <MSS_SYS_check_digest+0x78>

00006a28 <MSS_SYS_initiate_iap>:
uint8_t MSS_SYS_initiate_iap
(
    uint8_t mode,
    uint32_t bitstream_spi_addr
)
{
    6a28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
    uint16_t actual_response_length;
    uint8_t iap_prog_req[6];
    uint8_t response[IAP_PROG_SERV_RESP_LENGTH];
    
    if(mode == MSS_SYS_PROG_VERIFY)
    6a2c:	2802      	cmp	r0, #2
uint8_t MSS_SYS_initiate_iap
(
    uint8_t mode,
    uint32_t bitstream_spi_addr
)
{
    6a2e:	b089      	sub	sp, #36	; 0x24
    6a30:	4605      	mov	r5, r0
    6a32:	460e      	mov	r6, r1
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
    uint16_t actual_response_length;
    uint8_t iap_prog_req[6];
    uint8_t response[IAP_PROG_SERV_RESP_LENGTH];
    
    if(mode == MSS_SYS_PROG_VERIFY)
    6a34:	d056      	beq.n	6ae4 <MSS_SYS_initiate_iap+0xbc>
         * Check fabric digest before performing IAP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
    }
    
    if(mode != MSS_SYS_PROG_AUTHENTICATE)
    6a36:	2800      	cmp	r0, #0
    6a38:	d157      	bne.n	6aea <MSS_SYS_initiate_iap+0xc2>
    6a3a:	f640 24fc 	movw	r4, #2812	; 0xafc
    6a3e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6a42:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6a46:	f640 27fc 	movw	r7, #2812	; 0xafc
    6a4a:	f2c2 0700 	movt	r7, #8192	; 0x2000
    6a4e:	469c      	mov	ip, r3
    6a50:	2b00      	cmp	r3, #0
    6a52:	d1f6      	bne.n	6a42 <MSS_SYS_initiate_iap+0x1a>
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6a54:	f04f 0801 	mov.w	r8, #1
    6a58:	f887 802c 	strb.w	r8, [r7, #44]	; 0x2c
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);

        signal_request_start();
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
    6a5c:	f246 6e61 	movw	lr, #26209	; 0x6661
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6a60:	f8a7 c02e 	strh.w	ip, [r7, #46]	; 0x2e
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);

        signal_request_start();
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
    6a64:	af07      	add	r7, sp, #28
        iap_prog_req[1] = mode;

        iap_prog_req[2] = (uint8_t)(bitstream_spi_addr);
        iap_prog_req[3] = (uint8_t)(bitstream_spi_addr >> 8u);
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);
    6a66:	ea4f 6b16 	mov.w	fp, r6, lsr #24

        signal_request_start();
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
    6a6a:	f2c0 0e00 	movt	lr, #0
         */
        iap_prog_req[0] = IAP_PROGRAMMING_REQUEST_CMD;
        iap_prog_req[1] = mode;

        iap_prog_req[2] = (uint8_t)(bitstream_spi_addr);
        iap_prog_req[3] = (uint8_t)(bitstream_spi_addr >> 8u);
    6a6e:	ea4f 2a16 	mov.w	sl, r6, lsr #8
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
    6a72:	ea4f 4916 	mov.w	r9, r6, lsr #16
    {
        /*
         * There is no response for Program mode because the Cortex-M3 will
         * get reset on completion of the system service.
         */
        iap_prog_req[0] = IAP_PROGRAMMING_REQUEST_CMD;
    6a76:	f04f 0814 	mov.w	r8, #20
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);

        signal_request_start();
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
    6a7a:	9700      	str	r7, [sp, #0]
    6a7c:	461a      	mov	r2, r3
    6a7e:	2702      	movs	r7, #2
    6a80:	a805      	add	r0, sp, #20
    6a82:	2106      	movs	r1, #6
    {
        /*
         * There is no response for Program mode because the Cortex-M3 will
         * get reset on completion of the system service.
         */
        iap_prog_req[0] = IAP_PROGRAMMING_REQUEST_CMD;
    6a84:	f88d 8014 	strb.w	r8, [sp, #20]
        iap_prog_req[1] = mode;

        iap_prog_req[2] = (uint8_t)(bitstream_spi_addr);
        iap_prog_req[3] = (uint8_t)(bitstream_spi_addr >> 8u);
    6a88:	f88d a017 	strb.w	sl, [sp, #23]
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
    6a8c:	f88d 9018 	strb.w	r9, [sp, #24]
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);
    6a90:	f88d b019 	strb.w	fp, [sp, #25]

        signal_request_start();
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
    6a94:	9701      	str	r7, [sp, #4]
    6a96:	f8cd e008 	str.w	lr, [sp, #8]
        /*
         * There is no response for Program mode because the Cortex-M3 will
         * get reset on completion of the system service.
         */
        iap_prog_req[0] = IAP_PROGRAMMING_REQUEST_CMD;
        iap_prog_req[1] = mode;
    6a9a:	f88d 5015 	strb.w	r5, [sp, #21]

        iap_prog_req[2] = (uint8_t)(bitstream_spi_addr);
    6a9e:	f88d 6016 	strb.w	r6, [sp, #22]
        iap_prog_req[4] = (uint8_t)(bitstream_spi_addr >> 16u);
        iap_prog_req[5] = (uint8_t)(bitstream_spi_addr >> 24u);

        signal_request_start();
        
        MSS_COMBLK_send_cmd(iap_prog_req,                   /* p_cmd */
    6aa2:	f7fe ffa7 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6aa6:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6aaa:	f640 23fc 	movw	r3, #2812	; 0xafc
    6aae:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ab2:	2a00      	cmp	r2, #0
    6ab4:	d1f7      	bne.n	6aa6 <MSS_SYS_initiate_iap+0x7e>
    {
        ;
    }
    
    return g_last_response_length;
    6ab6:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
        /*
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
    6aba:	f1bc 0f02 	cmp.w	ip, #2
    6abe:	d040      	beq.n	6b42 <MSS_SYS_initiate_iap+0x11a>
    6ac0:	20c8      	movs	r0, #200	; 0xc8
        else
        {
            status = MSS_SYS_UNEXPECTED_ERROR;
        }
        
        if(mode != MSS_SYS_PROG_AUTHENTICATE)
    6ac2:	b165      	cbz	r5, 6ade <MSS_SYS_initiate_iap+0xb6>
        {
            /* Restore back to original value. */
            SYSREG->ENVM_CR = g_initial_envm_cr;
    6ac4:	f240 429c 	movw	r2, #1180	; 0x49c
    6ac8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    6acc:	69d1      	ldr	r1, [r2, #28]
    6ace:	f248 0300 	movw	r3, #32768	; 0x8000
    6ad2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6ad6:	60d9      	str	r1, [r3, #12]
            SYSREG->MSSDDR_FACC2_CR = g_initial_mssddr_facc2_cr;
    6ad8:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6ada:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
    }
    
    return status;
}
    6ade:	b009      	add	sp, #36	; 0x24
    6ae0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(mode == MSS_SYS_PROG_VERIFY)
    {
        /*
         * Check fabric digest before performing IAP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
    6ae4:	2001      	movs	r0, #1
    6ae6:	f7ff ff51 	bl	698c <MSS_SYS_check_digest>
        /*
         * Keep a copy of the initial eNVM configuration used before IAP was
         * initiated. The eNVM configuration will be restored, as part of the IAP
         * completion handler, when IAP completes.
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;
    6aea:	f248 0300 	movw	r3, #32768	; 0x8000
    6aee:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6af2:	68d9      	ldr	r1, [r3, #12]
    6af4:	f240 449c 	movw	r4, #1180	; 0x49c
    6af8:	f2c2 0400 	movt	r4, #8192	; 0x2000
    6afc:	61e1      	str	r1, [r4, #28]
     
        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the IAP operation is completed.asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
    6afe:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    6b02:	f640 24fc 	movw	r4, #2812	; 0xafc
        
        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;                
    6b06:	f441 50ff 	orr.w	r0, r1, #8160	; 0x1fe0
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;
     
        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the IAP operation is completed.asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
    6b0a:	f2c2 0400 	movt	r4, #8192	; 0x2000
    6b0e:	6262      	str	r2, [r4, #36]	; 0x24
        
        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;                
    6b10:	60d8      	str	r0, [r3, #12]

        /* Select output of MUX 0, MUX 1 and MUX 2 during standby */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR & ((uint32_t)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) | ~FACC_STANDBY_SEL_MASK);
    6b12:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
    6b16:	f421 70e0 	bic.w	r0, r1, #448	; 0x1c0
    6b1a:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 50 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_25_50MHZ_EN << MSS_25_50MHZ_EN_SHIFT) & MSS_25_50MHZ_EN_MASK);
    6b1e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    6b22:	f442 7100 	orr.w	r1, r2, #512	; 0x200
    6b26:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
        
        /* Enable the signal for the 1 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_1MHZ_EN << MSS_1MHZ_EN_SHIFT) & MSS_1MHZ_EN_MASK);
    6b2a:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
    6b2e:	f440 6280 	orr.w	r2, r0, #1024	; 0x400
    6b32:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        
        /* SAR 80563
         * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
         * clk_fic64 to the divided by 32 versions based on device version.
         */
        clk_switch_status = clk_switching_fix();
    6b36:	f7ff fa4d 	bl	5fd4 <clk_switching_fix>
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    6b3a:	2800      	cmp	r0, #0
    6b3c:	d081      	beq.n	6a42 <MSS_SYS_initiate_iap+0x1a>
    6b3e:	20c9      	movs	r0, #201	; 0xc9
    6b40:	e7cd      	b.n	6ade <MSS_SYS_initiate_iap+0xb6>
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
           (IAP_PROGRAMMING_REQUEST_CMD == response[0]))
    6b42:	f89d 101c 	ldrb.w	r1, [sp, #28]
    6b46:	2914      	cmp	r1, #20
        {
            status = response[1];
    6b48:	bf08      	it	eq
    6b4a:	f89d 001d 	ldrbeq.w	r0, [sp, #29]
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
           (IAP_PROGRAMMING_REQUEST_CMD == response[0]))
    6b4e:	d0b8      	beq.n	6ac2 <MSS_SYS_initiate_iap+0x9a>
        /*
         * Handle case where service is not implemented/enabled in the device.
         */
        actual_response_length = wait_for_request_completion();
        
        if((IAP_PROG_SERV_RESP_LENGTH == actual_response_length) &&
    6b50:	20c8      	movs	r0, #200	; 0xc8
    6b52:	e7b6      	b.n	6ac2 <MSS_SYS_initiate_iap+0x9a>

00006b54 <MSS_SYS_zeroize_device>:

/*==============================================================================
 * See mss_sys_services.h for details.
 */
void MSS_SYS_zeroize_device(void)
{
    6b54:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b56:	f640 24fc 	movw	r4, #2812	; 0xafc
    6b5a:	b087      	sub	sp, #28
    6b5c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6b60:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6b64:	f640 25fc 	movw	r5, #2812	; 0xafc
    6b68:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6b6c:	461e      	mov	r6, r3
    6b6e:	2b00      	cmp	r3, #0
    6b70:	d1f6      	bne.n	6b60 <MSS_SYS_zeroize_device+0xc>
     * We only need to send one command byte to initiate zeroization.
     * The zeroization process should result in the Cortex-M3 being reset. This
     * means we should never reach the end of this function if zeroization is
     * actually performed.
     */
    uint8_t zeroization_req = ZEROIZATION_REQUEST_CMD;
    6b72:	f06f 010f 	mvn.w	r1, #15
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6b76:	f04f 0c01 	mov.w	ip, #1
     * We only need to send one command byte to initiate zeroization.
     * The zeroization process should result in the Cortex-M3 being reset. This
     * means we should never reach the end of this function if zeroization is
     * actually performed.
     */
    uint8_t zeroization_req = ZEROIZATION_REQUEST_CMD;
    6b7a:	a806      	add	r0, sp, #24
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd(&zeroization_req,               /* p_cmd */
    6b7c:	f246 6761 	movw	r7, #26209	; 0x6661
     * We only need to send one command byte to initiate zeroization.
     * The zeroization process should result in the Cortex-M3 being reset. This
     * means we should never reach the end of this function if zeroization is
     * actually performed.
     */
    uint8_t zeroization_req = ZEROIZATION_REQUEST_CMD;
    6b80:	f800 1d01 	strb.w	r1, [r0, #-1]!
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd(&zeroization_req,               /* p_cmd */
    6b84:	f2c0 0700 	movt	r7, #0
    6b88:	461a      	mov	r2, r3
    6b8a:	4661      	mov	r1, ip
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6b8c:	f885 c02c 	strb.w	ip, [r5, #44]	; 0x2c
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd(&zeroization_req,               /* p_cmd */
    6b90:	9702      	str	r7, [sp, #8]
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6b92:	85ee      	strh	r6, [r5, #46]	; 0x2e
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd(&zeroization_req,               /* p_cmd */
    6b94:	9600      	str	r6, [sp, #0]
    6b96:	9601      	str	r6, [sp, #4]
    6b98:	f7fe ff2c 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6b9c:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6ba0:	f640 23fc 	movw	r3, #2812	; 0xafc
    6ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6ba8:	2a00      	cmp	r2, #0
    6baa:	d1f7      	bne.n	6b9c <MSS_SYS_zeroize_device+0x48>
    {
        ;
    }
    
    return g_last_response_length;
    6bac:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    /*
     * Handle case where Zeroization is not enabled in the device in Release 
     * mode.
     */
    wait_for_request_completion();
}
    6bae:	b007      	add	sp, #28
    6bb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6bb2:	bf00      	nop

00006bb4 <MSS_SYS_nrbg_uninstantiate>:
 */
uint8_t MSS_SYS_nrbg_uninstantiate
(
    uint8_t nrbg_handle
)
{
    6bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    6bb6:	f640 24fc 	movw	r4, #2812	; 0xafc
    6bba:	b087      	sub	sp, #28
    6bbc:	4686      	mov	lr, r0
    6bbe:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6bc2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6bc6:	f640 25fc 	movw	r5, #2812	; 0xafc
    6bca:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6bce:	469c      	mov	ip, r3
    6bd0:	2b00      	cmp	r3, #0
    6bd2:	d1f6      	bne.n	6bc2 <MSS_SYS_nrbg_uninstantiate+0xe>
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6bd4:	2701      	movs	r7, #1
    6bd6:	f885 702c 	strb.w	r7, [r5, #44]	; 0x2c
    signal_request_start();
    
    uninstantiate_req[0] = NRBG_UNINSTANTIATE_REQUEST_CMD;
    uninstantiate_req[1] = nrbg_handle;

    MSS_COMBLK_send_cmd(uninstantiate_req,              /* p_cmd */
    6bda:	f246 6661 	movw	r6, #26209	; 0x6661
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6bde:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    signal_request_start();
    
    uninstantiate_req[0] = NRBG_UNINSTANTIATE_REQUEST_CMD;
    uninstantiate_req[1] = nrbg_handle;

    MSS_COMBLK_send_cmd(uninstantiate_req,              /* p_cmd */
    6be2:	ad04      	add	r5, sp, #16
    6be4:	f2c0 0600 	movt	r6, #0
    uint8_t uninstantiate_req[2];
    uint8_t response[NRBG_UNINST_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    uninstantiate_req[0] = NRBG_UNINSTANTIATE_REQUEST_CMD;
    6be8:	272c      	movs	r7, #44	; 0x2c
    uninstantiate_req[1] = nrbg_handle;

    MSS_COMBLK_send_cmd(uninstantiate_req,              /* p_cmd */
    6bea:	9500      	str	r5, [sp, #0]
    6bec:	461a      	mov	r2, r3
    6bee:	2503      	movs	r5, #3
    6bf0:	a805      	add	r0, sp, #20
    6bf2:	2102      	movs	r1, #2
    uint8_t uninstantiate_req[2];
    uint8_t response[NRBG_UNINST_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    uninstantiate_req[0] = NRBG_UNINSTANTIATE_REQUEST_CMD;
    6bf4:	f88d 7014 	strb.w	r7, [sp, #20]
    uninstantiate_req[1] = nrbg_handle;
    6bf8:	f88d e015 	strb.w	lr, [sp, #21]

    MSS_COMBLK_send_cmd(uninstantiate_req,              /* p_cmd */
    6bfc:	9501      	str	r5, [sp, #4]
    6bfe:	9602      	str	r6, [sp, #8]
    6c00:	f7fe fef8 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6c04:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6c08:	f640 23fc 	movw	r3, #2812	; 0xafc
    6c0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c10:	2a00      	cmp	r2, #0
    6c12:	d1f7      	bne.n	6c04 <MSS_SYS_nrbg_uninstantiate+0x50>
    {
        ;
    }
    
    return g_last_response_length;
    6c14:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        NRBG_UNINST_SERV_RESP_LENGTH,   /* response_size */
                        request_completion_handler);    /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((NRBG_UNINST_SERV_RESP_LENGTH == actual_response_length) &&
    6c16:	2903      	cmp	r1, #3
    6c18:	d002      	beq.n	6c20 <MSS_SYS_nrbg_uninstantiate+0x6c>
    6c1a:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    6c1c:	b007      	add	sp, #28
    6c1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);    /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((NRBG_UNINST_SERV_RESP_LENGTH == actual_response_length) &&
       (NRBG_UNINSTANTIATE_REQUEST_CMD == response[0]))
    6c20:	f89d c010 	ldrb.w	ip, [sp, #16]
    6c24:	f1bc 0f2c 	cmp.w	ip, #44	; 0x2c
    {
        status = response[1];
    6c28:	bf08      	it	eq
    6c2a:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                        request_completion_handler);    /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((NRBG_UNINST_SERV_RESP_LENGTH == actual_response_length) &&
       (NRBG_UNINSTANTIATE_REQUEST_CMD == response[0]))
    6c2e:	d1f4      	bne.n	6c1a <MSS_SYS_nrbg_uninstantiate+0x66>
    6c30:	e7f4      	b.n	6c1c <MSS_SYS_nrbg_uninstantiate+0x68>
    6c32:	bf00      	nop

00006c34 <MSS_SYS_nrbg_self_test>:

/*==============================================================================
 * See mss_sys_services.h for details.
 */
uint8_t MSS_SYS_nrbg_self_test(void)
{
    6c34:	b5f0      	push	{r4, r5, r6, r7, lr}
    6c36:	f640 24fc 	movw	r4, #2812	; 0xafc
    6c3a:	b087      	sub	sp, #28
    6c3c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6c40:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6c44:	f640 25fc 	movw	r5, #2812	; 0xafc
    6c48:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6c4c:	469c      	mov	ip, r3
    6c4e:	2b00      	cmp	r3, #0
    6c50:	d1f6      	bne.n	6c40 <MSS_SYS_nrbg_self_test+0xc>
    uint8_t self_test;
    uint8_t response[NRBG_SELF_TEST_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    self_test = NRBG_SELF_TEST_REQUEST_CMD;
    6c52:	2128      	movs	r1, #40	; 0x28
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6c54:	f04f 0e01 	mov.w	lr, #1
    
    signal_request_start();
    
    self_test = NRBG_SELF_TEST_REQUEST_CMD;

    MSS_COMBLK_send_cmd(&self_test,                         /* p_cmd */
    6c58:	af05      	add	r7, sp, #20
    uint8_t self_test;
    uint8_t response[NRBG_SELF_TEST_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    self_test = NRBG_SELF_TEST_REQUEST_CMD;
    6c5a:	a806      	add	r0, sp, #24

    MSS_COMBLK_send_cmd(&self_test,                         /* p_cmd */
    6c5c:	f246 6661 	movw	r6, #26209	; 0x6661
    uint8_t self_test;
    uint8_t response[NRBG_SELF_TEST_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    self_test = NRBG_SELF_TEST_REQUEST_CMD;
    6c60:	f800 1d01 	strb.w	r1, [r0, #-1]!

    MSS_COMBLK_send_cmd(&self_test,                         /* p_cmd */
    6c64:	f2c0 0600 	movt	r6, #0
    6c68:	9700      	str	r7, [sp, #0]
    6c6a:	461a      	mov	r2, r3
    6c6c:	2702      	movs	r7, #2
    6c6e:	4671      	mov	r1, lr
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6c70:	f885 e02c 	strb.w	lr, [r5, #44]	; 0x2c
    
    signal_request_start();
    
    self_test = NRBG_SELF_TEST_REQUEST_CMD;

    MSS_COMBLK_send_cmd(&self_test,                         /* p_cmd */
    6c74:	9701      	str	r7, [sp, #4]
    6c76:	9602      	str	r6, [sp, #8]
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6c78:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    
    signal_request_start();
    
    self_test = NRBG_SELF_TEST_REQUEST_CMD;

    MSS_COMBLK_send_cmd(&self_test,                         /* p_cmd */
    6c7c:	f7fe feba 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6c80:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6c84:	f640 23fc 	movw	r3, #2812	; 0xafc
    6c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6c8c:	2a00      	cmp	r2, #0
    6c8e:	d1f7      	bne.n	6c80 <MSS_SYS_nrbg_self_test+0x4c>
    {
        ;
    }
    
    return g_last_response_length;
    6c90:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
                        NRBG_SELF_TEST_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((NRBG_SELF_TEST_SERV_RESP_LENGTH == actual_response_length) &&
    6c94:	f1bc 0f02 	cmp.w	ip, #2
    6c98:	d002      	beq.n	6ca0 <MSS_SYS_nrbg_self_test+0x6c>
    6c9a:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    6c9c:	b007      	add	sp, #28
    6c9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((NRBG_SELF_TEST_SERV_RESP_LENGTH == actual_response_length) &&
       (NRBG_SELF_TEST_REQUEST_CMD == response[0]))
    6ca0:	f89d 3014 	ldrb.w	r3, [sp, #20]
    6ca4:	2b28      	cmp	r3, #40	; 0x28
    {
        status = response[1];
    6ca6:	bf08      	it	eq
    6ca8:	f89d 0015 	ldrbeq.w	r0, [sp, #21]
                        request_completion_handler);        /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((NRBG_SELF_TEST_SERV_RESP_LENGTH == actual_response_length) &&
       (NRBG_SELF_TEST_REQUEST_CMD == response[0]))
    6cac:	d1f5      	bne.n	6c9a <MSS_SYS_nrbg_self_test+0x66>
    6cae:	e7f5      	b.n	6c9c <MSS_SYS_nrbg_self_test+0x68>

00006cb0 <MSS_SYS_nrbg_reset>:

/*==============================================================================
 * See mss_sys_services.h for details.
 */
uint8_t MSS_SYS_nrbg_reset(void)
{
    6cb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    6cb2:	f640 24fc 	movw	r4, #2812	; 0xafc
    6cb6:	b087      	sub	sp, #28
    6cb8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6cbc:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6cc0:	f640 25fc 	movw	r5, #2812	; 0xafc
    6cc4:	f2c2 0500 	movt	r5, #8192	; 0x2000
    6cc8:	469c      	mov	ip, r3
    6cca:	2b00      	cmp	r3, #0
    6ccc:	d1f6      	bne.n	6cbc <MSS_SYS_nrbg_reset+0xc>
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6cce:	2701      	movs	r7, #1
    6cd0:	f885 702c 	strb.w	r7, [r5, #44]	; 0x2c
    reset_cmd[0] = NRBG_RESET_REQUEST_CMD;
    reset_cmd[1] = 0u;
    reset_cmd[2] = 0u;
    reset_cmd[3] = 0u;

    MSS_COMBLK_send_cmd(reset_cmd,                      /* p_cmd */
    6cd4:	f246 6661 	movw	r6, #26209	; 0x6661
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6cd8:	f8a5 c02e 	strh.w	ip, [r5, #46]	; 0x2e
    reset_cmd[0] = NRBG_RESET_REQUEST_CMD;
    reset_cmd[1] = 0u;
    reset_cmd[2] = 0u;
    reset_cmd[3] = 0u;

    MSS_COMBLK_send_cmd(reset_cmd,                      /* p_cmd */
    6cdc:	ad05      	add	r5, sp, #20
    6cde:	f2c0 0600 	movt	r6, #0
    uint8_t reset_cmd[4];
    uint8_t response[NRBG_RESET_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    reset_cmd[0] = NRBG_RESET_REQUEST_CMD;
    6ce2:	272d      	movs	r7, #45	; 0x2d
    reset_cmd[1] = 0u;
    reset_cmd[2] = 0u;
    reset_cmd[3] = 0u;

    MSS_COMBLK_send_cmd(reset_cmd,                      /* p_cmd */
    6ce4:	9500      	str	r5, [sp, #0]
    6ce6:	461a      	mov	r2, r3
    6ce8:	2502      	movs	r5, #2
    6cea:	a804      	add	r0, sp, #16
    6cec:	2104      	movs	r1, #4
    uint8_t reset_cmd[4];
    uint8_t response[NRBG_RESET_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    reset_cmd[0] = NRBG_RESET_REQUEST_CMD;
    6cee:	f88d 7010 	strb.w	r7, [sp, #16]
    reset_cmd[1] = 0u;
    reset_cmd[2] = 0u;
    reset_cmd[3] = 0u;
    6cf2:	f88d c013 	strb.w	ip, [sp, #19]

    MSS_COMBLK_send_cmd(reset_cmd,                      /* p_cmd */
    6cf6:	9501      	str	r5, [sp, #4]
    6cf8:	9602      	str	r6, [sp, #8]
    uint8_t response[NRBG_RESET_SERV_RESP_LENGTH];
    
    signal_request_start();
    
    reset_cmd[0] = NRBG_RESET_REQUEST_CMD;
    reset_cmd[1] = 0u;
    6cfa:	f88d c011 	strb.w	ip, [sp, #17]
    reset_cmd[2] = 0u;
    6cfe:	f88d c012 	strb.w	ip, [sp, #18]
    reset_cmd[3] = 0u;

    MSS_COMBLK_send_cmd(reset_cmd,                      /* p_cmd */
    6d02:	f7fe fe77 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6d06:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6d0a:	f640 23fc 	movw	r3, #2812	; 0xafc
    6d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6d12:	2a00      	cmp	r2, #0
    6d14:	d1f7      	bne.n	6d06 <MSS_SYS_nrbg_reset+0x56>
    {
        ;
    }
    
    return g_last_response_length;
    6d16:	8dd9      	ldrh	r1, [r3, #46]	; 0x2e
                        DRBG_RESET_SERV_RESP_LENGTH,    /* response_size */
                        request_completion_handler);    /* completion_handler */
    
     actual_response_length = wait_for_request_completion();
    
    if((NRBG_RESET_SERV_RESP_LENGTH == actual_response_length) &&
    6d18:	2902      	cmp	r1, #2
    6d1a:	d002      	beq.n	6d22 <MSS_SYS_nrbg_reset+0x72>
    6d1c:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    6d1e:	b007      	add	sp, #28
    6d20:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        request_completion_handler);    /* completion_handler */
    
     actual_response_length = wait_for_request_completion();
    
    if((NRBG_RESET_SERV_RESP_LENGTH == actual_response_length) &&
       (NRBG_RESET_REQUEST_CMD == response[0]))
    6d22:	f89d c014 	ldrb.w	ip, [sp, #20]
    6d26:	f1bc 0f2d 	cmp.w	ip, #45	; 0x2d
    {
        status = response[1];
    6d2a:	bf08      	it	eq
    6d2c:	f89d 0015 	ldrbeq.w	r0, [sp, #21]
                        request_completion_handler);    /* completion_handler */
    
     actual_response_length = wait_for_request_completion();
    
    if((NRBG_RESET_SERV_RESP_LENGTH == actual_response_length) &&
       (NRBG_RESET_REQUEST_CMD == response[0]))
    6d30:	d1f4      	bne.n	6d1c <MSS_SYS_nrbg_reset+0x6c>
    6d32:	e7f4      	b.n	6d1e <MSS_SYS_nrbg_reset+0x6e>

00006d34 <MSS_SYS_flash_freeze>:
        /* Do Nothing. */
    }
}

uint8_t MSS_SYS_flash_freeze(uint8_t options)
{
    6d34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    
    /*
     * Keep track of the clocks configuration before entering Flash*Freeze so
     * that it can be restored on Flash*Freeze exit.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    6d38:	f248 0600 	movw	r6, #32768	; 0x8000
    6d3c:	f2c4 0603 	movt	r6, #16387	; 0x4003
    6d40:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
    6d44:	f640 24fc 	movw	r4, #2812	; 0xafc
    6d48:	f2c2 0400 	movt	r4, #8192	; 0x2000
        /* Do Nothing. */
    }
}

uint8_t MSS_SYS_flash_freeze(uint8_t options)
{
    6d4c:	b086      	sub	sp, #24
    
    /*
     * Keep track of the clocks configuration before entering Flash*Freeze so
     * that it can be restored on Flash*Freeze exit.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    6d4e:	61a3      	str	r3, [r4, #24]
        /* Do Nothing. */
    }
}

uint8_t MSS_SYS_flash_freeze(uint8_t options)
{
    6d50:	4605      	mov	r5, r0
    
    /* SAR 80563
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    clk_switch_status = clk_switching_fix();
    6d52:	f7ff f93f 	bl	5fd4 <clk_switching_fix>

    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    6d56:	2800      	cmp	r0, #0
    6d58:	d13e      	bne.n	6dd8 <MSS_SYS_flash_freeze+0xa4>
    {
        /*
         * Enable RTC wake-up interrupt to System Controller and FPGA fabric.
         */
        SYSREG->RTC_WAKEUP_CR |= (RTC_WAKEUP_G4C_EN_MASK | RTC_WAKEUP_FAB_EN_MASK);
    6d5a:	f8d6 1088 	ldr.w	r1, [r6, #136]	; 0x88
    6d5e:	f041 0006 	orr.w	r0, r1, #6
    6d62:	f8c6 0088 	str.w	r0, [r6, #136]	; 0x88
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6d66:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6d6a:	f640 26fc 	movw	r6, #2812	; 0xafc
    6d6e:	f2c2 0600 	movt	r6, #8192	; 0x2000
    6d72:	4694      	mov	ip, r2
    6d74:	2a00      	cmp	r2, #0
    6d76:	d1f6      	bne.n	6d66 <MSS_SYS_flash_freeze+0x32>
         */
        SYSREG->RTC_WAKEUP_CR |= (RTC_WAKEUP_G4C_EN_MASK | RTC_WAKEUP_FAB_EN_MASK);

        signal_request_start();

        flash_freeze_req[0] = FLASH_FREEZE_REQUEST_CMD;
    6d78:	2702      	movs	r7, #2
        flash_freeze_req[1] = options;

        MSS_COMBLK_send_cmd(flash_freeze_req,               /* p_cmd */
    6d7a:	f246 6e61 	movw	lr, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6d7e:	f04f 0801 	mov.w	r8, #1
    6d82:	f886 802c 	strb.w	r8, [r6, #44]	; 0x2c
        signal_request_start();

        flash_freeze_req[0] = FLASH_FREEZE_REQUEST_CMD;
        flash_freeze_req[1] = options;

        MSS_COMBLK_send_cmd(flash_freeze_req,               /* p_cmd */
    6d86:	f2c0 0e00 	movt	lr, #0
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6d8a:	f8a6 c02e 	strh.w	ip, [r6, #46]	; 0x2e
        SYSREG->RTC_WAKEUP_CR |= (RTC_WAKEUP_G4C_EN_MASK | RTC_WAKEUP_FAB_EN_MASK);

        signal_request_start();

        flash_freeze_req[0] = FLASH_FREEZE_REQUEST_CMD;
        flash_freeze_req[1] = options;
    6d8e:	f88d 5015 	strb.w	r5, [sp, #21]

        MSS_COMBLK_send_cmd(flash_freeze_req,               /* p_cmd */
    6d92:	4639      	mov	r1, r7
    6d94:	ad04      	add	r5, sp, #16
    6d96:	a805      	add	r0, sp, #20
    6d98:	4613      	mov	r3, r2
    6d9a:	9500      	str	r5, [sp, #0]
    6d9c:	f8cd e008 	str.w	lr, [sp, #8]
         */
        SYSREG->RTC_WAKEUP_CR |= (RTC_WAKEUP_G4C_EN_MASK | RTC_WAKEUP_FAB_EN_MASK);

        signal_request_start();

        flash_freeze_req[0] = FLASH_FREEZE_REQUEST_CMD;
    6da0:	f88d 7014 	strb.w	r7, [sp, #20]
        flash_freeze_req[1] = options;

        MSS_COMBLK_send_cmd(flash_freeze_req,               /* p_cmd */
    6da4:	9701      	str	r7, [sp, #4]
    6da6:	f7fe fe25 	bl	59f4 <MSS_COMBLK_send_cmd>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6daa:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
    6dae:	f640 23fc 	movw	r3, #2812	; 0xafc
    6db2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6db6:	2900      	cmp	r1, #0
    6db8:	d1f7      	bne.n	6daa <MSS_SYS_flash_freeze+0x76>
    {
        ;
    }
    
    return g_last_response_length;
    6dba:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
                            FLASH_FREEZE_SERV_RESP_LENGTH,  /* response_size */
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();
        
        if((FLASH_FREEZE_SERV_RESP_LENGTH == actual_response_length) &&
    6dbc:	2b02      	cmp	r3, #2
    6dbe:	d003      	beq.n	6dc8 <MSS_SYS_flash_freeze+0x94>
    6dc0:	20c8      	movs	r0, #200	; 0xc8
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
    }
    
    return status;
}
    6dc2:	b006      	add	sp, #24
    6dc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();
        
        if((FLASH_FREEZE_SERV_RESP_LENGTH == actual_response_length) &&
           (FLASH_FREEZE_REQUEST_CMD == response[0]))
    6dc8:	f89d 2010 	ldrb.w	r2, [sp, #16]
    6dcc:	2a02      	cmp	r2, #2
        {
            status = response[1];
    6dce:	bf08      	it	eq
    6dd0:	f89d 0011 	ldrbeq.w	r0, [sp, #17]
                            request_completion_handler);    /* completion_handler */

        actual_response_length = wait_for_request_completion();
        
        if((FLASH_FREEZE_SERV_RESP_LENGTH == actual_response_length) &&
           (FLASH_FREEZE_REQUEST_CMD == response[0]))
    6dd4:	d1f4      	bne.n	6dc0 <MSS_SYS_flash_freeze+0x8c>
    6dd6:	e7f4      	b.n	6dc2 <MSS_SYS_flash_freeze+0x8e>
     * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
     * clk_fic64 to the divided by 32 versions based on device version.
     */
    clk_switch_status = clk_switching_fix();

    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    6dd8:	20c9      	movs	r0, #201	; 0xc9
    6dda:	e7f2      	b.n	6dc2 <MSS_SYS_flash_freeze+0x8e>

00006ddc <MSS_SYS_ecc_get_base_point>:
 */
void MSS_SYS_ecc_get_base_point
(
    uint8_t* p_point_g
)
{
    6ddc:	b570      	push	{r4, r5, r6, lr}
        0xbf, 0x55, 0x29, 0x6c, 0x3a, 0x54, 0x5e, 0x38, 0x72, 0x76, 0x0a, 0xB7,
        0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf,
        0x92, 0x92, 0xdc, 0x29, 0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c,
        0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0, 0x0a, 0x60, 0xb1, 0xce,
        0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0x0e, 0x5F
    };
    6dde:	f648 6128 	movw	r1, #36392	; 0x8e28
 */
void MSS_SYS_ecc_get_base_point
(
    uint8_t* p_point_g
)
{
    6de2:	b098      	sub	sp, #96	; 0x60
        0xbf, 0x55, 0x29, 0x6c, 0x3a, 0x54, 0x5e, 0x38, 0x72, 0x76, 0x0a, 0xB7,
        0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf,
        0x92, 0x92, 0xdc, 0x29, 0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c,
        0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0, 0x0a, 0x60, 0xb1, 0xce,
        0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0x0e, 0x5F
    };
    6de4:	2460      	movs	r4, #96	; 0x60
 */
void MSS_SYS_ecc_get_base_point
(
    uint8_t* p_point_g
)
{
    6de6:	4606      	mov	r6, r0
        0xbf, 0x55, 0x29, 0x6c, 0x3a, 0x54, 0x5e, 0x38, 0x72, 0x76, 0x0a, 0xB7,
        0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf,
        0x92, 0x92, 0xdc, 0x29, 0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c,
        0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0, 0x0a, 0x60, 0xb1, 0xce,
        0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0x0e, 0x5F
    };
    6de8:	4622      	mov	r2, r4
    6dea:	f2c0 0100 	movt	r1, #0
    6dee:	4668      	mov	r0, sp
    6df0:	f001 fefa 	bl	8be8 <memcpy>
    
    memcpy(p_point_g, &base_point_g[0], sizeof(base_point_g));
    6df4:	4630      	mov	r0, r6
    6df6:	4669      	mov	r1, sp
    6df8:	4622      	mov	r2, r4
        0xbf, 0x55, 0x29, 0x6c, 0x3a, 0x54, 0x5e, 0x38, 0x72, 0x76, 0x0a, 0xB7,
        0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf,
        0x92, 0x92, 0xdc, 0x29, 0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c,
        0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0, 0x0a, 0x60, 0xb1, 0xce,
        0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0x0e, 0x5F
    };
    6dfa:	466d      	mov	r5, sp
    
    memcpy(p_point_g, &base_point_g[0], sizeof(base_point_g));
    6dfc:	f001 fef4 	bl	8be8 <memcpy>
}
    6e00:	b018      	add	sp, #96	; 0x60
    6e02:	bd70      	pop	{r4, r5, r6, pc}

00006e04 <execute_service>:
    uint8_t cmd_opcode,
    uint8_t * cmd_params_ptr,
    uint8_t * response,
    uint16_t response_length
)
{
    6e04:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    6e08:	f640 24fc 	movw	r4, #2812	; 0xafc
    6e0c:	b083      	sub	sp, #12
    6e0e:	4680      	mov	r8, r0
    6e10:	4616      	mov	r6, r2
    6e12:	461d      	mov	r5, r3
    6e14:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    6e18:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    6e1c:	f640 27fc 	movw	r7, #2812	; 0xafc
    6e20:	f2c2 0700 	movt	r7, #8192	; 0x2000
    6e24:	469c      	mov	ip, r3
    6e26:	2b00      	cmp	r3, #0
    6e28:	d1f6      	bne.n	6e18 <execute_service+0x14>
    uint8_t status;
    uint16_t actual_response_length;
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd_with_ptr(cmd_opcode,                    /* cmd_opcode */
    6e2a:	f246 6e61 	movw	lr, #26209	; 0x6661
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    6e2e:	f04f 0a01 	mov.w	sl, #1
    6e32:	f887 a02c 	strb.w	sl, [r7, #44]	; 0x2c
    uint8_t status;
    uint16_t actual_response_length;
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd_with_ptr(cmd_opcode,                    /* cmd_opcode */
    6e36:	f2c0 0e00 	movt	lr, #0
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    6e3a:	f8a7 c02e 	strh.w	ip, [r7, #46]	; 0x2e
    uint8_t status;
    uint16_t actual_response_length;
    
    signal_request_start();
    
    MSS_COMBLK_send_cmd_with_ptr(cmd_opcode,                    /* cmd_opcode */
    6e3e:	4640      	mov	r0, r8
    6e40:	4632      	mov	r2, r6
    6e42:	462b      	mov	r3, r5
    6e44:	f8cd e000 	str.w	lr, [sp]
    6e48:	f7fe fcd6 	bl	57f8 <MSS_COMBLK_send_cmd_with_ptr>
/*==============================================================================
 *
 */
static uint16_t wait_for_request_completion(void)
{
    while(g_request_in_progress)
    6e4c:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    6e50:	f640 23fc 	movw	r3, #2812	; 0xafc
    6e54:	f2c2 0300 	movt	r3, #8192	; 0x2000
    6e58:	2a00      	cmp	r2, #0
    6e5a:	d1f7      	bne.n	6e4c <execute_service+0x48>
    {
        ;
    }
    
    return g_last_response_length;
    6e5c:	f8b3 c02e 	ldrh.w	ip, [r3, #46]	; 0x2e
    6e60:	fa1f f18c 	uxth.w	r1, ip
                                 response_length,               /* response_size */
                                 request_completion_handler);   /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((response_length == actual_response_length) && (cmd_opcode == response[0]))
    6e64:	428d      	cmp	r5, r1
    6e66:	d003      	beq.n	6e70 <execute_service+0x6c>
    6e68:	20c8      	movs	r0, #200	; 0xc8
    {
        status = MSS_SYS_UNEXPECTED_ERROR;
    }
    
    return status;
}
    6e6a:	b003      	add	sp, #12
    6e6c:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
                                 response_length,               /* response_size */
                                 request_completion_handler);   /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((response_length == actual_response_length) && (cmd_opcode == response[0]))
    6e70:	7833      	ldrb	r3, [r6, #0]
    6e72:	4543      	cmp	r3, r8
    {
        status = response[1];
    6e74:	bf08      	it	eq
    6e76:	7870      	ldrbeq	r0, [r6, #1]
                                 response_length,               /* response_size */
                                 request_completion_handler);   /* completion_handler */
    
    actual_response_length = wait_for_request_completion();
    
    if((response_length == actual_response_length) && (cmd_opcode == response[0]))
    6e78:	d1f6      	bne.n	6e68 <execute_service+0x64>
    6e7a:	e7f6      	b.n	6e6a <execute_service+0x66>

00006e7c <MSS_SYS_ecc_point_addition>:
(
    uint8_t* p_point_p,
    uint8_t* p_point_q,
    uint8_t* p_point_r
)
{
    6e7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6e80:	0e13      	lsrs	r3, r2, #24
(
    uint8_t* p_point_p,
    uint8_t* p_point_q,
    uint8_t* p_point_r
)
{
    6e82:	b089      	sub	sp, #36	; 0x24
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6e84:	0c06      	lsrs	r6, r0, #16
(
    uint8_t* p_point_p,
    uint8_t* p_point_q,
    uint8_t* p_point_r
)
{
    6e86:	4604      	mov	r4, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6e88:	ea4f 6810 	mov.w	r8, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6e8c:	0a07      	lsrs	r7, r0, #8
    6e8e:	0a10      	lsrs	r0, r2, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6e90:	9301      	str	r3, [sp, #4]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6e92:	9000      	str	r0, [sp, #0]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6e94:	0c15      	lsrs	r5, r2, #16
    6e96:	f88d 600e 	strb.w	r6, [sp, #14]
    6e9a:	f88d 5016 	strb.w	r5, [sp, #22]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6e9e:	9e00      	ldr	r6, [sp, #0]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ea0:	9d01      	ldr	r5, [sp, #4]
(
    uint8_t* p_point_p,
    uint8_t* p_point_q,
    uint8_t* p_point_r
)
{
    6ea2:	468e      	mov	lr, r1
    6ea4:	4694      	mov	ip, r2
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ea6:	ea4f 6b11 	mov.w	fp, r1, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6eaa:	ea4f 2a11 	mov.w	sl, r1, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6eae:	ea4f 4911 	mov.w	r9, r1, lsr #16
    
    write_ptr_value_into_array(p_point_p, params, 0u);
    write_ptr_value_into_array(p_point_q, params, 4u);
    write_ptr_value_into_array(p_point_r, params, 8u);
    
    status = execute_service(POINT_ADDITION_REQUEST_CMD,
    6eb2:	2011      	movs	r0, #17
    6eb4:	a903      	add	r1, sp, #12
    6eb6:	aa06      	add	r2, sp, #24
    6eb8:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6eba:	f88d 700d 	strb.w	r7, [sp, #13]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ebe:	f88d 800f 	strb.w	r8, [sp, #15]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6ec2:	f88d a011 	strb.w	sl, [sp, #17]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6ec6:	f88d 9012 	strb.w	r9, [sp, #18]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6eca:	f88d b013 	strb.w	fp, [sp, #19]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6ece:	f88d 6015 	strb.w	r6, [sp, #21]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ed2:	f88d 5017 	strb.w	r5, [sp, #23]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    6ed6:	f88d 400c 	strb.w	r4, [sp, #12]
    6eda:	f88d e010 	strb.w	lr, [sp, #16]
    6ede:	f88d c014 	strb.w	ip, [sp, #20]
    
    write_ptr_value_into_array(p_point_p, params, 0u);
    write_ptr_value_into_array(p_point_q, params, 4u);
    write_ptr_value_into_array(p_point_r, params, 8u);
    
    status = execute_service(POINT_ADDITION_REQUEST_CMD,
    6ee2:	f7ff ff8f 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    return status;
}
    6ee6:	b009      	add	sp, #36	; 0x24
    6ee8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006eec <MSS_SYS_ecc_point_multiplication>:
(
    uint8_t* p_scalar_d,
    uint8_t* p_point_p,
    uint8_t* p_point_q
)
{
    6eec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ef0:	0e13      	lsrs	r3, r2, #24
(
    uint8_t* p_scalar_d,
    uint8_t* p_point_p,
    uint8_t* p_point_q
)
{
    6ef2:	b089      	sub	sp, #36	; 0x24
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6ef4:	0c06      	lsrs	r6, r0, #16
(
    uint8_t* p_scalar_d,
    uint8_t* p_point_p,
    uint8_t* p_point_q
)
{
    6ef6:	4604      	mov	r4, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ef8:	ea4f 6810 	mov.w	r8, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6efc:	0a07      	lsrs	r7, r0, #8
    6efe:	0a10      	lsrs	r0, r2, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f00:	9301      	str	r3, [sp, #4]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f02:	9000      	str	r0, [sp, #0]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6f04:	0c15      	lsrs	r5, r2, #16
    6f06:	f88d 600e 	strb.w	r6, [sp, #14]
    6f0a:	f88d 5016 	strb.w	r5, [sp, #22]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f0e:	9e00      	ldr	r6, [sp, #0]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f10:	9d01      	ldr	r5, [sp, #4]
(
    uint8_t* p_scalar_d,
    uint8_t* p_point_p,
    uint8_t* p_point_q
)
{
    6f12:	468e      	mov	lr, r1
    6f14:	4694      	mov	ip, r2
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f16:	ea4f 6b11 	mov.w	fp, r1, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f1a:	ea4f 2a11 	mov.w	sl, r1, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6f1e:	ea4f 4911 	mov.w	r9, r1, lsr #16
    
    write_ptr_value_into_array(p_scalar_d, params, 0u);
    write_ptr_value_into_array(p_point_p, params, 4u);
    write_ptr_value_into_array(p_point_q, params, 8u);
    
    status = execute_service(POINT_MULTIPLICATION_REQUEST_CMD,
    6f22:	2010      	movs	r0, #16
    6f24:	a903      	add	r1, sp, #12
    6f26:	aa06      	add	r2, sp, #24
    6f28:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f2a:	f88d 700d 	strb.w	r7, [sp, #13]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f2e:	f88d 800f 	strb.w	r8, [sp, #15]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f32:	f88d a011 	strb.w	sl, [sp, #17]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6f36:	f88d 9012 	strb.w	r9, [sp, #18]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f3a:	f88d b013 	strb.w	fp, [sp, #19]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f3e:	f88d 6015 	strb.w	r6, [sp, #21]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f42:	f88d 5017 	strb.w	r5, [sp, #23]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    6f46:	f88d 400c 	strb.w	r4, [sp, #12]
    6f4a:	f88d e010 	strb.w	lr, [sp, #16]
    6f4e:	f88d c014 	strb.w	ip, [sp, #20]
    
    write_ptr_value_into_array(p_scalar_d, params, 0u);
    write_ptr_value_into_array(p_point_p, params, 4u);
    write_ptr_value_into_array(p_point_q, params, 8u);
    
    status = execute_service(POINT_MULTIPLICATION_REQUEST_CMD,
    6f52:	f7ff ff57 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    return status;
}
    6f56:	b009      	add	sp, #36	; 0x24
    6f58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006f5c <MSS_SYS_puf_get_random_seed>:
 */
uint8_t MSS_SYS_puf_get_random_seed
(
    uint8_t* p_puf_seed
)
{
    6f5c:	b530      	push	{r4, r5, lr}
    6f5e:	b085      	sub	sp, #20
    6f60:	4684      	mov	ip, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f62:	ea4f 6e10 	mov.w	lr, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f66:	0a05      	lsrs	r5, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6f68:	0c04      	lsrs	r4, r0, #16
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    write_ptr_value_into_array(p_puf_seed, params, 0u);
    
    status = execute_service(PUF_SEED_REQUEST_CMD,
    6f6a:	a903      	add	r1, sp, #12
    6f6c:	201d      	movs	r0, #29
    6f6e:	aa01      	add	r2, sp, #4
    6f70:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f72:	f88d 500d 	strb.w	r5, [sp, #13]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6f76:	f88d 400e 	strb.w	r4, [sp, #14]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f7a:	f88d e00f 	strb.w	lr, [sp, #15]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    6f7e:	f88d c00c 	strb.w	ip, [sp, #12]
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    write_ptr_value_into_array(p_puf_seed, params, 0u);
    
    status = execute_service(PUF_SEED_REQUEST_CMD,
    6f82:	f7ff ff3f 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    return status;
}
    6f86:	b005      	add	sp, #20
    6f88:	bd30      	pop	{r4, r5, pc}
    6f8a:	bf00      	nop

00006f8c <MSS_SYS_puf_fetch_ecc_public_key>:
 */
uint8_t MSS_SYS_puf_fetch_ecc_public_key
(
    uint8_t* p_puf_public_key
)
{
    6f8c:	b530      	push	{r4, r5, lr}
    6f8e:	b085      	sub	sp, #20
    6f90:	4684      	mov	ip, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6f92:	ea4f 6e10 	mov.w	lr, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6f96:	0a05      	lsrs	r5, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6f98:	0c04      	lsrs	r4, r0, #16
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    write_ptr_value_into_array(p_puf_public_key, params, 0u);
    
    status = execute_service(PUF_ECC_PUBLIC_KEY_REQUEST_CMD,
    6f9a:	a903      	add	r1, sp, #12
    6f9c:	201c      	movs	r0, #28
    6f9e:	aa01      	add	r2, sp, #4
    6fa0:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6fa2:	f88d 500d 	strb.w	r5, [sp, #13]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6fa6:	f88d 400e 	strb.w	r4, [sp, #14]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6faa:	f88d e00f 	strb.w	lr, [sp, #15]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    6fae:	f88d c00c 	strb.w	ip, [sp, #12]
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    write_ptr_value_into_array(p_puf_public_key, params, 0u);
    
    status = execute_service(PUF_ECC_PUBLIC_KEY_REQUEST_CMD,
    6fb2:	f7ff ff27 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    return status;
}
    6fb6:	b005      	add	sp, #20
    6fb8:	bd30      	pop	{r4, r5, pc}
    6fba:	bf00      	nop

00006fbc <MSS_SYS_puf_import_keycodes>:
 */
uint8_t MSS_SYS_puf_import_keycodes
(
    uint8_t * p_keycodes
)
{
    6fbc:	b570      	push	{r4, r5, r6, lr}
    6fbe:	b086      	sub	sp, #24
    6fc0:	4684      	mov	ip, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6fc2:	ea4f 6e10 	mov.w	lr, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6fc6:	0a05      	lsrs	r5, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6fc8:	0c04      	lsrs	r4, r0, #16
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_IMPORT_ALL_KC_SUBCOMMAND;
    6fca:	2604      	movs	r6, #4
    
    write_ptr_value_into_array(p_keycodes, params, 1u);
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    6fcc:	201a      	movs	r0, #26
    6fce:	a901      	add	r1, sp, #4
    6fd0:	aa04      	add	r2, sp, #16
    6fd2:	2306      	movs	r3, #6
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_IMPORT_ALL_KC_SUBCOMMAND;
    6fd4:	f88d 6004 	strb.w	r6, [sp, #4]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6fd8:	f88d 5006 	strb.w	r5, [sp, #6]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6fdc:	f88d 4007 	strb.w	r4, [sp, #7]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6fe0:	f88d e008 	strb.w	lr, [sp, #8]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    6fe4:	f88d c005 	strb.w	ip, [sp, #5]

    params[0] = PUF_IMPORT_ALL_KC_SUBCOMMAND;
    
    write_ptr_value_into_array(p_keycodes, params, 1u);
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    6fe8:	f7ff ff0c 	bl	6e04 <execute_service>
                             params,
                             response,
                             PUF_IMPORT_ALL_KEYCODES_RESP_LENGTH);
        
    return status;
}
    6fec:	b006      	add	sp, #24
    6fee:	bd70      	pop	{r4, r5, r6, pc}

00006ff0 <MSS_SYS_puf_export_keycodes>:
 */
uint8_t MSS_SYS_puf_export_keycodes
(
    uint8_t * p_keycodes
)
{
    6ff0:	b570      	push	{r4, r5, r6, lr}
    6ff2:	b086      	sub	sp, #24
    6ff4:	4684      	mov	ip, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    6ff6:	ea4f 6e10 	mov.w	lr, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    6ffa:	0a05      	lsrs	r5, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    6ffc:	0c04      	lsrs	r4, r0, #16
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_EXPORT_ALL_KC_SUBCOMMAND;
    6ffe:	2603      	movs	r6, #3
    
    write_ptr_value_into_array(p_keycodes, params, 1u);
        
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    7000:	201a      	movs	r0, #26
    7002:	a901      	add	r1, sp, #4
    7004:	aa04      	add	r2, sp, #16
    7006:	2306      	movs	r3, #6
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_EXPORT_ALL_KC_SUBCOMMAND;
    7008:	f88d 6004 	strb.w	r6, [sp, #4]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    700c:	f88d 5006 	strb.w	r5, [sp, #6]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7010:	f88d 4007 	strb.w	r4, [sp, #7]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7014:	f88d e008 	strb.w	lr, [sp, #8]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    7018:	f88d c005 	strb.w	ip, [sp, #5]

    params[0] = PUF_EXPORT_ALL_KC_SUBCOMMAND;
    
    write_ptr_value_into_array(p_keycodes, params, 1u);
        
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    701c:	f7ff fef2 	bl	6e04 <execute_service>
                             params,
                             response,
                             PUF_EXPORT_ALL_KEYCODES_RESP_LENGTH);
       
    return status;
}
    7020:	b006      	add	sp, #24
    7022:	bd70      	pop	{r4, r5, r6, pc}

00007024 <MSS_SYS_puf_fetch_key>:
uint8_t MSS_SYS_puf_fetch_key
(
    uint8_t key_number,
    uint8_t ** pp_key
)
{
    7024:	b570      	push	{r4, r5, r6, lr}
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    write_ptr_value_into_array(*pp_key, params, 0u);
    7026:	680d      	ldr	r5, [r1, #0]
uint8_t MSS_SYS_puf_fetch_key
(
    uint8_t key_number,
    uint8_t ** pp_key
)
{
    7028:	b084      	sub	sp, #16
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    702a:	ea4f 6c15 	mov.w	ip, r5, lsr #24
uint8_t MSS_SYS_puf_fetch_key
(
    uint8_t key_number,
    uint8_t ** pp_key
)
{
    702e:	460c      	mov	r4, r1
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    write_ptr_value_into_array(*pp_key, params, 0u);
    
    params[4] = key_number;
    7030:	f88d 000c 	strb.w	r0, [sp, #12]
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7034:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    
    write_ptr_value_into_array(*pp_key, params, 0u);
    
    params[4] = key_number;
    
    status = execute_service(PUF_FETCH_KEY_REQUEST_CMD,
    7038:	a902      	add	r1, sp, #8
    703a:	466a      	mov	r2, sp
    703c:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    703e:	0a2e      	lsrs	r6, r5, #8
    
    write_ptr_value_into_array(*pp_key, params, 0u);
    
    params[4] = key_number;
    
    status = execute_service(PUF_FETCH_KEY_REQUEST_CMD,
    7040:	201b      	movs	r0, #27
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7042:	f88d c00b 	strb.w	ip, [sp, #11]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7046:	f88d 6009 	strb.w	r6, [sp, #9]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    704a:	f88d e00a 	strb.w	lr, [sp, #10]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    704e:	f88d 5008 	strb.w	r5, [sp, #8]
    
    write_ptr_value_into_array(*pp_key, params, 0u);
    
    params[4] = key_number;
    
    status = execute_service(PUF_FETCH_KEY_REQUEST_CMD,
    7052:	f7ff fed7 	bl	6e04 <execute_service>
)
{
    uint32_t var;
    
    var = (uint32_t)target_array[array_index + 3];
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index + 2];
    7056:	f89d 200b 	ldrb.w	r2, [sp, #11]
    705a:	f89d c00a 	ldrb.w	ip, [sp, #10]
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index + 1];
    705e:	f89d 1009 	ldrb.w	r1, [sp, #9]
)
{
    uint32_t var;
    
    var = (uint32_t)target_array[array_index + 3];
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index + 2];
    7062:	ea4c 2302 	orr.w	r3, ip, r2, lsl #8
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index + 1];
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index];
    
    *pointer = (uint8_t*)var;
    7066:	f89d 2008 	ldrb.w	r2, [sp, #8]
{
    uint32_t var;
    
    var = (uint32_t)target_array[array_index + 3];
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index + 2];
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index + 1];
    706a:	ea41 2c03 	orr.w	ip, r1, r3, lsl #8
    var = ((var << 8u) & 0xFFFFFF00) | target_array[array_index];
    
    *pointer = (uint8_t*)var;
    706e:	ea42 230c 	orr.w	r3, r2, ip, lsl #8
    7072:	6023      	str	r3, [r4, #0]
    {
        write_array_into_ptr_value(&(*pp_key), params, 0);
    }
    
    return status;
}
    7074:	b004      	add	sp, #16
    7076:	bd70      	pop	{r4, r5, r6, pc}

00007078 <MSS_SYS_puf_get_number_of_keys>:
 */
uint8_t MSS_SYS_puf_get_number_of_keys
(
    uint8_t* p_number_of_keys
)
{
    7078:	b5f0      	push	{r4, r5, r6, r7, lr}
    707a:	b087      	sub	sp, #28
    uint8_t response[6u] = { 0x00 };
    uint8_t params[11u] =  { 0x00 };
    707c:	a901      	add	r1, sp, #4
    707e:	1d0f      	adds	r7, r1, #4
uint8_t MSS_SYS_puf_get_number_of_keys
(
    uint8_t* p_number_of_keys
)
{
    uint8_t response[6u] = { 0x00 };
    7080:	2500      	movs	r5, #0
    uint8_t params[11u] =  { 0x00 };
    7082:	463e      	mov	r6, r7
    7084:	f846 5b04 	str.w	r5, [r6], #4
    7088:	3706      	adds	r7, #6
 */
uint8_t MSS_SYS_puf_get_number_of_keys
(
    uint8_t* p_number_of_keys
)
{
    708a:	4604      	mov	r4, r0
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_GET_NUMBER_OF_KC_SUBCOMMAND;    
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    708c:	2306      	movs	r3, #6
    708e:	201a      	movs	r0, #26
    7090:	aa04      	add	r2, sp, #16
(
    uint8_t* p_number_of_keys
)
{
    uint8_t response[6u] = { 0x00 };
    uint8_t params[11u] =  { 0x00 };
    7092:	8035      	strh	r5, [r6, #0]
    7094:	703d      	strb	r5, [r7, #0]
    7096:	9501      	str	r5, [sp, #4]
uint8_t MSS_SYS_puf_get_number_of_keys
(
    uint8_t* p_number_of_keys
)
{
    uint8_t response[6u] = { 0x00 };
    7098:	9504      	str	r5, [sp, #16]
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_GET_NUMBER_OF_KC_SUBCOMMAND;    
    709a:	f88d 5004 	strb.w	r5, [sp, #4]
uint8_t MSS_SYS_puf_get_number_of_keys
(
    uint8_t* p_number_of_keys
)
{
    uint8_t response[6u] = { 0x00 };
    709e:	f8ad 5014 	strh.w	r5, [sp, #20]
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_GET_NUMBER_OF_KC_SUBCOMMAND;    
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    70a2:	f7ff feaf 	bl	6e04 <execute_service>
                             params,
                             response,
                             PUF_GET_NUMBER_OF_KEYS_RESP_LENGTH);
    
    *p_number_of_keys = params[9];
    70a6:	f89d 300d 	ldrb.w	r3, [sp, #13]
    70aa:	7023      	strb	r3, [r4, #0]
    
    return status;
}
    70ac:	b007      	add	sp, #28
    70ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

000070b0 <MSS_SYS_puf_delete_key>:
 */
uint8_t MSS_SYS_puf_delete_key
(
    uint8_t key_number
)
{
    70b0:	b510      	push	{r4, lr}
    70b2:	b086      	sub	sp, #24
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_DELETE_KC_SUBCOMMAND;
    70b4:	f04f 0c05 	mov.w	ip, #5
    params[9] = key_number;
    70b8:	f88d 000d 	strb.w	r0, [sp, #13]
        
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    70bc:	a901      	add	r1, sp, #4
    70be:	aa04      	add	r2, sp, #16
    70c0:	2306      	movs	r3, #6
    70c2:	201a      	movs	r0, #26
)
{
    uint8_t response[6u];
    uint8_t params[11u];
    uint8_t status;
    uint8_t key_numbers = 0u;
    70c4:	2400      	movs	r4, #0
    70c6:	f88d 4017 	strb.w	r4, [sp, #23]
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params[0] = PUF_DELETE_KC_SUBCOMMAND;
    70ca:	f88d c004 	strb.w	ip, [sp, #4]
    params[9] = key_number;
        
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    70ce:	f7ff fe99 	bl	6e04 <execute_service>
    70d2:	4604      	mov	r4, r0
     * service, but system controller is not releasing back after completing the
     * operation. In order to unlock eNVM-1, call get number of key service. PUF
     * get number of key service will release the eNVM-1 lock after reading the 
     * number of keys enrolled.
     */
    MSS_SYS_puf_get_number_of_keys(&key_numbers);
    70d4:	f10d 0017 	add.w	r0, sp, #23
    70d8:	f7ff ffce 	bl	7078 <MSS_SYS_puf_get_number_of_keys>
    
    return status;
}
    70dc:	4620      	mov	r0, r4
    70de:	b006      	add	sp, #24
    70e0:	bd10      	pop	{r4, pc}
    70e2:	bf00      	nop

000070e4 <MSS_SYS_puf_enroll_key>:
    uint8_t key_number,
    uint16_t key_size,
    uint8_t* p_key_value,
    uint8_t* p_key_location
)
{
    70e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    if(p_key_value == 0)
    70e8:	4694      	mov	ip, r2
    uint8_t key_number,
    uint16_t key_size,
    uint8_t* p_key_value,
    uint8_t* p_key_location
)
{
    70ea:	b087      	sub	sp, #28
    70ec:	4605      	mov	r5, r0
    70ee:	460c      	mov	r4, r1
    70f0:	469e      	mov	lr, r3
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    if(p_key_value == 0)
    70f2:	2a00      	cmp	r2, #0
    70f4:	d034      	beq.n	7160 <MSS_SYS_puf_enroll_key+0x7c>
    {
        params[0] = PUF_CREATE_INT_KC_SUBCOMMAND;
    }
    else
    {
        params[0] = PUF_CREATE_EXT_KC_SUBCOMMAND;
    70f6:	2001      	movs	r0, #1
    70f8:	f88d 0004 	strb.w	r0, [sp, #4]
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    70fc:	ea4f 6a1e 	mov.w	sl, lr, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7100:	ea4f 6b1c 	mov.w	fp, ip, lsr #24
    7104:	ea4f 271e 	mov.w	r7, lr, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7108:	ea4f 481e 	mov.w	r8, lr, lsr #16
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    710c:	ea4f 291c 	mov.w	r9, ip, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7110:	ea4f 461c 	mov.w	r6, ip, lsr #16
    write_ptr_value_into_array(p_key_value, params, 5u);
    
    params[9] = key_number;
    params[10] = key_size;
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    7114:	a901      	add	r1, sp, #4
    7116:	aa04      	add	r2, sp, #16
    7118:	2306      	movs	r3, #6
    
    write_ptr_value_into_array(p_key_location, params, 1u);
    write_ptr_value_into_array(p_key_value, params, 5u);
    
    params[9] = key_number;
    params[10] = key_size;
    711a:	f88d 400e 	strb.w	r4, [sp, #14]
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    711e:	201a      	movs	r0, #26
)
{
    uint8_t response[6u];
    uint8_t params[11u];
    uint8_t status;
    uint8_t key_numbers = 0u;
    7120:	2400      	movs	r4, #0
    7122:	f88d 4017 	strb.w	r4, [sp, #23]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    7126:	f88d e005 	strb.w	lr, [sp, #5]
    712a:	f88d c009 	strb.w	ip, [sp, #9]
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    712e:	f88d 7006 	strb.w	r7, [sp, #6]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7132:	f88d 8007 	strb.w	r8, [sp, #7]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7136:	f88d a008 	strb.w	sl, [sp, #8]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    713a:	f88d 900a 	strb.w	r9, [sp, #10]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    713e:	f88d 600b 	strb.w	r6, [sp, #11]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7142:	f88d b00c 	strb.w	fp, [sp, #12]
    }
    
    write_ptr_value_into_array(p_key_location, params, 1u);
    write_ptr_value_into_array(p_key_value, params, 5u);
    
    params[9] = key_number;
    7146:	f88d 500d 	strb.w	r5, [sp, #13]
    params[10] = key_size;
    
    status = execute_service(PUF_USER_KEY_CODE_REQUEST_CMD,
    714a:	f7ff fe5b 	bl	6e04 <execute_service>
    714e:	4604      	mov	r4, r0
     * service, but system controller is not releasing back after completing the
     * operation. In order to unlock eNVM-1, call get number of key service. PUF
     * get number of key service will release the eNVM-1 lock after reading the 
     * number of keys enrolled.
     */
    MSS_SYS_puf_get_number_of_keys(&key_numbers);
    7150:	f10d 0017 	add.w	r0, sp, #23
    7154:	f7ff ff90 	bl	7078 <MSS_SYS_puf_get_number_of_keys>
       
    return status;
}
    7158:	4620      	mov	r0, r4
    715a:	b007      	add	sp, #28
    715c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    if(p_key_value == 0)
    {
        params[0] = PUF_CREATE_INT_KC_SUBCOMMAND;
    7160:	2302      	movs	r3, #2
    7162:	f88d 3004 	strb.w	r3, [sp, #4]
    7166:	e7c9      	b.n	70fc <MSS_SYS_puf_enroll_key+0x18>

00007168 <MSS_SYS_puf_delete_activation_code>:
 */
uint8_t MSS_SYS_puf_delete_activation_code
(
    void
)
{
    7168:	b510      	push	{r4, lr}
    716a:	b082      	sub	sp, #8
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    params = PUF_DELETE_USER_ACTIVATION_CODE;
    716c:	a902      	add	r1, sp, #8
    716e:	2301      	movs	r3, #1
    7170:	f801 3d01 	strb.w	r3, [r1, #-1]!
)
{
    uint8_t response[PUF_USER_ACTIVATION_CODE_RESP_LENGTH];
    uint8_t status;
    uint8_t params;
    uint8_t key_numbers = 0u;
    7174:	f04f 0c00 	mov.w	ip, #0
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    params = PUF_DELETE_USER_ACTIVATION_CODE;
    
    status = execute_service(PUF_ACTIVATION_CODE_REQUEST_CMD,
    7178:	aa01      	add	r2, sp, #4
    717a:	2302      	movs	r3, #2
    717c:	2019      	movs	r0, #25
)
{
    uint8_t response[PUF_USER_ACTIVATION_CODE_RESP_LENGTH];
    uint8_t status;
    uint8_t params;
    uint8_t key_numbers = 0u;
    717e:	f88d c006 	strb.w	ip, [sp, #6]
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    params = PUF_DELETE_USER_ACTIVATION_CODE;
    
    status = execute_service(PUF_ACTIVATION_CODE_REQUEST_CMD,
    7182:	f7ff fe3f 	bl	6e04 <execute_service>
    7186:	4604      	mov	r4, r0
     * code service, but system controller is not releasing back after 
     * completing the operation. In order to unlock eNVM-1, call get number of 
     * key service. PUF get number of key service will release the eNVM-1 lock
     * after reading the number of keys enrolled.
     */
    MSS_SYS_puf_get_number_of_keys(&key_numbers);
    7188:	f10d 0006 	add.w	r0, sp, #6
    718c:	f7ff ff74 	bl	7078 <MSS_SYS_puf_get_number_of_keys>
    
    return status;
}
    7190:	4620      	mov	r0, r4
    7192:	b002      	add	sp, #8
    7194:	bd10      	pop	{r4, pc}
    7196:	bf00      	nop

00007198 <MSS_SYS_puf_create_activation_code>:
 */
uint8_t MSS_SYS_puf_create_activation_code
(
    void
)
{
    7198:	b510      	push	{r4, lr}
    719a:	b082      	sub	sp, #8
    uint8_t response[PUF_USER_ACTIVATION_CODE_RESP_LENGTH];
    uint8_t status;
    uint8_t params;
    uint8_t key_numbers = 0u;
    719c:	f04f 0c00 	mov.w	ip, #0
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params = PUF_CREATE_USER_ACTIVATION_CODE;
    71a0:	a902      	add	r1, sp, #8
    71a2:	f801 cd01 	strb.w	ip, [r1, #-1]!
    
    status = execute_service(PUF_ACTIVATION_CODE_REQUEST_CMD,
    71a6:	aa01      	add	r2, sp, #4
    71a8:	2302      	movs	r3, #2
    71aa:	2019      	movs	r0, #25
)
{
    uint8_t response[PUF_USER_ACTIVATION_CODE_RESP_LENGTH];
    uint8_t status;
    uint8_t params;
    uint8_t key_numbers = 0u;
    71ac:	f88d c006 	strb.w	ip, [sp, #6]
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);

    params = PUF_CREATE_USER_ACTIVATION_CODE;
    
    status = execute_service(PUF_ACTIVATION_CODE_REQUEST_CMD,
    71b0:	f7ff fe28 	bl	6e04 <execute_service>
    71b4:	4604      	mov	r4, r0
     * code service, but system controller is not releasing back after 
     * completing the operation. In order to unlock eNVM-1, call get number of 
     * key service. PUF get number of key service will release the eNVM-1 lock
     * after reading the number of keys enrolled.
     */
    MSS_SYS_puf_get_number_of_keys(&key_numbers);
    71b6:	f10d 0006 	add.w	r0, sp, #6
    71ba:	f7ff ff5d 	bl	7078 <MSS_SYS_puf_get_number_of_keys>
    
    return status;
}
    71be:	4620      	mov	r0, r4
    71c0:	b002      	add	sp, #8
    71c2:	bd10      	pop	{r4, pc}

000071c4 <MSS_SYS_nrbg_reseed>:
(
    const uint8_t * p_additional_input,
    uint8_t additional_input_length,
    uint8_t nrbg_handle
)
{
    71c4:	b530      	push	{r4, r5, lr}
    71c6:	b085      	sub	sp, #20
    71c8:	4684      	mov	ip, r0
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    71ca:	ea4f 6e10 	mov.w	lr, r0, lsr #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    71ce:	0a05      	lsrs	r5, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    71d0:	0c04      	lsrs	r4, r0, #16
    uint8_t params[6];
    uint8_t status;

    write_ptr_value_into_array(p_additional_input, params, 0u);

    params[4] = (uint8_t)additional_input_length;
    71d2:	f88d 1004 	strb.w	r1, [sp, #4]
    params[5] = nrbg_handle;
    71d6:	f88d 2005 	strb.w	r2, [sp, #5]
    
    status = execute_service(NRBG_RESEED_REQUEST_CMD,
    71da:	202b      	movs	r0, #43	; 0x2b
    71dc:	4669      	mov	r1, sp
    71de:	aa02      	add	r2, sp, #8
    71e0:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    71e2:	f88d 5001 	strb.w	r5, [sp, #1]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    71e6:	f88d 4002 	strb.w	r4, [sp, #2]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    71ea:	f88d e003 	strb.w	lr, [sp, #3]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    71ee:	f88d c000 	strb.w	ip, [sp]
    write_ptr_value_into_array(p_additional_input, params, 0u);

    params[4] = (uint8_t)additional_input_length;
    params[5] = nrbg_handle;
    
    status = execute_service(NRBG_RESEED_REQUEST_CMD,
    71f2:	f7ff fe07 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    return status;
}
    71f6:	b005      	add	sp, #20
    71f8:	bd30      	pop	{r4, r5, pc}
    71fa:	bf00      	nop

000071fc <MSS_SYS_nrbg_generate>:
    uint8_t requested_length,
    uint8_t additional_input_length,
    uint8_t pr_req,
    uint8_t nrbg_handle
)
{
    71fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7200:	b087      	sub	sp, #28
    7202:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
    7206:	f89d b044 	ldrb.w	fp, [sp, #68]	; 0x44
    720a:	4686      	mov	lr, r0
    720c:	468c      	mov	ip, r1
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    720e:	0e05      	lsrs	r5, r0, #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7210:	ea4f 6a11 	mov.w	sl, r1, lsr #24
    7214:	0a07      	lsrs	r7, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7216:	0c06      	lsrs	r6, r0, #16
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7218:	ea4f 2811 	mov.w	r8, r1, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    721c:	0c0c      	lsrs	r4, r1, #16
    uint8_t status;

    write_ptr_value_into_array(p_requested_data, generate_params, 0u);
    write_ptr_value_into_array(p_additional_input, generate_params, 4u);

    generate_params[8] = requested_length;
    721e:	f88d 200c 	strb.w	r2, [sp, #12]
    generate_params[9] = additional_input_length;
    7222:	f88d 300d 	strb.w	r3, [sp, #13]
    generate_params[10] = pr_req;
    generate_params[11] = nrbg_handle;
    
    status = execute_service(NRBG_GENERATE_REQUEST_CMD,
    7226:	202a      	movs	r0, #42	; 0x2a
    7228:	a901      	add	r1, sp, #4
    722a:	aa04      	add	r2, sp, #16
    722c:	2306      	movs	r3, #6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    722e:	f88d 7005 	strb.w	r7, [sp, #5]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7232:	f88d 6006 	strb.w	r6, [sp, #6]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7236:	f88d 5007 	strb.w	r5, [sp, #7]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    723a:	f88d 8009 	strb.w	r8, [sp, #9]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    723e:	f88d 400a 	strb.w	r4, [sp, #10]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7242:	f88d a00b 	strb.w	sl, [sp, #11]
    write_ptr_value_into_array(p_requested_data, generate_params, 0u);
    write_ptr_value_into_array(p_additional_input, generate_params, 4u);

    generate_params[8] = requested_length;
    generate_params[9] = additional_input_length;
    generate_params[10] = pr_req;
    7246:	f88d 900e 	strb.w	r9, [sp, #14]
    generate_params[11] = nrbg_handle;
    724a:	f88d b00f 	strb.w	fp, [sp, #15]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    724e:	f88d e004 	strb.w	lr, [sp, #4]
    7252:	f88d c008 	strb.w	ip, [sp, #8]
    generate_params[8] = requested_length;
    generate_params[9] = additional_input_length;
    generate_params[10] = pr_req;
    generate_params[11] = nrbg_handle;
    
    status = execute_service(NRBG_GENERATE_REQUEST_CMD,
    7256:	f7ff fdd5 	bl	6e04 <execute_service>
                             generate_params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    return status;
}
    725a:	b007      	add	sp, #28
    725c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00007260 <MSS_SYS_nrbg_instantiate>:
(
    const uint8_t * personalization_str,
    uint16_t personalization_str_length,
    uint8_t * p_nrbg_handle
)
{
    7260:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t status;
    
    write_ptr_value_into_array(personalization_str, instantiate_params, 0u);
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    7264:	0a0c      	lsrs	r4, r1, #8
(
    const uint8_t * personalization_str,
    uint16_t personalization_str_length,
    uint8_t * p_nrbg_handle
)
{
    7266:	b084      	sub	sp, #16
    7268:	4684      	mov	ip, r0
    726a:	468e      	mov	lr, r1
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    726c:	0e05      	lsrs	r5, r0, #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    726e:	0a07      	lsrs	r7, r0, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7270:	0c06      	lsrs	r6, r0, #16
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    instantiate_params[6] = INVALID_NRBG_HANDLE;
    
    status = execute_service(NRBG_INSTANTIATE_REQUEST_CMD,
    7272:	2306      	movs	r3, #6
    uint8_t status;
    
    write_ptr_value_into_array(personalization_str, instantiate_params, 0u);
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    7274:	f88d 4005 	strb.w	r4, [sp, #5]
(
    const uint8_t * personalization_str,
    uint16_t personalization_str_length,
    uint8_t * p_nrbg_handle
)
{
    7278:	4690      	mov	r8, r2
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    instantiate_params[6] = INVALID_NRBG_HANDLE;
    
    status = execute_service(NRBG_INSTANTIATE_REQUEST_CMD,
    727a:	2029      	movs	r0, #41	; 0x29
    727c:	4669      	mov	r1, sp
    727e:	aa02      	add	r2, sp, #8
    
    write_ptr_value_into_array(personalization_str, instantiate_params, 0u);
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    instantiate_params[6] = INVALID_NRBG_HANDLE;
    7280:	f04f 34ff 	mov.w	r4, #4294967295
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7284:	f88d 7001 	strb.w	r7, [sp, #1]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7288:	f88d 6002 	strb.w	r6, [sp, #2]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    728c:	f88d 5003 	strb.w	r5, [sp, #3]
    
    write_ptr_value_into_array(personalization_str, instantiate_params, 0u);
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    instantiate_params[6] = INVALID_NRBG_HANDLE;
    7290:	f88d 4006 	strb.w	r4, [sp, #6]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    7294:	f88d c000 	strb.w	ip, [sp]
    uint8_t instantiate_params[7];
    uint8_t status;
    
    write_ptr_value_into_array(personalization_str, instantiate_params, 0u);
    
    instantiate_params[4] = (uint8_t)personalization_str_length;
    7298:	f88d e004 	strb.w	lr, [sp, #4]
    instantiate_params[5] = (uint8_t)(personalization_str_length >> 8u);
    instantiate_params[6] = INVALID_NRBG_HANDLE;
    
    status = execute_service(NRBG_INSTANTIATE_REQUEST_CMD,
    729c:	f7ff fdb2 	bl	6e04 <execute_service>
                             instantiate_params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
                             
    if(MSS_SYS_SUCCESS == status)
    72a0:	4603      	mov	r3, r0
    72a2:	b918      	cbnz	r0, 72ac <MSS_SYS_nrbg_instantiate+0x4c>
    {
        *p_nrbg_handle = instantiate_params[6];
    72a4:	f89d 2006 	ldrb.w	r2, [sp, #6]
    72a8:	f888 2000 	strb.w	r2, [r8]
    }
    
    return status;
}
    72ac:	4618      	mov	r0, r3
    72ae:	b004      	add	sp, #16
    72b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000072b4 <MSS_SYS_challenge_response>:
(
    uint8_t* p_key,
    uint8_t op_type,
    const uint8_t* path
)
{
    72b4:	b530      	push	{r4, r5, lr}
    72b6:	b089      	sub	sp, #36	; 0x24
    params[2] = (uint8_t)((uint32_t)p_key >> 16u);
    params[3] = (uint8_t)((uint32_t)p_key >> 24u);
    
    params[4] = op_type;
    
    memcpy(&params[5], path, KEYTREE_PATH_LENGTH);
    72b8:	466c      	mov	r4, sp
(
    uint8_t* p_key,
    uint8_t op_type,
    const uint8_t* path
)
{
    72ba:	4603      	mov	r3, r0
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)p_key);
    params[1] = (uint8_t)((uint32_t)p_key >> 8u);
    params[2] = (uint8_t)((uint32_t)p_key >> 16u);
    params[3] = (uint8_t)((uint32_t)p_key >> 24u);
    72bc:	ea4f 6c10 	mov.w	ip, r0, lsr #24
    uint8_t params[21];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)p_key);
    params[1] = (uint8_t)((uint32_t)p_key >> 8u);
    params[2] = (uint8_t)((uint32_t)p_key >> 16u);
    72c0:	ea4f 4e10 	mov.w	lr, r0, lsr #16
    params[3] = (uint8_t)((uint32_t)p_key >> 24u);
    
    params[4] = op_type;
    72c4:	f88d 1004 	strb.w	r1, [sp, #4]
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[21];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)p_key);
    params[1] = (uint8_t)((uint32_t)p_key >> 8u);
    72c8:	0a05      	lsrs	r5, r0, #8
    params[2] = (uint8_t)((uint32_t)p_key >> 16u);
    params[3] = (uint8_t)((uint32_t)p_key >> 24u);
    
    params[4] = op_type;
    
    memcpy(&params[5], path, KEYTREE_PATH_LENGTH);
    72ca:	4611      	mov	r1, r2
    72cc:	1d60      	adds	r0, r4, #5
    72ce:	2210      	movs	r2, #16
{
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[21];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)p_key);
    72d0:	f88d 3000 	strb.w	r3, [sp]
    params[1] = (uint8_t)((uint32_t)p_key >> 8u);
    72d4:	f88d 5001 	strb.w	r5, [sp, #1]
    params[2] = (uint8_t)((uint32_t)p_key >> 16u);
    72d8:	f88d e002 	strb.w	lr, [sp, #2]
    params[3] = (uint8_t)((uint32_t)p_key >> 24u);
    72dc:	f88d c003 	strb.w	ip, [sp, #3]
    
    params[4] = op_type;
    
    memcpy(&params[5], path, KEYTREE_PATH_LENGTH);
    72e0:	f001 fc82 	bl	8be8 <memcpy>
    
    status = execute_service(PPUF_CHALLENGE_RESP_REQUEST_CMD,
    72e4:	4669      	mov	r1, sp
    72e6:	200e      	movs	r0, #14
    72e8:	aa06      	add	r2, sp, #24
    72ea:	2306      	movs	r3, #6
    72ec:	f7ff fd8a 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
                             
    return status;
}
    72f0:	b009      	add	sp, #36	; 0x24
    72f2:	bd30      	pop	{r4, r5, pc}

000072f4 <MSS_SYS_key_tree>:
(
    uint8_t* p_key,
    uint8_t op_type,
    const uint8_t* path
)
{
    72f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    72f6:	b091      	sub	sp, #68	; 0x44
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[49];
    uint8_t status;
    
    memcpy(&params[0], p_key, KEYTREE_KEY_LENGTH);
    72f8:	ac01      	add	r4, sp, #4
(
    uint8_t* p_key,
    uint8_t op_type,
    const uint8_t* path
)
{
    72fa:	460e      	mov	r6, r1
    72fc:	4617      	mov	r7, r2
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[49];
    uint8_t status;
    
    memcpy(&params[0], p_key, KEYTREE_KEY_LENGTH);
    72fe:	4601      	mov	r1, r0
    7300:	2220      	movs	r2, #32
(
    uint8_t* p_key,
    uint8_t op_type,
    const uint8_t* path
)
{
    7302:	4605      	mov	r5, r0
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[49];
    uint8_t status;
    
    memcpy(&params[0], p_key, KEYTREE_KEY_LENGTH);
    7304:	4620      	mov	r0, r4
    7306:	f001 fc6f 	bl	8be8 <memcpy>
    
    params[32] = op_type;
    
    memcpy(&params[33], path, KEYTREE_PATH_LENGTH);
    730a:	4639      	mov	r1, r7
    730c:	2210      	movs	r2, #16
    730e:	f104 0021 	add.w	r0, r4, #33	; 0x21
    uint8_t params[49];
    uint8_t status;
    
    memcpy(&params[0], p_key, KEYTREE_KEY_LENGTH);
    
    params[32] = op_type;
    7312:	f88d 6024 	strb.w	r6, [sp, #36]	; 0x24
    
    memcpy(&params[33], path, KEYTREE_PATH_LENGTH);
    7316:	f001 fc67 	bl	8be8 <memcpy>
    
    status = execute_service(KEYTREE_REQUEST_CMD,
    731a:	2009      	movs	r0, #9
    731c:	4621      	mov	r1, r4
    731e:	aa0e      	add	r2, sp, #56	; 0x38
    7320:	2306      	movs	r3, #6
    7322:	f7ff fd6f 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
    
    if(status == MSS_SYS_SUCCESS)
    7326:	4606      	mov	r6, r0
    7328:	b920      	cbnz	r0, 7334 <MSS_SYS_key_tree+0x40>
    {
       memcpy(p_key, &params[0], KEYTREE_KEY_LENGTH);
    732a:	4628      	mov	r0, r5
    732c:	4621      	mov	r1, r4
    732e:	2220      	movs	r2, #32
    7330:	f001 fc5a 	bl	8be8 <memcpy>
    }
    
    return status;
}
    7334:	4630      	mov	r0, r6
    7336:	b011      	add	sp, #68	; 0x44
    7338:	bdf0      	pop	{r4, r5, r6, r7, pc}
    733a:	bf00      	nop

0000733c <MSS_SYS_hmac>:
    const uint8_t * key,
    const uint8_t * p_data_in,
    uint32_t length,
    uint8_t * p_result
)
{
    733c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7340:	b095      	sub	sp, #84	; 0x54
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[58];
    uint8_t status;
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    7342:	af03      	add	r7, sp, #12
    const uint8_t * key,
    const uint8_t * p_data_in,
    uint32_t length,
    uint8_t * p_result
)
{
    7344:	461c      	mov	r4, r3
    7346:	460d      	mov	r5, r1
    7348:	4616      	mov	r6, r2
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[58];
    uint8_t status;
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    734a:	4601      	mov	r1, r0
    734c:	2220      	movs	r2, #32
    734e:	4638      	mov	r0, r7
    7350:	f001 fc4a 	bl	8be8 <memcpy>
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7354:	ea4f 6814 	mov.w	r8, r4, lsr #24
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    params[33] = (uint8_t)((uint32_t)length >> 8u);
    params[34] = (uint8_t)((uint32_t)length >> 16u);
    7358:	0e2b      	lsrs	r3, r5, #24
    735a:	9300      	str	r3, [sp, #0]
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    735c:	f8cd 8004 	str.w	r8, [sp, #4]
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    params[33] = (uint8_t)((uint32_t)length >> 8u);
    params[34] = (uint8_t)((uint32_t)length >> 16u);
    7360:	ea4f 4e16 	mov.w	lr, r6, lsr #16
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7364:	ea4f 4c14 	mov.w	ip, r4, lsr #16
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    params[33] = (uint8_t)((uint32_t)length >> 8u);
    params[34] = (uint8_t)((uint32_t)length >> 16u);
    7368:	f88d e02e 	strb.w	lr, [sp, #46]	; 0x2e
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    736c:	f88d c036 	strb.w	ip, [sp, #54]	; 0x36
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7370:	f8dd e000 	ldr.w	lr, [sp]
    7374:	f8dd c004 	ldr.w	ip, [sp, #4]
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    params[33] = (uint8_t)((uint32_t)length >> 8u);
    params[34] = (uint8_t)((uint32_t)length >> 16u);
    params[35] = (uint8_t)((uint32_t)length >> 24u);
    7378:	ea4f 6b16 	mov.w	fp, r6, lsr #24

    write_ptr_value_into_array(p_data_in, params, 36u);
    write_ptr_value_into_array(p_result, params, 40u);

    status = execute_service(HMAC_REQUEST_CMD,
    737c:	4639      	mov	r1, r7
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    737e:	ea4f 2815 	mov.w	r8, r5, lsr #8
    uint8_t status;
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    params[33] = (uint8_t)((uint32_t)length >> 8u);
    7382:	0a37      	lsrs	r7, r6, #8
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7384:	ea4f 4a15 	mov.w	sl, r5, lsr #16
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7388:	ea4f 2914 	mov.w	r9, r4, lsr #8
    params[35] = (uint8_t)((uint32_t)length >> 24u);

    write_ptr_value_into_array(p_data_in, params, 36u);
    write_ptr_value_into_array(p_result, params, 40u);

    status = execute_service(HMAC_REQUEST_CMD,
    738c:	200c      	movs	r0, #12
    738e:	aa12      	add	r2, sp, #72	; 0x48
    7390:	2306      	movs	r3, #6
    uint8_t status;
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    params[33] = (uint8_t)((uint32_t)length >> 8u);
    7392:	f88d 702d 	strb.w	r7, [sp, #45]	; 0x2d
    params[34] = (uint8_t)((uint32_t)length >> 16u);
    params[35] = (uint8_t)((uint32_t)length >> 24u);
    7396:	f88d b02f 	strb.w	fp, [sp, #47]	; 0x2f
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    739a:	f88d 8031 	strb.w	r8, [sp, #49]	; 0x31
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    739e:	f88d a032 	strb.w	sl, [sp, #50]	; 0x32
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    73a2:	f88d e033 	strb.w	lr, [sp, #51]	; 0x33
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    73a6:	f88d 9035 	strb.w	r9, [sp, #53]	; 0x35
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    73aa:	f88d c037 	strb.w	ip, [sp, #55]	; 0x37
    uint8_t params[58];
    uint8_t status;
    
    memcpy(&params[0], key, HMAC_KEY_LENGTH);
    
    params[32] = (uint8_t)((uint32_t)length);
    73ae:	f88d 602c 	strb.w	r6, [sp, #44]	; 0x2c
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    73b2:	f88d 5030 	strb.w	r5, [sp, #48]	; 0x30
    73b6:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
    params[35] = (uint8_t)((uint32_t)length >> 24u);

    write_ptr_value_into_array(p_data_in, params, 36u);
    write_ptr_value_into_array(p_result, params, 40u);

    status = execute_service(HMAC_REQUEST_CMD,
    73ba:	f7ff fd23 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
                             
    return status;
}
    73be:	b015      	add	sp, #84	; 0x54
    73c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000073c4 <MSS_SYS_sha256>:
(
    const uint8_t * p_data_in,
    uint32_t length,
    uint8_t * result
)
{
    73c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    73c8:	4684      	mov	ip, r0
    73ca:	b089      	sub	sp, #36	; 0x24
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    73cc:	0e03      	lsrs	r3, r0, #24
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    73ce:	0a00      	lsrs	r0, r0, #8
    uint8_t params[12];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)length);
    params[1] = (uint8_t)((uint32_t)length >> 8u);
    params[2] = (uint8_t)((uint32_t)length >> 16u);
    73d0:	0c0e      	lsrs	r6, r1, #16
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    73d2:	9301      	str	r3, [sp, #4]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    73d4:	9000      	str	r0, [sp, #0]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    73d6:	ea4f 451c 	mov.w	r5, ip, lsr #16
    uint8_t params[12];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)length);
    params[1] = (uint8_t)((uint32_t)length >> 8u);
    params[2] = (uint8_t)((uint32_t)length >> 16u);
    73da:	f88d 600e 	strb.w	r6, [sp, #14]
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    73de:	f88d 5016 	strb.w	r5, [sp, #22]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    73e2:	9e00      	ldr	r6, [sp, #0]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    73e4:	9d01      	ldr	r5, [sp, #4]
(
    const uint8_t * p_data_in,
    uint32_t length,
    uint8_t * result
)
{
    73e6:	460c      	mov	r4, r1
    73e8:	4696      	mov	lr, r2
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)length);
    params[1] = (uint8_t)((uint32_t)length >> 8u);
    params[2] = (uint8_t)((uint32_t)length >> 16u);
    params[3] = (uint8_t)((uint32_t)length >> 24u);
    73ea:	ea4f 6811 	mov.w	r8, r1, lsr #24
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    73ee:	ea4f 6b12 	mov.w	fp, r2, lsr #24
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[12];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)length);
    params[1] = (uint8_t)((uint32_t)length >> 8u);
    73f2:	0a0f      	lsrs	r7, r1, #8
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    73f4:	ea4f 2a12 	mov.w	sl, r2, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    73f8:	ea4f 4912 	mov.w	r9, r2, lsr #16
    params[3] = (uint8_t)((uint32_t)length >> 24u);
    
    write_ptr_value_into_array(result, params, 4u);
    write_ptr_value_into_array(p_data_in, params, 8u);

    status = execute_service(SHA256_REQUEST_CMD,
    73fc:	200a      	movs	r0, #10
    73fe:	a903      	add	r1, sp, #12
    7400:	aa06      	add	r2, sp, #24
    7402:	2306      	movs	r3, #6
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[12];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)length);
    params[1] = (uint8_t)((uint32_t)length >> 8u);
    7404:	f88d 700d 	strb.w	r7, [sp, #13]
    params[2] = (uint8_t)((uint32_t)length >> 16u);
    params[3] = (uint8_t)((uint32_t)length >> 24u);
    7408:	f88d 800f 	strb.w	r8, [sp, #15]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    740c:	f88d a011 	strb.w	sl, [sp, #17]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7410:	f88d 9012 	strb.w	r9, [sp, #18]
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7414:	f88d b013 	strb.w	fp, [sp, #19]
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7418:	f88d 6015 	strb.w	r6, [sp, #21]
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    741c:	f88d 5017 	strb.w	r5, [sp, #23]
{
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[12];
    uint8_t status;
    
    params[0] = (uint8_t)((uint32_t)length);
    7420:	f88d 400c 	strb.w	r4, [sp, #12]
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    7424:	f88d e010 	strb.w	lr, [sp, #16]
    7428:	f88d c014 	strb.w	ip, [sp, #20]
    params[3] = (uint8_t)((uint32_t)length >> 24u);
    
    write_ptr_value_into_array(result, params, 4u);
    write_ptr_value_into_array(p_data_in, params, 8u);

    status = execute_service(SHA256_REQUEST_CMD,
    742c:	f7ff fcea 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
                             
    return status;
}
    7430:	b009      	add	sp, #36	; 0x24
    7432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7436:	bf00      	nop

00007438 <MSS_SYS_256bit_aes>:
    uint16_t nb_blocks,
    uint8_t mode,
    uint8_t * dest_addr,
    const uint8_t * src_addr
)
{
    7438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    743c:	b095      	sub	sp, #84	; 0x54
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[60];
    uint8_t status;
    
    memcpy(&params[0], key, AES256_KEY_LENGTH);
    743e:	ae03      	add	r6, sp, #12
    uint16_t nb_blocks,
    uint8_t mode,
    uint8_t * dest_addr,
    const uint8_t * src_addr
)
{
    7440:	4617      	mov	r7, r2
    7442:	4688      	mov	r8, r1
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[60];
    uint8_t status;
    
    memcpy(&params[0], key, AES256_KEY_LENGTH);
    7444:	2220      	movs	r2, #32
    7446:	4601      	mov	r1, r0
    7448:	4630      	mov	r0, r6
    uint16_t nb_blocks,
    uint8_t mode,
    uint8_t * dest_addr,
    const uint8_t * src_addr
)
{
    744a:	9d1e      	ldr	r5, [sp, #120]	; 0x78
    744c:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
    744e:	9301      	str	r3, [sp, #4]
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[60];
    uint8_t status;
    
    memcpy(&params[0], key, AES256_KEY_LENGTH);
    7450:	f001 fbca 	bl	8be8 <memcpy>
    memcpy(&params[32], iv, IV_LENGTH);
    7454:	4641      	mov	r1, r8
    7456:	2210      	movs	r2, #16
    7458:	f106 0020 	add.w	r0, r6, #32
    745c:	f001 fbc4 	bl	8be8 <memcpy>
    
    params[48] = (uint8_t)nb_blocks;
    params[49] = (uint8_t)(nb_blocks >> 8u);
    7460:	ea4f 2e17 	mov.w	lr, r7, lsr #8
    7464:	f88d e03d 	strb.w	lr, [sp, #61]	; 0x3d
    params[50] = mode;
    7468:	f8dd e004 	ldr.w	lr, [sp, #4]
    params[51] = 0u;

    write_ptr_value_into_array(dest_addr, params, 52u);
    write_ptr_value_into_array(src_addr, params, 56u);

    status = execute_service(AES256_REQUEST_CMD,
    746c:	2006      	movs	r0, #6
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    746e:	ea4f 6915 	mov.w	r9, r5, lsr #24
    params[51] = 0u;

    write_ptr_value_into_array(dest_addr, params, 52u);
    write_ptr_value_into_array(src_addr, params, 56u);

    status = execute_service(AES256_REQUEST_CMD,
    7472:	ea4f 6b14 	mov.w	fp, r4, lsr #24
    7476:	4631      	mov	r1, r6
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7478:	ea4f 4c15 	mov.w	ip, r5, lsr #16
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    747c:	0a2e      	lsrs	r6, r5, #8
    747e:	ea4f 2814 	mov.w	r8, r4, lsr #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7482:	ea4f 4a14 	mov.w	sl, r4, lsr #16
    memcpy(&params[0], key, AES256_KEY_LENGTH);
    memcpy(&params[32], iv, IV_LENGTH);
    
    params[48] = (uint8_t)nb_blocks;
    params[49] = (uint8_t)(nb_blocks >> 8u);
    params[50] = mode;
    7486:	f88d e03e 	strb.w	lr, [sp, #62]	; 0x3e
    params[51] = 0u;

    write_ptr_value_into_array(dest_addr, params, 52u);
    write_ptr_value_into_array(src_addr, params, 56u);

    status = execute_service(AES256_REQUEST_CMD,
    748a:	aa12      	add	r2, sp, #72	; 0x48
    memcpy(&params[32], iv, IV_LENGTH);
    
    params[48] = (uint8_t)nb_blocks;
    params[49] = (uint8_t)(nb_blocks >> 8u);
    params[50] = mode;
    params[51] = 0u;
    748c:	f04f 0e00 	mov.w	lr, #0

    write_ptr_value_into_array(dest_addr, params, 52u);
    write_ptr_value_into_array(src_addr, params, 56u);

    status = execute_service(AES256_REQUEST_CMD,
    7490:	4603      	mov	r3, r0
    memcpy(&params[32], iv, IV_LENGTH);
    
    params[48] = (uint8_t)nb_blocks;
    params[49] = (uint8_t)(nb_blocks >> 8u);
    params[50] = mode;
    params[51] = 0u;
    7492:	f88d e03f 	strb.w	lr, [sp, #63]	; 0x3f
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7496:	f88d 6041 	strb.w	r6, [sp, #65]	; 0x41
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    749a:	f88d c042 	strb.w	ip, [sp, #66]	; 0x42
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    749e:	f88d 9043 	strb.w	r9, [sp, #67]	; 0x43
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    74a2:	f88d 8045 	strb.w	r8, [sp, #69]	; 0x45
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    74a6:	f88d a046 	strb.w	sl, [sp, #70]	; 0x46
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    74aa:	f88d b047 	strb.w	fp, [sp, #71]	; 0x47
    uint8_t status;
    
    memcpy(&params[0], key, AES256_KEY_LENGTH);
    memcpy(&params[32], iv, IV_LENGTH);
    
    params[48] = (uint8_t)nb_blocks;
    74ae:	f88d 703c 	strb.w	r7, [sp, #60]	; 0x3c
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    74b2:	f88d 5040 	strb.w	r5, [sp, #64]	; 0x40
    74b6:	f88d 4044 	strb.w	r4, [sp, #68]	; 0x44
    params[51] = 0u;

    write_ptr_value_into_array(dest_addr, params, 52u);
    write_ptr_value_into_array(src_addr, params, 56u);

    status = execute_service(AES256_REQUEST_CMD,
    74ba:	f7ff fca3 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
                             
    return status;
}
    74be:	b015      	add	sp, #84	; 0x54
    74c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000074c4 <MSS_SYS_128bit_aes>:
    const uint8_t * iv,
    uint16_t nb_blocks,
    uint8_t mode,
    uint8_t * dest_addr,
    const uint8_t * src_addr)
{
    74c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    74c8:	b091      	sub	sp, #68	; 0x44
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[44];
    uint8_t status;
    
    memcpy(&params[0], key, AES128_KEY_LENGTH);
    74ca:	2710      	movs	r7, #16
    74cc:	ae03      	add	r6, sp, #12
    const uint8_t * iv,
    uint16_t nb_blocks,
    uint8_t mode,
    uint8_t * dest_addr,
    const uint8_t * src_addr)
{
    74ce:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    74d0:	4690      	mov	r8, r2
    74d2:	468a      	mov	sl, r1
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[44];
    uint8_t status;
    
    memcpy(&params[0], key, AES128_KEY_LENGTH);
    74d4:	463a      	mov	r2, r7
    74d6:	4601      	mov	r1, r0
    74d8:	4630      	mov	r0, r6
    const uint8_t * iv,
    uint16_t nb_blocks,
    uint8_t mode,
    uint8_t * dest_addr,
    const uint8_t * src_addr)
{
    74da:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
    74dc:	9301      	str	r3, [sp, #4]
    uint8_t response[STANDARD_SERV_RESP_LENGTH];
    uint8_t params[44];
    uint8_t status;
    
    memcpy(&params[0], key, AES128_KEY_LENGTH);
    74de:	f001 fb83 	bl	8be8 <memcpy>
    memcpy(&params[16], iv, IV_LENGTH);
    74e2:	19f0      	adds	r0, r6, r7
    74e4:	4651      	mov	r1, sl
    74e6:	463a      	mov	r2, r7
    74e8:	f001 fb7e 	bl	8be8 <memcpy>
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    74ec:	fa25 fc07 	lsr.w	ip, r5, r7
    
    memcpy(&params[0], key, AES128_KEY_LENGTH);
    memcpy(&params[16], iv, IV_LENGTH);
    
    params[32] = (uint8_t)nb_blocks;
    params[33] = (uint8_t)(nb_blocks >> 8u);
    74f0:	ea4f 2e18 	mov.w	lr, r8, lsr #8
    74f4:	f88d e02d 	strb.w	lr, [sp, #45]	; 0x2d
    params[34] = mode;
    74f8:	f8dd e004 	ldr.w	lr, [sp, #4]
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    74fc:	ea4f 6915 	mov.w	r9, r5, lsr #24
    params[35] = 0u;

    write_ptr_value_into_array(dest_addr, params, 36u);
    write_ptr_value_into_array(src_addr, params, 40u);

    status = execute_service(AES128_REQUEST_CMD,
    7500:	ea4f 6b14 	mov.w	fp, r4, lsr #24
    7504:	4631      	mov	r1, r6
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7506:	0a27      	lsrs	r7, r4, #8
    7508:	0a2e      	lsrs	r6, r5, #8
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    750a:	ea4f 4a14 	mov.w	sl, r4, lsr #16
    memcpy(&params[0], key, AES128_KEY_LENGTH);
    memcpy(&params[16], iv, IV_LENGTH);
    
    params[32] = (uint8_t)nb_blocks;
    params[33] = (uint8_t)(nb_blocks >> 8u);
    params[34] = mode;
    750e:	f88d e02e 	strb.w	lr, [sp, #46]	; 0x2e
    params[35] = 0u;

    write_ptr_value_into_array(dest_addr, params, 36u);
    write_ptr_value_into_array(src_addr, params, 40u);

    status = execute_service(AES128_REQUEST_CMD,
    7512:	2003      	movs	r0, #3
    memcpy(&params[16], iv, IV_LENGTH);
    
    params[32] = (uint8_t)nb_blocks;
    params[33] = (uint8_t)(nb_blocks >> 8u);
    params[34] = mode;
    params[35] = 0u;
    7514:	f04f 0e00 	mov.w	lr, #0

    write_ptr_value_into_array(dest_addr, params, 36u);
    write_ptr_value_into_array(src_addr, params, 40u);

    status = execute_service(AES128_REQUEST_CMD,
    7518:	aa0e      	add	r2, sp, #56	; 0x38
    751a:	2306      	movs	r3, #6
    memcpy(&params[16], iv, IV_LENGTH);
    
    params[32] = (uint8_t)nb_blocks;
    params[33] = (uint8_t)(nb_blocks >> 8u);
    params[34] = mode;
    params[35] = 0u;
    751c:	f88d e02f 	strb.w	lr, [sp, #47]	; 0x2f
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    7520:	f88d 6031 	strb.w	r6, [sp, #49]	; 0x31
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7524:	f88d c032 	strb.w	ip, [sp, #50]	; 0x32
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7528:	f88d 9033 	strb.w	r9, [sp, #51]	; 0x33
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    target_array[array_index + 1] = (uint8_t)((uint32_t)pointer >> 8u);
    752c:	f88d 7035 	strb.w	r7, [sp, #53]	; 0x35
    target_array[array_index + 2] = (uint8_t)((uint32_t)pointer >> 16u);
    7530:	f88d a036 	strb.w	sl, [sp, #54]	; 0x36
    target_array[array_index + 3] = (uint8_t)((uint32_t)pointer >> 24u);
    7534:	f88d b037 	strb.w	fp, [sp, #55]	; 0x37
    uint8_t status;
    
    memcpy(&params[0], key, AES128_KEY_LENGTH);
    memcpy(&params[16], iv, IV_LENGTH);
    
    params[32] = (uint8_t)nb_blocks;
    7538:	f88d 802c 	strb.w	r8, [sp, #44]	; 0x2c
    const uint8_t * pointer,
    uint8_t target_array[],
    uint32_t array_index
)
{
    target_array[array_index] = (uint8_t)((uint32_t)pointer);
    753c:	f88d 5030 	strb.w	r5, [sp, #48]	; 0x30
    7540:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
    params[35] = 0u;

    write_ptr_value_into_array(dest_addr, params, 36u);
    write_ptr_value_into_array(src_addr, params, 40u);

    status = execute_service(AES128_REQUEST_CMD,
    7544:	f7ff fc5e 	bl	6e04 <execute_service>
                             params,
                             response,
                             STANDARD_SERV_RESP_LENGTH);
                             
    return status;
}
    7548:	b011      	add	sp, #68	; 0x44
    754a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    754e:	bf00      	nop

00007550 <MSS_SYS_get_secondary_device_certificate>:
 */
uint8_t MSS_SYS_get_secondary_device_certificate
(
    uint8_t * p_secondary_device_certificate
)
{
    7550:	b500      	push	{lr}
    7552:	b083      	sub	sp, #12
    7554:	4601      	mov	r1, r0
    ASSERT(0x0000F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0001F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0002F802u != SYSREG->DEVICE_VERSION);
    ASSERT(0x0003F802u != SYSREG->DEVICE_VERSION);
    
    status = execute_service(SECONDARY_DEVICE_CERTIFICATE_REQUEST_CMD,
    7556:	466a      	mov	r2, sp
    7558:	201e      	movs	r0, #30
    755a:	2306      	movs	r3, #6
    755c:	f7ff fc52 	bl	6e04 <execute_service>
                             p_secondary_device_certificate,
                             response,
                             SECONDARY_DEVICE_CERT_SERV_RESP_LENGTH);
    
    return status;
}
    7560:	b003      	add	sp, #12
    7562:	bd00      	pop	{pc}

00007564 <MSS_SYS_get_device_certificate>:
 */
uint8_t MSS_SYS_get_device_certificate
(
    uint8_t * p_device_certificate
)
{
    7564:	b500      	push	{lr}
    7566:	b083      	sub	sp, #12
    7568:	4601      	mov	r1, r0
    uint8_t response[DEVICE_CERT_SERV_RESP_LENGTH];
    uint8_t status;
    
    status = execute_service(DEVICE_CERTIFICATE_REQUEST_CMD,
    756a:	466a      	mov	r2, sp
    756c:	2000      	movs	r0, #0
    756e:	2306      	movs	r3, #6
    7570:	f7ff fc48 	bl	6e04 <execute_service>
                             p_device_certificate,
                             response,
                             DEVICE_CERT_SERV_RESP_LENGTH);
    
    return status;
}
    7574:	b003      	add	sp, #12
    7576:	bd00      	pop	{pc}

00007578 <MSS_SYS_get_design_version>:
 */
uint8_t MSS_SYS_get_design_version
(
    uint8_t * p_design_version
)
{
    7578:	b500      	push	{lr}
    757a:	b083      	sub	sp, #12
    757c:	4601      	mov	r1, r0
    uint8_t response[DESIGNVER_SERV_RESP_LENGTH];
    uint8_t status;
    
    status = execute_service(DESIGNVER_REQUEST_CMD,
    757e:	466a      	mov	r2, sp
    7580:	2005      	movs	r0, #5
    7582:	2306      	movs	r3, #6
    7584:	f7ff fc3e 	bl	6e04 <execute_service>
                             p_design_version,
                             response,
                             DESIGNVER_SERV_RESP_LENGTH);
    
    return status;
}
    7588:	b003      	add	sp, #12
    758a:	bd00      	pop	{pc}

0000758c <MSS_SYS_get_user_code>:
 */
uint8_t MSS_SYS_get_user_code
(
    uint8_t * p_user_code
)
{
    758c:	b500      	push	{lr}
    758e:	b083      	sub	sp, #12
    7590:	4601      	mov	r1, r0
    uint8_t response[USERCODE_SERV_RESP_LENGTH];
    uint8_t status;
    
    status = execute_service(USERCODE_REQUEST_CMD,
    7592:	466a      	mov	r2, sp
    7594:	2004      	movs	r0, #4
    7596:	2306      	movs	r3, #6
    7598:	f7ff fc34 	bl	6e04 <execute_service>
                             p_user_code,
                             response,
                             USERCODE_SERV_RESP_LENGTH);
    
    return status;
}
    759c:	b003      	add	sp, #12
    759e:	bd00      	pop	{pc}

000075a0 <MSS_SYS_get_serial_number>:
 */
uint8_t MSS_SYS_get_serial_number
(
    uint8_t * p_serial_number
)
{
    75a0:	b500      	push	{lr}
    75a2:	b083      	sub	sp, #12
    75a4:	4601      	mov	r1, r0
    uint8_t response[SERIAL_NUMBER_SERV_RESP_LENGTH];
    uint8_t status;
    
    status = execute_service(SERIAL_NUMBER_REQUEST_CMD,
    75a6:	466a      	mov	r2, sp
    75a8:	2001      	movs	r0, #1
    75aa:	2306      	movs	r3, #6
    75ac:	f7ff fc2a 	bl	6e04 <execute_service>
                             p_serial_number,
                             response,
                             SERIAL_NUMBER_SERV_RESP_LENGTH);
    
    return status;
}
    75b0:	b003      	add	sp, #12
    75b2:	bd00      	pop	{pc}

000075b4 <MSS_SYS_start_isp>:
(
    uint8_t mode,
    comblk_page_handler_t page_read_handler,
    sys_serv_isp_complete_handler_t isp_completion_handler
)
{
    75b4:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
         * Check fabric digest before performing ISP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
    }
    
    g_mode = mode;
    75b8:	f640 23fc 	movw	r3, #2812	; 0xafc
{
    uint8_t isp_prog_request[2];
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
    uint8_t status = MSS_SYS_SUCCESS;
    
    if(mode == MSS_SYS_PROG_VERIFY)
    75bc:	2802      	cmp	r0, #2
(
    uint8_t mode,
    comblk_page_handler_t page_read_handler,
    sys_serv_isp_complete_handler_t isp_completion_handler
)
{
    75be:	b087      	sub	sp, #28
    75c0:	4605      	mov	r5, r0
    75c2:	4688      	mov	r8, r1
    75c4:	4616      	mov	r6, r2
         * Check fabric digest before performing ISP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
    }
    
    g_mode = mode;
    75c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
    uint8_t isp_prog_request[2];
    uint8_t clk_switch_status = CLOCK_SWITCHING_SUCCESS;
    uint8_t status = MSS_SYS_SUCCESS;
    
    if(mode == MSS_SYS_PROG_VERIFY)
    75ca:	d030      	beq.n	762e <MSS_SYS_start_isp+0x7a>
         * Check fabric digest before performing ISP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
    }
    
    g_mode = mode;
    75cc:	7718      	strb	r0, [r3, #28]
    
    if(mode != MSS_SYS_PROG_AUTHENTICATE)
    75ce:	2800      	cmp	r0, #0
    75d0:	d133      	bne.n	763a <MSS_SYS_start_isp+0x86>
 *
 */
static void signal_request_start(void)
{
    /* Wait for current request to complete. */
    while(g_request_in_progress)
    75d2:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
    75d6:	f640 27fc 	movw	r7, #2812	; 0xafc
    75da:	f2c2 0700 	movt	r7, #8192	; 0x2000
    75de:	4614      	mov	r4, r2
    75e0:	2a00      	cmp	r2, #0
    75e2:	d1f6      	bne.n	75d2 <MSS_SYS_start_isp+0x1e>
        
        g_isp_completion_handler = isp_completion_handler;
        
        g_isp_page_read_handler = page_read_handler;
        
        MSS_COMBLK_send_paged_cmd(isp_prog_request,                 /* p_cmd */
    75e4:	f246 5ec9 	movw	lr, #26057	; 0x65c9
    75e8:	f246 6c2d 	movw	ip, #26157	; 0x662d
    75ec:	2102      	movs	r1, #2
    75ee:	f2c0 0e00 	movt	lr, #0
    75f2:	f2c0 0c00 	movt	ip, #0
    while(g_request_in_progress)
    {
        ;
    }
    
    g_request_in_progress = 1u;
    75f6:	f04f 0a01 	mov.w	sl, #1
    75fa:	f887 a02c 	strb.w	sl, [r7, #44]	; 0x2c
        signal_request_start();
        
        isp_prog_request[0] = ISP_PROGRAMMING_REQUEST_CMD;
        isp_prog_request[1] = mode;
        
        g_isp_completion_handler = isp_completion_handler;
    75fe:	62be      	str	r6, [r7, #40]	; 0x28
        
        g_isp_page_read_handler = page_read_handler;
    7600:	f8c7 8020 	str.w	r8, [r7, #32]
        
        MSS_COMBLK_send_paged_cmd(isp_prog_request,                 /* p_cmd */
    7604:	a805      	add	r0, sp, #20
    7606:	f8cd e000 	str.w	lr, [sp]
    760a:	f8cd c004 	str.w	ip, [sp, #4]
    760e:	f107 0230 	add.w	r2, r7, #48	; 0x30
    7612:	460b      	mov	r3, r1
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    {
        signal_request_start();
        
        isp_prog_request[0] = ISP_PROGRAMMING_REQUEST_CMD;
    7614:	f04f 0a15 	mov.w	sl, #21
    {
        ;
    }
    
    g_request_in_progress = 1u;
    g_last_response_length = 0u;
    7618:	85fc      	strh	r4, [r7, #46]	; 0x2e
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    {
        signal_request_start();
        
        isp_prog_request[0] = ISP_PROGRAMMING_REQUEST_CMD;
    761a:	f88d a014 	strb.w	sl, [sp, #20]
        isp_prog_request[1] = mode;
    761e:	f88d 5015 	strb.w	r5, [sp, #21]
        
        g_isp_completion_handler = isp_completion_handler;
        
        g_isp_page_read_handler = page_read_handler;
        
        MSS_COMBLK_send_paged_cmd(isp_prog_request,                 /* p_cmd */
    7622:	f7fe f945 	bl	58b0 <MSS_COMBLK_send_paged_cmd>
    7626:	4620      	mov	r0, r4
         */
        status = MSS_SYS_CLK_DIVISOR_ERROR;
    }
    
    return status;
}
    7628:	b007      	add	sp, #28
    762a:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
    if(mode == MSS_SYS_PROG_VERIFY)
    {
        /*
         * Check fabric digest before performing ISP verify
         */
        MSS_SYS_check_digest(MSS_SYS_DIGEST_CHECK_FABRIC);
    762e:	2001      	movs	r0, #1
    7630:	9303      	str	r3, [sp, #12]
    7632:	f7ff f9ab 	bl	698c <MSS_SYS_check_digest>
    }
    
    g_mode = mode;
    7636:	9b03      	ldr	r3, [sp, #12]
    7638:	771d      	strb	r5, [r3, #28]
        /*
         * Keep a copy of the initial eNVM configuration used before ISP was
         * initiated. The eNVM configuration will be restored, as part of the ISP
         * completion handler, when ISP completes.
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;
    763a:	f248 0200 	movw	r2, #32768	; 0x8000
    763e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    7642:	68d1      	ldr	r1, [r2, #12]
    7644:	f240 449c 	movw	r4, #1180	; 0x49c
    7648:	f2c2 0400 	movt	r4, #8192	; 0x2000
    764c:	61e1      	str	r1, [r4, #28]

        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the ISP operation is completed in asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
    764e:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c

        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;        
    7652:	f441 51ff 	orr.w	r1, r1, #8160	; 0x1fe0
         */
        g_initial_envm_cr = SYSREG->ENVM_CR;

        /* Store the MSS DDR FACC 2 register value so that its can be restored back 
         * when the ISP operation is completed in asynchronous_event_handler. */
        g_initial_mssddr_facc2_cr = SYSREG->MSSDDR_FACC2_CR;
    7656:	6258      	str	r0, [r3, #36]	; 0x24

        /*
         * Set the eNVM's frequency range to its maximum. This is required to ensure
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;        
    7658:	60d1      	str	r1, [r2, #12]
    
        /* Select output of MUX 0, MUX 1 and MUX 2 during standby */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR & ((uint32_t)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) | ~FACC_STANDBY_SEL_MASK);
    765a:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
        
        /* SAR 80563
         * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
         * clk_fic64 to the divided by 32 versions based on device version.
         */
        clk_switch_status = clk_switching_fix();
    765e:	9303      	str	r3, [sp, #12]
         * successful eNVM programming on all devices.
         */
        SYSREG->ENVM_CR = (g_initial_envm_cr & ~NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;        
    
        /* Select output of MUX 0, MUX 1 and MUX 2 during standby */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR & ((uint32_t)(FACC_STANDBY_SEL << FACC_STANDBY_SHIFT) | ~FACC_STANDBY_SEL_MASK);
    7660:	f420 71e0 	bic.w	r1, r0, #448	; 0x1c0
    7664:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
        
        /* Enable the signal for the 50 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_25_50MHZ_EN << MSS_25_50MHZ_EN_SHIFT) & MSS_25_50MHZ_EN_MASK);
    7668:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
    766c:	f440 7100 	orr.w	r1, r0, #512	; 0x200
    7670:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
        
        /* Enable the signal for the 1 MHz RC oscillator */
        SYSREG->MSSDDR_FACC2_CR = SYSREG->MSSDDR_FACC2_CR | ((uint32_t)(MSS_1MHZ_EN << MSS_1MHZ_EN_SHIFT) & MSS_1MHZ_EN_MASK);
    7674:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
    7678:	f440 6180 	orr.w	r1, r0, #1024	; 0x400
    767c:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
        
        /* SAR 80563
         * Cortex-M3 firmware dynamically divides down fclk, pclk0, pclk1 and
         * clk_fic64 to the divided by 32 versions based on device version.
         */
        clk_switch_status = clk_switching_fix();
    7680:	f7fe fca8 	bl	5fd4 <clk_switching_fix>
        
        wait_for_clock_switch = 1;
    7684:	2201      	movs	r2, #1
    7686:	76a2      	strb	r2, [r4, #26]
    }
    
    if(clk_switch_status == CLOCK_SWITCHING_SUCCESS)
    7688:	9b03      	ldr	r3, [sp, #12]
    768a:	2800      	cmp	r0, #0
    768c:	d0a1      	beq.n	75d2 <MSS_SYS_start_isp+0x1e>
    768e:	20c9      	movs	r0, #201	; 0xc9
    7690:	e7ca      	b.n	7628 <MSS_SYS_start_isp+0x74>
    7692:	bf00      	nop

00007694 <MSS_SYS_init>:
/*==============================================================================
 * See mss_sys_services.h for details.
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
    g_event_handler = event_handler;
    7694:	f640 23fc 	movw	r3, #2812	; 0xafc
    7698:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_last_response_length = 0u;
    769c:	2100      	movs	r1, #0
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    769e:	f248 0200 	movw	r2, #32768	; 0x8000
 * See mss_sys_services.h for details.
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
    g_event_handler = event_handler;
    g_last_response_length = 0u;
    76a2:	85d9      	strh	r1, [r3, #46]	; 0x2e
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    76a4:	f2c4 0203 	movt	r2, #16387	; 0x4003
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
    g_event_handler = event_handler;
    g_last_response_length = 0u;
    g_request_in_progress = 0u;
    76a8:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
/*==============================================================================
 * See mss_sys_services.h for details.
 */
void MSS_SYS_init(sys_serv_async_event_handler_t event_handler)
{   
    g_event_handler = event_handler;
    76ac:	6118      	str	r0, [r3, #16]
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    76ae:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    
    /*
     * Initialize the COMBLK used to communicate with the System Controller.
     */
    MSS_COMBLK_init(asynchronous_event_handler, g_response);
    76b2:	f246 20e1 	movw	r0, #25313	; 0x62e1
    76b6:	f2c0 0000 	movt	r0, #0
    76ba:	f103 0114 	add.w	r1, r3, #20
    
    /*
     * Set a default good value for g_initial_mssddr_facc1_cr used to control
     * the clock dividers coming in and out of Flash*Freeze.
     */
    g_initial_mssddr_facc1_cr = SYSREG->MSSDDR_FACC1_CR;
    76be:	619a      	str	r2, [r3, #24]
    
    /*
     * Initialize the COMBLK used to communicate with the System Controller.
     */
    MSS_COMBLK_init(asynchronous_event_handler, g_response);
    76c0:	f7fe b83a 	b.w	5738 <MSS_COMBLK_init>

000076c4 <request_nvm_access>:
    
    /*
     * Use the SystemCoreClock frequency to compute a delay counter value giving
     * us a delay in the 500ms range. This is a very approximate delay.
     */
    timeout_counter = SystemCoreClock / 16u;
    76c4:	f240 42bc 	movw	r2, #1212	; 0x4bc
    76c8:	f2c2 0200 	movt	r2, #8192	; 0x2000
    76cc:	6811      	ldr	r1, [r2, #0]
    76ce:	f648 6388 	movw	r3, #36488	; 0x8e88
    76d2:	f2c0 0300 	movt	r3, #0
    76d6:	090a      	lsrs	r2, r1, #4
#define CORTEX_M3_ACCESS_GRANTED    0x05u

static uint8_t g_envm_ctrl_locks = 0x00u;

static nvm_status_t request_nvm_access(uint32_t nvm_block_id)
{
    76d8:	b082      	sub	sp, #8
    
    /*
     * Use the SystemCoreClock frequency to compute a delay counter value giving
     * us a delay in the 500ms range. This is a very approximate delay.
     */
    timeout_counter = SystemCoreClock / 16u;
    76da:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    76de:	9201      	str	r2, [sp, #4]
    
    /*
     * Gain access to eNVM controller.
     */
    do {
        g_nvm[nvm_block_id]->REQ_ACCESS = REQUEST_NVM_ACCESS;
    76e0:	2101      	movs	r1, #1
    76e2:	f8c3 11fc 	str.w	r1, [r3, #508]	; 0x1fc
        access = g_nvm[nvm_block_id]->REQ_ACCESS;
    76e6:	f8d3 21fc 	ldr.w	r2, [r3, #508]	; 0x1fc
        if(access != CORTEX_M3_ACCESS_GRANTED)
    76ea:	2a05      	cmp	r2, #5
    76ec:	d008      	beq.n	7700 <request_nvm_access+0x3c>
            /*
             * Time out if another AHB master locked access to eNVM to prevent
             * the Cortex-M3 from locking up on eNVM write if some other part
             * of the system fails from releasing the eNVM.
             */
            --timeout_counter;
    76ee:	9a01      	ldr	r2, [sp, #4]
    76f0:	3a01      	subs	r2, #1
    76f2:	9201      	str	r2, [sp, #4]
            if(0u == timeout_counter)
    76f4:	9a01      	ldr	r2, [sp, #4]
    76f6:	2a00      	cmp	r2, #0
    76f8:	d1f3      	bne.n	76e2 <request_nvm_access+0x1e>
    76fa:	2005      	movs	r0, #5
    {
        g_envm_ctrl_locks |= (uint8_t)((uint32_t)0x01 << nvm_block_id);
    }
    
    return status;
}
    76fc:	b002      	add	sp, #8
    76fe:	4770      	bx	lr
     * Mark controller as locked if successful so that it will be unlocked by a
     * call to release_ctrl_access.
     */
    if(NVM_SUCCESS == status)
    {
        g_envm_ctrl_locks |= (uint8_t)((uint32_t)0x01 << nvm_block_id);
    7700:	2201      	movs	r2, #1
    7702:	4082      	lsls	r2, r0
    7704:	f640 3330 	movw	r3, #2864	; 0xb30
    7708:	f2c2 0300 	movt	r3, #8192	; 0x2000
    770c:	7819      	ldrb	r1, [r3, #0]
    770e:	2000      	movs	r0, #0
    7710:	430a      	orrs	r2, r1
    7712:	701a      	strb	r2, [r3, #0]
    7714:	e7f2      	b.n	76fc <request_nvm_access+0x38>
    7716:	bf00      	nop

00007718 <get_ctrl_access>:

/**************************************************************************//**
 * Get access to eNVM controller for eNVM0 and eNVM1
 */
static nvm_status_t get_ctrl_access(uint32_t nvm_offset, uint32_t length)
{
    7718:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    nvm_status_t access_req_status;
    
    /*
     * Gain access to eNVM controller(s).
     */
    if(nvm_offset < NVM1_BOTTOM_OFFSET)
    771c:	f64f 74ff 	movw	r4, #65535	; 0xffff
    7720:	f2c0 0403 	movt	r4, #3
    7724:	42a0      	cmp	r0, r4

/**************************************************************************//**
 * Get access to eNVM controller for eNVM0 and eNVM1
 */
static nvm_status_t get_ctrl_access(uint32_t nvm_offset, uint32_t length)
{
    7726:	4605      	mov	r5, r0
    7728:	460e      	mov	r6, r1
    nvm_status_t access_req_status;
    
    /*
     * Gain access to eNVM controller(s).
     */
    if(nvm_offset < NVM1_BOTTOM_OFFSET)
    772a:	d80a      	bhi.n	7742 <get_ctrl_access+0x2a>
    {
        access_req_status = request_nvm_access(NVM_BLOCK_0);
    772c:	2000      	movs	r0, #0
    772e:	f7ff ffc9 	bl	76c4 <request_nvm_access>
    7732:	4607      	mov	r7, r0
        if(NVM_SUCCESS == access_req_status)
    7734:	b918      	cbnz	r0, 773e <get_ctrl_access+0x26>
        {
            uint32_t last_offset;
            last_offset = nvm_offset + (length - 0x1u);
            if(last_offset >= NVM1_BOTTOM_OFFSET)
    7736:	3d01      	subs	r5, #1
    7738:	19ae      	adds	r6, r5, r6
    773a:	42a6      	cmp	r6, r4
    773c:	d805      	bhi.n	774a <get_ctrl_access+0x32>
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
    }
    
    return access_req_status;
}
    773e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            }
        }
    }
    else
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
    7742:	2001      	movs	r0, #1
    }
    
    return access_req_status;
}
    7744:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            }
        }
    }
    else
    {
        access_req_status = request_nvm_access(NVM_BLOCK_1);
    7748:	e7bc      	b.n	76c4 <request_nvm_access>
        {
            uint32_t last_offset;
            last_offset = nvm_offset + (length - 0x1u);
            if(last_offset >= NVM1_BOTTOM_OFFSET)
            {
                access_req_status = request_nvm_access(NVM_BLOCK_1);
    774a:	2001      	movs	r0, #1
    774c:	f7ff ffba 	bl	76c4 <request_nvm_access>
                if(NVM_IN_USE_BY_OTHER_MASTER == access_req_status)
    7750:	2805      	cmp	r0, #5
    7752:	d1f4      	bne.n	773e <get_ctrl_access+0x26>

static void release_ctrl_access(void)
{
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    7754:	f640 3330 	movw	r3, #2864	; 0xb30
    7758:	f2c2 0300 	movt	r3, #8192	; 0x2000
    775c:	781a      	ldrb	r2, [r3, #0]
    if(block_locked)
    775e:	f012 0f01 	tst.w	r2, #1
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    7762:	bf1f      	itttt	ne
    7764:	f240 0100 	movwne	r1, #0
    7768:	f2c6 0108 	movtne	r1, #24584	; 0x6008
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    776c:	f002 02fe 	andne.w	r2, r2, #254	; 0xfe
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    7770:	f8c1 71fc 	strne.w	r7, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    7774:	bf18      	it	ne
    7776:	701a      	strbne	r2, [r3, #0]
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    7778:	f012 0f02 	tst.w	r2, #2
    777c:	d0df      	beq.n	773e <get_ctrl_access+0x26>
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    777e:	f240 0100 	movw	r1, #0
    7782:	f2c6 010c 	movt	r1, #24588	; 0x600c
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7786:	f022 0202 	bic.w	r2, r2, #2
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    778a:	2400      	movs	r4, #0
    778c:	f8c1 41fc 	str.w	r4, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7790:	701a      	strb	r2, [r3, #0]
    7792:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7796:	bf00      	nop

00007798 <check_protection_reserved_nvm>:
 *  0x7C000 - 0x7CFFF - 4KB(32 pages) user lower1(bottom) protected area of eNVM1 memory.
 *  0x7B000 - 0x7BFFF - 4KB(32 pages) user upper1(top) protected area of eNVM1 memory.          
 *
 */
static nvm_status_t check_protection_reserved_nvm(uint32_t offset, uint32_t length)
{
    7798:	b4f0      	push	{r4, r5, r6, r7}
    uint32_t protection_user2;
    uint32_t protection_user3;
    uint32_t length_minus_one = 0u;
    nvm_status_t status = NVM_SUCCESS;
    
    if(0u != length)
    779a:	460b      	mov	r3, r1
    779c:	2900      	cmp	r1, #0
    779e:	d17e      	bne.n	789e <check_protection_reserved_nvm+0x106>
    {
        length_minus_one = length - 1u;
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    77a0:	f248 0200 	movw	r2, #32768	; 0x8000
    77a4:	f2c4 0203 	movt	r2, #16387	; 0x4003
    uint32_t protection_user2;
    uint32_t protection_user3;
    uint32_t length_minus_one = 0u;
    nvm_status_t status = NVM_SUCCESS;
    
    if(0u != length)
    77a8:	460c      	mov	r4, r1
    {
        length_minus_one = length - 1u;
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    77aa:	f8d2 114c 	ldr.w	r1, [r2, #332]	; 0x14c
    
    /* 005 device */
    if((0xF805u == device_version))
    77ae:	f64f 0c05 	movw	ip, #63493	; 0xf805
    if(0u != length)
    {
        length_minus_one = length - 1u;
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    77b2:	b289      	uxth	r1, r1
    
    /* 005 device */
    if((0xF805u == device_version))
    77b4:	4561      	cmp	r1, ip
    77b6:	d07e      	beq.n	78b6 <check_protection_reserved_nvm+0x11e>
                }
            }
        }
    }
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    77b8:	f5a1 4c78 	sub.w	ip, r1, #63488	; 0xf800
    77bc:	f1ac 0c02 	sub.w	ip, ip, #2
    77c0:	f1bc 0f02 	cmp.w	ip, #2
    77c4:	f200 80e2 	bhi.w	798c <check_protection_reserved_nvm+0x1f4>
    {    
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    77c8:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
        /* Check whether the eNVM0 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
    77cc:	f64f 71ff 	movw	r1, #65535	; 0xffff
    /* 010/025/050 device */
    else if((0xF802u == device_version) || (0xF803u == device_version) || (0xF804u == device_version))
    {    
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    77d0:	fa1f fc82 	uxth.w	ip, r2
        /* Check whether the eNVM0 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
    77d4:	458c      	cmp	ip, r1
    77d6:	d04b      	beq.n	7870 <check_protection_reserved_nvm+0xd8>
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
    77d8:	f002 0109 	and.w	r1, r2, #9
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            /* Check NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    77dc:	2901      	cmp	r1, #1
    77de:	bf14      	ite	ne
    77e0:	f04f 0c00 	movne.w	ip, #0
    77e4:	f04f 0c01 	moveq.w	ip, #1
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
        /* Check whether the eNVM0 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
    77e8:	f3c2 1603 	ubfx	r6, r2, #4, #4
            /* Check NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    77ec:	2908      	cmp	r1, #8
    77ee:	bf14      	ite	ne
    77f0:	4665      	movne	r5, ip
    77f2:	f04c 0501 	orreq.w	r5, ip, #1
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
        /* Check whether the eNVM0 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
    77f6:	f006 0209 	and.w	r2, r6, #9
            /* Check NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    77fa:	2d00      	cmp	r5, #0
    77fc:	f000 815d 	beq.w	7aba <check_protection_reserved_nvm+0x322>
               (NO_READ_WRITE == protection_user0))
            {
                /* Check offset is in the range of lower protect memory if it is
                 * then memory protected.
                 */            
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    7800:	1e45      	subs	r5, r0, #1
    7802:	f640 71fe 	movw	r1, #4094	; 0xffe
    7806:	428d      	cmp	r5, r1
    7808:	f200 815a 	bhi.w	7ac0 <check_protection_reserved_nvm+0x328>
    780c:	2b00      	cmp	r3, #0
    780e:	bf14      	ite	ne
    7810:	f04f 0c00 	movne.w	ip, #0
    7814:	f00c 0c01 	andeq.w	ip, ip, #1
    7818:	f08c 0601 	eor.w	r6, ip, #1
                {
                    protection_flag = protection_check(protection_user0, length);
                }
            }
            /* Check NVM0 upper protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user1) ||(WRITE_ONLY == protection_user1) || \
    781c:	2a01      	cmp	r2, #1
    781e:	bf14      	ite	ne
    7820:	2100      	movne	r1, #0
    7822:	2101      	moveq	r1, #1
    7824:	2a08      	cmp	r2, #8
    7826:	bf14      	ite	ne
    7828:	460d      	movne	r5, r1
    782a:	f041 0501 	orreq.w	r5, r1, #1
    782e:	b915      	cbnz	r5, 7836 <check_protection_reserved_nvm+0x9e>
    7830:	2a00      	cmp	r2, #0
    7832:	f040 814c 	bne.w	7ace <check_protection_reserved_nvm+0x336>
               (NO_READ_WRITE == protection_user1))
            {
                /* Check offset or (offset + length) is in the range of upper 
                 * protect memory if it is then memory protected.
                 */
                if(((offset >= UPPER0_PROTECT_BOTTOM_OFFSET) && \
    7836:	f5a0 327c 	sub.w	r2, r0, #258048	; 0x3f000
    783a:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    783e:	d30f      	bcc.n	7860 <check_protection_reserved_nvm+0xc8>
    7840:	eb04 0c00 	add.w	ip, r4, r0
    7844:	f5b0 3f7c 	cmp.w	r0, #258048	; 0x3f000
    7848:	bf2c      	ite	cs
    784a:	2200      	movcs	r2, #0
    784c:	2201      	movcc	r2, #1
    784e:	f5bc 3f7c 	cmp.w	ip, #258048	; 0x3f000
    7852:	bf34      	ite	cc
    7854:	2200      	movcc	r2, #0
    7856:	f002 0201 	andcs.w	r2, r2, #1
    785a:	2a00      	cmp	r2, #0
    785c:	f000 8137 	beq.w	7ace <check_protection_reserved_nvm+0x336>
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
    7860:	2b00      	cmp	r3, #0
    7862:	bf14      	ite	ne
    7864:	2300      	movne	r3, #0
    7866:	f001 0301 	andeq.w	r3, r1, #1
    786a:	2b00      	cmp	r3, #0
    786c:	f000 8132 	beq.w	7ad4 <check_protection_reserved_nvm+0x33c>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
             /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > UPPER0_PROTECT_TOP_OFFSET)
    7870:	1824      	adds	r4, r4, r0
    7872:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
    7876:	f080 811d 	bcs.w	7ab4 <check_protection_reserved_nvm+0x31c>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 16 pages reserved */
                if(((offset >= NVM0_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) || \
    787a:	f5a0 317e 	sub.w	r1, r0, #260096	; 0x3f800
    787e:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
    7882:	f0c0 8127 	bcc.w	7ad4 <check_protection_reserved_nvm+0x33c>
    7886:	f5b0 3f7e 	cmp.w	r0, #260096	; 0x3f800
    788a:	bf2c      	ite	cs
    788c:	2000      	movcs	r0, #0
    788e:	2001      	movcc	r0, #1
    7890:	f5b4 3f7e 	cmp.w	r4, #260096	; 0x3f800
    7894:	bf34      	ite	cc
    7896:	2000      	movcc	r0, #0
    7898:	f000 0001 	andcs.w	r0, r0, #1
    789c:	e10b      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
    if(0u != length)
    {
        length_minus_one = length - 1u;
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    789e:	f248 0200 	movw	r2, #32768	; 0x8000
    78a2:	f2c4 0203 	movt	r2, #16387	; 0x4003
    uint32_t length_minus_one = 0u;
    nvm_status_t status = NVM_SUCCESS;
    
    if(0u != length)
    {
        length_minus_one = length - 1u;
    78a6:	1e4c      	subs	r4, r1, #1
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    78a8:	f8d2 114c 	ldr.w	r1, [r2, #332]	; 0x14c
    
    /* 005 device */
    if((0xF805u == device_version))
    78ac:	f64f 0c05 	movw	ip, #63493	; 0xf805
    if(0u != length)
    {
        length_minus_one = length - 1u;
    }

    device_version = (SYSREG->DEVICE_VERSION & 0xFFFFu);
    78b0:	b289      	uxth	r1, r1
    
    /* 005 device */
    if((0xF805u == device_version))
    78b2:	4561      	cmp	r1, ip
    78b4:	d180      	bne.n	77b8 <check_protection_reserved_nvm+0x20>
    {
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    78b6:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    78ba:	f64f 71ff 	movw	r1, #65535	; 0xffff
    /* 005 device */
    if((0xF805u == device_version))
    {
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    78be:	fa1f fc82 	uxth.w	ip, r2
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    78c2:	458c      	cmp	ip, r1
    78c4:	d04b      	beq.n	795e <check_protection_reserved_nvm+0x1c6>
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
    78c6:	f002 0109 	and.w	r1, r2, #9
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            /* Checking NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    78ca:	2901      	cmp	r1, #1
    78cc:	bf14      	ite	ne
    78ce:	f04f 0c00 	movne.w	ip, #0
    78d2:	f04f 0c01 	moveq.w	ip, #1
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
    78d6:	f3c2 1203 	ubfx	r2, r2, #4, #4
            /* Checking NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    78da:	2908      	cmp	r1, #8
    78dc:	bf14      	ite	ne
    78de:	4665      	movne	r5, ip
    78e0:	f04c 0501 	orreq.w	r5, ip, #1
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
        /* Check whether the eNVM0 lower or upper area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
    78e4:	f002 0209 	and.w	r2, r2, #9
            /* Checking NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    78e8:	2d00      	cmp	r5, #0
    78ea:	f000 80eb 	beq.w	7ac4 <check_protection_reserved_nvm+0x32c>
               (NO_READ_WRITE == protection_user0))
            {   
                /* Check offset is in the range of lower protect memory if it is
                 * then memory protected.
                 */
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    78ee:	1e41      	subs	r1, r0, #1
    78f0:	f640 76fe 	movw	r6, #4094	; 0xffe
    78f4:	42b1      	cmp	r1, r6
    78f6:	f200 80e8 	bhi.w	7aca <check_protection_reserved_nvm+0x332>
    78fa:	2b00      	cmp	r3, #0
    78fc:	bf14      	ite	ne
    78fe:	f04f 0c00 	movne.w	ip, #0
    7902:	f00c 0c01 	andeq.w	ip, ip, #1
    7906:	f08c 0601 	eor.w	r6, ip, #1
                {
                    protection_flag = protection_check(protection_user0, length);
                }
            }
            /* Checking NVM0 upper protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user1) ||(WRITE_ONLY == protection_user1) || \
    790a:	2a01      	cmp	r2, #1
    790c:	bf14      	ite	ne
    790e:	2100      	movne	r1, #0
    7910:	2101      	moveq	r1, #1
    7912:	2a08      	cmp	r2, #8
    7914:	bf14      	ite	ne
    7916:	460d      	movne	r5, r1
    7918:	f041 0501 	orreq.w	r5, r1, #1
    791c:	b915      	cbnz	r5, 7924 <check_protection_reserved_nvm+0x18c>
    791e:	2a00      	cmp	r2, #0
    7920:	f040 80da 	bne.w	7ad8 <check_protection_reserved_nvm+0x340>
               (NO_READ_WRITE == protection_user1))
            {
                /* Check offset or (offset + length) is in the range of upper 
                 *  protect memory if it is then memory protected.
                 */
                if(((offset >= OO5_UPPER0_PROTECT_BOTTOM_OFFSET) && \
    7924:	f5a0 3cf8 	sub.w	ip, r0, #126976	; 0x1f000
    7928:	f5bc 5f80 	cmp.w	ip, #4096	; 0x1000
    792c:	d30f      	bcc.n	794e <check_protection_reserved_nvm+0x1b6>
    792e:	eb04 0c00 	add.w	ip, r4, r0
    7932:	f5b0 3ff8 	cmp.w	r0, #126976	; 0x1f000
    7936:	bf2c      	ite	cs
    7938:	2200      	movcs	r2, #0
    793a:	2201      	movcc	r2, #1
    793c:	f5bc 3ff8 	cmp.w	ip, #126976	; 0x1f000
    7940:	bf34      	ite	cc
    7942:	2200      	movcc	r2, #0
    7944:	f002 0201 	andcs.w	r2, r2, #1
    7948:	2a00      	cmp	r2, #0
    794a:	f000 80c5 	beq.w	7ad8 <check_protection_reserved_nvm+0x340>
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
    794e:	2b00      	cmp	r3, #0
    7950:	bf14      	ite	ne
    7952:	2300      	movne	r3, #0
    7954:	f001 0301 	andeq.w	r3, r1, #1
    7958:	2b00      	cmp	r3, #0
    795a:	f000 80bb 	beq.w	7ad4 <check_protection_reserved_nvm+0x33c>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > OO5_UPPER0_PROTECT_TOP_OFFSET)
    795e:	1824      	adds	r4, r4, r0
    7960:	f5b4 3f00 	cmp.w	r4, #131072	; 0x20000
    7964:	f080 80a6 	bcs.w	7ab4 <check_protection_reserved_nvm+0x31c>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 16 pages reserved */
                if(((offset >= OO5_NVM_RSV_OFFSET) && (offset <= OO5_UPPER0_PROTECT_TOP_OFFSET)) || \
    7968:	f5a0 31fc 	sub.w	r1, r0, #129024	; 0x1f800
    796c:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
    7970:	f0c0 80b0 	bcc.w	7ad4 <check_protection_reserved_nvm+0x33c>
    7974:	f5b0 3ffc 	cmp.w	r0, #129024	; 0x1f800
    7978:	bf2c      	ite	cs
    797a:	2000      	movcs	r0, #0
    797c:	2001      	movcc	r0, #1
    797e:	f5b4 3ffc 	cmp.w	r4, #129024	; 0x1f800
    7982:	bf34      	ite	cc
    7984:	2000      	movcc	r0, #0
    7986:	f000 0001 	andcs.w	r0, r0, #1
    798a:	e094      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
                }
            }
        }
    }
    /* 060 device */
    else if(0xF808u == device_version)
    798c:	f64f 0c08 	movw	ip, #63496	; 0xf808
    7990:	4561      	cmp	r1, ip
    7992:	f000 80b2 	beq.w	7afa <check_protection_reserved_nvm+0x362>
                }
            }
        }    
    }
    /* 090/150 device */
    else if((0xF807u == device_version) || (0xF806u == device_version))
    7996:	f5a1 4178 	sub.w	r1, r1, #63488	; 0xf800
    799a:	3906      	subs	r1, #6
    799c:	2901      	cmp	r1, #1
    799e:	d901      	bls.n	79a4 <check_protection_reserved_nvm+0x20c>
    79a0:	2000      	movs	r0, #0
    79a2:	e088      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
    {
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    79a4:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
    79a8:	f64f 71ff 	movw	r1, #65535	; 0xffff
    /* 090/150 device */
    else if((0xF807u == device_version) || (0xF806u == device_version))
    {
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    79ac:	fa1f fc82 	uxth.w	ip, r2
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
    79b0:	458c      	cmp	ip, r1
    79b2:	d07b      	beq.n	7aac <check_protection_reserved_nvm+0x314>
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
    79b4:	f002 0609 	and.w	r6, r2, #9
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
            
            /* Check eNVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    79b8:	2e01      	cmp	r6, #1
    79ba:	bf14      	ite	ne
    79bc:	2700      	movne	r7, #0
    79be:	2701      	moveq	r7, #1
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
    79c0:	f3c2 3103 	ubfx	r1, r2, #12, #4
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
    79c4:	f3c2 1503 	ubfx	r5, r2, #4, #4
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
            
            /* Check eNVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    79c8:	2e08      	cmp	r6, #8
    79ca:	bf14      	ite	ne
    79cc:	46bc      	movne	ip, r7
    79ce:	f047 0c01 	orreq.w	ip, r7, #1
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
    79d2:	f3c2 2203 	ubfx	r2, r2, #8, #4
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
        /* Check whether the eNVM0 and eNVM1 lower or upper area is protected or not */        
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
    79d6:	f005 0509 	and.w	r5, r5, #9
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
    79da:	f002 0209 	and.w	r2, r2, #9
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
    79de:	f001 0109 	and.w	r1, r1, #9
            
            /* Check eNVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    79e2:	f1bc 0f00 	cmp.w	ip, #0
    79e6:	d17b      	bne.n	7ae0 <check_protection_reserved_nvm+0x348>
    79e8:	2e00      	cmp	r6, #0
    79ea:	d079      	beq.n	7ae0 <check_protection_reserved_nvm+0x348>
               (NO_READ_WRITE == protection_user0))
            {
                /* Check offset is in the range of lower0 protect memory if it is
                 * then memory protected.
                 */
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    79ec:	2700      	movs	r7, #0
                {
                    protection_flag = protection_check(protection_user0, length);
                }
            }
            /* Check eNVM0 upper0 protected area(in eNVM1) is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user1) ||(WRITE_ONLY == protection_user1) || \
    79ee:	2d01      	cmp	r5, #1
    79f0:	bf14      	ite	ne
    79f2:	2600      	movne	r6, #0
    79f4:	2601      	moveq	r6, #1
    79f6:	2d08      	cmp	r5, #8
    79f8:	bf14      	ite	ne
    79fa:	46b4      	movne	ip, r6
    79fc:	f046 0c01 	orreq.w	ip, r6, #1
    7a00:	f1bc 0f00 	cmp.w	ip, #0
    7a04:	d100      	bne.n	7a08 <check_protection_reserved_nvm+0x270>
    7a06:	b9d5      	cbnz	r5, 7a3e <check_protection_reserved_nvm+0x2a6>
               (NO_READ_WRITE == protection_user1))
            {
                /* Check offset or (offset + length) is in the range of upper0
                 *  protect memory if it is then memory protected.
                 */
                if(((offset >= NVM0_UPPER0_PROTECT_BOTTOM_OFFSET) && \
    7a08:	f5a0 25fa 	sub.w	r5, r0, #512000	; 0x7d000
    7a0c:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
    7a10:	d30e      	bcc.n	7a30 <check_protection_reserved_nvm+0x298>
    7a12:	1825      	adds	r5, r4, r0
    7a14:	f5b0 2ffa 	cmp.w	r0, #512000	; 0x7d000
    7a18:	bf2c      	ite	cs
    7a1a:	f04f 0c00 	movcs.w	ip, #0
    7a1e:	f04f 0c01 	movcc.w	ip, #1
    7a22:	f5b5 2ffa 	cmp.w	r5, #512000	; 0x7d000
    7a26:	bf34      	ite	cc
    7a28:	2500      	movcc	r5, #0
    7a2a:	f00c 0501 	andcs.w	r5, ip, #1
    7a2e:	b135      	cbz	r5, 7a3e <check_protection_reserved_nvm+0x2a6>
    7a30:	2b00      	cmp	r3, #0
    7a32:	bf14      	ite	ne
    7a34:	2600      	movne	r6, #0
    7a36:	f006 0601 	andeq.w	r6, r6, #1
    7a3a:	f086 0701 	eor.w	r7, r6, #1
                {
                    protection_flag = protection_check(protection_user1, length);
                }
            }
            /* Check NVM1 lower1 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user2) ||(WRITE_ONLY == protection_user2) || \
    7a3e:	2a01      	cmp	r2, #1
    7a40:	bf14      	ite	ne
    7a42:	f04f 0c00 	movne.w	ip, #0
    7a46:	f04f 0c01 	moveq.w	ip, #1
    7a4a:	2a08      	cmp	r2, #8
    7a4c:	bf14      	ite	ne
    7a4e:	4665      	movne	r5, ip
    7a50:	f04c 0501 	orreq.w	r5, ip, #1
    7a54:	b905      	cbnz	r5, 7a58 <check_protection_reserved_nvm+0x2c0>
    7a56:	b9ca      	cbnz	r2, 7a8c <check_protection_reserved_nvm+0x2f4>
               (NO_READ_WRITE == protection_user2))
            {
                /* Check offset or (offset + length)is in the range of lower1 
                 * protect memory if it is then memory protected.
                 */
                if(((offset >= LOWER1_PROTECT_BOTTOM_OFFSET) && \
    7a58:	f5a0 22f8 	sub.w	r2, r0, #507904	; 0x7c000
    7a5c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    7a60:	d30c      	bcc.n	7a7c <check_protection_reserved_nvm+0x2e4>
    7a62:	1825      	adds	r5, r4, r0
    7a64:	f5b0 2ff8 	cmp.w	r0, #507904	; 0x7c000
    7a68:	bf2c      	ite	cs
    7a6a:	2200      	movcs	r2, #0
    7a6c:	2201      	movcc	r2, #1
    7a6e:	f5b5 2ff8 	cmp.w	r5, #507904	; 0x7c000
    7a72:	bf34      	ite	cc
    7a74:	2200      	movcc	r2, #0
    7a76:	f002 0201 	andcs.w	r2, r2, #1
    7a7a:	b13a      	cbz	r2, 7a8c <check_protection_reserved_nvm+0x2f4>
    7a7c:	2b00      	cmp	r3, #0
    7a7e:	bf14      	ite	ne
    7a80:	f04f 0c00 	movne.w	ip, #0
    7a84:	f00c 0c01 	andeq.w	ip, ip, #1
    7a88:	f08c 0701 	eor.w	r7, ip, #1
                {
                    protection_flag = protection_check(protection_user2, length);
                }
            }
            /* Checking NVM1 upper protected area for Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user3) ||(WRITE_ONLY == protection_user3) || \
    7a8c:	2901      	cmp	r1, #1
    7a8e:	bf14      	ite	ne
    7a90:	2200      	movne	r2, #0
    7a92:	2201      	moveq	r2, #1
    7a94:	2908      	cmp	r1, #8
    7a96:	bf14      	ite	ne
    7a98:	4615      	movne	r5, r2
    7a9a:	f042 0501 	orreq.w	r5, r2, #1
    7a9e:	2d00      	cmp	r5, #0
    7aa0:	f040 80a9 	bne.w	7bf6 <check_protection_reserved_nvm+0x45e>
    7aa4:	2900      	cmp	r1, #0
    7aa6:	f000 80a6 	beq.w	7bf6 <check_protection_reserved_nvm+0x45e>
                    protection_flag = protection_check(protection_user3, length);
                }
            }
        }
        /* Check lower0/1 and upper0/1 memory is protected or not */
        if(PROTECTION_ON == protection_flag)
    7aaa:	b99f      	cbnz	r7, 7ad4 <check_protection_reserved_nvm+0x33c>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory */
            if((offset + length_minus_one) > NVM1_TOP_OFFSET)
    7aac:	1824      	adds	r4, r4, r0
    7aae:	f5b4 2f00 	cmp.w	r4, #524288	; 0x80000
    7ab2:	d37f      	bcc.n	7bb4 <check_protection_reserved_nvm+0x41c>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) || \
    7ab4:	2006      	movs	r0, #6
                }
            }
        }
    }
    return status;
}
    7ab6:	bcf0      	pop	{r4, r5, r6, r7}
    7ab8:	4770      	bx	lr
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            /* Check NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    7aba:	2900      	cmp	r1, #0
    7abc:	f43f aea0 	beq.w	7800 <check_protection_reserved_nvm+0x68>
               (NO_READ_WRITE == protection_user0))
            {
                /* Check offset is in the range of lower protect memory if it is
                 * then memory protected.
                 */            
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    7ac0:	2600      	movs	r6, #0
    7ac2:	e6ab      	b.n	781c <check_protection_reserved_nvm+0x84>
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            /* Checking NVM0 lower protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    7ac4:	2900      	cmp	r1, #0
    7ac6:	f43f af12 	beq.w	78ee <check_protection_reserved_nvm+0x156>
               (NO_READ_WRITE == protection_user0))
            {   
                /* Check offset is in the range of lower protect memory if it is
                 * then memory protected.
                 */
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    7aca:	2600      	movs	r6, #0
    7acc:	e71d      	b.n	790a <check_protection_reserved_nvm+0x172>
                    protection_flag = protection_check(protection_user1, length);
                }
            }
        }
        /* Check lower or upper memory is protected or not */
        if(PROTECTION_ON == protection_flag)
    7ace:	2e00      	cmp	r6, #0
    7ad0:	f43f aece 	beq.w	7870 <check_protection_reserved_nvm+0xd8>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) || \
    7ad4:	2001      	movs	r0, #1
    7ad6:	e7ee      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
                    protection_flag = protection_check(protection_user1, length);
                }
            }
        }
        /* Check memory is protected or not */
        if(PROTECTION_ON == protection_flag)
    7ad8:	2e00      	cmp	r6, #0
    7ada:	f43f af40 	beq.w	795e <check_protection_reserved_nvm+0x1c6>
    7ade:	e7f9      	b.n	7ad4 <check_protection_reserved_nvm+0x33c>
               (NO_READ_WRITE == protection_user0))
            {
                /* Check offset is in the range of lower0 protect memory if it is
                 * then memory protected.
                 */
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    7ae0:	1e46      	subs	r6, r0, #1
    7ae2:	f640 7cfe 	movw	ip, #4094	; 0xffe
    7ae6:	4566      	cmp	r6, ip
    7ae8:	d880      	bhi.n	79ec <check_protection_reserved_nvm+0x254>
    7aea:	2b00      	cmp	r3, #0
    7aec:	bf14      	ite	ne
    7aee:	2700      	movne	r7, #0
    7af0:	f007 0701 	andeq.w	r7, r7, #1
    7af4:	f087 0701 	eor.w	r7, r7, #1
    7af8:	e779      	b.n	79ee <check_protection_reserved_nvm+0x256>
    /* 060 device */
    else if(0xF808u == device_version)
    {
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    7afa:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
        /* Check whether the eNVM0 lower0/1 or upper0/1 area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    7afe:	f64f 71ff 	movw	r1, #65535	; 0xffff
    /* 060 device */
    else if(0xF808u == device_version)
    {
        protection_flag = PROTECTION_OFF;
        /* Read eNVM user protect register for lower and upper area protection data */
        protection_data = (SYSREG->ENVM_PROTECT_USER & PROTECT_USER_MASK);
    7b02:	fa1f fc82 	uxth.w	ip, r2
        /* Check whether the eNVM0 lower0/1 or upper0/1 area is protected or not */
        if(PROTECT_USER_MASK != protection_data)
    7b06:	458c      	cmp	ip, r1
    7b08:	d03f      	beq.n	7b8a <check_protection_reserved_nvm+0x3f2>
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
    7b0a:	f002 0109 	and.w	r1, r2, #9
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
            
            /* Check NVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    7b0e:	2901      	cmp	r1, #1
    7b10:	bf14      	ite	ne
    7b12:	f04f 0c00 	movne.w	ip, #0
    7b16:	f04f 0c01 	moveq.w	ip, #1
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
    7b1a:	f3c2 3503 	ubfx	r5, r2, #12, #4
            
            /* Check NVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    7b1e:	2908      	cmp	r1, #8
    7b20:	bf14      	ite	ne
    7b22:	4666      	movne	r6, ip
    7b24:	f04c 0601 	orreq.w	r6, ip, #1
        if(PROTECT_USER_MASK != protection_data)
        {
            protection_user0 = (protection_data & 0x000Fu) & READ_WRITE_MASK;
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
    7b28:	f005 0209 	and.w	r2, r5, #9
            
            /* Check NVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    7b2c:	2e00      	cmp	r6, #0
    7b2e:	d052      	beq.n	7bd6 <check_protection_reserved_nvm+0x43e>
               (NO_READ_WRITE == protection_user0))
            {
                /* Check offset is in the range of lower0 protect memory if it is
                 * then memory protected.
                 */
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    7b30:	1e46      	subs	r6, r0, #1
    7b32:	f640 71fe 	movw	r1, #4094	; 0xffe
    7b36:	428e      	cmp	r6, r1
    7b38:	d950      	bls.n	7bdc <check_protection_reserved_nvm+0x444>
    7b3a:	2600      	movs	r6, #0
                {
                    protection_flag = protection_check(protection_user0, length);
                }
            }
            /* Check NVM0 upper1 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user3) ||(WRITE_ONLY == protection_user3) || \
    7b3c:	2a01      	cmp	r2, #1
    7b3e:	bf14      	ite	ne
    7b40:	2100      	movne	r1, #0
    7b42:	2101      	moveq	r1, #1
    7b44:	2a08      	cmp	r2, #8
    7b46:	bf14      	ite	ne
    7b48:	460d      	movne	r5, r1
    7b4a:	f041 0501 	orreq.w	r5, r1, #1
    7b4e:	b90d      	cbnz	r5, 7b54 <check_protection_reserved_nvm+0x3bc>
    7b50:	2a00      	cmp	r2, #0
    7b52:	d14c      	bne.n	7bee <check_protection_reserved_nvm+0x456>
               (NO_READ_WRITE == protection_user3))
            {
                /* Check offset or (offset + length) is in the range of upper1 
                 *  protect memory if it is then memory protected.
                 */
                if(((offset >= NVM0_UPPER1_PROTECT_BOTTOM_OFFSET) && \
    7b54:	f5a0 3274 	sub.w	r2, r0, #249856	; 0x3d000
    7b58:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    7b5c:	d30e      	bcc.n	7b7c <check_protection_reserved_nvm+0x3e4>
    7b5e:	eb04 0c00 	add.w	ip, r4, r0
    7b62:	f5b0 3f74 	cmp.w	r0, #249856	; 0x3d000
    7b66:	bf2c      	ite	cs
    7b68:	2200      	movcs	r2, #0
    7b6a:	2201      	movcc	r2, #1
    7b6c:	f5bc 3f74 	cmp.w	ip, #249856	; 0x3d000
    7b70:	bf34      	ite	cc
    7b72:	2200      	movcc	r2, #0
    7b74:	f002 0201 	andcs.w	r2, r2, #1
    7b78:	2a00      	cmp	r2, #0
    7b7a:	d038      	beq.n	7bee <check_protection_reserved_nvm+0x456>
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
    7b7c:	2b00      	cmp	r3, #0
    7b7e:	bf14      	ite	ne
    7b80:	2300      	movne	r3, #0
    7b82:	f001 0301 	andeq.w	r3, r1, #1
    7b86:	2b00      	cmp	r3, #0
    7b88:	d0a4      	beq.n	7ad4 <check_protection_reserved_nvm+0x33c>
            status = NVM_PROTECTION_ERROR;
        }
        else
        {
            /* Check (offset + length) is out of eNVM memory*/
            if((offset + length_minus_one) > UPPER0_PROTECT_TOP_OFFSET)
    7b8a:	1824      	adds	r4, r4, r0
    7b8c:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
    7b90:	d290      	bcs.n	7ab4 <check_protection_reserved_nvm+0x31c>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 64 pages reserved */
                if(((offset >= O60_NVM_RSV_OFFSET) && (offset <= UPPER0_PROTECT_TOP_OFFSET)) || \
    7b92:	f5a0 3178 	sub.w	r1, r0, #253952	; 0x3e000
    7b96:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
    7b9a:	d39b      	bcc.n	7ad4 <check_protection_reserved_nvm+0x33c>
    7b9c:	f5b0 3f78 	cmp.w	r0, #253952	; 0x3e000
    7ba0:	bf2c      	ite	cs
    7ba2:	2000      	movcs	r0, #0
    7ba4:	2001      	movcc	r0, #1
    7ba6:	f5b4 3f78 	cmp.w	r4, #253952	; 0x3e000
    7baa:	bf34      	ite	cc
    7bac:	2000      	movcc	r0, #0
    7bae:	f000 0001 	andcs.w	r0, r0, #1
    7bb2:	e780      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) || \
    7bb4:	f5a0 22fc 	sub.w	r2, r0, #516096	; 0x7e000
    7bb8:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    7bbc:	d38a      	bcc.n	7ad4 <check_protection_reserved_nvm+0x33c>
    7bbe:	f5b0 2ffc 	cmp.w	r0, #516096	; 0x7e000
    7bc2:	bf2c      	ite	cs
    7bc4:	2000      	movcs	r0, #0
    7bc6:	2001      	movcc	r0, #1
    7bc8:	f5b4 2ffc 	cmp.w	r4, #516096	; 0x7e000
    7bcc:	bf34      	ite	cc
    7bce:	2000      	movcc	r0, #0
    7bd0:	f000 0001 	andcs.w	r0, r0, #1
    7bd4:	e76f      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
            protection_user1 = ((protection_data & 0x00F0u) >> 4u) & READ_WRITE_MASK;
            protection_user2 = ((protection_data & 0x0F00u) >> 8u) & READ_WRITE_MASK;
            protection_user3 = ((protection_data & 0xF000u) >> 12u) & READ_WRITE_MASK;
            
            /* Check NVM0 lower0 protected area is Read or Write or 'No R/W' access */
            if((READ_ONLY == protection_user0) ||(WRITE_ONLY == protection_user0) || \
    7bd6:	2900      	cmp	r1, #0
    7bd8:	d1af      	bne.n	7b3a <check_protection_reserved_nvm+0x3a2>
    7bda:	e7a9      	b.n	7b30 <check_protection_reserved_nvm+0x398>
               (NO_READ_WRITE == protection_user0))
            {
                /* Check offset is in the range of lower0 protect memory if it is
                 * then memory protected.
                 */
                if((offset > LOWER0_PROTECT_BOTTOM_OFFSET) && \
    7bdc:	2b00      	cmp	r3, #0
    7bde:	bf14      	ite	ne
    7be0:	f04f 0c00 	movne.w	ip, #0
    7be4:	f00c 0c01 	andeq.w	ip, ip, #1
    7be8:	f08c 0601 	eor.w	r6, ip, #1
    7bec:	e7a6      	b.n	7b3c <check_protection_reserved_nvm+0x3a4>
        }
        /* Check lower0 or upper1 memory is protected or not.
         * No protection check for  0x3F000 - 0x3FFFF and 0x3E000 - 0x3EFFF lower1/upper0 
         * protected area of eNVM0 memory because it's fall under eNVM reserved area    
         */
        if(PROTECTION_ON == protection_flag)
    7bee:	2e00      	cmp	r6, #0
    7bf0:	d0cb      	beq.n	7b8a <check_protection_reserved_nvm+0x3f2>
                status = NVM_INVALID_PARAMETER;
            }
            else
            {
                /* Check offset is in eNVM reserved memory - 64 pages reserved */
                if(((offset >= NVM1_RSV_OFFSET) && (offset <= NVM1_TOP_OFFSET)) || \
    7bf2:	2001      	movs	r0, #1
    7bf4:	e75f      	b.n	7ab6 <check_protection_reserved_nvm+0x31e>
               (NO_READ_WRITE == protection_user3))
            {
                /* Check offset or (offset + length)is in the range of upper1 
                 * protect memory if it is then memory protected.
                 */
                if(((offset >= UPPER1_PROTECT_BOTTOM_OFFSET) && \
    7bf6:	f5a0 21f6 	sub.w	r1, r0, #503808	; 0x7b000
    7bfa:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
    7bfe:	d30f      	bcc.n	7c20 <check_protection_reserved_nvm+0x488>
    7c00:	eb04 0c00 	add.w	ip, r4, r0
    7c04:	f5b0 2ff6 	cmp.w	r0, #503808	; 0x7b000
    7c08:	bf2c      	ite	cs
    7c0a:	2100      	movcs	r1, #0
    7c0c:	2101      	movcc	r1, #1
    7c0e:	f5bc 2ff6 	cmp.w	ip, #503808	; 0x7b000
    7c12:	bf34      	ite	cc
    7c14:	2100      	movcc	r1, #0
    7c16:	f001 0101 	andcs.w	r1, r1, #1
    7c1a:	2900      	cmp	r1, #0
    7c1c:	f43f af45 	beq.w	7aaa <check_protection_reserved_nvm+0x312>
static uint32_t protection_check(uint32_t protect_user, uint32_t length)
{    
    uint32_t protect_flag;
    
    /* Check Read Only access for page write count */
    if((READ_ONLY == protect_user) && (0x0u == length))
    7c20:	2b00      	cmp	r3, #0
    7c22:	bf14      	ite	ne
    7c24:	2300      	movne	r3, #0
    7c26:	f002 0301 	andeq.w	r3, r2, #1
    7c2a:	2b00      	cmp	r3, #0
    7c2c:	f47f af3e 	bne.w	7aac <check_protection_reserved_nvm+0x314>
    7c30:	e750      	b.n	7ad4 <check_protection_reserved_nvm+0x33c>
    7c32:	bf00      	nop

00007c34 <NVM_read_page_write_count>:
uint32_t
NVM_read_page_write_count
(
    uint32_t addr
)
{
    7c34:	b530      	push	{r4, r5, lr}
    uint32_t write_count = 0u;
    uint32_t block;
    uint32_t offset;
    uint32_t status;

    if((addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7c36:	f240 0201 	movw	r2, #1
    7c3a:	f64f 7cfe 	movw	ip, #65534	; 0xfffe
    7c3e:	f6cf 72f8 	movt	r2, #65528	; 0xfff8
    7c42:	f2c6 0c07 	movt	ip, #24583	; 0x6007
    7c46:	f240 0100 	movw	r1, #0
    7c4a:	1883      	adds	r3, r0, r2
    7c4c:	f6c5 71f8 	movt	r1, #24568	; 0x5ff8
    7c50:	4560      	cmp	r0, ip
    7c52:	bf94      	ite	ls
    7c54:	2200      	movls	r2, #0
    7c56:	2201      	movhi	r2, #1
    7c58:	428b      	cmp	r3, r1
    7c5a:	bf8c      	ite	hi
    7c5c:	4611      	movhi	r1, r2
    7c5e:	f042 0101 	orrls.w	r1, r2, #1
uint32_t
NVM_read_page_write_count
(
    uint32_t addr
)
{
    7c62:	b083      	sub	sp, #12
    uint32_t write_count = 0u;
    uint32_t block;
    uint32_t offset;
    uint32_t status;

    if((addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7c64:	b111      	cbz	r1, 7c6c <NVM_read_page_write_count+0x38>
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7c66:	2000      	movs	r0, #0
            /* The write count is contained in bits [24:4] of the page's auxiliary data. */
            write_count = (write_count & AUX_DATA_WC_MASK) >> AUX_DATA_WC_SHIFT;
        }
    }
    return write_count;
}
    7c68:	b003      	add	sp, #12
    7c6a:	bd30      	pop	{r4, r5, pc}
        write_count = 0u;
    }
    else
    {
        write_count = 0u;
        offset = addr & NVM_OFFSET_SIGNIFICANT_BITS;
    7c6c:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
    7c70:	f424 0478 	bic.w	r4, r4, #16252928	; 0xf80000

        status = check_protection_reserved_nvm(offset, 0u);
    7c74:	4620      	mov	r0, r4
    7c76:	f7ff fd8f 	bl	7798 <check_protection_reserved_nvm>
        
        if(NVM_SUCCESS == status)
    7c7a:	4605      	mov	r5, r0
    7c7c:	2800      	cmp	r0, #0
    7c7e:	d1f2      	bne.n	7c66 <NVM_read_page_write_count+0x32>
        {  
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(offset, 1u);
    7c80:	4620      	mov	r0, r4
    7c82:	2101      	movs	r1, #1
    7c84:	f7ff fd48 	bl	7718 <get_ctrl_access>
        
            /* Read page write counter. */
            if(NVM_SUCCESS == status)
    7c88:	b308      	cbz	r0, 7cce <NVM_read_page_write_count+0x9a>
    7c8a:	4628      	mov	r0, r5

static void release_ctrl_access(void)
{
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    7c8c:	f640 3330 	movw	r3, #2864	; 0xb30
    7c90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7c94:	781a      	ldrb	r2, [r3, #0]
    if(block_locked)
    7c96:	f012 0f01 	tst.w	r2, #1
    7c9a:	d009      	beq.n	7cb0 <NVM_read_page_write_count+0x7c>
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    7c9c:	f240 0100 	movw	r1, #0
    7ca0:	f2c6 0108 	movt	r1, #24584	; 0x6008
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    7ca4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    7ca8:	2400      	movs	r4, #0
    7caa:	f8c1 41fc 	str.w	r4, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    7cae:	701a      	strb	r2, [r3, #0]
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    7cb0:	f012 0f02 	tst.w	r2, #2
    7cb4:	d0d8      	beq.n	7c68 <NVM_read_page_write_count+0x34>
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    7cb6:	f240 0100 	movw	r1, #0
    7cba:	f2c6 010c 	movt	r1, #24588	; 0x600c
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7cbe:	f022 0e02 	bic.w	lr, r2, #2
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    7cc2:	2400      	movs	r4, #0
    7cc4:	f8c1 41fc 	str.w	r4, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7cc8:	f883 e000 	strb.w	lr, [r3]
    7ccc:	e7cc      	b.n	7c68 <NVM_read_page_write_count+0x34>
            status = get_ctrl_access(offset, 1u);
        
            /* Read page write counter. */
            if(NVM_SUCCESS == status)
            {
                if(offset < NVM1_BOTTOM_OFFSET)
    7cce:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
                {
                    block = NVM_BLOCK_1;
                    offset = offset - NVM1_BOTTOM_OFFSET;
                }
        
                g_nvm[block]->NV_PAGE_STATUS |= 0x2u;
    7cd2:	bf2b      	itete	cs
    7cd4:	f240 0200 	movwcs	r2, #0
    7cd8:	f240 0200 	movwcc	r2, #0
    7cdc:	f2c6 020c 	movtcs	r2, #24588	; 0x600c
    7ce0:	f2c6 0208 	movtcc	r2, #24584	; 0x6008
    7ce4:	f8d2 3128 	ldr.w	r3, [r2, #296]	; 0x128
        
                if(block == NVM_BLOCK_0)
                {
                    write_count = *((uint32_t *)((NVM0_BASE_ADDRESS + offset) & PAGE_ADDR_MASK));
    7ce8:	f104 40c0 	add.w	r0, r4, #1610612736	; 0x60000000
                {
                    block = NVM_BLOCK_1;
                    offset = offset - NVM1_BOTTOM_OFFSET;
                }
        
                g_nvm[block]->NV_PAGE_STATUS |= 0x2u;
    7cec:	f043 0102 	orr.w	r1, r3, #2
    7cf0:	f8c2 1128 	str.w	r1, [r2, #296]	; 0x128
        
                if(block == NVM_BLOCK_0)
                {
                    write_count = *((uint32_t *)((NVM0_BASE_ADDRESS + offset) & PAGE_ADDR_MASK));
    7cf4:	f020 047f 	bic.w	r4, r0, #127	; 0x7f
    7cf8:	6820      	ldr	r0, [r4, #0]
    7cfa:	2100      	movs	r1, #0
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    {
        do {
            ctrl_status = g_nvm[block]->STATUS;
    7cfc:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
    7d00:	9301      	str	r3, [sp, #4]
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
    7d02:	9b01      	ldr	r3, [sp, #4]
        } while(0u == ctrl_ready);
    7d04:	f013 0f01 	tst.w	r3, #1
    7d08:	d0f8      	beq.n	7cfc <NVM_read_page_write_count+0xc8>
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    7d0a:	3101      	adds	r1, #1
    7d0c:	2902      	cmp	r1, #2
    7d0e:	d1f5      	bne.n	7cfc <NVM_read_page_write_count+0xc8>
            ctrl_status = g_nvm[block]->STATUS;
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
        } while(0u == ctrl_ready);
    }
    
    return ctrl_status;
    7d10:	9b01      	ldr	r3, [sp, #4]
                }
        
                /* Wait for NVM to become ready. */
                status = wait_nvm_ready(block);
        
                g_nvm[block]->NV_PAGE_STATUS &= ~(0x2u);
    7d12:	f8d2 3128 	ldr.w	r3, [r2, #296]	; 0x128
    7d16:	f3c0 1013 	ubfx	r0, r0, #4, #20
    7d1a:	f023 0102 	bic.w	r1, r3, #2
    7d1e:	f8c2 1128 	str.w	r1, [r2, #296]	; 0x128
    7d22:	e7b3      	b.n	7c8c <NVM_read_page_write_count+0x58>

00007d24 <NVM_unlock>:
NVM_unlock
(
    uint32_t start_addr,
    uint32_t length
)
{
    7d24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    7d28:	f248 0200 	movw	r2, #32768	; 0x8000
    7d2c:	f2c4 0203 	movt	r2, #16387	; 0x4003
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    
    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7d30:	f240 0301 	movw	r3, #1
    7d34:	f64f 75fe 	movw	r5, #65534	; 0xfffe
    7d38:	f2c6 0507 	movt	r5, #24583	; 0x6007
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    7d3c:	68d4      	ldr	r4, [r2, #12]
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    
    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7d3e:	f6cf 73f8 	movt	r3, #65528	; 0xfff8
    7d42:	f240 0a00 	movw	sl, #0
    7d46:	42a8      	cmp	r0, r5
    7d48:	bf94      	ite	ls
    7d4a:	f04f 0c00 	movls.w	ip, #0
    7d4e:	f04f 0c01 	movhi.w	ip, #1
    7d52:	18c3      	adds	r3, r0, r3
    7d54:	f6c5 7af8 	movt	sl, #24568	; 0x5ff8
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    7d58:	f444 55ff 	orr.w	r5, r4, #8160	; 0x1fe0
    
    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7d5c:	4553      	cmp	r3, sl
    7d5e:	bf8c      	ite	hi
    7d60:	4663      	movhi	r3, ip
    7d62:	f04c 0301 	orrls.w	r3, ip, #1
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    7d66:	60d5      	str	r5, [r2, #12]
NVM_unlock
(
    uint32_t start_addr,
    uint32_t length
)
{
    7d68:	b083      	sub	sp, #12
    7d6a:	460d      	mov	r5, r1
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    
    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7d6c:	b903      	cbnz	r3, 7d70 <NVM_unlock+0x4c>
    7d6e:	b951      	cbnz	r1, 7d86 <NVM_unlock+0x62>
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7d70:	f04f 0a06 	mov.w	sl, #6
            }
        }
    }
    
    /* Restore back to original value. */
    SYSREG->ENVM_CR = initial_nvm_config;
    7d74:	f248 0300 	movw	r3, #32768	; 0x8000
    7d78:	f2c4 0303 	movt	r3, #16387	; 0x4003
    7d7c:	60dc      	str	r4, [r3, #12]
    
    return status;
}
    7d7e:	4650      	mov	r0, sl
    7d80:	b003      	add	sp, #12
    7d82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        status =  NVM_INVALID_PARAMETER;
    }
    else
    {
        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */
    7d86:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
    7d8a:	f426 0678 	bic.w	r6, r6, #16252928	; 0xf80000

        status = check_protection_reserved_nvm(nvm_offset, length);
    7d8e:	4630      	mov	r0, r6
    7d90:	f7ff fd02 	bl	7798 <check_protection_reserved_nvm>

        /* Check  */
        if(NVM_SUCCESS == status)
    7d94:	4682      	mov	sl, r0
    7d96:	2800      	cmp	r0, #0
    7d98:	d1ec      	bne.n	7d74 <NVM_unlock+0x50>

            first_page = nvm_offset / BYTES_PER_PAGE;
            last_page = (nvm_offset + (length - 1u)) / BYTES_PER_PAGE;

            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);
    7d9a:	4630      	mov	r0, r6
    7d9c:	4629      	mov	r1, r5
    7d9e:	f7ff fcbb 	bl	7718 <get_ctrl_access>

            /* Unlock eNVM one page at a time. */
            if(NVM_SUCCESS == status)
    7da2:	4682      	mov	sl, r0
    7da4:	2800      	cmp	r0, #0
    7da6:	d1e5      	bne.n	7d74 <NVM_unlock+0x50>
        /* Check  */
        if(NVM_SUCCESS == status)
        {

            first_page = nvm_offset / BYTES_PER_PAGE;
            last_page = (nvm_offset + (length - 1u)) / BYTES_PER_PAGE;
    7da8:	19ad      	adds	r5, r5, r6
    7daa:	f105 3bff 	add.w	fp, r5, #4294967295
    7dae:	ea4f 1bdb 	mov.w	fp, fp, lsr #7

        /* Check  */
        if(NVM_SUCCESS == status)
        {

            first_page = nvm_offset / BYTES_PER_PAGE;
    7db2:	09f7      	lsrs	r7, r6, #7
                uint32_t inc;
                uint32_t * p_nvm32;
                uint32_t errors_and_warnings;


                for(current_page = first_page; (current_page <= last_page) &&
    7db4:	455f      	cmp	r7, fp
    7db6:	d87f      	bhi.n	7eb8 <NVM_unlock+0x194>
    7db8:	f648 6988 	movw	r9, #36488	; 0x8e88
    7dbc:	f2c0 0900 	movt	r9, #0
                    {
                        /* Clear the access denied flag */
                        g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
                    }

                    current_offset = (current_page << 0x7u);
    7dc0:	46a0      	mov	r8, r4
                uint32_t inc;
                uint32_t * p_nvm32;
                uint32_t errors_and_warnings;


                for(current_page = first_page; (current_page <= last_page) &&
    7dc2:	f5b7 6f00 	cmp.w	r7, #2048	; 0x800
    7dc6:	bf94      	ite	ls
    7dc8:	2000      	movls	r0, #0
    7dca:	2001      	movhi	r0, #1
                    else
                    {
                        block = NVM_BLOCK_0;
                    }

                    if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    7dcc:	f859 5020 	ldr.w	r5, [r9, r0, lsl #2]
                    {
                        /* Clear the access denied flag */
                        g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
                    }

                    current_offset = (current_page << 0x7u);
    7dd0:	eb09 0280 	add.w	r2, r9, r0, lsl #2
                    else
                    {
                        block = NVM_BLOCK_0;
                    }

                    if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    7dd4:	f8d5 6120 	ldr.w	r6, [r5, #288]	; 0x120
                    {
                        /* Clear the access denied flag */
                        g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
                    }

                    current_offset = (current_page << 0x7u);
    7dd8:	6890      	ldr	r0, [r2, #8]
                    else
                    {
                        block = NVM_BLOCK_0;
                    }

                    if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    7dda:	f416 2f80 	tst.w	r6, #262144	; 0x40000
                    {
                        /* Clear the access denied flag */
                        g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
    7dde:	bf1e      	ittt	ne
    7de0:	f8d5 6158 	ldrne.w	r6, [r5, #344]	; 0x158
    7de4:	f046 0602 	orrne.w	r6, r6, #2
    7de8:	f8c5 6158 	strne.w	r6, [r5, #344]	; 0x158
                    }

                    current_offset = (current_page << 0x7u);
    7dec:	01fe      	lsls	r6, r7, #7
    7dee:	f106 43c0 	add.w	r3, r6, #1610612736	; 0x60000000
                    p_nvm32 = (uint32_t *)(NVM_BASE_ADDRESS + current_offset);
                     
                    for(inc = 0u; inc < WD_WORD_SIZE; ++inc)
                    {
                        g_nvm32[block]->WD[inc] = p_nvm32[inc];
    7df2:	4619      	mov	r1, r3
    7df4:	f851 4b04 	ldr.w	r4, [r1], #4
    7df8:	2220      	movs	r2, #32
    7dfa:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
    7dfe:	685c      	ldr	r4, [r3, #4]
    7e00:	2221      	movs	r2, #33	; 0x21
    7e02:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
                    }

                    current_offset = (current_page << 0x7u);
                    p_nvm32 = (uint32_t *)(NVM_BASE_ADDRESS + current_offset);
                     
                    for(inc = 0u; inc < WD_WORD_SIZE; ++inc)
    7e06:	3104      	adds	r1, #4
    7e08:	2302      	movs	r3, #2
                    {
                        g_nvm32[block]->WD[inc] = p_nvm32[inc];
    7e0a:	460a      	mov	r2, r1
    7e0c:	f852 4b04 	ldr.w	r4, [r2], #4
    7e10:	f103 0c20 	add.w	ip, r3, #32
    7e14:	f840 402c 	str.w	r4, [r0, ip, lsl #2]
    7e18:	684c      	ldr	r4, [r1, #4]
    7e1a:	f103 0e21 	add.w	lr, r3, #33	; 0x21
                    }

                    current_offset = (current_page << 0x7u);
                    p_nvm32 = (uint32_t *)(NVM_BASE_ADDRESS + current_offset);
                     
                    for(inc = 0u; inc < WD_WORD_SIZE; ++inc)
    7e1e:	3302      	adds	r3, #2
    7e20:	1d11      	adds	r1, r2, #4
    7e22:	2b20      	cmp	r3, #32
                    {
                        g_nvm32[block]->WD[inc] = p_nvm32[inc];
    7e24:	f840 402e 	str.w	r4, [r0, lr, lsl #2]
                    }

                    current_offset = (current_page << 0x7u);
                    p_nvm32 = (uint32_t *)(NVM_BASE_ADDRESS + current_offset);
                     
                    for(inc = 0u; inc < WD_WORD_SIZE; ++inc)
    7e28:	d1ef      	bne.n	7e0a <NVM_unlock+0xe6>
                    
                    g_nvm[block]->PAGE_LOCK = NVM_DO_NOT_LOCK_PAGE;
                    g_nvm[block]->CMD = USER_UNLOCK | (current_offset & PAGE_ADDR_MASK);

                    /* Issue program command */
                    g_nvm[block]->CMD = PROG_ADS | (current_offset & PAGE_ADDR_MASK);
    7e2a:	f026 6200 	bic.w	r2, r6, #134217728	; 0x8000000
                    {
                        g_nvm32[block]->WD[inc] = p_nvm32[inc];
                    }
                    
                    g_nvm[block]->PAGE_LOCK = NVM_DO_NOT_LOCK_PAGE;
                    g_nvm[block]->CMD = USER_UNLOCK | (current_offset & PAGE_ADDR_MASK);
    7e2e:	f026 5698 	bic.w	r6, r6, #318767104	; 0x13000000

                    /* Issue program command */
                    g_nvm[block]->CMD = PROG_ADS | (current_offset & PAGE_ADDR_MASK);
    7e32:	f022 037f 	bic.w	r3, r2, #127	; 0x7f
                    {
                        g_nvm32[block]->WD[inc] = p_nvm32[inc];
                    }
                    
                    g_nvm[block]->PAGE_LOCK = NVM_DO_NOT_LOCK_PAGE;
                    g_nvm[block]->CMD = USER_UNLOCK | (current_offset & PAGE_ADDR_MASK);
    7e36:	f026 007f 	bic.w	r0, r6, #127	; 0x7f
    7e3a:	f040 5698 	orr.w	r6, r0, #318767104	; 0x13000000

                    /* Issue program command */
                    g_nvm[block]->CMD = PROG_ADS | (current_offset & PAGE_ADDR_MASK);
    7e3e:	f043 6100 	orr.w	r1, r3, #134217728	; 0x8000000
                    for(inc = 0u; inc < WD_WORD_SIZE; ++inc)
                    {
                        g_nvm32[block]->WD[inc] = p_nvm32[inc];
                    }
                    
                    g_nvm[block]->PAGE_LOCK = NVM_DO_NOT_LOCK_PAGE;
    7e42:	2200      	movs	r2, #0
    7e44:	f8c5 2140 	str.w	r2, [r5, #320]	; 0x140
                    g_nvm[block]->CMD = USER_UNLOCK | (current_offset & PAGE_ADDR_MASK);
    7e48:	f8c5 6148 	str.w	r6, [r5, #328]	; 0x148

                    /* Issue program command */
                    g_nvm[block]->CMD = PROG_ADS | (current_offset & PAGE_ADDR_MASK);
    7e4c:	f8c5 1148 	str.w	r1, [r5, #328]	; 0x148
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    {
        do {
            ctrl_status = g_nvm[block]->STATUS;
    7e50:	f8d5 1120 	ldr.w	r1, [r5, #288]	; 0x120
    7e54:	9101      	str	r1, [sp, #4]
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
    7e56:	9c01      	ldr	r4, [sp, #4]
        } while(0u == ctrl_ready);
    7e58:	f014 0f01 	tst.w	r4, #1
    7e5c:	d0f8      	beq.n	7e50 <NVM_unlock+0x12c>
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    7e5e:	3201      	adds	r2, #1
    7e60:	2a02      	cmp	r2, #2
    7e62:	d1f5      	bne.n	7e50 <NVM_unlock+0x12c>
            ctrl_status = g_nvm[block]->STATUS;
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
        } while(0u == ctrl_ready);
    }
    
    return ctrl_status;
    7e64:	9801      	ldr	r0, [sp, #4]
                    /* Wait for NVM to become ready. */
                    ctrl_status = wait_nvm_ready(block);

                    /* Check for errors and warnings. */
                    errors_and_warnings = ctrl_status & (WRITE_ERROR_MASK | MSS_NVM_WRCNT_OVER);
                    if(errors_and_warnings)
    7e66:	f240 0e3e 	movw	lr, #62	; 0x3e
    7e6a:	f2c0 0e04 	movt	lr, #4
    7e6e:	ea00 030e 	and.w	r3, r0, lr
    7e72:	b193      	cbz	r3, 7e9a <NVM_unlock+0x176>
                    {
                        uint32_t nvm_hw_status;
                        nvm_hw_status = g_nvm[block]->STATUS;
    7e74:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
 */
static nvm_status_t get_error_code(uint32_t nvm_hw_status)
{
    nvm_status_t status;
    
    if(nvm_hw_status & MSS_NVM_WR_DENIED)
    7e78:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    7e7c:	bf18      	it	ne
    7e7e:	f04f 0a01 	movne.w	sl, #1
    7e82:	d10a      	bne.n	7e9a <NVM_unlock+0x176>
    {
        status = NVM_PROTECTION_ERROR;
    }
    else if(nvm_hw_status & MSS_NVM_PEFAIL_LOCK)
    7e84:	f013 0f10 	tst.w	r3, #16
    7e88:	bf18      	it	ne
    7e8a:	f04f 0a03 	movne.w	sl, #3
    7e8e:	d104      	bne.n	7e9a <NVM_unlock+0x176>
    {
        status = NVM_PAGE_LOCK_ERROR;
    }
    else if(nvm_hw_status & (MSS_NVM_VERIFY_FAIL |
    7e90:	f013 0f0e 	tst.w	r3, #14
    7e94:	bf18      	it	ne
    7e96:	4692      	movne	sl, r2
    7e98:	d030      	beq.n	7efc <NVM_unlock+0x1d8>
                uint32_t errors_and_warnings;


                for(current_page = first_page; (current_page <= last_page) &&
                    ((NVM_SUCCESS == status) ||(NVM_WRITE_THRESHOLD_WARNING == status));
                    ++current_page)
    7e9a:	3701      	adds	r7, #1
                uint32_t inc;
                uint32_t * p_nvm32;
                uint32_t errors_and_warnings;


                for(current_page = first_page; (current_page <= last_page) &&
    7e9c:	45bb      	cmp	fp, r7
    7e9e:	d30a      	bcc.n	7eb6 <NVM_unlock+0x192>
    7ea0:	f1da 0201 	rsbs	r2, sl, #1
    7ea4:	bf38      	it	cc
    7ea6:	2200      	movcc	r2, #0
    7ea8:	f1ba 0f04 	cmp.w	sl, #4
    7eac:	bf08      	it	eq
    7eae:	f042 0201 	orreq.w	r2, r2, #1
    7eb2:	2a00      	cmp	r2, #0
    7eb4:	d185      	bne.n	7dc2 <NVM_unlock+0x9e>
    7eb6:	4644      	mov	r4, r8

static void release_ctrl_access(void)
{
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    7eb8:	f640 3330 	movw	r3, #2864	; 0xb30
    7ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    7ec0:	781a      	ldrb	r2, [r3, #0]
    if(block_locked)
    7ec2:	f012 0f01 	tst.w	r2, #1
    7ec6:	d009      	beq.n	7edc <NVM_unlock+0x1b8>
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    7ec8:	f240 0100 	movw	r1, #0
    7ecc:	f2c6 0108 	movt	r1, #24584	; 0x6008
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    7ed0:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    7ed4:	2000      	movs	r0, #0
    7ed6:	f8c1 01fc 	str.w	r0, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    7eda:	701a      	strb	r2, [r3, #0]
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    7edc:	f012 0f02 	tst.w	r2, #2
    7ee0:	f43f af48 	beq.w	7d74 <NVM_unlock+0x50>
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    7ee4:	f240 0100 	movw	r1, #0
    7ee8:	f2c6 010c 	movt	r1, #24588	; 0x600c
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7eec:	f022 0c02 	bic.w	ip, r2, #2
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    7ef0:	2000      	movs	r0, #0
    7ef2:	f8c1 01fc 	str.w	r0, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    7ef6:	f883 c000 	strb.w	ip, [r3]
    7efa:	e73b      	b.n	7d74 <NVM_unlock+0x50>
    else if(nvm_hw_status & (MSS_NVM_VERIFY_FAIL |
            MSS_NVM_EVERIFY_FAIL | MSS_NVM_WVERIFY_FAIL))
    {
        status = NVM_VERIFY_FAILURE;
    }
    else if(nvm_hw_status & MSS_NVM_WRCNT_OVER)
    7efc:	f013 0f20 	tst.w	r3, #32
    7f00:	bf14      	ite	ne
    7f02:	f04f 0a04 	movne.w	sl, #4
    7f06:	f04f 0a00 	moveq.w	sl, #0
    7f0a:	e7c6      	b.n	7e9a <NVM_unlock+0x176>

00007f0c <NVM_write>:
    uint32_t start_addr,
    const uint8_t * pidata,
    uint32_t length,
    uint32_t lock_page
)
{
    7f0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    7f10:	f248 0400 	movw	r4, #32768	; 0x8000
    uint32_t start_addr,
    const uint8_t * pidata,
    uint32_t length,
    uint32_t lock_page
)
{
    7f14:	b08d      	sub	sp, #52	; 0x34
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    7f16:	f2c4 0403 	movt	r4, #16387	; 0x4003
    uint32_t start_addr,
    const uint8_t * pidata,
    uint32_t length,
    uint32_t lock_page
)
{
    7f1a:	9000      	str	r0, [sp, #0]
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    7f1c:	68e0      	ldr	r0, [r4, #12]
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7f1e:	9e00      	ldr	r6, [sp, #0]
    7f20:	f240 0c01 	movw	ip, #1
    7f24:	f64f 75fe 	movw	r5, #65534	; 0xfffe
     * to its maximum value (i.e. 15) to ensure successful writes to eNVM. 
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    7f28:	9002      	str	r0, [sp, #8]
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7f2a:	f6cf 7cf8 	movt	ip, #65528	; 0xfff8
    7f2e:	f2c6 0507 	movt	r5, #24583	; 0x6007
    7f32:	42ae      	cmp	r6, r5
    7f34:	bf94      	ite	ls
    7f36:	2500      	movls	r5, #0
    7f38:	2501      	movhi	r5, #1
    7f3a:	44b4      	add	ip, r6
    7f3c:	f240 0000 	movw	r0, #0
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    7f40:	9e02      	ldr	r6, [sp, #8]

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7f42:	f6c5 70f8 	movt	r0, #24568	; 0x5ff8
    7f46:	4584      	cmp	ip, r0
    7f48:	bf8c      	ite	hi
    7f4a:	4628      	movhi	r0, r5
    7f4c:	f045 0001 	orrls.w	r0, r5, #1
     * Store the value of the eNVM configuration before updating it, so 
     * that the prior configuration can be restored when the eNVM write
     * operation has completed. 
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;
    7f50:	f446 55ff 	orr.w	r5, r6, #8160	; 0x1fe0
    7f54:	60e5      	str	r5, [r4, #12]
    uint32_t start_addr,
    const uint8_t * pidata,
    uint32_t length,
    uint32_t lock_page
)
{
    7f56:	9103      	str	r1, [sp, #12]
    7f58:	9204      	str	r2, [sp, #16]
     */
    initial_nvm_config = SYSREG->ENVM_CR;
    SYSREG->ENVM_CR = (initial_nvm_config & NVM_FREQRNG_MASK) | NVM_FREQRNG_MAX;

    /* Check input parameters */
    if((start_addr >= (NVM_BASE_ADDRESS + NVM_TOP_OFFSET)) || \
    7f5a:	2800      	cmp	r0, #0
    7f5c:	f040 8182 	bne.w	8264 <NVM_write+0x358>
    7f60:	f8dd c010 	ldr.w	ip, [sp, #16]
    7f64:	f1d1 0201 	rsbs	r2, r1, #1
    7f68:	bf38      	it	cc
    7f6a:	2200      	movcc	r2, #0
    7f6c:	f1bc 0f00 	cmp.w	ip, #0
    7f70:	bf08      	it	eq
    7f72:	f042 0201 	orreq.w	r2, r2, #1
    7f76:	2a00      	cmp	r2, #0
    7f78:	f040 8174 	bne.w	8264 <NVM_write+0x358>
    7f7c:	2b02      	cmp	r3, #2
    7f7e:	f200 8171 	bhi.w	8264 <NVM_write+0x358>
    {
        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
    7f82:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
        {
            lock_page = NVM_DO_NOT_LOCK_PAGE;
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */
    7f86:	9800      	ldr	r0, [sp, #0]
        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
        if((0x0000F802u == device_version) || (0x0001F802u == device_version))
    7f88:	f64f 0e02 	movw	lr, #63490	; 0xf802
    7f8c:	f64f 0102 	movw	r1, #63490	; 0xf802
        {
            lock_page = NVM_DO_NOT_LOCK_PAGE;
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */
    7f90:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
        if((0x0000F802u == device_version) || (0x0001F802u == device_version))
    7f94:	f2c0 0101 	movt	r1, #1
    7f98:	4572      	cmp	r2, lr
    7f9a:	bf14      	ite	ne
    7f9c:	2000      	movne	r0, #0
    7f9e:	2001      	moveq	r0, #1
    7fa0:	428a      	cmp	r2, r1
    7fa2:	bf14      	ite	ne
    7fa4:	4686      	movne	lr, r0
    7fa6:	f040 0e01 	orreq.w	lr, r0, #1
        {
            lock_page = NVM_DO_NOT_LOCK_PAGE;
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */
    7faa:	f424 0478 	bic.w	r4, r4, #16252928	; 0xf80000
        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
        if((0x0000F802u == device_version) || (0x0001F802u == device_version))
    7fae:	f1be 0f00 	cmp.w	lr, #0
    7fb2:	bf18      	it	ne
    7fb4:	2300      	movne	r3, #0
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */

        status = check_protection_reserved_nvm(nvm_offset, length);
    7fb6:	4620      	mov	r0, r4
    7fb8:	4661      	mov	r1, ip
        /*
         * Prevent pages being locked for silicon versions which do not allow
         * locked pages to be unlocked.
         */
        device_version = SYSREG->DEVICE_VERSION;
        if((0x0000F802u == device_version) || (0x0001F802u == device_version))
    7fba:	9309      	str	r3, [sp, #36]	; 0x24
        }

        /* Ignore upper address bits to ignore remapping setting. */
        nvm_offset = start_addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */

        status = check_protection_reserved_nvm(nvm_offset, length);
    7fbc:	f7ff fbec 	bl	7798 <check_protection_reserved_nvm>

        /* Check  */
        if(NVM_SUCCESS == status)
    7fc0:	9001      	str	r0, [sp, #4]
    7fc2:	2800      	cmp	r0, #0
    7fc4:	f040 8152 	bne.w	826c <NVM_write+0x360>
        {
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);
    7fc8:	4620      	mov	r0, r4
    7fca:	9904      	ldr	r1, [sp, #16]
    7fcc:	f7ff fba4 	bl	7718 <get_ctrl_access>

            /* Write eNVM one page at a time. */
            if(NVM_SUCCESS == status)
    7fd0:	2800      	cmp	r0, #0
    7fd2:	f040 817e 	bne.w	82d2 <NVM_write+0x3c6>
    7fd6:	f648 6688 	movw	r6, #36488	; 0x8e88
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
    7fda:	f64f 75ff 	movw	r5, #65535	; 0xffff
        {
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);

            /* Write eNVM one page at a time. */
            if(NVM_SUCCESS == status)
    7fde:	9b04      	ldr	r3, [sp, #16]
    7fe0:	f2c0 0600 	movt	r6, #0
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
    7fe4:	f2c0 0503 	movt	r5, #3
    7fe8:	9607      	str	r6, [sp, #28]
    7fea:	9508      	str	r5, [sp, #32]
        {
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);

            /* Write eNVM one page at a time. */
            if(NVM_SUCCESS == status)
    7fec:	9305      	str	r3, [sp, #20]
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
    7fee:	9d05      	ldr	r5, [sp, #20]
    7ff0:	9a04      	ldr	r2, [sp, #16]
    uint32_t length_written;
    uint32_t offset;
   
    *p_status = 0u;
    
    offset = addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */
    7ff2:	9800      	ldr	r0, [sp, #0]
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
    7ff4:	1b54      	subs	r4, r2, r5
    uint32_t length_written;
    uint32_t offset;
   
    *p_status = 0u;
    
    offset = addr & NVM_OFFSET_SIGNIFICANT_BITS;  /* Ignore remapping. */
    7ff6:	1823      	adds	r3, r4, r0
    7ff8:	f023 487f 	bic.w	r8, r3, #4278190080	; 0xff000000
    7ffc:	f428 0878 	bic.w	r8, r8, #16252928	; 0xf80000
    uint32_t start_page_plus_one;
    uint32_t last_page;
    
    start_page_plus_one = (offset / BYTES_PER_PAGE) + 1u;
    last_page = (offset + length) / BYTES_PER_PAGE;
    if(last_page >= start_page_plus_one)
    8000:	ea4f 11d8 	mov.w	r1, r8, lsr #7
    8004:	eb08 0005 	add.w	r0, r8, r5
    8008:	1c4e      	adds	r6, r1, #1
    800a:	ebb6 1fd0 	cmp.w	r6, r0, lsr #7
    {
        length = BYTES_PER_PAGE - (offset % BYTES_PER_PAGE);
    800e:	bf98      	it	ls
    8010:	f003 037f 	andls.w	r3, r3, #127	; 0x7f
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
    8014:	f8dd c00c 	ldr.w	ip, [sp, #12]
    
    start_page_plus_one = (offset / BYTES_PER_PAGE) + 1u;
    last_page = (offset + length) / BYTES_PER_PAGE;
    if(last_page >= start_page_plus_one)
    {
        length = BYTES_PER_PAGE - (offset % BYTES_PER_PAGE);
    8018:	bf98      	it	ls
    801a:	f1c3 0080 	rsbls	r0, r3, #128	; 0x80
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
    801e:	9b08      	ldr	r3, [sp, #32]
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
    8020:	eb0c 0104 	add.w	r1, ip, r4
    uint32_t start_page_plus_one;
    uint32_t last_page;
    
    start_page_plus_one = (offset / BYTES_PER_PAGE) + 1u;
    last_page = (offset + length) / BYTES_PER_PAGE;
    if(last_page >= start_page_plus_one)
    8024:	bf88      	it	hi
    8026:	4628      	movhi	r0, r5
                while(remaining_length > 0u)
                {
                    uint32_t length_written;
                    uint32_t nvm_hw_status = 0u;

                    length_written = write_nvm(start_addr + (length - remaining_length),
    8028:	9406      	str	r4, [sp, #24]
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
    802a:	4598      	cmp	r8, r3
        {
            block = NVM_BLOCK_1;
            offset = offset - NVM1_BOTTOM_OFFSET;
        }
        
        if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    802c:	9c07      	ldr	r4, [sp, #28]
    {
        uint32_t block;
        volatile uint32_t ctrl_status;
        uint32_t errors;
        
        if(offset < NVM1_BOTTOM_OFFSET)
    802e:	bf94      	ite	ls
    8030:	f04f 0c00 	movls.w	ip, #0
            block = NVM_BLOCK_0;
        }
        else
        {
            block = NVM_BLOCK_1;
            offset = offset - NVM1_BOTTOM_OFFSET;
    8034:	f04f 0c01 	movhi.w	ip, #1
        }
        
        if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    8038:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
            block = NVM_BLOCK_0;
        }
        else
        {
            block = NVM_BLOCK_1;
            offset = offset - NVM1_BOTTOM_OFFSET;
    803c:	bf88      	it	hi
    803e:	f5a8 2880 	subhi.w	r8, r8, #262144	; 0x40000
        }
        
        if(g_nvm[block]->STATUS & MSS_NVM_WR_DENIED)
    8042:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    8046:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        {
            /* Clear the access denied flag */
            g_nvm[block]->CLRHINT |= ACCESS_DENIED_FLAG_CLEAR;
    804a:	bf1e      	ittt	ne
    804c:	f8d3 2158 	ldrne.w	r2, [r3, #344]	; 0x158
    8050:	f042 0202 	orrne.w	r2, r2, #2
    8054:	f8c3 2158 	strne.w	r2, [r3, #344]	; 0x158
)
{
    uint32_t inc;
    uint32_t wd_offset;
    
    if(length != BYTES_PER_PAGE)
    8058:	2880      	cmp	r0, #128	; 0x80
    805a:	f000 812a 	beq.w	82b2 <NVM_write+0x3a6>
        /* 
         * Fill beginning of WD[] with current content of NVM page that must not
         * be overwritten.
         */
        p_nvm32 = (uint32_t *)((NVM_BASE_ADDRESS + offset + (block * NVM1_BOTTOM_OFFSET)) & PAGE_ADDR_MASK);
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
    805e:	f008 027f 	and.w	r2, r8, #127	; 0x7f
        uint32_t first_non_written_word;
        /* 
         * Fill beginning of WD[] with current content of NVM page that must not
         * be overwritten.
         */
        p_nvm32 = (uint32_t *)((NVM_BASE_ADDRESS + offset + (block * NVM1_BOTTOM_OFFSET)) & PAGE_ADDR_MASK);
    8062:	f108 47c0 	add.w	r7, r8, #1610612736	; 0x60000000
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
    8066:	ea4f 0992 	mov.w	r9, r2, lsr #2
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
    806a:	f018 0f03 	tst.w	r8, #3
        uint32_t first_non_written_word;
        /* 
         * Fill beginning of WD[] with current content of NVM page that must not
         * be overwritten.
         */
        p_nvm32 = (uint32_t *)((NVM_BASE_ADDRESS + offset + (block * NVM1_BOTTOM_OFFSET)) & PAGE_ADDR_MASK);
    806e:	eb07 4a8c 	add.w	sl, r7, ip, lsl #18
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
    8072:	bf18      	it	ne
    8074:	f109 0901 	addne.w	r9, r9, #1
        uint32_t first_non_written_word;
        /* 
         * Fill beginning of WD[] with current content of NVM page that must not
         * be overwritten.
         */
        p_nvm32 = (uint32_t *)((NVM_BASE_ADDRESS + offset + (block * NVM1_BOTTOM_OFFSET)) & PAGE_ADDR_MASK);
    8078:	f02a 0a7f 	bic.w	sl, sl, #127	; 0x7f
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
    807c:	f1b9 0f00 	cmp.w	r9, #0
    8080:	f000 8129 	beq.w	82d6 <NVM_write+0x3ca>
    8084:	9e07      	ldr	r6, [sp, #28]
    8086:	46d3      	mov	fp, sl
    8088:	eb06 048c 	add.w	r4, r6, ip, lsl #2
    808c:	68a4      	ldr	r4, [r4, #8]
    808e:	469a      	mov	sl, r3
    8090:	f04f 0c00 	mov.w	ip, #0
    8094:	465b      	mov	r3, fp
        {
            g_nvm32[block]->WD[inc] = p_nvm32[inc];
    8096:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
    809a:	f10c 0e20 	add.w	lr, ip, #32
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
    809e:	f10c 0c01 	add.w	ip, ip, #1
    80a2:	f1bc 0f1f 	cmp.w	ip, #31
    80a6:	bf8c      	ite	hi
    80a8:	2500      	movhi	r5, #0
    80aa:	2501      	movls	r5, #1
    80ac:	45cc      	cmp	ip, r9
    80ae:	bf2c      	ite	cs
    80b0:	2500      	movcs	r5, #0
    80b2:	f005 0501 	andcc.w	r5, r5, #1
        {
            g_nvm32[block]->WD[inc] = p_nvm32[inc];
    80b6:	f844 702e 	str.w	r7, [r4, lr, lsl #2]
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
    80ba:	2d00      	cmp	r5, #0
    80bc:	d1eb      	bne.n	8096 <NVM_write+0x18a>
    80be:	4699      	mov	r9, r3
    80c0:	4653      	mov	r3, sl
    80c2:	46ca      	mov	sl, r9
        
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
    80c4:	eb08 0c00 	add.w	ip, r8, r0
    80c8:	f3cc 0784 	ubfx	r7, ip, #2, #5
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    80cc:	f85a 9027 	ldr.w	r9, [sl, r7, lsl #2]
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
    80d0:	f1c7 0b20 	rsb	fp, r7, #32
    80d4:	eb0a 0587 	add.w	r5, sl, r7, lsl #2
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    80d8:	f107 0620 	add.w	r6, r7, #32
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    80dc:	f04f 0c01 	mov.w	ip, #1
    80e0:	f10b 3aff 	add.w	sl, fp, #4294967295
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    80e4:	f844 9026 	str.w	r9, [r4, r6, lsl #2]
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    80e8:	1d2e      	adds	r6, r5, #4
    80ea:	45e3      	cmp	fp, ip
    80ec:	ea0a 0a0c 	and.w	sl, sl, ip
    80f0:	d925      	bls.n	813e <NVM_write+0x232>
    80f2:	f1ba 0f00 	cmp.w	sl, #0
    80f6:	d00b      	beq.n	8110 <NVM_write+0x204>
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
    80f8:	44bc      	add	ip, r7
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    80fa:	f8d5 a004 	ldr.w	sl, [r5, #4]
    80fe:	f10c 0520 	add.w	r5, ip, #32
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    8102:	f04f 0c02 	mov.w	ip, #2
    8106:	3604      	adds	r6, #4
    8108:	45e3      	cmp	fp, ip
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    810a:	f844 a025 	str.w	sl, [r4, r5, lsl #2]
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    810e:	d916      	bls.n	813e <NVM_write+0x232>
    8110:	4699      	mov	r9, r3
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    8112:	4633      	mov	r3, r6
    8114:	f853 ab04 	ldr.w	sl, [r3], #4
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
    8118:	eb0c 0507 	add.w	r5, ip, r7
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    811c:	3520      	adds	r5, #32
    811e:	f844 a025 	str.w	sl, [r4, r5, lsl #2]
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    8122:	f10c 0e01 	add.w	lr, ip, #1
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    8126:	6876      	ldr	r6, [r6, #4]
        /*
         * Fill end of WD[] with current content of NVM page that must not be
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
    8128:	eb0e 0507 	add.w	r5, lr, r7
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    812c:	3520      	adds	r5, #32
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    812e:	f10e 0c01 	add.w	ip, lr, #1
        {
            g_nvm32[block]->WD[first_non_written_word + inc] = p_nvm32[first_non_written_word + inc];
    8132:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
         * overwritten.
         */
        first_non_written_word = ((offset + length) % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        nb_non_written_words = (BYTES_PER_PAGE / NB_OF_BYTES_IN_A_WORD) - first_non_written_word;
        
        for(inc = 0u; inc < nb_non_written_words; ++inc)
    8136:	1d1e      	adds	r6, r3, #4
    8138:	45e3      	cmp	fp, ip
    813a:	d8ea      	bhi.n	8112 <NVM_write+0x206>
    813c:	464b      	mov	r3, r9
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    813e:	b368      	cbz	r0, 819c <NVM_write+0x290>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8140:	9d03      	ldr	r5, [sp, #12]
    8142:	9c06      	ldr	r4, [sp, #24]
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8144:	f04f 0c01 	mov.w	ip, #1
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8148:	5d2e      	ldrb	r6, [r5, r4]
    814a:	1e44      	subs	r4, r0, #1
    814c:	189d      	adds	r5, r3, r2
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    814e:	4560      	cmp	r0, ip
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8150:	f885 6080 	strb.w	r6, [r5, #128]	; 0x80
    8154:	ea04 040c 	and.w	r4, r4, ip
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8158:	d920      	bls.n	819c <NVM_write+0x290>
    815a:	b15c      	cbz	r4, 8174 <NVM_write+0x268>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    815c:	f811 500c 	ldrb.w	r5, [r1, ip]
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8160:	eb0c 0e02 	add.w	lr, ip, r2
    8164:	f04f 0c02 	mov.w	ip, #2
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8168:	eb03 040e 	add.w	r4, r3, lr
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    816c:	4560      	cmp	r0, ip
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    816e:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8172:	d913      	bls.n	819c <NVM_write+0x290>
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8174:	f811 e00c 	ldrb.w	lr, [r1, ip]
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8178:	eb0c 0502 	add.w	r5, ip, r2
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    817c:	195c      	adds	r4, r3, r5
    817e:	f884 e080 	strb.w	lr, [r4, #128]	; 0x80
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8182:	f10c 0c01 	add.w	ip, ip, #1
    8186:	eb0c 0402 	add.w	r4, ip, r2
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    818a:	f811 500c 	ldrb.w	r5, [r1, ip]
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    818e:	f10c 0c01 	add.w	ip, ip, #1
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8192:	191c      	adds	r4, r3, r4
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    8194:	4560      	cmp	r0, ip
    {
        g_nvm[block]->WD[wd_offset + inc] = p_data[inc];
    8196:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    for(inc = 0u; inc < length; ++inc)
    819a:	d8eb      	bhi.n	8174 <NVM_write+0x268>

        /* Set requested locking option. */
        g_nvm[block]->PAGE_LOCK = lock_page;
        
        /* Issue program command */
        g_nvm[block]->CMD = PROG_ADS | (offset & PAGE_ADDR_MASK);
    819c:	f028 6e00 	bic.w	lr, r8, #134217728	; 0x8000000
        }

        fill_wd_buffer(pidata, length_written, block, offset);

        /* Set requested locking option. */
        g_nvm[block]->PAGE_LOCK = lock_page;
    81a0:	9909      	ldr	r1, [sp, #36]	; 0x24
        
        /* Issue program command */
        g_nvm[block]->CMD = PROG_ADS | (offset & PAGE_ADDR_MASK);
    81a2:	f02e 0c7f 	bic.w	ip, lr, #127	; 0x7f
    81a6:	f04c 6200 	orr.w	r2, ip, #134217728	; 0x8000000
        }

        fill_wd_buffer(pidata, length_written, block, offset);

        /* Set requested locking option. */
        g_nvm[block]->PAGE_LOCK = lock_page;
    81aa:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
        
        /* Issue program command */
        g_nvm[block]->CMD = PROG_ADS | (offset & PAGE_ADDR_MASK);
    81ae:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    81b2:	2100      	movs	r1, #0
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    {
        do {
            ctrl_status = g_nvm[block]->STATUS;
    81b4:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    81b8:	920a      	str	r2, [sp, #40]	; 0x28
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
    81ba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        } while(0u == ctrl_ready);
    81bc:	f012 0f01 	tst.w	r2, #1
    81c0:	d0f8      	beq.n	81b4 <NVM_write+0x2a8>
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    81c2:	3101      	adds	r1, #1
    81c4:	2902      	cmp	r1, #2
    81c6:	d1f5      	bne.n	81b4 <NVM_write+0x2a8>
            ctrl_status = g_nvm[block]->STATUS;
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
        } while(0u == ctrl_ready);
    }
    
    return ctrl_status;
    81c8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        /* Wait for NVM to become ready. */
        ctrl_status = wait_nvm_ready(block);

        /* Check for errors. */
        errors = ctrl_status & WRITE_ERROR_MASK;
        if(errors)
    81ca:	f240 0c1e 	movw	ip, #30
        
        /* Issue program command */
        g_nvm[block]->CMD = PROG_ADS | (offset & PAGE_ADDR_MASK);
        
        /* Wait for NVM to become ready. */
        ctrl_status = wait_nvm_ready(block);
    81ce:	920b      	str	r2, [sp, #44]	; 0x2c

        /* Check for errors. */
        errors = ctrl_status & WRITE_ERROR_MASK;
    81d0:	990b      	ldr	r1, [sp, #44]	; 0x2c
        if(errors)
    81d2:	f2c0 0c04 	movt	ip, #4
    81d6:	ea01 020c 	and.w	r2, r1, ip
    81da:	b99a      	cbnz	r2, 8204 <NVM_write+0x2f8>
            *p_status = g_nvm[block]->STATUS;
        }
        else
        {
            /* Perform a verify. */
            g_nvm[block]->CMD = VERIFY_ADS | (offset & PAGE_ADDR_MASK);
    81dc:	f028 5880 	bic.w	r8, r8, #268435456	; 0x10000000
    81e0:	f028 087f 	bic.w	r8, r8, #127	; 0x7f
    81e4:	f048 5180 	orr.w	r1, r8, #268435456	; 0x10000000
    81e8:	f8c3 1148 	str.w	r1, [r3, #328]	; 0x148
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    {
        do {
            ctrl_status = g_nvm[block]->STATUS;
    81ec:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    81f0:	910a      	str	r1, [sp, #40]	; 0x28
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
    81f2:	990a      	ldr	r1, [sp, #40]	; 0x28
        } while(0u == ctrl_ready);
    81f4:	f011 0f01 	tst.w	r1, #1
    81f8:	d0f8      	beq.n	81ec <NVM_write+0x2e0>
    /*
     * Wait for NVM to become ready.
     * We must ensure that we can read the ready bit set to 1 twice before we
     * can assume that the other status bits are valid. See SmartFusion2 errata.
     */
    for(inc = 0u; inc < 2u; ++inc)
    81fa:	3201      	adds	r2, #1
    81fc:	2a02      	cmp	r2, #2
    81fe:	d1f5      	bne.n	81ec <NVM_write+0x2e0>
            ctrl_status = g_nvm[block]->STATUS;
            ctrl_ready = ctrl_status  & MSS_NVM_BUSY_B;
        } while(0u == ctrl_ready);
    }
    
    return ctrl_status;
    8200:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        else
        {
            /* Perform a verify. */
            g_nvm[block]->CMD = VERIFY_ADS | (offset & PAGE_ADDR_MASK);
            /* Wait for NVM to become ready. */
            ctrl_status = wait_nvm_ready(block);
    8202:	920b      	str	r2, [sp, #44]	; 0x2c

            *p_status = g_nvm[block]->STATUS;
    8204:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
                                                lock_page,
                                                &nvm_hw_status);

                    /* Check for errors and warnings. */
                    errors_and_warnings = nvm_hw_status & (WRITE_ERROR_MASK | MSS_NVM_WRCNT_OVER);
                    if(errors_and_warnings)
    8208:	f240 0e3e 	movw	lr, #62	; 0x3e
    820c:	f2c0 0e04 	movt	lr, #4
    8210:	ea02 030e 	and.w	r3, r2, lr
    8214:	2b00      	cmp	r3, #0
    8216:	d033      	beq.n	8280 <NVM_write+0x374>
 */
static nvm_status_t get_error_code(uint32_t nvm_hw_status)
{
    nvm_status_t status;
    
    if(nvm_hw_status & MSS_NVM_WR_DENIED)
    8218:	f412 2f80 	tst.w	r2, #262144	; 0x40000
    821c:	d043      	beq.n	82a6 <NVM_write+0x39a>
    821e:	2001      	movs	r0, #1
    8220:	9001      	str	r0, [sp, #4]

static void release_ctrl_access(void)
{
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    8222:	f640 3230 	movw	r2, #2864	; 0xb30
    8226:	f2c2 0200 	movt	r2, #8192	; 0x2000
    822a:	7813      	ldrb	r3, [r2, #0]
    if(block_locked)
    822c:	f013 0f01 	tst.w	r3, #1
    8230:	d009      	beq.n	8246 <NVM_write+0x33a>
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    8232:	f240 0100 	movw	r1, #0
    8236:	f2c6 0108 	movt	r1, #24584	; 0x6008
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    823a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    uint8_t block_locked;
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_0_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_0]->REQ_ACCESS = 0x00u;
    823e:	2000      	movs	r0, #0
    8240:	f8c1 01fc 	str.w	r0, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_0_LOCK_MASK;
    8244:	7013      	strb	r3, [r2, #0]
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    8246:	f013 0f02 	tst.w	r3, #2
    824a:	d00f      	beq.n	826c <NVM_write+0x360>
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    824c:	f240 0100 	movw	r1, #0
    8250:	f2c6 010c 	movt	r1, #24588	; 0x600c
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    8254:	f023 0c02 	bic.w	ip, r3, #2
    }
    
    block_locked = g_envm_ctrl_locks & NVM_BLOCK_1_LOCK_MASK;
    if(block_locked)
    {
        g_nvm[NVM_BLOCK_1]->REQ_ACCESS = 0x00u;
    8258:	2000      	movs	r0, #0
    825a:	f8c1 01fc 	str.w	r0, [r1, #508]	; 0x1fc
        g_envm_ctrl_locks &= ~NVM_BLOCK_1_LOCK_MASK;
    825e:	f882 c000 	strb.w	ip, [r2]
    8262:	e003      	b.n	826c <NVM_write+0x360>
    8264:	f04f 0c06 	mov.w	ip, #6
    8268:	f8cd c004 	str.w	ip, [sp, #4]
            }
        }
    }
    
    /* Restore back to original value. */
    SYSREG->ENVM_CR = initial_nvm_config;
    826c:	9a02      	ldr	r2, [sp, #8]
    826e:	f248 0300 	movw	r3, #32768	; 0x8000
    8272:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8276:	60da      	str	r2, [r3, #12]
    
    return status;
}
    8278:	9801      	ldr	r0, [sp, #4]
    827a:	b00d      	add	sp, #52	; 0x34
    827c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        * threshold condition.
                        */ 
                        status = get_error_code(nvm_hw_status);
                    }

                    if((NVM_SUCCESS == status) || (NVM_WRITE_THRESHOLD_WARNING == status ))
    8280:	9d01      	ldr	r5, [sp, #4]
    8282:	f1d5 0201 	rsbs	r2, r5, #1
    8286:	bf38      	it	cc
    8288:	2200      	movcc	r2, #0
    828a:	2d04      	cmp	r5, #4
    828c:	bf08      	it	eq
    828e:	f042 0201 	orreq.w	r2, r2, #1
    8292:	2a00      	cmp	r2, #0
    8294:	d0c5      	beq.n	8222 <NVM_write+0x316>
                    {
                        if(remaining_length > length_written)
    8296:	9e05      	ldr	r6, [sp, #20]
    8298:	42b0      	cmp	r0, r6
    829a:	d2c2      	bcs.n	8222 <NVM_write+0x316>
            if(NVM_SUCCESS == status)
            {
                uint32_t remaining_length = length;
                uint32_t errors_and_warnings;
                
                while(remaining_length > 0u)
    829c:	1a36      	subs	r6, r6, r0
    829e:	9605      	str	r6, [sp, #20]
    82a0:	f47f aea5 	bne.w	7fee <NVM_write+0xe2>
    82a4:	e7bd      	b.n	8222 <NVM_write+0x316>
    
    if(nvm_hw_status & MSS_NVM_WR_DENIED)
    {
        status = NVM_PROTECTION_ERROR;
    }
    else if(nvm_hw_status & MSS_NVM_PEFAIL_LOCK)
    82a6:	f012 0f10 	tst.w	r2, #16
    82aa:	d005      	beq.n	82b8 <NVM_write+0x3ac>
    82ac:	2103      	movs	r1, #3
    82ae:	9101      	str	r1, [sp, #4]
    82b0:	e7b7      	b.n	8222 <NVM_write+0x316>
    }
    
    /*
     * Fill WD[] with data requested to be written into NVM.
     */
    wd_offset = offset % BYTES_PER_PAGE;
    82b2:	f008 027f 	and.w	r2, r8, #127	; 0x7f
    82b6:	e743      	b.n	8140 <NVM_write+0x234>
    }
    else if(nvm_hw_status & MSS_NVM_PEFAIL_LOCK)
    {
        status = NVM_PAGE_LOCK_ERROR;
    }
    else if(nvm_hw_status & (MSS_NVM_VERIFY_FAIL |
    82b8:	f012 0f0e 	tst.w	r2, #14
    82bc:	d002      	beq.n	82c4 <NVM_write+0x3b8>
            }
        }
    }
    
    /* Restore back to original value. */
    SYSREG->ENVM_CR = initial_nvm_config;
    82be:	2002      	movs	r0, #2
    82c0:	9001      	str	r0, [sp, #4]
    82c2:	e7ae      	b.n	8222 <NVM_write+0x316>
    else if(nvm_hw_status & (MSS_NVM_VERIFY_FAIL |
            MSS_NVM_EVERIFY_FAIL | MSS_NVM_WVERIFY_FAIL))
    {
        status = NVM_VERIFY_FAILURE;
    }
    else if(nvm_hw_status & MSS_NVM_WRCNT_OVER)
    82c4:	f012 0f20 	tst.w	r2, #32
    82c8:	bf0c      	ite	eq
    82ca:	2400      	moveq	r4, #0
    82cc:	2404      	movne	r4, #4
    82ce:	9401      	str	r4, [sp, #4]
    82d0:	e7e1      	b.n	8296 <NVM_write+0x38a>
        {
            /* Gain exclusive access to eNVM controller */
            status = get_ctrl_access(nvm_offset, length);

            /* Write eNVM one page at a time. */
            if(NVM_SUCCESS == status)
    82d2:	9001      	str	r0, [sp, #4]
    82d4:	e7ca      	b.n	826c <NVM_write+0x360>
        nb_non_written_words = (offset % BYTES_PER_PAGE) / NB_OF_BYTES_IN_A_WORD;
        if((offset % NB_OF_BYTES_IN_A_WORD) > 0u)
        {
            ++nb_non_written_words;
        }
        for(inc = 0u; (inc < WD_WORD_SIZE) && (inc < nb_non_written_words); ++inc)
    82d6:	9d07      	ldr	r5, [sp, #28]
    82d8:	eb05 0c8c 	add.w	ip, r5, ip, lsl #2
    82dc:	f8dc 4008 	ldr.w	r4, [ip, #8]
    82e0:	e6f0      	b.n	80c4 <NVM_write+0x1b8>
    82e2:	bf00      	nop

000082e4 <MSS_HPDMA_init>:
)
{
    uint8_t inc;
    
    /* Reset HPDMA block. */
    SYSREG->SOFT_RST_CR |= HPDMA_SOFT_RESET;
    82e4:	f248 0200 	movw	r2, #32768	; 0x8000
    82e8:	f2c4 0203 	movt	r2, #16387	; 0x4003
    82ec:	6c91      	ldr	r1, [r2, #72]	; 0x48
void
MSS_HPDMA_init
(
    void
)
{
    82ee:	b4f0      	push	{r4, r5, r6, r7}
    uint8_t inc;
    
    /* Reset HPDMA block. */
    SYSREG->SOFT_RST_CR |= HPDMA_SOFT_RESET;
    82f0:	f441 3300 	orr.w	r3, r1, #131072	; 0x20000
    82f4:	6493      	str	r3, [r2, #72]	; 0x48

    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;
    82f6:	6c96      	ldr	r6, [r2, #72]	; 0x48

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    82f8:	f640 3034 	movw	r0, #2868	; 0xb34
    g_transfer.state = HPDMA_COMPLETED;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    82fc:	f240 0100 	movw	r1, #0
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    g_transfer.completion_handler = NULL_HANDLER;
    g_transfer.state = HPDMA_COMPLETED;
    8300:	2401      	movs	r4, #1
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    8302:	f2c4 2128 	movt	r1, #16936	; 0x4228

    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    8306:	f2c2 0000 	movt	r0, #8192	; 0x2000
    
    /* Reset HPDMA block. */
    SYSREG->SOFT_RST_CR |= HPDMA_SOFT_RESET;

    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;
    830a:	f426 3500 	bic.w	r5, r6, #131072	; 0x20000
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
        /* Disable Interrupt. */
        HPDMA->Descriptor[inc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    830e:	f244 0300 	movw	r3, #16384	; 0x4000

    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    8312:	2600      	movs	r6, #0
    
    /* Reset HPDMA block. */
    SYSREG->SOFT_RST_CR |= HPDMA_SOFT_RESET;

    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;
    8314:	6495      	str	r5, [r2, #72]	; 0x48
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
        /* Disable Interrupt. */
        HPDMA->Descriptor[inc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8316:	f2c4 0301 	movt	r3, #16385	; 0x4001
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    g_transfer.completion_handler = NULL_HANDLER;
    g_transfer.state = HPDMA_COMPLETED;
    831a:	7004      	strb	r4, [r0, #0]

    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    831c:	6106      	str	r6, [r0, #16]
    g_transfer.state = HPDMA_COMPLETED;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    831e:	f8c1 41cc 	str.w	r4, [r1, #460]	; 0x1cc
        /* Disable Interrupt. */
        HPDMA->Descriptor[inc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8322:	68df      	ldr	r7, [r3, #12]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    8324:	f24e 1200 	movw	r2, #57600	; 0xe100
    8328:	f427 05e0 	bic.w	r5, r7, #7340032	; 0x700000
    832c:	60dd      	str	r5, [r3, #12]
    g_transfer.state = HPDMA_COMPLETED;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    832e:	f8c1 444c 	str.w	r4, [r1, #1100]	; 0x44c
        /* Disable Interrupt. */
        HPDMA->Descriptor[inc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8332:	6a1f      	ldr	r7, [r3, #32]
    8334:	f2ce 0200 	movt	r2, #57344	; 0xe000
    8338:	f427 05e0 	bic.w	r5, r7, #7340032	; 0x700000
    833c:	621d      	str	r5, [r3, #32]
    g_transfer.state = HPDMA_COMPLETED;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    833e:	f8c1 46cc 	str.w	r4, [r1, #1740]	; 0x6cc
        /* Disable Interrupt. */
        HPDMA->Descriptor[inc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8342:	6b5f      	ldr	r7, [r3, #52]	; 0x34
    8344:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
    8348:	f427 07e0 	bic.w	r7, r7, #7340032	; 0x700000
    834c:	635f      	str	r7, [r3, #52]	; 0x34
    g_transfer.state = HPDMA_COMPLETED;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Pause transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    834e:	f8c1 494c 	str.w	r4, [r1, #2380]	; 0x94c
        /* Disable Interrupt. */
        HPDMA->Descriptor[inc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8352:	6c9c      	ldr	r4, [r3, #72]	; 0x48
    8354:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    8358:	f424 04e0 	bic.w	r4, r4, #7340032	; 0x700000
    835c:	649c      	str	r4, [r3, #72]	; 0x48
    835e:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
    8362:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    8366:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    /* Clear any previously pending MSS HPDMA interrupt. */
    NVIC_ClearPendingIRQ(HPDMA_Error_IRQn);
    NVIC_ClearPendingIRQ(HPDMA_Complete_IRQn);
    
    /* Clear all interrupts. */
    HPDMA->HPDMAICR_REG = HPDMAICR_CLEAR_ALL_IRQ;
    836a:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
    836e:	22ff      	movs	r2, #255	; 0xff
    /* Take HPDMA controller out of reset. */
    SYSREG->SOFT_RST_CR &= ~HPDMA_SOFT_RESET;

    /* Initialize data structures. */
    g_transfer.xfr_size = 0u;
    g_transfer.completion_handler = NULL_HANDLER;
    8370:	6046      	str	r6, [r0, #4]
    /* Clear any previously pending MSS HPDMA interrupt. */
    NVIC_ClearPendingIRQ(HPDMA_Error_IRQn);
    NVIC_ClearPendingIRQ(HPDMA_Complete_IRQn);
    
    /* Clear all interrupts. */
    HPDMA->HPDMAICR_REG = HPDMAICR_CLEAR_ALL_IRQ;
    8372:	655a      	str	r2, [r3, #84]	; 0x54
}
    8374:	bcf0      	pop	{r4, r5, r6, r7}
    8376:	4770      	bx	lr

00008378 <MSS_HPDMA_start>:
    uint32_t src_addr,
    uint32_t dest_addr,
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    8378:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    ASSERT((src_addr & ADDRESS_NON_WORD_ALIGNED_MASK) == 0u); 
    ASSERT((dest_addr & ADDRESS_NON_WORD_ALIGNED_MASK) == 0u);      
    ASSERT((g_transfer.state != HPDMA_IN_PROGRESS) && (transfer_size > 0u));
    
    /* Check transfer_size is not zero and that a transfer is not in progress */   
    if((g_transfer.state != HPDMA_IN_PROGRESS) && (transfer_size > 0u))
    837c:	f640 3434 	movw	r4, #2868	; 0xb34
    8380:	f2c2 0400 	movt	r4, #8192	; 0x2000
    8384:	7825      	ldrb	r5, [r4, #0]
    8386:	2d00      	cmp	r5, #0
    8388:	f000 80ce 	beq.w	8528 <MSS_HPDMA_start+0x1b0>
    838c:	2a00      	cmp	r2, #0
    838e:	f000 80cb 	beq.w	8528 <MSS_HPDMA_start+0x1b0>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    8392:	f24e 1c00 	movw	ip, #57600	; 0xe100
    8396:	f2ce 0c00 	movt	ip, #57344	; 0xe000
    839a:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    839e:	f240 0900 	movw	r9, #0
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    83a2:	f244 0700 	movw	r7, #16384	; 0x4000
    83a6:	f8cc b000 	str.w	fp, [ip]
    83aa:	f2c4 0701 	movt	r7, #16385	; 0x4001
        g_transfer.src_addr = src_addr; 
        g_transfer.xfr_dir = transfer_dir;
        /* Total no of descriptors used for transfer */
        hpdma_total_desc = ((transfer_size - 1u) / MAX_SIZE_PER_DMA_XFR) + 1u;
        /* Current HPDMA descriptor */
        g_hpdma_current_desc = 0u;         
    83ae:	f04f 0a00 	mov.w	sl, #0
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    83b2:	f2c4 2928 	movt	r9, #16936	; 0x4228
    83b6:	f04f 5b80 	mov.w	fp, #268435456	; 0x10000000
    83ba:	f8cc b000 	str.w	fp, [ip]
    if((g_transfer.state != HPDMA_IN_PROGRESS) && (transfer_size > 0u))
    {        
        NVIC_EnableIRQ(HPDMA_Complete_IRQn);
        NVIC_EnableIRQ(HPDMA_Error_IRQn);
   
        g_transfer.xfr_size = transfer_size;
    83be:	6122      	str	r2, [r4, #16]
        g_transfer.des_addr = dest_addr;
    83c0:	60e1      	str	r1, [r4, #12]
        g_transfer.src_addr = src_addr; 
    83c2:	60a0      	str	r0, [r4, #8]
        g_transfer.xfr_dir = transfer_dir;
    83c4:	7523      	strb	r3, [r4, #20]
        /* Total no of descriptors used for transfer */
        hpdma_total_desc = ((transfer_size - 1u) / MAX_SIZE_PER_DMA_XFR) + 1u;
        /* Current HPDMA descriptor */
        g_hpdma_current_desc = 0u;         
    83c6:	f8c4 a018 	str.w	sl, [r4, #24]
        g_hpdma_end_desc = 0u; 
    83ca:	f8c4 a01c 	str.w	sl, [r4, #28]
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
    83ce:	f884 a000 	strb.w	sl, [r4]
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    83d2:	f8c9 31c4 	str.w	r3, [r9, #452]	; 0x1c4
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    83d6:	6078      	str	r0, [r7, #4]
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    83d8:	60b9      	str	r1, [r7, #8]
        /* Current HPDMA descriptor */
        g_hpdma_current_desc = 0u;         
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
    83da:	4698      	mov	r8, r3
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    83dc:	68fb      	ldr	r3, [r7, #12]
        /* Current HPDMA descriptor */
        g_hpdma_current_desc = 0u;         
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
    83de:	460e      	mov	r6, r1
        g_transfer.xfr_size = transfer_size;
        g_transfer.des_addr = dest_addr;
        g_transfer.src_addr = src_addr; 
        g_transfer.xfr_dir = transfer_dir;
        /* Total no of descriptors used for transfer */
        hpdma_total_desc = ((transfer_size - 1u) / MAX_SIZE_PER_DMA_XFR) + 1u;
    83e0:	1e51      	subs	r1, r2, #1
        /* Current HPDMA descriptor */
        g_hpdma_current_desc = 0u;         
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
    83e2:	4605      	mov	r5, r0
        g_transfer.xfr_size = transfer_size;
        g_transfer.des_addr = dest_addr;
        g_transfer.src_addr = src_addr; 
        g_transfer.xfr_dir = transfer_dir;
        /* Total no of descriptors used for transfer */
        hpdma_total_desc = ((transfer_size - 1u) / MAX_SIZE_PER_DMA_XFR) + 1u;
    83e4:	0c09      	lsrs	r1, r1, #16
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    83e6:	0c18      	lsrs	r0, r3, #16
    83e8:	0403      	lsls	r3, r0, #16
        g_transfer.xfr_size = transfer_size;
        g_transfer.des_addr = dest_addr;
        g_transfer.src_addr = src_addr; 
        g_transfer.xfr_dir = transfer_dir;
        /* Total no of descriptors used for transfer */
        hpdma_total_desc = ((transfer_size - 1u) / MAX_SIZE_PER_DMA_XFR) + 1u;
    83ea:	3101      	adds	r1, #1
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    83ec:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    83f0:	60fb      	str	r3, [r7, #12]
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    {
        g_transfer.xfr_size = transfer_size - MAX_SIZE_PER_DMA_XFR;
    83f2:	bf82      	ittt	hi
    83f4:	f5a2 3280 	subhi.w	r2, r2, #65536	; 0x10000
        g_transfer.des_addr = dest_addr + MAX_SIZE_PER_DMA_XFR;
    83f8:	f506 3680 	addhi.w	r6, r6, #65536	; 0x10000
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    83fc:	f505 3580 	addhi.w	r5, r5, #65536	; 0x10000
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    8400:	f240 8095 	bls.w	852e <MSS_HPDMA_start+0x1b6>
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    8404:	f244 0300 	movw	r3, #16384	; 0x4000
    8408:	f2c4 0301 	movt	r3, #16385	; 0x4001
    840c:	68df      	ldr	r7, [r3, #12]
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    840e:	f240 0000 	movw	r0, #0
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    8412:	f447 0ce0 	orr.w	ip, r7, #7340032	; 0x700000
    8416:	f8c3 c00c 	str.w	ip, [r3, #12]
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    841a:	f04f 0c01 	mov.w	ip, #1
    841e:	f2c4 2028 	movt	r0, #16936	; 0x4228
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    8422:	2700      	movs	r7, #0
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    8424:	4561      	cmp	r1, ip
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    8426:	f8c0 c1c0 	str.w	ip, [r0, #448]	; 0x1c0
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    842a:	f8c0 71cc 	str.w	r7, [r0, #460]	; 0x1cc
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    842e:	f000 8096 	beq.w	855e <MSS_HPDMA_start+0x1e6>
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    8432:	f8c0 8444 	str.w	r8, [r0, #1092]	; 0x444
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    8436:	619d      	str	r5, [r3, #24]
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    8438:	61de      	str	r6, [r3, #28]
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    843a:	6a18      	ldr	r0, [r3, #32]
    843c:	0c00      	lsrs	r0, r0, #16
    843e:	0400      	lsls	r0, r0, #16
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    8440:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    8444:	6218      	str	r0, [r3, #32]
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    {
        g_transfer.xfr_size = transfer_size - MAX_SIZE_PER_DMA_XFR;
    8446:	bf82      	ittt	hi
    8448:	f5a2 3280 	subhi.w	r2, r2, #65536	; 0x10000
        g_transfer.des_addr = dest_addr + MAX_SIZE_PER_DMA_XFR;
    844c:	f506 3680 	addhi.w	r6, r6, #65536	; 0x10000
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    8450:	f505 3580 	addhi.w	r5, r5, #65536	; 0x10000
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    8454:	d971      	bls.n	853a <MSS_HPDMA_start+0x1c2>
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    8456:	f244 0300 	movw	r3, #16384	; 0x4000
    845a:	f2c4 0301 	movt	r3, #16385	; 0x4001
    845e:	6a1f      	ldr	r7, [r3, #32]
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    8460:	f240 0000 	movw	r0, #0
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    8464:	f447 0ce0 	orr.w	ip, r7, #7340032	; 0x700000
    8468:	f8c3 c020 	str.w	ip, [r3, #32]
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    846c:	f2c4 2028 	movt	r0, #16936	; 0x4228
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    8470:	2700      	movs	r7, #0
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    8472:	f04f 0c01 	mov.w	ip, #1
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    8476:	2902      	cmp	r1, #2
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    8478:	f8c0 c440 	str.w	ip, [r0, #1088]	; 0x440
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    847c:	f8c0 744c 	str.w	r7, [r0, #1100]	; 0x44c
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    8480:	d06d      	beq.n	855e <MSS_HPDMA_start+0x1e6>
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    8482:	f8c0 86c4 	str.w	r8, [r0, #1732]	; 0x6c4
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    8486:	62dd      	str	r5, [r3, #44]	; 0x2c
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    8488:	631e      	str	r6, [r3, #48]	; 0x30
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    848a:	6b58      	ldr	r0, [r3, #52]	; 0x34
    848c:	0c00      	lsrs	r0, r0, #16
    848e:	0400      	lsls	r0, r0, #16
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    8490:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    8494:	6358      	str	r0, [r3, #52]	; 0x34
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    {
        g_transfer.xfr_size = transfer_size - MAX_SIZE_PER_DMA_XFR;
    8496:	bf82      	ittt	hi
    8498:	f5a2 3280 	subhi.w	r2, r2, #65536	; 0x10000
        g_transfer.des_addr = dest_addr + MAX_SIZE_PER_DMA_XFR;
    849c:	f506 3680 	addhi.w	r6, r6, #65536	; 0x10000
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    84a0:	f505 3580 	addhi.w	r5, r5, #65536	; 0x10000
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    84a4:	d94f      	bls.n	8546 <MSS_HPDMA_start+0x1ce>
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    84a6:	f244 0300 	movw	r3, #16384	; 0x4000
    84aa:	f2c4 0301 	movt	r3, #16385	; 0x4001
    84ae:	6b5f      	ldr	r7, [r3, #52]	; 0x34
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    84b0:	f240 0000 	movw	r0, #0
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    84b4:	f447 0ce0 	orr.w	ip, r7, #7340032	; 0x700000
    84b8:	f8c3 c034 	str.w	ip, [r3, #52]	; 0x34
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    84bc:	f2c4 2028 	movt	r0, #16936	; 0x4228
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    84c0:	2700      	movs	r7, #0
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    84c2:	f04f 0c01 	mov.w	ip, #1
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    84c6:	2903      	cmp	r1, #3
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    84c8:	f8c0 c6c0 	str.w	ip, [r0, #1728]	; 0x6c0
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    84cc:	f8c0 76cc 	str.w	r7, [r0, #1740]	; 0x6cc
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    84d0:	d045      	beq.n	855e <MSS_HPDMA_start+0x1e6>
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    84d2:	f8c0 8944 	str.w	r8, [r0, #2372]	; 0x944
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    84d6:	641d      	str	r5, [r3, #64]	; 0x40
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    84d8:	645e      	str	r6, [r3, #68]	; 0x44
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    84da:	6c98      	ldr	r0, [r3, #72]	; 0x48
    84dc:	0c00      	lsrs	r0, r0, #16
    84de:	0400      	lsls	r0, r0, #16
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    84e0:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    84e4:	6498      	str	r0, [r3, #72]	; 0x48
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    {
        g_transfer.xfr_size = transfer_size - MAX_SIZE_PER_DMA_XFR;
    84e6:	bf82      	ittt	hi
    84e8:	f5a2 3280 	subhi.w	r2, r2, #65536	; 0x10000
        g_transfer.des_addr = dest_addr + MAX_SIZE_PER_DMA_XFR;
    84ec:	f506 3680 	addhi.w	r6, r6, #65536	; 0x10000
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    84f0:	f505 3580 	addhi.w	r5, r5, #65536	; 0x10000
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    84f4:	d92d      	bls.n	8552 <MSS_HPDMA_start+0x1da>
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    84f6:	f244 0000 	movw	r0, #16384	; 0x4000
    84fa:	f2c4 0001 	movt	r0, #16385	; 0x4001
    84fe:	6c87      	ldr	r7, [r0, #72]	; 0x48
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    8500:	f240 0300 	movw	r3, #0
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    8504:	f447 07e0 	orr.w	r7, r7, #7340032	; 0x700000
    8508:	6487      	str	r7, [r0, #72]	; 0x48
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    850a:	f2c4 2328 	movt	r3, #16936	; 0x4228
    850e:	2001      	movs	r0, #1
    8510:	f8c3 0940 	str.w	r0, [r3, #2368]	; 0x940
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    8514:	2000      	movs	r0, #0
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    8516:	2904      	cmp	r1, #4
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    8518:	f8c3 094c 	str.w	r0, [r3, #2380]	; 0x94c
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    851c:	d01f      	beq.n	855e <MSS_HPDMA_start+0x1e6>
    851e:	2104      	movs	r1, #4
    8520:	61e1      	str	r1, [r4, #28]
    8522:	6122      	str	r2, [r4, #16]
    8524:	60e6      	str	r6, [r4, #12]
    8526:	60a5      	str	r5, [r4, #8]
                            g_transfer.xfr_dir);
                        
            ++g_hpdma_end_desc;            
        }
   }
}
    8528:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    852c:	4770      	bx	lr
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    }
    else
    {
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
    852e:	68f8      	ldr	r0, [r7, #12]
    8530:	b292      	uxth	r2, r2
    8532:	4302      	orrs	r2, r0
    8534:	60fa      	str	r2, [r7, #12]
    8536:	4652      	mov	r2, sl
    8538:	e764      	b.n	8404 <MSS_HPDMA_start+0x8c>
    853a:	6a18      	ldr	r0, [r3, #32]
    853c:	b292      	uxth	r2, r2
    853e:	4302      	orrs	r2, r0
    8540:	621a      	str	r2, [r3, #32]
    8542:	463a      	mov	r2, r7
    8544:	e787      	b.n	8456 <MSS_HPDMA_start+0xde>
    8546:	6b58      	ldr	r0, [r3, #52]	; 0x34
    8548:	b292      	uxth	r2, r2
    854a:	4302      	orrs	r2, r0
    854c:	635a      	str	r2, [r3, #52]	; 0x34
    854e:	463a      	mov	r2, r7
    8550:	e7a9      	b.n	84a6 <MSS_HPDMA_start+0x12e>
    8552:	6c98      	ldr	r0, [r3, #72]	; 0x48
    8554:	b292      	uxth	r2, r2
    8556:	4302      	orrs	r2, r0
    8558:	649a      	str	r2, [r3, #72]	; 0x48
    855a:	463a      	mov	r2, r7
    855c:	e7cb      	b.n	84f6 <MSS_HPDMA_start+0x17e>
        g_hpdma_end_desc = 0u; 
        
        /* Start transfer */
        g_transfer.state = HPDMA_IN_PROGRESS; 
        
        while((g_hpdma_end_desc < hpdma_total_desc) && (g_hpdma_end_desc < NO_OF_HPDMA_DESCRIPTORS))  
    855e:	61e1      	str	r1, [r4, #28]
    8560:	6122      	str	r2, [r4, #16]
    8562:	60e6      	str	r6, [r4, #12]
    8564:	60a5      	str	r5, [r4, #8]
    8566:	e7df      	b.n	8528 <MSS_HPDMA_start+0x1b0>

00008568 <MSS_HPDMA_pause>:
(
    void
)
{
    /* Pause transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMACR_DCP_PAUSE = HPDMA_ENABLE;
    8568:	f640 3034 	movw	r0, #2868	; 0xb34
    856c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    8570:	6983      	ldr	r3, [r0, #24]
    8572:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    8576:	01d1      	lsls	r1, r2, #7
    8578:	f101 4084 	add.w	r0, r1, #1107296256	; 0x42000000
    857c:	f500 1320 	add.w	r3, r0, #2621440	; 0x280000
    8580:	2201      	movs	r2, #1
    8582:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
}
    8586:	4770      	bx	lr

00008588 <MSS_HPDMA_resume>:
(
    void
)
{
    /* Resume transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;
    8588:	f640 3034 	movw	r0, #2868	; 0xb34
    858c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    8590:	6983      	ldr	r3, [r0, #24]
    8592:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    8596:	01d1      	lsls	r1, r2, #7
    8598:	f101 4084 	add.w	r0, r1, #1107296256	; 0x42000000
    859c:	f500 1320 	add.w	r3, r0, #2621440	; 0x280000
    85a0:	2200      	movs	r2, #0
    85a2:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
}
    85a6:	4770      	bx	lr

000085a8 <MSS_HPDMA_abort>:
    uint32_t inc;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    85a8:	f240 0300 	movw	r3, #0
    }
    g_transfer.state = HPDMA_COMPLETED;
    85ac:	f640 3134 	movw	r1, #2868	; 0xb34
    uint32_t inc;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    85b0:	2201      	movs	r2, #1
    85b2:	f2c4 2328 	movt	r3, #16936	; 0x4228
    }
    g_transfer.state = HPDMA_COMPLETED;
    85b6:	f2c2 0100 	movt	r1, #8192	; 0x2000
    uint32_t inc;
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    85ba:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
    85be:	f8c3 2448 	str.w	r2, [r3, #1096]	; 0x448
    85c2:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
    85c6:	f8c3 2948 	str.w	r2, [r3, #2376]	; 0x948
    }
    g_transfer.state = HPDMA_COMPLETED;
    85ca:	700a      	strb	r2, [r1, #0]
}
    85cc:	4770      	bx	lr
    85ce:	bf00      	nop

000085d0 <MSS_HPDMA_get_transfer_status>:
MSS_HPDMA_get_transfer_status
(
    void
)
{
    return g_transfer.state;
    85d0:	f640 3334 	movw	r3, #2868	; 0xb34
    85d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    85d8:	7818      	ldrb	r0, [r3, #0]
}
    85da:	4770      	bx	lr

000085dc <MSS_HPDMA_set_handler>:
    {
        g_transfer.completion_handler = NULL_HANDLER;
    }
    else
    {
        g_transfer.completion_handler = handler;
    85dc:	f640 3234 	movw	r2, #2868	; 0xb34
    85e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    85e4:	6050      	str	r0, [r2, #4]
    85e6:	4770      	bx	lr

000085e8 <HPDMA_Complete_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void HPDMA_Complete_IRQHandler(void)
#else
void HPDMA_Complete_IRQHandler(void)
#endif 
{
    85e8:	466b      	mov	r3, sp
    85ea:	f023 0107 	bic.w	r1, r3, #7
    85ee:	468d      	mov	sp, r1
    85f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* Clear interrupt */
    HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[g_hpdma_current_desc] = HPDMA_ENABLE;
    85f2:	f640 3334 	movw	r3, #2868	; 0xb34
    85f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    85fa:	6999      	ldr	r1, [r3, #24]
    85fc:	f240 0000 	movw	r0, #0
    /* Disable interrupts */
    HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8600:	eb01 0281 	add.w	r2, r1, r1, lsl #2
    8604:	0094      	lsls	r4, r2, #2
#else
void HPDMA_Complete_IRQHandler(void)
#endif 
{
    /* Clear interrupt */
    HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[g_hpdma_current_desc] = HPDMA_ENABLE;
    8606:	f2c4 2028 	movt	r0, #16936	; 0x4228
    /* Disable interrupts */
    HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    860a:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
#else
void HPDMA_Complete_IRQHandler(void)
#endif 
{
    /* Clear interrupt */
    HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[g_hpdma_current_desc] = HPDMA_ENABLE;
    860e:	f501 7c28 	add.w	ip, r1, #672	; 0x2a0
    8612:	2401      	movs	r4, #1
    8614:	f840 402c 	str.w	r4, [r0, ip, lsl #2]
    /* Disable interrupts */
    HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8618:	f502 32a0 	add.w	r2, r2, #81920	; 0x14000
    861c:	68d0      	ldr	r0, [r2, #12]
    
    ++g_hpdma_current_desc;
    861e:	1909      	adds	r1, r1, r4
#endif 
{
    /* Clear interrupt */
    HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[g_hpdma_current_desc] = HPDMA_ENABLE;
    /* Disable interrupts */
    HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8620:	f420 00e0 	bic.w	r0, r0, #7340032	; 0x700000
    
    ++g_hpdma_current_desc;
    
    if(NO_OF_HPDMA_DESCRIPTORS == g_hpdma_current_desc)
    8624:	2904      	cmp	r1, #4
#endif 
{
    /* Clear interrupt */
    HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[g_hpdma_current_desc] = HPDMA_ENABLE;
    /* Disable interrupts */
    HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG &= ~HPDMACR_ALL_IRQ_ENABLE_MASK;
    8626:	60d0      	str	r0, [r2, #12]
    
    ++g_hpdma_current_desc;
    8628:	6199      	str	r1, [r3, #24]
    
    if(NO_OF_HPDMA_DESCRIPTORS == g_hpdma_current_desc)
    862a:	d062      	beq.n	86f2 <HPDMA_Complete_IRQHandler+0x10a>
    {
        g_hpdma_current_desc = 0u;
    } 
    
    if(g_transfer.xfr_size > 0u)
    862c:	6919      	ldr	r1, [r3, #16]
    862e:	f640 3234 	movw	r2, #2868	; 0xb34
    8632:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8636:	2900      	cmp	r1, #0
    8638:	d046      	beq.n	86c8 <HPDMA_Complete_IRQHandler+0xe0>
    {
        if(NO_OF_HPDMA_DESCRIPTORS == g_hpdma_end_desc)
    863a:	69d4      	ldr	r4, [r2, #28]
    863c:	2c04      	cmp	r4, #4
    863e:	d062      	beq.n	8706 <HPDMA_Complete_IRQHandler+0x11e>
        {
            g_hpdma_end_desc = 0u;
        }
        else
        {
            ++g_hpdma_end_desc;
    8640:	3401      	adds	r4, #1
    8642:	61d4      	str	r4, [r2, #28]
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    8644:	ea4f 0c84 	mov.w	ip, r4, lsl #2
    8648:	eb0c 0704 	add.w	r7, ip, r4
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    864c:	00bd      	lsls	r5, r7, #2
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    864e:	01fe      	lsls	r6, r7, #7
    8650:	f106 4084 	add.w	r0, r6, #1107296256	; 0x42000000
    8654:	7d1f      	ldrb	r7, [r3, #20]
        }
        else
        {
            ++g_hpdma_end_desc;
        }
        start_transfer(g_transfer.src_addr,
    8656:	68de      	ldr	r6, [r3, #12]
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    8658:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
        }
        else
        {
            ++g_hpdma_end_desc;
        }
        start_transfer(g_transfer.src_addr,
    865c:	689d      	ldr	r5, [r3, #8]
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    865e:	f502 32a0 	add.w	r2, r2, #81920	; 0x14000
    uint32_t transfer_size,
    uint8_t transfer_dir
)
{
    /* Set descriptor transfer direction */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_XFR_DIR = transfer_dir;
    8662:	f500 1020 	add.w	r0, r0, #2621440	; 0x280000
    8666:	f8c0 71c4 	str.w	r7, [r0, #452]	; 0x1c4
    
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    866a:	6055      	str	r5, [r2, #4]
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    866c:	6096      	str	r6, [r2, #8]
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    866e:	68d3      	ldr	r3, [r2, #12]
        }
        else
        {
            ++g_hpdma_end_desc;
        }
        start_transfer(g_transfer.src_addr,
    8670:	f640 3034 	movw	r0, #2868	; 0xb34
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    8674:	0c1b      	lsrs	r3, r3, #16
    8676:	041b      	lsls	r3, r3, #16
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    8678:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    /* Store Source and destination Address */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMASAR_REG = src_addr;
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    867c:	60d3      	str	r3, [r2, #12]
        }
        else
        {
            ++g_hpdma_end_desc;
        }
        start_transfer(g_transfer.src_addr,
    867e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMADAR_REG = dest_addr;
    
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    8682:	d939      	bls.n	86f8 <HPDMA_Complete_IRQHandler+0x110>
    {
        g_transfer.xfr_size = transfer_size - MAX_SIZE_PER_DMA_XFR;
    8684:	f5a1 3180 	sub.w	r1, r1, #65536	; 0x10000
        g_transfer.des_addr = dest_addr + MAX_SIZE_PER_DMA_XFR;
    8688:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    868c:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
    8690:	6085      	str	r5, [r0, #8]
    /* Set the transfer size to 64K */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG &= HPDMA_XFR_SIZE_MASK;
    
    if(transfer_size > MAX_SIZE_PER_DMA_XFR)
    {
        g_transfer.xfr_size = transfer_size - MAX_SIZE_PER_DMA_XFR;
    8692:	6101      	str	r1, [r0, #16]
        g_transfer.des_addr = dest_addr + MAX_SIZE_PER_DMA_XFR;
    8694:	60c6      	str	r6, [r0, #12]
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    8696:	4464      	add	r4, ip
    8698:	00a2      	lsls	r2, r4, #2
    869a:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    869e:	f503 30a0 	add.w	r0, r3, #81920	; 0x14000
    86a2:	68c1      	ldr	r1, [r0, #12]
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    86a4:	01e4      	lsls	r4, r4, #7
    86a6:	f104 4c84 	add.w	ip, r4, #1107296256	; 0x42000000
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    86aa:	f441 01e0 	orr.w	r1, r1, #7340032	; 0x700000
    86ae:	60c1      	str	r1, [r0, #12]
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    86b0:	f50c 1320 	add.w	r3, ip, #2621440	; 0x280000
    86b4:	2201      	movs	r2, #1
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    86b6:	2000      	movs	r0, #0
        g_transfer.xfr_size = 0u;     
    }    
    /* Enable interrupts for the requested descriptor. */
    HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= HPDMACR_ALL_IRQ_ENABLE_MASK;       
    /* Set valid descriptor to start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_VALID = HPDMA_ENABLE;  
    86b8:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
    /* Start transfer */
    HPDMA_BITBAND->Descriptor[g_hpdma_end_desc].HPDMACR_DCP_PAUSE = HPDMA_DISABLE;        
    86bc:	f8c3 01cc 	str.w	r0, [r3, #460]	; 0x1cc
            {
                (*(g_transfer.completion_handler))(HPDMA_COMPLETED);
            }  
        }
    }
}
    86c0:	e8bd 40f1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, lr}
    86c4:	4685      	mov	sp, r0
    86c6:	4770      	bx	lr
                        g_transfer.xfr_size,
                        g_transfer.xfr_dir);
    }
    else
    {
        if(((HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG) & HPDMACR_ALL_IRQ_ENABLE_MASK) == 0u)  
    86c8:	6991      	ldr	r1, [r2, #24]
    86ca:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    86ce:	0083      	lsls	r3, r0, #2
    86d0:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
    86d4:	f50c 31a0 	add.w	r1, ip, #81920	; 0x14000
    86d8:	68c8      	ldr	r0, [r1, #12]
    86da:	f410 01e0 	ands.w	r1, r0, #7340032	; 0x700000
    86de:	d1ef      	bne.n	86c0 <HPDMA_Complete_IRQHandler+0xd8>
        {
            g_hpdma_current_desc = 0u;
            g_hpdma_end_desc = 0u;
        
            g_transfer.state = HPDMA_COMPLETED;
            if(g_transfer.completion_handler != NULL_HANDLER)
    86e0:	6853      	ldr	r3, [r2, #4]
        if(((HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG) & HPDMACR_ALL_IRQ_ENABLE_MASK) == 0u)  
        {
            g_hpdma_current_desc = 0u;
            g_hpdma_end_desc = 0u;
        
            g_transfer.state = HPDMA_COMPLETED;
    86e2:	2001      	movs	r0, #1
    else
    {
        if(((HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG) & HPDMACR_ALL_IRQ_ENABLE_MASK) == 0u)  
        {
            g_hpdma_current_desc = 0u;
            g_hpdma_end_desc = 0u;
    86e4:	61d1      	str	r1, [r2, #28]
    }
    else
    {
        if(((HPDMA->Descriptor[g_hpdma_current_desc].HPDMACR_REG) & HPDMACR_ALL_IRQ_ENABLE_MASK) == 0u)  
        {
            g_hpdma_current_desc = 0u;
    86e6:	6191      	str	r1, [r2, #24]
            g_hpdma_end_desc = 0u;
        
            g_transfer.state = HPDMA_COMPLETED;
    86e8:	7010      	strb	r0, [r2, #0]
            if(g_transfer.completion_handler != NULL_HANDLER)
    86ea:	2b00      	cmp	r3, #0
    86ec:	d0e8      	beq.n	86c0 <HPDMA_Complete_IRQHandler+0xd8>
            {
                (*(g_transfer.completion_handler))(HPDMA_COMPLETED);
    86ee:	4798      	blx	r3
    86f0:	e7e6      	b.n	86c0 <HPDMA_Complete_IRQHandler+0xd8>
    
    ++g_hpdma_current_desc;
    
    if(NO_OF_HPDMA_DESCRIPTORS == g_hpdma_current_desc)
    {
        g_hpdma_current_desc = 0u;
    86f2:	2000      	movs	r0, #0
    86f4:	6198      	str	r0, [r3, #24]
    86f6:	e799      	b.n	862c <HPDMA_Complete_IRQHandler+0x44>
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    }
    else
    {
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
    86f8:	68d3      	ldr	r3, [r2, #12]
    86fa:	b289      	uxth	r1, r1
    86fc:	4319      	orrs	r1, r3
        g_transfer.xfr_size = 0u;     
    86fe:	2300      	movs	r3, #0
        g_transfer.src_addr = src_addr + MAX_SIZE_PER_DMA_XFR; 
    }
    else
    {
        /* Set descriptor transfer size */
        HPDMA->Descriptor[g_hpdma_end_desc].HPDMACR_REG |= (uint16_t)transfer_size;
    8700:	60d1      	str	r1, [r2, #12]
        g_transfer.xfr_size = 0u;     
    8702:	6103      	str	r3, [r0, #16]
    8704:	e7c7      	b.n	8696 <HPDMA_Complete_IRQHandler+0xae>
    
    if(g_transfer.xfr_size > 0u)
    {
        if(NO_OF_HPDMA_DESCRIPTORS == g_hpdma_end_desc)
        {
            g_hpdma_end_desc = 0u;
    8706:	2400      	movs	r4, #0
    8708:	61d4      	str	r4, [r2, #28]
    870a:	e79b      	b.n	8644 <HPDMA_Complete_IRQHandler+0x5c>

0000870c <HPDMA_Error_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void HPDMA_Error_IRQHandler(void)
#else
void HPDMA_Error_IRQHandler(void)
#endif 
{
    870c:	466a      	mov	r2, sp
    870e:	f022 0107 	bic.w	r1, r2, #7
    uint32_t inc;

    /*
     * Handle source/destination errors.
     */
    error_bits = HPDMA->HPDMAEDR_REG;
    8712:	f244 0000 	movw	r0, #16384	; 0x4000
#if defined(__GNUC__)
__attribute__((__interrupt__)) void HPDMA_Error_IRQHandler(void)
#else
void HPDMA_Error_IRQHandler(void)
#endif 
{
    8716:	468d      	mov	sp, r1
    uint32_t inc;

    /*
     * Handle source/destination errors.
     */
    error_bits = HPDMA->HPDMAEDR_REG;
    8718:	f2c4 0001 	movt	r0, #16385	; 0x4001
#if defined(__GNUC__)
__attribute__((__interrupt__)) void HPDMA_Error_IRQHandler(void)
#else
void HPDMA_Error_IRQHandler(void)
#endif 
{
    871c:	b51c      	push	{r2, r3, r4, lr}
    uint32_t inc;

    /*
     * Handle source/destination errors.
     */
    error_bits = HPDMA->HPDMAEDR_REG;
    871e:	6803      	ldr	r3, [r0, #0]
    error_bits = error_bits & HPDMAEDR_DCP_ERR_MASK;
    
    if(error_bits != 0u)
    8720:	f413 6f70 	tst.w	r3, #3840	; 0xf00
    8724:	d01f      	beq.n	8766 <HPDMA_Error_IRQHandler+0x5a>
    {
        if(HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMASR_DCP_SERR != 0u)
    8726:	f640 3434 	movw	r4, #2868	; 0xb34
    872a:	f2c2 0400 	movt	r4, #8192	; 0x2000
    872e:	69a2      	ldr	r2, [r4, #24]
    8730:	0091      	lsls	r1, r2, #2
    8732:	1888      	adds	r0, r1, r2
    8734:	01c3      	lsls	r3, r0, #7
    8736:	f103 4c84 	add.w	ip, r3, #1107296256	; 0x42000000
    873a:	f50c 1020 	add.w	r0, ip, #2621440	; 0x280000
    873e:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    8742:	b133      	cbz	r3, 8752 <HPDMA_Error_IRQHandler+0x46>
        {
            g_transfer.state = HPDMA_SOURCE_ERROR;
            if(g_transfer.completion_handler != NULL_HANDLER)
    8744:	6863      	ldr	r3, [r4, #4]
    
    if(error_bits != 0u)
    {
        if(HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMASR_DCP_SERR != 0u)
        {
            g_transfer.state = HPDMA_SOURCE_ERROR;
    8746:	2002      	movs	r0, #2
    8748:	7020      	strb	r0, [r4, #0]
            if(g_transfer.completion_handler != NULL_HANDLER)
    874a:	b113      	cbz	r3, 8752 <HPDMA_Error_IRQHandler+0x46>
            {                        
                (*(g_transfer.completion_handler))(HPDMA_SOURCE_ERROR);
    874c:	4798      	blx	r3
    874e:	69a2      	ldr	r2, [r4, #24]
    8750:	0091      	lsls	r1, r2, #2
            }
        }
        
        if(HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMASR_DCP_DERR != 0u)
    8752:	1888      	adds	r0, r1, r2
    8754:	01c3      	lsls	r3, r0, #7
    8756:	f103 4c84 	add.w	ip, r3, #1107296256	; 0x42000000
    875a:	f50c 1220 	add.w	r2, ip, #2621440	; 0x280000
    875e:	f8d2 120c 	ldr.w	r1, [r2, #524]	; 0x20c
    8762:	2900      	cmp	r1, #0
    8764:	d129      	bne.n	87ba <HPDMA_Error_IRQHandler+0xae>
    }
    
    /*
     * Handle non word aligned errors.
     */
    error_bits = HPDMA->HPDMAEDR_REG;
    8766:	f244 0200 	movw	r2, #16384	; 0x4000
    876a:	f2c4 0201 	movt	r2, #16385	; 0x4001
    876e:	6811      	ldr	r1, [r2, #0]
    error_bits = error_bits & HPDMAEDR_NON_WORD_ERR_MASK;
    
    if(error_bits != 0u)
    8770:	f411 4f70 	tst.w	r1, #61440	; 0xf000
    8774:	d008      	beq.n	8788 <HPDMA_Error_IRQHandler+0x7c>
    {
        g_transfer.state = HPDMA_WORD_ALIGN_ERROR;
    8776:	f640 3134 	movw	r1, #2868	; 0xb34
    877a:	f2c2 0100 	movt	r1, #8192	; 0x2000
        /* Call handler. */
        if(g_transfer.completion_handler != NULL_HANDLER)
    877e:	684b      	ldr	r3, [r1, #4]
    error_bits = HPDMA->HPDMAEDR_REG;
    error_bits = error_bits & HPDMAEDR_NON_WORD_ERR_MASK;
    
    if(error_bits != 0u)
    {
        g_transfer.state = HPDMA_WORD_ALIGN_ERROR;
    8780:	2004      	movs	r0, #4
    8782:	7008      	strb	r0, [r1, #0]
        /* Call handler. */
        if(g_transfer.completion_handler != NULL_HANDLER)
    8784:	b103      	cbz	r3, 8788 <HPDMA_Error_IRQHandler+0x7c>
        {
            (*(g_transfer.completion_handler))(HPDMA_WORD_ALIGN_ERROR);
    8786:	4798      	blx	r3
    }
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    8788:	f240 0300 	movw	r3, #0
    878c:	f2c4 2328 	movt	r3, #16936	; 0x4228
    8790:	2001      	movs	r0, #1
    8792:	f8c3 01c8 	str.w	r0, [r3, #456]	; 0x1c8
        /* Clear interrupt. */
        HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[inc] = HPDMA_ENABLE;
    8796:	f8c3 0a80 	str.w	r0, [r3, #2688]	; 0xa80
    }
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    879a:	f8c3 0448 	str.w	r0, [r3, #1096]	; 0x448
        /* Clear interrupt. */
        HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[inc] = HPDMA_ENABLE;
    879e:	f8c3 0a84 	str.w	r0, [r3, #2692]	; 0xa84
    }
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    87a2:	f8c3 06c8 	str.w	r0, [r3, #1736]	; 0x6c8
        /* Clear interrupt. */
        HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[inc] = HPDMA_ENABLE;
    87a6:	f8c3 0a88 	str.w	r0, [r3, #2696]	; 0xa88
    }
    
    for(inc = 0u; inc < NO_OF_HPDMA_DESCRIPTORS; inc++)
    {
        /* Abort transfer. */
        HPDMA_BITBAND->Descriptor[inc].HPDMACR_DCP_CLR = HPDMA_ENABLE;
    87aa:	f8c3 0948 	str.w	r0, [r3, #2376]	; 0x948
        /* Clear interrupt. */
        HPDMA_BITBAND->HPDMAICR_CLR_XFR_INT[inc] = HPDMA_ENABLE;
    87ae:	f8c3 0a8c 	str.w	r0, [r3, #2700]	; 0xa8c
    }
}
    87b2:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
    87b6:	4685      	mov	sp, r0
    87b8:	4770      	bx	lr
        }
        
        if(HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMASR_DCP_DERR != 0u)
        {
            g_transfer.state = HPDMA_DESTINATION_ERROR;
            if(g_transfer.completion_handler != NULL_HANDLER)
    87ba:	6863      	ldr	r3, [r4, #4]
            }
        }
        
        if(HPDMA_BITBAND->Descriptor[g_hpdma_current_desc].HPDMASR_DCP_DERR != 0u)
        {
            g_transfer.state = HPDMA_DESTINATION_ERROR;
    87bc:	2003      	movs	r0, #3
    87be:	7020      	strb	r0, [r4, #0]
            if(g_transfer.completion_handler != NULL_HANDLER)
    87c0:	2b00      	cmp	r3, #0
    87c2:	d0d0      	beq.n	8766 <HPDMA_Error_IRQHandler+0x5a>
            {                        
                (*(g_transfer.completion_handler))(HPDMA_DESTINATION_ERROR);
    87c4:	4798      	blx	r3
    87c6:	e7ce      	b.n	8766 <HPDMA_Error_IRQHandler+0x5a>

000087c8 <MSS_GPIO_init>:
void MSS_GPIO_init( void )
{
    uint32_t inc;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    87c8:	f248 0200 	movw	r2, #32768	; 0x8000
    87cc:	f2c4 0203 	movt	r2, #16387	; 0x4003
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
    87d0:	e92d 05f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl}
    uint32_t inc;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    87d4:	6c94      	ldr	r4, [r2, #72]	; 0x48
    87d6:	f648 6698 	movw	r6, #36504	; 0x8e98
    87da:	f444 1380 	orr.w	r3, r4, #1048576	; 0x100000
    87de:	6493      	str	r3, [r2, #72]	; 0x48
    SYSREG->SOFT_RST_CR |= (SYSREG_GPIO_7_0_SOFTRESET_MASK |
    87e0:	6c90      	ldr	r0, [r2, #72]	; 0x48

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    87e2:	f24e 1300 	movw	r3, #57600	; 0xe100
    87e6:	f040 71f0 	orr.w	r1, r0, #31457280	; 0x1e00000
    87ea:	6491      	str	r1, [r2, #72]	; 0x48
    87ec:	f2c0 0600 	movt	r6, #0
    87f0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    87f4:	2200      	movs	r2, #0
    87f6:	2701      	movs	r7, #1
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
    87f8:	1c55      	adds	r5, r2, #1
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
    87fa:	5cb4      	ldrb	r4, [r6, r2]
    87fc:	f816 a005 	ldrb.w	sl, [r6, r5]
    8800:	f004 001f 	and.w	r0, r4, #31
    8804:	f00a 011f 	and.w	r1, sl, #31
    8808:	fa17 f000 	lsls.w	r0, r7, r0
    880c:	fa17 f101 	lsls.w	r1, r7, r1
    8810:	fa4f f88a 	sxtb.w	r8, sl
    8814:	b262      	sxtb	r2, r4
    8816:	0954      	lsrs	r4, r2, #5
    8818:	ea4f 1c58 	mov.w	ip, r8, lsr #5
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
    881c:	1c6a      	adds	r2, r5, #1

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    881e:	f104 0a60 	add.w	sl, r4, #96	; 0x60
    8822:	f10c 0860 	add.w	r8, ip, #96	; 0x60

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    8826:	3420      	adds	r4, #32
    8828:	f10c 0c20 	add.w	ip, ip, #32
    882c:	2a20      	cmp	r2, #32
    882e:	f843 0024 	str.w	r0, [r3, r4, lsl #2]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    8832:	f843 002a 	str.w	r0, [r3, sl, lsl #2]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
    8836:	f843 102c 	str.w	r1, [r3, ip, lsl #2]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    883a:	f843 1028 	str.w	r1, [r3, r8, lsl #2]
    883e:	d1db      	bne.n	87f8 <MSS_GPIO_init+0x30>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~(SYSREG_GPIO_7_0_SOFTRESET_MASK |
    8840:	f248 0300 	movw	r3, #32768	; 0x8000
    8844:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8848:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    884a:	f022 70f0 	bic.w	r0, r2, #31457280	; 0x1e00000
    884e:	6498      	str	r0, [r3, #72]	; 0x48
                             SYSREG_GPIO_15_8_SOFTRESET_MASK |
                             SYSREG_GPIO_23_16_SOFTRESET_MASK |
                             SYSREG_GPIO_31_24_SOFTRESET_MASK);
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
    8850:	6c99      	ldr	r1, [r3, #72]	; 0x48
    8852:	f421 1280 	bic.w	r2, r1, #1048576	; 0x100000
    8856:	649a      	str	r2, [r3, #72]	; 0x48
}
    8858:	e8bd 05f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl}
    885c:	4770      	bx	lr
    885e:	bf00      	nop

00008860 <MSS_GPIO_config>:
{
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);

    if(gpio_idx < NB_OF_GPIO)
    8860:	281f      	cmp	r0, #31
    {
        *(g_config_reg_lut[gpio_idx]) = config;
    8862:	bf9f      	itttt	ls
    8864:	f648 6398 	movwls	r3, #36504	; 0x8e98
    8868:	f2c0 0300 	movtls	r3, #0
    886c:	eb03 0080 	addls.w	r0, r3, r0, lsl #2
    8870:	6a03      	ldrls	r3, [r0, #32]
    8872:	bf98      	it	ls
    8874:	6019      	strls	r1, [r3, #0]
    8876:	4770      	bx	lr

00008878 <MSS_GPIO_set_output>:
    uint32_t gpio_setting;
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    8878:	281f      	cmp	r0, #31
    887a:	d812      	bhi.n	88a2 <MSS_GPIO_set_output+0x2a>
    {
        gpio_setting = GPIO->GPIO_OUT;
        gpio_setting &= ~((uint32_t)0x01u << gpio_idx);
    887c:	2201      	movs	r2, #1
    887e:	fa02 fc00 	lsl.w	ip, r2, r0
        gpio_setting |= ((uint32_t)value & 0x01u) << gpio_idx;
    8882:	f001 0301 	and.w	r3, r1, #1
    8886:	fa13 f000 	lsls.w	r0, r3, r0
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    {
        gpio_setting = GPIO->GPIO_OUT;
    888a:	f243 0300 	movw	r3, #12288	; 0x3000
    888e:	f2c4 0301 	movt	r3, #16385	; 0x4001
    8892:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
        gpio_setting &= ~((uint32_t)0x01u << gpio_idx);
    8896:	ea22 010c 	bic.w	r1, r2, ip
        gpio_setting |= ((uint32_t)value & 0x01u) << gpio_idx;
    889a:	ea41 0000 	orr.w	r0, r1, r0
        GPIO->GPIO_OUT = gpio_setting;
    889e:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
    88a2:	4770      	bx	lr

000088a4 <MSS_GPIO_drive_inout>:
    uint32_t config;
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    88a4:	281f      	cmp	r0, #31
void MSS_GPIO_drive_inout
(
    mss_gpio_id_t port_id,
    mss_gpio_inout_state_t inout_state
)
{
    88a6:	b410      	push	{r4}
    uint32_t config;
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    88a8:	d81a      	bhi.n	88e0 <MSS_GPIO_drive_inout+0x3c>
    {
        switch(inout_state)
    88aa:	2901      	cmp	r1, #1
    88ac:	d028      	beq.n	8900 <MSS_GPIO_drive_inout+0x5c>
    88ae:	d219      	bcs.n	88e4 <MSS_GPIO_drive_inout+0x40>
            break;
                
            case MSS_GPIO_DRIVE_LOW:
                /* Set output low */
                outputs_state = GPIO->GPIO_OUT;
                outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
    88b0:	2301      	movs	r3, #1
    88b2:	fa03 fc00 	lsl.w	ip, r3, r0
                *(g_config_reg_lut[gpio_idx]) = config;
            break;
                
            case MSS_GPIO_DRIVE_LOW:
                /* Set output low */
                outputs_state = GPIO->GPIO_OUT;
    88b6:	f243 0300 	movw	r3, #12288	; 0x3000
    88ba:	f2c4 0301 	movt	r3, #16385	; 0x4001
                outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
                GPIO->GPIO_OUT = outputs_state;
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    88be:	f648 6298 	movw	r2, #36504	; 0x8e98
                *(g_config_reg_lut[gpio_idx]) = config;
            break;
                
            case MSS_GPIO_DRIVE_LOW:
                /* Set output low */
                outputs_state = GPIO->GPIO_OUT;
    88c2:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
                outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
                GPIO->GPIO_OUT = outputs_state;
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    88c6:	f2c0 0200 	movt	r2, #0
    88ca:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    88ce:	6a02      	ldr	r2, [r0, #32]
            break;
                
            case MSS_GPIO_DRIVE_LOW:
                /* Set output low */
                outputs_state = GPIO->GPIO_OUT;
                outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
    88d0:	ea21 010c 	bic.w	r1, r1, ip
                GPIO->GPIO_OUT = outputs_state;
    88d4:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    88d8:	6811      	ldr	r1, [r2, #0]
                config |= OUTPUT_BUFFER_ENABLE_MASK;
    88da:	f041 0004 	orr.w	r0, r1, #4
                *(g_config_reg_lut[gpio_idx]) = config;
    88de:	6010      	str	r0, [r2, #0]
            default:
                ASSERT(0);
            break;
        }
    }
}
    88e0:	bc10      	pop	{r4}
    88e2:	4770      	bx	lr
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    {
        switch(inout_state)
    88e4:	2902      	cmp	r1, #2
    88e6:	d1fb      	bne.n	88e0 <MSS_GPIO_drive_inout+0x3c>
                *(g_config_reg_lut[gpio_idx]) = config;
            break;
                
            case MSS_GPIO_HIGH_Z:
                /* Disable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    88e8:	f648 6c98 	movw	ip, #36504	; 0x8e98
    88ec:	f2c0 0c00 	movt	ip, #0
    88f0:	eb0c 0180 	add.w	r1, ip, r0, lsl #2
    88f4:	6a0b      	ldr	r3, [r1, #32]
    88f6:	6818      	ldr	r0, [r3, #0]
                config &= ~OUTPUT_BUFFER_ENABLE_MASK;
    88f8:	f020 0204 	bic.w	r2, r0, #4
                *(g_config_reg_lut[gpio_idx]) = config;
    88fc:	601a      	str	r2, [r3, #0]
    88fe:	e7ef      	b.n	88e0 <MSS_GPIO_drive_inout+0x3c>
        switch(inout_state)
        {
            case MSS_GPIO_DRIVE_HIGH:
                /* Set output high */
                outputs_state = GPIO->GPIO_OUT;
                outputs_state |= (uint32_t)1 << gpio_idx;
    8900:	4081      	lsls	r1, r0
    {
        switch(inout_state)
        {
            case MSS_GPIO_DRIVE_HIGH:
                /* Set output high */
                outputs_state = GPIO->GPIO_OUT;
    8902:	f243 0300 	movw	r3, #12288	; 0x3000
    8906:	f2c4 0301 	movt	r3, #16385	; 0x4001
                outputs_state |= (uint32_t)1 << gpio_idx;
                GPIO->GPIO_OUT = outputs_state;
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    890a:	f648 6298 	movw	r2, #36504	; 0x8e98
    {
        switch(inout_state)
        {
            case MSS_GPIO_DRIVE_HIGH:
                /* Set output high */
                outputs_state = GPIO->GPIO_OUT;
    890e:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
                outputs_state |= (uint32_t)1 << gpio_idx;
                GPIO->GPIO_OUT = outputs_state;
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    8912:	f2c0 0200 	movt	r2, #0
    8916:	eb02 0080 	add.w	r0, r2, r0, lsl #2
                /* Set output low */
                outputs_state = GPIO->GPIO_OUT;
                outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
                GPIO->GPIO_OUT = outputs_state;
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    891a:	6a02      	ldr	r2, [r0, #32]
        switch(inout_state)
        {
            case MSS_GPIO_DRIVE_HIGH:
                /* Set output high */
                outputs_state = GPIO->GPIO_OUT;
                outputs_state |= (uint32_t)1 << gpio_idx;
    891c:	4321      	orrs	r1, r4
                
            case MSS_GPIO_DRIVE_LOW:
                /* Set output low */
                outputs_state = GPIO->GPIO_OUT;
                outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
                GPIO->GPIO_OUT = outputs_state;
    891e:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
                /* Enable output buffer */
                config = *(g_config_reg_lut[gpio_idx]);
    8922:	6811      	ldr	r1, [r2, #0]
                config |= OUTPUT_BUFFER_ENABLE_MASK;
    8924:	f041 0004 	orr.w	r0, r1, #4
                *(g_config_reg_lut[gpio_idx]) = config;
    8928:	6010      	str	r0, [r2, #0]
    892a:	e7d9      	b.n	88e0 <MSS_GPIO_drive_inout+0x3c>

0000892c <MSS_GPIO_enable_irq>:
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    892c:	281f      	cmp	r0, #31
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
    892e:	b410      	push	{r4}
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    8930:	d819      	bhi.n	8966 <MSS_GPIO_enable_irq+0x3a>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    8932:	f648 6398 	movw	r3, #36504	; 0x8e98
    8936:	f2c0 0300 	movt	r3, #0
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
        NVIC_EnableIRQ(g_gpio_irqn_lut[gpio_idx]);
    893a:	f813 c000 	ldrb.w	ip, [r3, r0]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
    893e:	2401      	movs	r4, #1
    8940:	f00c 021f 	and.w	r2, ip, #31
    8944:	4094      	lsls	r4, r2
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    8946:	eb03 0180 	add.w	r1, r3, r0, lsl #2
    894a:	6a0a      	ldr	r2, [r1, #32]
    894c:	f24e 1300 	movw	r3, #57600	; 0xe100
    8950:	6810      	ldr	r0, [r2, #0]
    8952:	fa4f f18c 	sxtb.w	r1, ip
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
    8956:	f040 0008 	orr.w	r0, r0, #8
    895a:	0949      	lsrs	r1, r1, #5
    895c:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8960:	6010      	str	r0, [r2, #0]
    8962:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
        NVIC_EnableIRQ(g_gpio_irqn_lut[gpio_idx]);
    }
}
    8966:	bc10      	pop	{r4}
    8968:	4770      	bx	lr
    896a:	bf00      	nop

0000896c <MSS_GPIO_disable_irq>:
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);

    if(gpio_idx < NB_OF_GPIO)
    896c:	281f      	cmp	r0, #31
    896e:	d80a      	bhi.n	8986 <MSS_GPIO_disable_irq+0x1a>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
    8970:	f648 6c98 	movw	ip, #36504	; 0x8e98
    8974:	f2c0 0c00 	movt	ip, #0
    8978:	eb0c 0180 	add.w	r1, ip, r0, lsl #2
    897c:	6a0b      	ldr	r3, [r1, #32]
    897e:	6818      	ldr	r0, [r3, #0]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value & ~GPIO_INT_ENABLE_MASK);
    8980:	f020 0208 	bic.w	r2, r0, #8
    8984:	601a      	str	r2, [r3, #0]
    8986:	4770      	bx	lr

00008988 <MSS_GPIO_clear_irq>:
{
    uint32_t gpio_idx = (uint32_t)port_id;
    
    ASSERT(gpio_idx < NB_OF_GPIO);
    
    if(gpio_idx < NB_OF_GPIO)
    8988:	281f      	cmp	r0, #31
    898a:	d808      	bhi.n	899e <MSS_GPIO_clear_irq+0x16>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
    898c:	2101      	movs	r1, #1
    898e:	fa11 f000 	lsls.w	r0, r1, r0
    8992:	f243 0300 	movw	r3, #12288	; 0x3000
    8996:	f2c4 0301 	movt	r3, #16385	; 0x4001
    899a:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
    899e:	4770      	bx	lr

000089a0 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
    89a0:	f248 0300 	movw	r3, #32768	; 0x8000
    89a4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    89a8:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
    89ac:	b082      	sub	sp, #8
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;

    if(0u == controller_pll_init)
    89ae:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
    89b2:	d117      	bne.n	89e4 <SystemCoreClockUpdate+0x44>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
    89b4:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
        if(0u == global_mux_sel)
    89b8:	f410 5f80 	tst.w	r0, #4096	; 0x1000
    89bc:	d02d      	beq.n	8a1a <SystemCoreClockUpdate+0x7a>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
    89be:	f648 7138 	movw	r1, #36664	; 0x8f38
    89c2:	f2c0 0100 	movt	r1, #0
    89c6:	46ec      	mov	ip, sp
    89c8:	c903      	ldmia	r1!, {r0, r1}
    89ca:	e88c 0003 	stmia.w	ip, {r0, r1}

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
    89ce:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
            clock_source = standby_clock_lut[standby_sel];
            switch(clock_source)
    89d2:	a902      	add	r1, sp, #8
    89d4:	f3c2 1082 	ubfx	r0, r2, #6, #3
    89d8:	180a      	adds	r2, r1, r0
    89da:	f812 1c08 	ldrb.w	r1, [r2, #-8]
    89de:	2901      	cmp	r1, #1
    89e0:	d035      	beq.n	8a4e <SystemCoreClockUpdate+0xae>
    89e2:	d227      	bcs.n	8a34 <SystemCoreClockUpdate+0x94>
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
    89e4:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
    if(0u == rcosc_div2)
    89e8:	f647 0140 	movw	r1, #30784	; 0x7840
    89ec:	f24f 0280 	movw	r2, #61568	; 0xf080
    89f0:	f013 0f04 	tst.w	r3, #4
    89f4:	f2c0 117d 	movt	r1, #381	; 0x17d
    89f8:	f2c0 22fa 	movt	r2, #762	; 0x2fa
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    89fc:	f240 43bc 	movw	r3, #1212	; 0x4bc
{
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
    if(0u == rcosc_div2)
    8a00:	bf08      	it	eq
    8a02:	460a      	moveq	r2, r1
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a04:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_FrequencyPCLK0 = standby_clk;
    g_FrequencyPCLK1 = standby_clk;
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    g_FrequencyFIC0 = standby_clk;
    g_FrequencyFIC1 = standby_clk;
    g_FrequencyFIC64 = standby_clk;
    8a08:	619a      	str	r2, [r3, #24]
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    g_FrequencyPCLK0 = standby_clk;
    g_FrequencyPCLK1 = standby_clk;
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a0a:	60d9      	str	r1, [r3, #12]
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a0c:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
    8a0e:	605a      	str	r2, [r3, #4]
    g_FrequencyPCLK1 = standby_clk;
    8a10:	609a      	str	r2, [r3, #8]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    g_FrequencyFIC0 = standby_clk;
    8a12:	611a      	str	r2, [r3, #16]
    g_FrequencyFIC1 = standby_clk;
    8a14:	615a      	str	r2, [r3, #20]
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
        set_clock_frequency_globals(clk_src);
    }
}
    8a16:	b002      	add	sp, #8
    8a18:	4770      	bx	lr

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
        if(0u == global_mux_sel)
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
    8a1a:	f240 43bc 	movw	r3, #1212	; 0x4bc
    8a1e:	f24e 1200 	movw	r2, #57600	; 0xe100
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a22:	f647 0140 	movw	r1, #30784	; 0x7840

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
        if(0u == global_mux_sel)
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
    8a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a2a:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a2e:	f2c0 117d 	movt	r1, #381	; 0x17d
    8a32:	e7e9      	b.n	8a08 <SystemCoreClockUpdate+0x68>
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a34:	f240 43bc 	movw	r3, #1212	; 0x4bc
    8a38:	f244 2240 	movw	r2, #16960	; 0x4240
    g_FrequencyPCLK0 = standby_clk;
    g_FrequencyPCLK1 = standby_clk;
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a3c:	f647 0140 	movw	r1, #30784	; 0x7840
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a40:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8a44:	f2c0 020f 	movt	r2, #15
    g_FrequencyPCLK0 = standby_clk;
    g_FrequencyPCLK1 = standby_clk;
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a48:	f2c0 117d 	movt	r1, #381	; 0x17d
    8a4c:	e7dc      	b.n	8a08 <SystemCoreClockUpdate+0x68>
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a4e:	f240 43bc 	movw	r3, #1212	; 0x4bc
    g_FrequencyPCLK0 = standby_clk;
    g_FrequencyPCLK1 = standby_clk;
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a52:	f647 0140 	movw	r1, #30784	; 0x7840
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
    g_FrequencyPCLK0 = standby_clk;
    g_FrequencyPCLK1 = standby_clk;
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
    8a5a:	f2c0 117d 	movt	r1, #381	; 0x17d
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
    SystemCoreClock = standby_clk;
    8a5e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    8a62:	e7d1      	b.n	8a08 <SystemCoreClockUpdate+0x68>

00008a64 <SystemInit>:
static uint32_t get_silicon_revision(void)
{
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
    8a64:	f248 0300 	movw	r3, #32768	; 0x8000
    8a68:	f2c4 0303 	movt	r3, #16387	; 0x4003
    8a6c:	f8d3 114c 	ldr.w	r1, [r3, #332]	; 0x14c
    switch(device_version)
    8a70:	f64f 0202 	movw	r2, #63490	; 0xf802
    8a74:	4291      	cmp	r1, r2
    8a76:	d10b      	bne.n	8a90 <SystemInit+0x2c>
{
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
    8a78:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
    8a7c:	f440 7280 	orr.w	r2, r0, #256	; 0x100
    8a80:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
    8a84:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
    8a88:	f021 6080 	bic.w	r0, r1, #67108864	; 0x4000000
    8a8c:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    8a90:	f64e 5300 	movw	r3, #60672	; 0xed00
    8a94:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8a98:	695a      	ldr	r2, [r3, #20]
    8a9a:	f442 7100 	orr.w	r1, r2, #512	; 0x200
    8a9e:	6159      	str	r1, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
    8aa0:	f7f7 bcc8 	b.w	434 <mscc_post_hw_cfg_init>

00008aa4 <_close>:
 * Close a file.
 */
int _close(int file)
{
    return -1;
}
    8aa4:	f04f 30ff 	mov.w	r0, #4294967295
    8aa8:	4770      	bx	lr
    8aaa:	bf00      	nop

00008aac <_exit>:
    /* Should we force a system reset? */
    while( 1 )
    {
        ;
    }
}
    8aac:	e7fe      	b.n	8aac <_exit>
    8aae:	bf00      	nop

00008ab0 <_fstat>:
/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
    st->st_mode = S_IFCHR;
    8ab0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    8ab4:	604b      	str	r3, [r1, #4]
    return 0;
}
    8ab6:	2000      	movs	r0, #0
    8ab8:	4770      	bx	lr
    8aba:	bf00      	nop

00008abc <_getpid>:
 * Process-ID
 */
int _getpid(void)
{
    return 1;
}
    8abc:	2001      	movs	r0, #1
    8abe:	4770      	bx	lr

00008ac0 <_isatty>:
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
    return 1;
}
    8ac0:	2001      	movs	r0, #1
    8ac2:	4770      	bx	lr

00008ac4 <_lseek>:
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
    return 0;
}
    8ac4:	2000      	movs	r0, #0
    8ac6:	4770      	bx	lr

00008ac8 <_open>:
 * Open a file.
 */
int _open(const char *name, int flags, int mode)
{
    return -1;
}
    8ac8:	f04f 30ff 	mov.w	r0, #4294967295
    8acc:	4770      	bx	lr
    8ace:	bf00      	nop

00008ad0 <_read>:
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
    return 0;
}
    8ad0:	2000      	movs	r0, #0
    8ad2:	4770      	bx	lr

00008ad4 <_write_r>:
    
    return len;
#else   /* MICROSEMI_STDIO_THRU_UART */
    return 0;
#endif  /* MICROSEMI_STDIO_THRU_UART */
}
    8ad4:	2000      	movs	r0, #0
    8ad6:	4770      	bx	lr

00008ad8 <_sbrk>:
    extern char _end;       /* Defined by the linker */
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
    8ad8:	f640 3254 	movw	r2, #2900	; 0xb54
    8adc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8ae0:	6813      	ldr	r3, [r2, #0]
    {
      heap_end = &_end;
    8ae2:	f640 4170 	movw	r1, #3184	; 0xc70
    8ae6:	f2c2 0100 	movt	r1, #8192	; 0x2000
    8aea:	2b00      	cmp	r3, #0
    8aec:	bf08      	it	eq
    8aee:	460b      	moveq	r3, r1
 * it is useful to have a working implementation. The following suffices for a
 * standalone system; it exploits the symbol _end automatically defined by the
 * GNU linker. 
 */
caddr_t _sbrk(int incr)
{
    8af0:	4601      	mov	r1, r0
      heap_end = &_end;
    }
    
    prev_heap_end = heap_end;
    
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
    8af2:	f3ef 8008 	mrs	r0, MSP
    if(heap_end < stack_ptr)
    8af6:	4298      	cmp	r0, r3
    8af8:	d903      	bls.n	8b02 <_sbrk+0x2a>
        /*
         * Heap is at an address below the stack, growing up toward the stack.
         * The stack is above the heap, growing down towards the heap.
         * Make sure the stack and heap do not run into each other.
         */
        if (heap_end + incr > stack_ptr)
    8afa:	1859      	adds	r1, r3, r1
    8afc:	4288      	cmp	r0, r1
    8afe:	d207      	bcs.n	8b10 <_sbrk+0x38>
    8b00:	e7fe      	b.n	8b00 <_sbrk+0x28>
         * SmartFusion2 cache design.
         */
        extern char _eheap;     /* Defined by the linker */
        char *top_of_heap;
        
        top_of_heap = &_eheap;
    8b02:	f24f 0c00 	movw	ip, #61440	; 0xf000
        if(heap_end + incr  > top_of_heap)
    8b06:	1859      	adds	r1, r3, r1
         * SmartFusion2 cache design.
         */
        extern char _eheap;     /* Defined by the linker */
        char *top_of_heap;
        
        top_of_heap = &_eheap;
    8b08:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    8b0c:	4561      	cmp	r1, ip
    8b0e:	d802      	bhi.n	8b16 <_sbrk+0x3e>
          _write_r ((void *)0, 1, "Out of heap memory\n", 25);
          _exit (1);
        }
    }
  
    heap_end += incr;
    8b10:	6011      	str	r1, [r2, #0]
    return (caddr_t) prev_heap_end;
}
    8b12:	4618      	mov	r0, r3
    8b14:	4770      	bx	lr
    8b16:	e7fe      	b.n	8b16 <_sbrk+0x3e>

00008b18 <_stat>:
/*==============================================================================
 * Status of a file (by name).
 */
int _stat(char *file, struct stat *st)
{
    st->st_mode = S_IFCHR;
    8b18:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    8b1c:	604b      	str	r3, [r1, #4]
    return 0;
}
    8b1e:	2000      	movs	r0, #0
    8b20:	4770      	bx	lr
    8b22:	bf00      	nop

00008b24 <_times>:
 * Timing information for current process.
 */
int _times(struct tms *buf)
{
    return -1;
}
    8b24:	f04f 30ff 	mov.w	r0, #4294967295
    8b28:	4770      	bx	lr
    8b2a:	bf00      	nop

00008b2c <_wait>:

/*==============================================================================
 * Wait for a child process.
 */
int _wait(int *status)
{
    8b2c:	b508      	push	{r3, lr}
    errno = ECHILD;
    8b2e:	f000 f82d 	bl	8b8c <__errno>
    8b32:	230a      	movs	r3, #10
    8b34:	6003      	str	r3, [r0, #0]
    return -1;
}
    8b36:	f04f 30ff 	mov.w	r0, #4294967295
    8b3a:	bd08      	pop	{r3, pc}

00008b3c <_unlink>:

/*==============================================================================
 * Remove a file's directory entry.
 */
int _unlink(char *name)
{
    8b3c:	b508      	push	{r3, lr}
    errno = ENOENT;
    8b3e:	f000 f825 	bl	8b8c <__errno>
    8b42:	2302      	movs	r3, #2
    8b44:	6003      	str	r3, [r0, #0]
    return -1;
}
    8b46:	f04f 30ff 	mov.w	r0, #4294967295
    8b4a:	bd08      	pop	{r3, pc}

00008b4c <_link>:

/*==============================================================================
 * Establish a new name for an existing file.
 */
int _link(char *old, char *new)
{
    8b4c:	b508      	push	{r3, lr}
    errno = EMLINK;
    8b4e:	f000 f81d 	bl	8b8c <__errno>
    8b52:	231f      	movs	r3, #31
    8b54:	6003      	str	r3, [r0, #0]
    return -1;
}
    8b56:	f04f 30ff 	mov.w	r0, #4294967295
    8b5a:	bd08      	pop	{r3, pc}

00008b5c <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
    8b5c:	b508      	push	{r3, lr}
    errno = EINVAL;
    8b5e:	f000 f815 	bl	8b8c <__errno>
    8b62:	2316      	movs	r3, #22
    8b64:	6003      	str	r3, [r0, #0]
    return -1;
}
    8b66:	f04f 30ff 	mov.w	r0, #4294967295
    8b6a:	bd08      	pop	{r3, pc}

00008b6c <_fork>:

/*==============================================================================
 * Create a new process.
 */
int _fork(void)
{
    8b6c:	b508      	push	{r3, lr}
    errno = EAGAIN;
    8b6e:	f000 f80d 	bl	8b8c <__errno>
    8b72:	230b      	movs	r3, #11
    8b74:	6003      	str	r3, [r0, #0]
    return -1;
}
    8b76:	f04f 30ff 	mov.w	r0, #4294967295
    8b7a:	bd08      	pop	{r3, pc}

00008b7c <_execve>:

/*==============================================================================
 * Transfer control to a new process.
 */
int _execve(char *name, char **argv, char **env)
{
    8b7c:	b508      	push	{r3, lr}
    errno = ENOMEM;
    8b7e:	f000 f805 	bl	8b8c <__errno>
    8b82:	230c      	movs	r3, #12
    8b84:	6003      	str	r3, [r0, #0]
    return -1;
}
    8b86:	f04f 30ff 	mov.w	r0, #4294967295
    8b8a:	bd08      	pop	{r3, pc}

00008b8c <__errno>:
    8b8c:	f240 43dc 	movw	r3, #1244	; 0x4dc
    8b90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b94:	6818      	ldr	r0, [r3, #0]
    8b96:	4770      	bx	lr

00008b98 <__libc_init_array>:
    8b98:	b570      	push	{r4, r5, r6, lr}
    8b9a:	f648 765c 	movw	r6, #36700	; 0x8f5c
    8b9e:	f648 755c 	movw	r5, #36700	; 0x8f5c
    8ba2:	f2c0 0600 	movt	r6, #0
    8ba6:	f2c0 0500 	movt	r5, #0
    8baa:	1b76      	subs	r6, r6, r5
    8bac:	10b6      	asrs	r6, r6, #2
    8bae:	d006      	beq.n	8bbe <__libc_init_array+0x26>
    8bb0:	2400      	movs	r4, #0
    8bb2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    8bb6:	3401      	adds	r4, #1
    8bb8:	4798      	blx	r3
    8bba:	42a6      	cmp	r6, r4
    8bbc:	d8f9      	bhi.n	8bb2 <__libc_init_array+0x1a>
    8bbe:	f648 755c 	movw	r5, #36700	; 0x8f5c
    8bc2:	f648 7660 	movw	r6, #36704	; 0x8f60
    8bc6:	f2c0 0500 	movt	r5, #0
    8bca:	f2c0 0600 	movt	r6, #0
    8bce:	1b76      	subs	r6, r6, r5
    8bd0:	f000 f9b8 	bl	8f44 <_init>
    8bd4:	10b6      	asrs	r6, r6, #2
    8bd6:	d006      	beq.n	8be6 <__libc_init_array+0x4e>
    8bd8:	2400      	movs	r4, #0
    8bda:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    8bde:	3401      	adds	r4, #1
    8be0:	4798      	blx	r3
    8be2:	42a6      	cmp	r6, r4
    8be4:	d8f9      	bhi.n	8bda <__libc_init_array+0x42>
    8be6:	bd70      	pop	{r4, r5, r6, pc}

00008be8 <memcpy>:
    8be8:	2a03      	cmp	r2, #3
    8bea:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
    8bee:	d80b      	bhi.n	8c08 <memcpy+0x20>
    8bf0:	b13a      	cbz	r2, 8c02 <memcpy+0x1a>
    8bf2:	2300      	movs	r3, #0
    8bf4:	f811 c003 	ldrb.w	ip, [r1, r3]
    8bf8:	f800 c003 	strb.w	ip, [r0, r3]
    8bfc:	3301      	adds	r3, #1
    8bfe:	4293      	cmp	r3, r2
    8c00:	d1f8      	bne.n	8bf4 <memcpy+0xc>
    8c02:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
    8c06:	4770      	bx	lr
    8c08:	1882      	adds	r2, r0, r2
    8c0a:	460c      	mov	r4, r1
    8c0c:	4603      	mov	r3, r0
    8c0e:	e003      	b.n	8c18 <memcpy+0x30>
    8c10:	f814 1c01 	ldrb.w	r1, [r4, #-1]
    8c14:	f803 1c01 	strb.w	r1, [r3, #-1]
    8c18:	f003 0603 	and.w	r6, r3, #3
    8c1c:	4619      	mov	r1, r3
    8c1e:	46a4      	mov	ip, r4
    8c20:	3301      	adds	r3, #1
    8c22:	3401      	adds	r4, #1
    8c24:	2e00      	cmp	r6, #0
    8c26:	d1f3      	bne.n	8c10 <memcpy+0x28>
    8c28:	f01c 0403 	ands.w	r4, ip, #3
    8c2c:	4663      	mov	r3, ip
    8c2e:	bf08      	it	eq
    8c30:	ebc1 0c02 	rsbeq	ip, r1, r2
    8c34:	d068      	beq.n	8d08 <memcpy+0x120>
    8c36:	4265      	negs	r5, r4
    8c38:	f1c4 0a04 	rsb	sl, r4, #4
    8c3c:	eb0c 0705 	add.w	r7, ip, r5
    8c40:	4633      	mov	r3, r6
    8c42:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    8c46:	f85c 6005 	ldr.w	r6, [ip, r5]
    8c4a:	ea4f 08c4 	mov.w	r8, r4, lsl #3
    8c4e:	1a55      	subs	r5, r2, r1
    8c50:	e008      	b.n	8c64 <memcpy+0x7c>
    8c52:	f857 4f04 	ldr.w	r4, [r7, #4]!
    8c56:	4626      	mov	r6, r4
    8c58:	fa04 f40a 	lsl.w	r4, r4, sl
    8c5c:	ea49 0404 	orr.w	r4, r9, r4
    8c60:	50cc      	str	r4, [r1, r3]
    8c62:	3304      	adds	r3, #4
    8c64:	185c      	adds	r4, r3, r1
    8c66:	2d03      	cmp	r5, #3
    8c68:	fa26 f908 	lsr.w	r9, r6, r8
    8c6c:	f1a5 0504 	sub.w	r5, r5, #4
    8c70:	eb0c 0603 	add.w	r6, ip, r3
    8c74:	dced      	bgt.n	8c52 <memcpy+0x6a>
    8c76:	2300      	movs	r3, #0
    8c78:	e002      	b.n	8c80 <memcpy+0x98>
    8c7a:	5cf1      	ldrb	r1, [r6, r3]
    8c7c:	54e1      	strb	r1, [r4, r3]
    8c7e:	3301      	adds	r3, #1
    8c80:	1919      	adds	r1, r3, r4
    8c82:	4291      	cmp	r1, r2
    8c84:	d3f9      	bcc.n	8c7a <memcpy+0x92>
    8c86:	e7bc      	b.n	8c02 <memcpy+0x1a>
    8c88:	f853 4c40 	ldr.w	r4, [r3, #-64]
    8c8c:	f841 4c40 	str.w	r4, [r1, #-64]
    8c90:	f853 4c3c 	ldr.w	r4, [r3, #-60]
    8c94:	f841 4c3c 	str.w	r4, [r1, #-60]
    8c98:	f853 4c38 	ldr.w	r4, [r3, #-56]
    8c9c:	f841 4c38 	str.w	r4, [r1, #-56]
    8ca0:	f853 4c34 	ldr.w	r4, [r3, #-52]
    8ca4:	f841 4c34 	str.w	r4, [r1, #-52]
    8ca8:	f853 4c30 	ldr.w	r4, [r3, #-48]
    8cac:	f841 4c30 	str.w	r4, [r1, #-48]
    8cb0:	f853 4c2c 	ldr.w	r4, [r3, #-44]
    8cb4:	f841 4c2c 	str.w	r4, [r1, #-44]
    8cb8:	f853 4c28 	ldr.w	r4, [r3, #-40]
    8cbc:	f841 4c28 	str.w	r4, [r1, #-40]
    8cc0:	f853 4c24 	ldr.w	r4, [r3, #-36]
    8cc4:	f841 4c24 	str.w	r4, [r1, #-36]
    8cc8:	f853 4c20 	ldr.w	r4, [r3, #-32]
    8ccc:	f841 4c20 	str.w	r4, [r1, #-32]
    8cd0:	f853 4c1c 	ldr.w	r4, [r3, #-28]
    8cd4:	f841 4c1c 	str.w	r4, [r1, #-28]
    8cd8:	f853 4c18 	ldr.w	r4, [r3, #-24]
    8cdc:	f841 4c18 	str.w	r4, [r1, #-24]
    8ce0:	f853 4c14 	ldr.w	r4, [r3, #-20]
    8ce4:	f841 4c14 	str.w	r4, [r1, #-20]
    8ce8:	f853 4c10 	ldr.w	r4, [r3, #-16]
    8cec:	f841 4c10 	str.w	r4, [r1, #-16]
    8cf0:	f853 4c0c 	ldr.w	r4, [r3, #-12]
    8cf4:	f841 4c0c 	str.w	r4, [r1, #-12]
    8cf8:	f853 4c08 	ldr.w	r4, [r3, #-8]
    8cfc:	f841 4c08 	str.w	r4, [r1, #-8]
    8d00:	f853 4c04 	ldr.w	r4, [r3, #-4]
    8d04:	f841 4c04 	str.w	r4, [r1, #-4]
    8d08:	461c      	mov	r4, r3
    8d0a:	460d      	mov	r5, r1
    8d0c:	3340      	adds	r3, #64	; 0x40
    8d0e:	3140      	adds	r1, #64	; 0x40
    8d10:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
    8d14:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
    8d18:	dcb6      	bgt.n	8c88 <memcpy+0xa0>
    8d1a:	4621      	mov	r1, r4
    8d1c:	462b      	mov	r3, r5
    8d1e:	1b54      	subs	r4, r2, r5
    8d20:	e00f      	b.n	8d42 <memcpy+0x15a>
    8d22:	f851 5c10 	ldr.w	r5, [r1, #-16]
    8d26:	f843 5c10 	str.w	r5, [r3, #-16]
    8d2a:	f851 5c0c 	ldr.w	r5, [r1, #-12]
    8d2e:	f843 5c0c 	str.w	r5, [r3, #-12]
    8d32:	f851 5c08 	ldr.w	r5, [r1, #-8]
    8d36:	f843 5c08 	str.w	r5, [r3, #-8]
    8d3a:	f851 5c04 	ldr.w	r5, [r1, #-4]
    8d3e:	f843 5c04 	str.w	r5, [r3, #-4]
    8d42:	2c0f      	cmp	r4, #15
    8d44:	460d      	mov	r5, r1
    8d46:	469c      	mov	ip, r3
    8d48:	f101 0110 	add.w	r1, r1, #16
    8d4c:	f103 0310 	add.w	r3, r3, #16
    8d50:	f1a4 0410 	sub.w	r4, r4, #16
    8d54:	dce5      	bgt.n	8d22 <memcpy+0x13a>
    8d56:	ebcc 0102 	rsb	r1, ip, r2
    8d5a:	2300      	movs	r3, #0
    8d5c:	e003      	b.n	8d66 <memcpy+0x17e>
    8d5e:	58ec      	ldr	r4, [r5, r3]
    8d60:	f84c 4003 	str.w	r4, [ip, r3]
    8d64:	3304      	adds	r3, #4
    8d66:	195e      	adds	r6, r3, r5
    8d68:	2903      	cmp	r1, #3
    8d6a:	eb03 040c 	add.w	r4, r3, ip
    8d6e:	f1a1 0104 	sub.w	r1, r1, #4
    8d72:	dcf4      	bgt.n	8d5e <memcpy+0x176>
    8d74:	e77f      	b.n	8c76 <memcpy+0x8e>
    8d76:	bf00      	nop
    8d78:	7263694d 	.word	0x7263694d
    8d7c:	6d65736f 	.word	0x6d65736f
    8d80:	6e492069 	.word	0x6e492069
    8d84:	00000063 	.word	0x00000063
    8d88:	72616d53 	.word	0x72616d53
    8d8c:	73754674 	.word	0x73754674
    8d90:	326e6f69 	.word	0x326e6f69
    8d94:	4344432d 	.word	0x4344432d
    8d98:	5043562d 	.word	0x5043562d
    8d9c:	00000000 	.word	0x00000000
    8da0:	31504356 	.word	0x31504356
    8da4:	00343332 	.word	0x00343332
    8da8:	2d474643 	.word	0x2d474643
    8dac:	00005348 	.word	0x00005348
    8db0:	65746e49 	.word	0x65746e49
    8db4:	63616672 	.word	0x63616672
    8db8:	44432d65 	.word	0x44432d65
    8dbc:	00000043 	.word	0x00000043

00008dc0 <C.72.4969>:
	...
    8dc8:	aaaaaa00 aaaaaaaa eeeeeeaa eeeeeeee     ................
    8dd8:	fffffeee ffffffff ffffffff dfbf7fff     ................
    8de8:	fdfbf7ef dfbf7efc fdfbf7ef 0000007e     .....~......~...

00008df8 <CSWTCH.86>:
    8df8:	00010101                                ....

00008dfc <CSWTCH.87>:
    8dfc:	02000400 00000400                       ........

00008e04 <CSWTCH.90>:
    8e04:	00010101                                ....

00008e08 <CSWTCH.91>:
    8e08:	004003ff 00000040                       ..@.@...

00008e10 <CSWTCH.94>:
    8e10:	00010101                                ....

00008e14 <CSWTCH.95>:
    8e14:	02000400 00000400                       ........

00008e1c <CSWTCH.98>:
    8e1c:	00010101                                ....

00008e20 <CSWTCH.99>:
    8e20:	004003ff 00000040                       ..@.@...

00008e28 <C.101.4585>:
    8e28:	22ca87aa 37058bbe 1ec7b18e 74ad20f3     ..."...7..... .t
    8e38:	623b1d6e 989ba78b e041f759 382a5482     n.;b....Y.A..T*8
    8e48:	5df20255 6c2955bf 385e543a b70a7672     U..].U)l:T^8rv..
    8e58:	4ade1736 6f2c2696 bf989e5d 29dc9292     6..J.&,o]......)
    8e68:	bd1df4f8 7c149a28 1331dae9 c0b8f0b5     ....(..|..1.....
    8e78:	ceb1600a 9d817e1d 7c1d437a 5f0eea90     .`...~..zC.|..._

00008e88 <g_nvm>:
    8e88:	60080000 600c0000                       ...`...`

00008e90 <g_nvm32>:
    8e90:	60080000 600c0000                       ...`...`

00008e98 <g_gpio_irqn_lut>:
    8e98:	35343332 39383736 3d3c3b3a 41403f3e     23456789:;<=>?@A
    8ea8:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ

00008eb8 <g_config_reg_lut>:
    8eb8:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
    8ec8:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
    8ed8:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
    8ee8:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
    8ef8:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
    8f08:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
    8f18:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
    8f28:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

00008f38 <C.16.3514>:
    8f38:	01000100 03030202                       ........

00008f40 <_global_impure_ptr>:
    8f40:	200004e0                                ... 

00008f44 <_init>:
    8f44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8f46:	bf00      	nop
    8f48:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8f4a:	bc08      	pop	{r3}
    8f4c:	469e      	mov	lr, r3
    8f4e:	4770      	bx	lr

00008f50 <_fini>:
    8f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8f52:	bf00      	nop
    8f54:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8f56:	bc08      	pop	{r3}
    8f58:	469e      	mov	lr, r3
    8f5a:	4770      	bx	lr

00008f5c <__frame_dummy_init_array_entry>:
    8f5c:	04d5 0000                                   ....

00008f60 <__do_global_dtors_aux_fini_array_entry>:
    8f60:	04c1 0000 0000 0000 0000 0000 0000 0000     ................
