
M2S010_I2C_UART_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  20000000  20000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000330  20000190  20000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00002200  200004c0  200004c0  000084c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000030  200026c0  200026c0  0000a6c0  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000001b0  200026f0  200026f0  0000a6f0  2**4
                  ALLOC
  5 .heap         0000c760  200028a0  200028a0  0000a6f0  2**4
                  ALLOC
  6 .stack        00001000  2000f000  2000f000  0000a6f0  2**4
                  ALLOC
  7 .comment      000000d7  00000000  00000000  0000a6f0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000450  00000000  00000000  0000a7c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000ae8  00000000  00000000  0000ac17  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00005c77  00000000  00000000  0000b6ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000009da  00000000  00000000  00011376  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00001df0  00000000  00000000  00011d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000f40  00000000  00000000  00013b40  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00002642  00000000  00000000  00014a80  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001a01  00000000  00000000  000170c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 00026958  00000000  00000000  00018ac3  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  0003f41b  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00000440  00000000  00000000  0003f440  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .vector_table:

20000000 <__vector_table_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000191 	.word	0x20000191
20000008:	2000037f 	.word	0x2000037f
2000000c:	20000381 	.word	0x20000381
20000010:	20000383 	.word	0x20000383
20000014:	20000385 	.word	0x20000385
20000018:	20000387 	.word	0x20000387
	...
2000002c:	20000389 	.word	0x20000389
20000030:	2000038b 	.word	0x2000038b
20000034:	00000000 	.word	0x00000000
20000038:	2000038d 	.word	0x2000038d
2000003c:	2000038f 	.word	0x2000038f
20000040:	20000391 	.word	0x20000391
20000044:	20000393 	.word	0x20000393
20000048:	20000395 	.word	0x20000395
2000004c:	20000397 	.word	0x20000397
20000050:	20002249 	.word	0x20002249
20000054:	2000039b 	.word	0x2000039b
20000058:	2000039d 	.word	0x2000039d
2000005c:	2000226d 	.word	0x2000226d
20000060:	200003a1 	.word	0x200003a1
20000064:	200003a3 	.word	0x200003a3
20000068:	20000cd1 	.word	0x20000cd1
2000006c:	20000cf5 	.word	0x20000cf5
20000070:	200003a9 	.word	0x200003a9
20000074:	200003ab 	.word	0x200003ab
20000078:	200003ad 	.word	0x200003ad
2000007c:	200003af 	.word	0x200003af
20000080:	200003b1 	.word	0x200003b1
20000084:	200003b3 	.word	0x200003b3
20000088:	200003b5 	.word	0x200003b5
2000008c:	200003b7 	.word	0x200003b7
20000090:	200003b9 	.word	0x200003b9
20000094:	200003bb 	.word	0x200003bb
20000098:	200003bd 	.word	0x200003bd
2000009c:	200003bf 	.word	0x200003bf
200000a0:	200003c1 	.word	0x200003c1
200000a4:	200003c3 	.word	0x200003c3
200000a8:	200003c5 	.word	0x200003c5
200000ac:	200003c7 	.word	0x200003c7
200000b0:	200003c9 	.word	0x200003c9
200000b4:	200003cb 	.word	0x200003cb
200000b8:	200003cd 	.word	0x200003cd
200000bc:	200003cf 	.word	0x200003cf
200000c0:	200003d1 	.word	0x200003d1
200000c4:	200003d3 	.word	0x200003d3
200000c8:	200003d5 	.word	0x200003d5
200000cc:	200003d7 	.word	0x200003d7
200000d0:	200003d9 	.word	0x200003d9
200000d4:	200003db 	.word	0x200003db
200000d8:	200003dd 	.word	0x200003dd
200000dc:	200003df 	.word	0x200003df
200000e0:	200003e1 	.word	0x200003e1
200000e4:	200003e3 	.word	0x200003e3
200000e8:	200003e5 	.word	0x200003e5
200000ec:	200003e7 	.word	0x200003e7
200000f0:	200003e9 	.word	0x200003e9
200000f4:	200003eb 	.word	0x200003eb
200000f8:	200003ed 	.word	0x200003ed
200000fc:	200003ef 	.word	0x200003ef
20000100:	200003f1 	.word	0x200003f1
20000104:	200003f3 	.word	0x200003f3
20000108:	200003f5 	.word	0x200003f5
2000010c:	200003f7 	.word	0x200003f7
20000110:	200003f9 	.word	0x200003f9
20000114:	200003fb 	.word	0x200003fb
20000118:	200003fd 	.word	0x200003fd
2000011c:	200003ff 	.word	0x200003ff
20000120:	20000401 	.word	0x20000401
20000124:	20000403 	.word	0x20000403
20000128:	20000405 	.word	0x20000405
2000012c:	20000407 	.word	0x20000407
20000130:	20000409 	.word	0x20000409
20000134:	2000040b 	.word	0x2000040b
20000138:	2000040d 	.word	0x2000040d
2000013c:	2000040f 	.word	0x2000040f
20000140:	20000411 	.word	0x20000411
20000144:	20000413 	.word	0x20000413
20000148:	20000415 	.word	0x20000415
2000014c:	20000417 	.word	0x20000417
20000150:	20000419 	.word	0x20000419
20000154:	2000041b 	.word	0x2000041b
20000158:	2000041d 	.word	0x2000041d
2000015c:	2000041f 	.word	0x2000041f
20000160:	20000421 	.word	0x20000421
20000164:	20000423 	.word	0x20000423
20000168:	20000425 	.word	0x20000425
2000016c:	20000427 	.word	0x20000427
20000170:	20000429 	.word	0x20000429
20000174:	2000042b 	.word	0x2000042b
20000178:	2000042d 	.word	0x2000042d
2000017c:	2000042f 	.word	0x2000042f
20000180:	20000431 	.word	0x20000431
20000184:	20000433 	.word	0x20000433
	...

Disassembly of section .boot_code:

20000190 <Reset_Handler>:
20000190:	f04f 0b00 	mov.w	fp, #0
20000194:	f8df 02be 	ldr.w	r0, [pc, #702]	; 20000456 <SF2_MDDR_MODE_CR>
20000198:	6800      	ldr	r0, [r0, #0]
2000019a:	f8df 12b6 	ldr.w	r1, [pc, #694]	; 20000452 <SF2_EDAC_CR>
2000019e:	6809      	ldr	r1, [r1, #0]
200001a0:	f001 0103 	and.w	r1, r1, #3
200001a4:	f000 001c 	and.w	r0, r0, #28
200001a8:	2814      	cmp	r0, #20
200001aa:	d101      	bne.n	200001b0 <check_esram_edac>
200001ac:	f04b 0b02 	orr.w	fp, fp, #2

200001b0 <check_esram_edac>:
200001b0:	2900      	cmp	r1, #0
200001b2:	d001      	beq.n	200001b8 <check_stack_init>
200001b4:	f04b 0b01 	orr.w	fp, fp, #1

200001b8 <check_stack_init>:
200001b8:	f1bb 0f00 	cmp.w	fp, #0
200001bc:	d005      	beq.n	200001ca <system_init>

200001be <clear_stack>:
200001be:	48a7      	ldr	r0, [pc, #668]	; (2000045c <SF2_MDDR_MODE_CR+0x6>)
200001c0:	49a7      	ldr	r1, [pc, #668]	; (20000460 <SF2_MDDR_MODE_CR+0xa>)
200001c2:	f8df 2272 	ldr.w	r2, [pc, #626]	; 20000436 <RAM_INIT_PATTERN>
200001c6:	f000 f89f 	bl	20000308 <fill_memory>

200001ca <system_init>:
200001ca:	48a6      	ldr	r0, [pc, #664]	; (20000464 <SF2_MDDR_MODE_CR+0xe>)
200001cc:	4780      	blx	r0
200001ce:	f00b 0a02 	and.w	sl, fp, #2
200001d2:	f1ba 0f00 	cmp.w	sl, #0
200001d6:	d00c      	beq.n	200001f2 <remap_memory>
200001d8:	f8df 026e 	ldr.w	r0, [pc, #622]	; 2000044a <SF2_DDRB_NB_SIZE>
200001dc:	f8df 126e 	ldr.w	r1, [pc, #622]	; 2000044e <SF2_DDRB_CR>
200001e0:	6802      	ldr	r2, [r0, #0]
200001e2:	680b      	ldr	r3, [r1, #0]
200001e4:	b40f      	push	{r0, r1, r2, r3}
200001e6:	f04f 0200 	mov.w	r2, #0
200001ea:	f04f 03ff 	mov.w	r3, #255	; 0xff
200001ee:	6002      	str	r2, [r0, #0]
200001f0:	600b      	str	r3, [r1, #0]

200001f2 <remap_memory>:
200001f2:	489d      	ldr	r0, [pc, #628]	; (20000468 <SF2_MDDR_MODE_CR+0x12>)
200001f4:	4a9d      	ldr	r2, [pc, #628]	; (2000046c <SF2_MDDR_MODE_CR+0x16>)
200001f6:	4b9e      	ldr	r3, [pc, #632]	; (20000470 <SF2_MDDR_MODE_CR+0x1a>)
200001f8:	2802      	cmp	r0, #2
200001fa:	d108      	bne.n	2000020e <check_esram_remap>
200001fc:	f8df 123e 	ldr.w	r1, [pc, #574]	; 2000043e <SF2_ESRAM_CR>
20000200:	600a      	str	r2, [r1, #0]
20000202:	f8df 1242 	ldr.w	r1, [pc, #578]	; 20000446 <SF2_ENVM_REMAP_CR>
20000206:	600a      	str	r2, [r1, #0]
20000208:	f8df 1236 	ldr.w	r1, [pc, #566]	; 20000442 <SF2_DDR_CR>
2000020c:	600b      	str	r3, [r1, #0]

2000020e <check_esram_remap>:
2000020e:	2801      	cmp	r0, #1
20000210:	d108      	bne.n	20000224 <check_mirrored_nvm>
20000212:	f8df 122e 	ldr.w	r1, [pc, #558]	; 20000442 <SF2_DDR_CR>
20000216:	600a      	str	r2, [r1, #0]
20000218:	f8df 122a 	ldr.w	r1, [pc, #554]	; 20000446 <SF2_ENVM_REMAP_CR>
2000021c:	600a      	str	r2, [r1, #0]
2000021e:	f8df 121e 	ldr.w	r1, [pc, #542]	; 2000043e <SF2_ESRAM_CR>
20000222:	600b      	str	r3, [r1, #0]

20000224 <check_mirrored_nvm>:
20000224:	4893      	ldr	r0, [pc, #588]	; (20000474 <SF2_MDDR_MODE_CR+0x1e>)
20000226:	2800      	cmp	r0, #0
20000228:	d109      	bne.n	2000023e <copy_data>
2000022a:	4893      	ldr	r0, [pc, #588]	; (20000478 <SF2_MDDR_MODE_CR+0x22>)
2000022c:	4993      	ldr	r1, [pc, #588]	; (2000047c <SF2_MDDR_MODE_CR+0x26>)
2000022e:	4a94      	ldr	r2, [pc, #592]	; (20000480 <SF2_MDDR_MODE_CR+0x2a>)
20000230:	f000 f832 	bl	20000298 <block_copy>

20000234 <copy_text>:
20000234:	4893      	ldr	r0, [pc, #588]	; (20000484 <SF2_MDDR_MODE_CR+0x2e>)
20000236:	4994      	ldr	r1, [pc, #592]	; (20000488 <SF2_MDDR_MODE_CR+0x32>)
20000238:	4a94      	ldr	r2, [pc, #592]	; (2000048c <SF2_MDDR_MODE_CR+0x36>)
2000023a:	f000 f82d 	bl	20000298 <block_copy>

2000023e <copy_data>:
2000023e:	4894      	ldr	r0, [pc, #592]	; (20000490 <SF2_MDDR_MODE_CR+0x3a>)
20000240:	4994      	ldr	r1, [pc, #592]	; (20000494 <SF2_MDDR_MODE_CR+0x3e>)
20000242:	4a95      	ldr	r2, [pc, #596]	; (20000498 <SF2_MDDR_MODE_CR+0x42>)
20000244:	f000 f828 	bl	20000298 <block_copy>

20000248 <clear_bss>:
20000248:	4894      	ldr	r0, [pc, #592]	; (2000049c <SF2_MDDR_MODE_CR+0x46>)
2000024a:	4995      	ldr	r1, [pc, #596]	; (200004a0 <SF2_MDDR_MODE_CR+0x4a>)
2000024c:	f8df 21e6 	ldr.w	r2, [pc, #486]	; 20000436 <RAM_INIT_PATTERN>
20000250:	f000 f85a 	bl	20000308 <fill_memory>

20000254 <clear_heap>:
20000254:	f1bb 0f00 	cmp.w	fp, #0
20000258:	d012      	beq.n	20000280 <call_glob_ctor>
2000025a:	4892      	ldr	r0, [pc, #584]	; (200004a4 <SF2_MDDR_MODE_CR+0x4e>)
2000025c:	4992      	ldr	r1, [pc, #584]	; (200004a8 <SF2_MDDR_MODE_CR+0x52>)
2000025e:	f8df 21da 	ldr.w	r2, [pc, #474]	; 2000043a <HEAP_INIT_PATTERN>
20000262:	f000 f851 	bl	20000308 <fill_memory>
20000266:	f00b 0a02 	and.w	sl, fp, #2
2000026a:	f1ba 0f00 	cmp.w	sl, #0
2000026e:	d007      	beq.n	20000280 <call_glob_ctor>
20000270:	bc0f      	pop	{r0, r1, r2, r3}
20000272:	6002      	str	r2, [r0, #0]
20000274:	600b      	str	r3, [r1, #0]
20000276:	bf00      	nop
20000278:	f3af 8000 	nop.w
2000027c:	f3af 8000 	nop.w

20000280 <call_glob_ctor>:
20000280:	f8df 0228 	ldr.w	r0, [pc, #552]	; 200004ac <SF2_MDDR_MODE_CR+0x56>
20000284:	f20f 0e03 	addw	lr, pc, #3
20000288:	4700      	bx	r0

2000028a <branch_to_main>:
2000028a:	f04f 0000 	mov.w	r0, #0
2000028e:	f04f 0100 	mov.w	r1, #0
20000292:	f8df f21c 	ldr.w	pc, [pc, #540]	; 200004b0 <SF2_MDDR_MODE_CR+0x5a>

20000296 <ExitLoop>:
20000296:	e7fe      	b.n	20000296 <ExitLoop>

20000298 <block_copy>:
20000298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
2000029c:	4288      	cmp	r0, r1
2000029e:	d025      	beq.n	200002ec <block_copy_exit>
200002a0:	ebb2 0201 	subs.w	r2, r2, r1
200002a4:	d500      	bpl.n	200002a8 <block_copy_address_ok>
200002a6:	e7fe      	b.n	200002a6 <block_copy+0xe>

200002a8 <block_copy_address_ok>:
200002a8:	ea40 0301 	orr.w	r3, r0, r1
200002ac:	f013 0303 	ands.w	r3, r3, #3
200002b0:	d002      	beq.n	200002b8 <block_copy_continue>

200002b2 <block_copy_byte_copy>:
200002b2:	f000 f81d 	bl	200002f0 <block_copy_byte>
200002b6:	e019      	b.n	200002ec <block_copy_exit>

200002b8 <block_copy_continue>:
200002b8:	f04f 0300 	mov.w	r3, #0
200002bc:	4690      	mov	r8, r2
200002be:	1112      	asrs	r2, r2, #4
200002c0:	d0f7      	beq.n	200002b2 <block_copy_byte_copy>

200002c2 <block_copy_loop>:
200002c2:	429a      	cmp	r2, r3
200002c4:	bf1c      	itt	ne
200002c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
200002c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
200002ca:	f103 0301 	add.w	r3, r3, #1
200002ce:	d1f8      	bne.n	200002c2 <block_copy_loop>
200002d0:	f008 080f 	and.w	r8, r8, #15
200002d4:	f1b8 0f00 	cmp.w	r8, #0
200002d8:	d008      	beq.n	200002ec <block_copy_exit>

200002da <copy_spare_bytes>:
200002da:	7804      	ldrb	r4, [r0, #0]
200002dc:	700c      	strb	r4, [r1, #0]
200002de:	f100 0001 	add.w	r0, r0, #1
200002e2:	f101 0101 	add.w	r1, r1, #1
200002e6:	f1b8 0801 	subs.w	r8, r8, #1
200002ea:	d1f6      	bne.n	200002da <copy_spare_bytes>

200002ec <block_copy_exit>:
200002ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

200002f0 <block_copy_byte>:
200002f0:	b508      	push	{r3, lr}
200002f2:	f04f 0300 	mov.w	r3, #0

200002f6 <block_copy_byte_loop>:
200002f6:	7803      	ldrb	r3, [r0, #0]
200002f8:	700b      	strb	r3, [r1, #0]
200002fa:	f100 0001 	add.w	r0, r0, #1
200002fe:	f101 0101 	add.w	r1, r1, #1
20000302:	3a01      	subs	r2, #1
20000304:	d1f7      	bne.n	200002f6 <block_copy_byte_loop>
20000306:	bd08      	pop	{r3, pc}

20000308 <fill_memory>:
20000308:	4288      	cmp	r0, r1
2000030a:	d037      	beq.n	2000037c <fill_memory_exit>
2000030c:	f000 0603 	and.w	r6, r0, #3
20000310:	2e00      	cmp	r6, #0
20000312:	d014      	beq.n	2000033e <fill_memory_end_start>
20000314:	f04f 0504 	mov.w	r5, #4
20000318:	eba5 0406 	sub.w	r4, r5, r6
2000031c:	f04f 0708 	mov.w	r7, #8
20000320:	fb07 f806 	mul.w	r8, r7, r6
20000324:	4691      	mov	r9, r2
20000326:	fa69 f908 	ror.w	r9, r9, r8

2000032a <fill_memory_spare_bytes_start>:
2000032a:	2c00      	cmp	r4, #0
2000032c:	d007      	beq.n	2000033e <fill_memory_end_start>
2000032e:	f880 9000 	strb.w	r9, [r0]
20000332:	fa69 f907 	ror.w	r9, r9, r7
20000336:	f100 0001 	add.w	r0, r0, #1
2000033a:	3c01      	subs	r4, #1
2000033c:	e7f5      	b.n	2000032a <fill_memory_spare_bytes_start>

2000033e <fill_memory_end_start>:
2000033e:	f04f 0600 	mov.w	r6, #0
20000342:	460f      	mov	r7, r1
20000344:	1a09      	subs	r1, r1, r0
20000346:	4688      	mov	r8, r1
20000348:	1109      	asrs	r1, r1, #4
2000034a:	4691      	mov	r9, r2
2000034c:	4614      	mov	r4, r2
2000034e:	4615      	mov	r5, r2
20000350:	42b1      	cmp	r1, r6
20000352:	d006      	beq.n	20000362 <fill_memory_spare_bytes_end>

20000354 <fill_memory_loop>:
20000354:	bf18      	it	ne
20000356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
2000035a:	f106 0601 	add.w	r6, r6, #1
2000035e:	42b1      	cmp	r1, r6
20000360:	d1f8      	bne.n	20000354 <fill_memory_loop>

20000362 <fill_memory_spare_bytes_end>:
20000362:	f008 080f 	and.w	r8, r8, #15

20000366 <fill_memory_spare_end_loop>:
20000366:	f1b8 0f00 	cmp.w	r8, #0
2000036a:	d007      	beq.n	2000037c <fill_memory_exit>
2000036c:	7002      	strb	r2, [r0, #0]
2000036e:	ea4f 2232 	mov.w	r2, r2, ror #8
20000372:	f100 0001 	add.w	r0, r0, #1
20000376:	f1b8 0801 	subs.w	r8, r8, #1
2000037a:	e7f4      	b.n	20000366 <fill_memory_spare_end_loop>

2000037c <fill_memory_exit>:
2000037c:	4770      	bx	lr

2000037e <NMI_Handler>:
2000037e:	e7fe      	b.n	2000037e <NMI_Handler>

20000380 <HardFault_Handler>:
20000380:	e7fe      	b.n	20000380 <HardFault_Handler>

20000382 <MemManage_Handler>:
20000382:	e7fe      	b.n	20000382 <MemManage_Handler>

20000384 <BusFault_Handler>:
20000384:	e7fe      	b.n	20000384 <BusFault_Handler>

20000386 <UsageFault_Handler>:
20000386:	e7fe      	b.n	20000386 <UsageFault_Handler>

20000388 <SVC_Handler>:
20000388:	e7fe      	b.n	20000388 <SVC_Handler>

2000038a <DebugMon_Handler>:
2000038a:	e7fe      	b.n	2000038a <DebugMon_Handler>

2000038c <PendSV_Handler>:
2000038c:	e7fe      	b.n	2000038c <PendSV_Handler>

2000038e <SysTick_Handler>:
2000038e:	e7fe      	b.n	2000038e <SysTick_Handler>

20000390 <WdogWakeup_IRQHandler>:
20000390:	e7fe      	b.n	20000390 <WdogWakeup_IRQHandler>

20000392 <RTC_Wakeup_IRQHandler>:
20000392:	e7fe      	b.n	20000392 <RTC_Wakeup_IRQHandler>

20000394 <SPI0_IRQHandler>:
20000394:	e7fe      	b.n	20000394 <SPI0_IRQHandler>

20000396 <SPI1_IRQHandler>:
20000396:	e7fe      	b.n	20000396 <SPI1_IRQHandler>
20000398:	e7fe      	b.n	20000398 <SPI1_IRQHandler+0x2>

2000039a <I2C0_SMBAlert_IRQHandler>:
2000039a:	e7fe      	b.n	2000039a <I2C0_SMBAlert_IRQHandler>

2000039c <I2C0_SMBus_IRQHandler>:
2000039c:	e7fe      	b.n	2000039c <I2C0_SMBus_IRQHandler>
2000039e:	e7fe      	b.n	2000039e <I2C0_SMBus_IRQHandler+0x2>

200003a0 <I2C1_SMBAlert_IRQHandler>:
200003a0:	e7fe      	b.n	200003a0 <I2C1_SMBAlert_IRQHandler>

200003a2 <I2C1_SMBus_IRQHandler>:
200003a2:	e7fe      	b.n	200003a2 <I2C1_SMBus_IRQHandler>
200003a4:	e7fe      	b.n	200003a4 <I2C1_SMBus_IRQHandler+0x2>
200003a6:	e7fe      	b.n	200003a6 <I2C1_SMBus_IRQHandler+0x4>

200003a8 <EthernetMAC_IRQHandler>:
200003a8:	e7fe      	b.n	200003a8 <EthernetMAC_IRQHandler>

200003aa <DMA_IRQHandler>:
200003aa:	e7fe      	b.n	200003aa <DMA_IRQHandler>

200003ac <Timer1_IRQHandler>:
200003ac:	e7fe      	b.n	200003ac <Timer1_IRQHandler>

200003ae <Timer2_IRQHandler>:
200003ae:	e7fe      	b.n	200003ae <Timer2_IRQHandler>

200003b0 <CAN_IRQHandler>:
200003b0:	e7fe      	b.n	200003b0 <CAN_IRQHandler>

200003b2 <ENVM0_IRQHandler>:
200003b2:	e7fe      	b.n	200003b2 <ENVM0_IRQHandler>

200003b4 <ENVM1_IRQHandler>:
200003b4:	e7fe      	b.n	200003b4 <ENVM1_IRQHandler>

200003b6 <ComBlk_IRQHandler>:
200003b6:	e7fe      	b.n	200003b6 <ComBlk_IRQHandler>

200003b8 <USB_IRQHandler>:
200003b8:	e7fe      	b.n	200003b8 <USB_IRQHandler>

200003ba <USB_DMA_IRQHandler>:
200003ba:	e7fe      	b.n	200003ba <USB_DMA_IRQHandler>

200003bc <PLL_Lock_IRQHandler>:
200003bc:	e7fe      	b.n	200003bc <PLL_Lock_IRQHandler>

200003be <PLL_LockLost_IRQHandler>:
200003be:	e7fe      	b.n	200003be <PLL_LockLost_IRQHandler>

200003c0 <CommSwitchError_IRQHandler>:
200003c0:	e7fe      	b.n	200003c0 <CommSwitchError_IRQHandler>

200003c2 <CacheError_IRQHandler>:
200003c2:	e7fe      	b.n	200003c2 <CacheError_IRQHandler>

200003c4 <DDR_IRQHandler>:
200003c4:	e7fe      	b.n	200003c4 <DDR_IRQHandler>

200003c6 <HPDMA_Complete_IRQHandler>:
200003c6:	e7fe      	b.n	200003c6 <HPDMA_Complete_IRQHandler>

200003c8 <HPDMA_Error_IRQHandler>:
200003c8:	e7fe      	b.n	200003c8 <HPDMA_Error_IRQHandler>

200003ca <ECC_Error_IRQHandler>:
200003ca:	e7fe      	b.n	200003ca <ECC_Error_IRQHandler>

200003cc <MDDR_IOCalib_IRQHandler>:
200003cc:	e7fe      	b.n	200003cc <MDDR_IOCalib_IRQHandler>

200003ce <FAB_PLL_Lock_IRQHandler>:
200003ce:	e7fe      	b.n	200003ce <FAB_PLL_Lock_IRQHandler>

200003d0 <FAB_PLL_LockLost_IRQHandler>:
200003d0:	e7fe      	b.n	200003d0 <FAB_PLL_LockLost_IRQHandler>

200003d2 <FIC64_IRQHandler>:
200003d2:	e7fe      	b.n	200003d2 <FIC64_IRQHandler>

200003d4 <FabricIrq0_IRQHandler>:
200003d4:	e7fe      	b.n	200003d4 <FabricIrq0_IRQHandler>

200003d6 <FabricIrq1_IRQHandler>:
200003d6:	e7fe      	b.n	200003d6 <FabricIrq1_IRQHandler>

200003d8 <FabricIrq2_IRQHandler>:
200003d8:	e7fe      	b.n	200003d8 <FabricIrq2_IRQHandler>

200003da <FabricIrq3_IRQHandler>:
200003da:	e7fe      	b.n	200003da <FabricIrq3_IRQHandler>

200003dc <FabricIrq4_IRQHandler>:
200003dc:	e7fe      	b.n	200003dc <FabricIrq4_IRQHandler>

200003de <FabricIrq5_IRQHandler>:
200003de:	e7fe      	b.n	200003de <FabricIrq5_IRQHandler>

200003e0 <FabricIrq6_IRQHandler>:
200003e0:	e7fe      	b.n	200003e0 <FabricIrq6_IRQHandler>

200003e2 <FabricIrq7_IRQHandler>:
200003e2:	e7fe      	b.n	200003e2 <FabricIrq7_IRQHandler>

200003e4 <FabricIrq8_IRQHandler>:
200003e4:	e7fe      	b.n	200003e4 <FabricIrq8_IRQHandler>

200003e6 <FabricIrq9_IRQHandler>:
200003e6:	e7fe      	b.n	200003e6 <FabricIrq9_IRQHandler>

200003e8 <FabricIrq10_IRQHandler>:
200003e8:	e7fe      	b.n	200003e8 <FabricIrq10_IRQHandler>

200003ea <FabricIrq11_IRQHandler>:
200003ea:	e7fe      	b.n	200003ea <FabricIrq11_IRQHandler>

200003ec <FabricIrq12_IRQHandler>:
200003ec:	e7fe      	b.n	200003ec <FabricIrq12_IRQHandler>

200003ee <FabricIrq13_IRQHandler>:
200003ee:	e7fe      	b.n	200003ee <FabricIrq13_IRQHandler>

200003f0 <FabricIrq14_IRQHandler>:
200003f0:	e7fe      	b.n	200003f0 <FabricIrq14_IRQHandler>

200003f2 <FabricIrq15_IRQHandler>:
200003f2:	e7fe      	b.n	200003f2 <FabricIrq15_IRQHandler>

200003f4 <GPIO0_IRQHandler>:
200003f4:	e7fe      	b.n	200003f4 <GPIO0_IRQHandler>

200003f6 <GPIO1_IRQHandler>:
200003f6:	e7fe      	b.n	200003f6 <GPIO1_IRQHandler>

200003f8 <GPIO2_IRQHandler>:
200003f8:	e7fe      	b.n	200003f8 <GPIO2_IRQHandler>

200003fa <GPIO3_IRQHandler>:
200003fa:	e7fe      	b.n	200003fa <GPIO3_IRQHandler>

200003fc <GPIO4_IRQHandler>:
200003fc:	e7fe      	b.n	200003fc <GPIO4_IRQHandler>

200003fe <GPIO5_IRQHandler>:
200003fe:	e7fe      	b.n	200003fe <GPIO5_IRQHandler>

20000400 <GPIO6_IRQHandler>:
20000400:	e7fe      	b.n	20000400 <GPIO6_IRQHandler>

20000402 <GPIO7_IRQHandler>:
20000402:	e7fe      	b.n	20000402 <GPIO7_IRQHandler>

20000404 <GPIO8_IRQHandler>:
20000404:	e7fe      	b.n	20000404 <GPIO8_IRQHandler>

20000406 <GPIO9_IRQHandler>:
20000406:	e7fe      	b.n	20000406 <GPIO9_IRQHandler>

20000408 <GPIO10_IRQHandler>:
20000408:	e7fe      	b.n	20000408 <GPIO10_IRQHandler>

2000040a <GPIO11_IRQHandler>:
2000040a:	e7fe      	b.n	2000040a <GPIO11_IRQHandler>

2000040c <GPIO12_IRQHandler>:
2000040c:	e7fe      	b.n	2000040c <GPIO12_IRQHandler>

2000040e <GPIO13_IRQHandler>:
2000040e:	e7fe      	b.n	2000040e <GPIO13_IRQHandler>

20000410 <GPIO14_IRQHandler>:
20000410:	e7fe      	b.n	20000410 <GPIO14_IRQHandler>

20000412 <GPIO15_IRQHandler>:
20000412:	e7fe      	b.n	20000412 <GPIO15_IRQHandler>

20000414 <GPIO16_IRQHandler>:
20000414:	e7fe      	b.n	20000414 <GPIO16_IRQHandler>

20000416 <GPIO17_IRQHandler>:
20000416:	e7fe      	b.n	20000416 <GPIO17_IRQHandler>

20000418 <GPIO18_IRQHandler>:
20000418:	e7fe      	b.n	20000418 <GPIO18_IRQHandler>

2000041a <GPIO19_IRQHandler>:
2000041a:	e7fe      	b.n	2000041a <GPIO19_IRQHandler>

2000041c <GPIO20_IRQHandler>:
2000041c:	e7fe      	b.n	2000041c <GPIO20_IRQHandler>

2000041e <GPIO21_IRQHandler>:
2000041e:	e7fe      	b.n	2000041e <GPIO21_IRQHandler>

20000420 <GPIO22_IRQHandler>:
20000420:	e7fe      	b.n	20000420 <GPIO22_IRQHandler>

20000422 <GPIO23_IRQHandler>:
20000422:	e7fe      	b.n	20000422 <GPIO23_IRQHandler>

20000424 <GPIO24_IRQHandler>:
20000424:	e7fe      	b.n	20000424 <GPIO24_IRQHandler>

20000426 <GPIO25_IRQHandler>:
20000426:	e7fe      	b.n	20000426 <GPIO25_IRQHandler>

20000428 <GPIO26_IRQHandler>:
20000428:	e7fe      	b.n	20000428 <GPIO26_IRQHandler>

2000042a <GPIO27_IRQHandler>:
2000042a:	e7fe      	b.n	2000042a <GPIO27_IRQHandler>

2000042c <GPIO28_IRQHandler>:
2000042c:	e7fe      	b.n	2000042c <GPIO28_IRQHandler>

2000042e <GPIO29_IRQHandler>:
2000042e:	e7fe      	b.n	2000042e <GPIO29_IRQHandler>

20000430 <GPIO30_IRQHandler>:
20000430:	e7fe      	b.n	20000430 <GPIO30_IRQHandler>

20000432 <GPIO31_IRQHandler>:
20000432:	e7fe      	b.n	20000432 <GPIO31_IRQHandler>

20000434 <mscc_post_hw_cfg_init>:
20000434:	4770      	bx	lr

20000436 <RAM_INIT_PATTERN>:
20000436:	0000      	.short	0x0000
	...

2000043a <HEAP_INIT_PATTERN>:
2000043a:	a2a2      	.short	0xa2a2
2000043c:	a2a2      	.short	0xa2a2

2000043e <SF2_ESRAM_CR>:
2000043e:	8000      	.short	0x8000
20000440:	4003      	.short	0x4003

20000442 <SF2_DDR_CR>:
20000442:	8008      	.short	0x8008
20000444:	4003      	.short	0x4003

20000446 <SF2_ENVM_REMAP_CR>:
20000446:	8010      	.short	0x8010
20000448:	4003      	.short	0x4003

2000044a <SF2_DDRB_NB_SIZE>:
2000044a:	8030      	.short	0x8030
2000044c:	4003      	.short	0x4003

2000044e <SF2_DDRB_CR>:
2000044e:	8034      	.short	0x8034
20000450:	4003      	.short	0x4003

20000452 <SF2_EDAC_CR>:
20000452:	8038      	.short	0x8038
20000454:	4003      	.short	0x4003

20000456 <SF2_MDDR_MODE_CR>:
20000456:	0818      	.short	0x0818
20000458:	00004002 	.word	0x00004002
2000045c:	2000f000 	.word	0x2000f000
20000460:	20010000 	.word	0x20010000
20000464:	20002291 	.word	0x20002291
	...
20000470:	00000001 	.word	0x00000001
20000474:	00000000 	.word	0x00000000
20000478:	20000000 	.word	0x20000000
2000047c:	20000000 	.word	0x20000000
20000480:	20000190 	.word	0x20000190
20000484:	200004c0 	.word	0x200004c0
20000488:	200004c0 	.word	0x200004c0
2000048c:	200026c0 	.word	0x200026c0
20000490:	200026c0 	.word	0x200026c0
20000494:	200026c0 	.word	0x200026c0
20000498:	200026f0 	.word	0x200026f0
2000049c:	200026f0 	.word	0x200026f0
200004a0:	200028a0 	.word	0x200028a0
200004a4:	200028a0 	.word	0x200028a0
200004a8:	2000f000 	.word	0x2000f000
200004ac:	20002569 	.word	0x20002569
200004b0:	20000549 	.word	0x20000549
200004b4:	f3af 8000 	nop.w
200004b8:	f3af 8000 	nop.w
200004bc:	f3af 8000 	nop.w

Disassembly of section .text:

200004c0 <__do_global_dtors_aux>:
200004c0:	f242 63f0 	movw	r3, #9968	; 0x26f0
200004c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004c8:	781a      	ldrb	r2, [r3, #0]
200004ca:	b90a      	cbnz	r2, 200004d0 <__do_global_dtors_aux+0x10>
200004cc:	2001      	movs	r0, #1
200004ce:	7018      	strb	r0, [r3, #0]
200004d0:	4770      	bx	lr
200004d2:	bf00      	nop

200004d4 <frame_dummy>:
200004d4:	f242 60c0 	movw	r0, #9920	; 0x26c0
200004d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200004dc:	b508      	push	{r3, lr}
200004de:	6803      	ldr	r3, [r0, #0]
200004e0:	b12b      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004e2:	f240 0300 	movw	r3, #0
200004e6:	f2c0 0300 	movt	r3, #0
200004ea:	b103      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004ec:	4798      	blx	r3
200004ee:	bd08      	pop	{r3, pc}

200004f0 <UART_Polled_Rx>:
mss_uart_instance_t * const gp_my_uart = &g_mss_uart0;
uint8_t slave_address;
mss_i2c_status_t mss_instance;

size_t UART_Polled_Rx(mss_uart_instance_t * this_uart, uint8_t * rx_buff,
		size_t buff_size) {
200004f0:	b480      	push	{r7}
200004f2:	b087      	sub	sp, #28
200004f4:	af00      	add	r7, sp, #0
200004f6:	60f8      	str	r0, [r7, #12]
200004f8:	60b9      	str	r1, [r7, #8]
200004fa:	607a      	str	r2, [r7, #4]
	size_t rx_size = 0U;
200004fc:	f04f 0300 	mov.w	r3, #0
20000500:	617b      	str	r3, [r7, #20]

	while (rx_size < buff_size) {
20000502:	e016      	b.n	20000532 <UART_Polled_Rx+0x42>
		while (((this_uart->hw_reg->LSR) & 0x1) != 0U) {
			rx_buff[rx_size] = this_uart->hw_reg->RBR;
20000504:	68ba      	ldr	r2, [r7, #8]
20000506:	697b      	ldr	r3, [r7, #20]
20000508:	4413      	add	r3, r2
2000050a:	68fa      	ldr	r2, [r7, #12]
2000050c:	6812      	ldr	r2, [r2, #0]
2000050e:	7812      	ldrb	r2, [r2, #0]
20000510:	b2d2      	uxtb	r2, r2
20000512:	701a      	strb	r2, [r3, #0]
			++rx_size;
20000514:	697b      	ldr	r3, [r7, #20]
20000516:	f103 0301 	add.w	r3, r3, #1
2000051a:	617b      	str	r3, [r7, #20]
2000051c:	e000      	b.n	20000520 <UART_Polled_Rx+0x30>
size_t UART_Polled_Rx(mss_uart_instance_t * this_uart, uint8_t * rx_buff,
		size_t buff_size) {
	size_t rx_size = 0U;

	while (rx_size < buff_size) {
		while (((this_uart->hw_reg->LSR) & 0x1) != 0U) {
2000051e:	bf00      	nop
20000520:	68fb      	ldr	r3, [r7, #12]
20000522:	681b      	ldr	r3, [r3, #0]
20000524:	7d1b      	ldrb	r3, [r3, #20]
20000526:	b2db      	uxtb	r3, r3
20000528:	f003 0301 	and.w	r3, r3, #1
2000052c:	b2db      	uxtb	r3, r3
2000052e:	2b00      	cmp	r3, #0
20000530:	d1e8      	bne.n	20000504 <UART_Polled_Rx+0x14>

size_t UART_Polled_Rx(mss_uart_instance_t * this_uart, uint8_t * rx_buff,
		size_t buff_size) {
	size_t rx_size = 0U;

	while (rx_size < buff_size) {
20000532:	697a      	ldr	r2, [r7, #20]
20000534:	687b      	ldr	r3, [r7, #4]
20000536:	429a      	cmp	r2, r3
20000538:	d3f1      	bcc.n	2000051e <UART_Polled_Rx+0x2e>
		while (((this_uart->hw_reg->LSR) & 0x1) != 0U) {
			rx_buff[rx_size] = this_uart->hw_reg->RBR;
			++rx_size;
		}
	}
	return rx_size;
2000053a:	697b      	ldr	r3, [r7, #20]
}
2000053c:	4618      	mov	r0, r3
2000053e:	f107 071c 	add.w	r7, r7, #28
20000542:	46bd      	mov	sp, r7
20000544:	bc80      	pop	{r7}
20000546:	4770      	bx	lr

20000548 <main>:

/*------------------------------------------------------------------------------
 * main function.
 *------------------------------------------------------------------------------*/
int main(void) {
20000548:	b580      	push	{r7, lr}
2000054a:	b084      	sub	sp, #16
2000054c:	af02      	add	r7, sp, #8
	uint8_t RegAdd[2];
	static uint8_t stateWorking;

	// инициализация UART
	MSS_UART_init(gp_my_uart, MSS_UART_115200_BAUD, MSS_UART_DATA_8_BITS
2000054e:	f242 638c 	movw	r3, #9868	; 0x268c
20000552:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000556:	681b      	ldr	r3, [r3, #0]
20000558:	4618      	mov	r0, r3
2000055a:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
2000055e:	f04f 0203 	mov.w	r2, #3
20000562:	f000 fb01 	bl	20000b68 <MSS_UART_init>
			      | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);

	// инициализация I2С
	MSS_I2C_init(MSS_I2C_MASTER, MSS_MASTER_SER_ADDR, clock_speed);
20000566:	f242 63c4 	movw	r3, #9924	; 0x26c4
2000056a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000056e:	781b      	ldrb	r3, [r3, #0]
20000570:	f242 70b4 	movw	r0, #10164	; 0x27b4
20000574:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000578:	f04f 0120 	mov.w	r1, #32
2000057c:	461a      	mov	r2, r3
2000057e:	f000 ffc1 	bl	20001504 <MSS_I2C_init>

	//включаем режим bypass дополнительного интерфейса Auxiliary I2C (ES_CL and ES_DA)
	slave_address = 0x68;
20000582:	f242 731c 	movw	r3, #10012	; 0x271c
20000586:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000058a:	f04f 0268 	mov.w	r2, #104	; 0x68
2000058e:	701a      	strb	r2, [r3, #0]
	mss_instance = I2C_writeU(0x37, 0x02);
20000590:	f04f 0037 	mov.w	r0, #55	; 0x37
20000594:	f04f 0102 	mov.w	r1, #2
20000598:	f000 f930 	bl	200007fc <I2C_writeU>
2000059c:	4603      	mov	r3, r0
2000059e:	461a      	mov	r2, r3
200005a0:	f242 732c 	movw	r3, #10028	; 0x272c
200005a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005a8:	701a      	strb	r2, [r3, #0]

	// включаем Continuous_measurement_mode_2 компаса (100 Гц)
	slave_address = 0x0C;
200005aa:	f242 731c 	movw	r3, #10012	; 0x271c
200005ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005b2:	f04f 020c 	mov.w	r2, #12
200005b6:	701a      	strb	r2, [r3, #0]
	mss_instance = I2C_writeU(0x0A, 0x06);//многократный 2
200005b8:	f04f 000a 	mov.w	r0, #10
200005bc:	f04f 0106 	mov.w	r1, #6
200005c0:	f000 f91c 	bl	200007fc <I2C_writeU>
200005c4:	4603      	mov	r3, r0
200005c6:	461a      	mov	r2, r3
200005c8:	f242 732c 	movw	r3, #10028	; 0x272c
200005cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005d0:	701a      	strb	r2, [r3, #0]
	stateWorking = 0;
200005d2:	f242 63f1 	movw	r3, #9969	; 0x26f1
200005d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005da:	f04f 0200 	mov.w	r2, #0
200005de:	701a      	strb	r2, [r3, #0]
	while (1) {
		if (stateWorking == 0) {
200005e0:	f242 63f1 	movw	r3, #9969	; 0x26f1
200005e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005e8:	781b      	ldrb	r3, [r3, #0]
200005ea:	2b00      	cmp	r3, #0
200005ec:	d145      	bne.n	2000067a <main+0x132>
			UART_Polled_Rx(gp_my_uart, uart_rx_buf, 1);
200005ee:	f242 638c 	movw	r3, #9868	; 0x268c
200005f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005f6:	681b      	ldr	r3, [r3, #0]
200005f8:	4618      	mov	r0, r3
200005fa:	f242 7130 	movw	r1, #10032	; 0x2730
200005fe:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000602:	f04f 0201 	mov.w	r2, #1
20000606:	f7ff ff73 	bl	200004f0 <UART_Polled_Rx>
			if (uart_rx_buf[0] == 119)  {
2000060a:	f242 7330 	movw	r3, #10032	; 0x2730
2000060e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000612:	781b      	ldrb	r3, [r3, #0]
20000614:	2b77      	cmp	r3, #119	; 0x77
20000616:	d130      	bne.n	2000067a <main+0x132>
				uart_tx_buf[0] = 121;
20000618:	f242 7304 	movw	r3, #9988	; 0x2704
2000061c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000620:	f04f 0279 	mov.w	r2, #121	; 0x79
20000624:	701a      	strb	r2, [r3, #0]
				MSS_UART_polled_tx(gp_my_uart, uart_tx_buf, 1);
20000626:	f242 638c 	movw	r3, #9868	; 0x268c
2000062a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000062e:	681b      	ldr	r3, [r3, #0]
20000630:	4618      	mov	r0, r3
20000632:	f242 7104 	movw	r1, #9988	; 0x2704
20000636:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000063a:	f04f 0201 	mov.w	r2, #1
2000063e:	f000 fad5 	bl	20000bec <MSS_UART_polled_tx>
				UART_Polled_Rx(gp_my_uart, uart_rx_buf, 1);
20000642:	f242 638c 	movw	r3, #9868	; 0x268c
20000646:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000064a:	681b      	ldr	r3, [r3, #0]
2000064c:	4618      	mov	r0, r3
2000064e:	f242 7130 	movw	r1, #10032	; 0x2730
20000652:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000656:	f04f 0201 	mov.w	r2, #1
2000065a:	f7ff ff49 	bl	200004f0 <UART_Polled_Rx>
				if (uart_rx_buf[0] == 115)  stateWorking = 1;
2000065e:	f242 7330 	movw	r3, #10032	; 0x2730
20000662:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000666:	781b      	ldrb	r3, [r3, #0]
20000668:	2b73      	cmp	r3, #115	; 0x73
2000066a:	d106      	bne.n	2000067a <main+0x132>
2000066c:	f242 63f1 	movw	r3, #9969	; 0x26f1
20000670:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000674:	f04f 0201 	mov.w	r2, #1
20000678:	701a      	strb	r2, [r3, #0]
			}
		}
		if (stateWorking == 1) {
2000067a:	f242 63f1 	movw	r3, #9969	; 0x26f1
2000067e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000682:	781b      	ldrb	r3, [r3, #0]
20000684:	2b01      	cmp	r3, #1
20000686:	d161      	bne.n	2000074c <main+0x204>
			while (1) {
				// чтение данных из регистров MPU-6555
				slave_address = 0x68;
20000688:	f242 731c 	movw	r3, #10012	; 0x271c
2000068c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000690:	f04f 0268 	mov.w	r2, #104	; 0x68
20000694:	701a      	strb	r2, [r3, #0]
				RegAdd[0]= 59;
20000696:	f04f 033b 	mov.w	r3, #59	; 0x3b
2000069a:	713b      	strb	r3, [r7, #4]
				mss_instance = mss_write_read_transaction(slave_address, RegAdd, 1, AG_buf, 14);
2000069c:	f242 731c 	movw	r3, #10012	; 0x271c
200006a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006a4:	781a      	ldrb	r2, [r3, #0]
200006a6:	f107 0304 	add.w	r3, r7, #4
200006aa:	f04f 010e 	mov.w	r1, #14
200006ae:	9100      	str	r1, [sp, #0]
200006b0:	4610      	mov	r0, r2
200006b2:	4619      	mov	r1, r3
200006b4:	f04f 0201 	mov.w	r2, #1
200006b8:	f242 63f4 	movw	r3, #9972	; 0x26f4
200006bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006c0:	f000 f872 	bl	200007a8 <mss_write_read_transaction>
200006c4:	4603      	mov	r3, r0
200006c6:	461a      	mov	r2, r3
200006c8:	f242 732c 	movw	r3, #10028	; 0x272c
200006cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006d0:	701a      	strb	r2, [r3, #0]

				// чтение данных из регистров AK8963
				mss_instance = readcompass();
200006d2:	f000 f8b3 	bl	2000083c <readcompass>
200006d6:	4603      	mov	r3, r0
200006d8:	461a      	mov	r2, r3
200006da:	f242 732c 	movw	r3, #10028	; 0x272c
200006de:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006e2:	701a      	strb	r2, [r3, #0]
				// компоновка данных полученных от MPU-6555 и AK8963 в единый массив для выдачи по UART
				fill_uart_tx_buf();
200006e4:	f000 f8d4 	bl	20000890 <fill_uart_tx_buf>
				if(MSS_I2C_SUCCESS == mss_instance)
200006e8:	f242 732c 	movw	r3, #10028	; 0x272c
200006ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006f0:	781b      	ldrb	r3, [r3, #0]
200006f2:	2b00      	cmp	r3, #0
200006f4:	d10e      	bne.n	20000714 <main+0x1cc>
				{
					MSS_UART_polled_tx(gp_my_uart, uart_tx_buf, 22);
200006f6:	f242 638c 	movw	r3, #9868	; 0x268c
200006fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006fe:	681b      	ldr	r3, [r3, #0]
20000700:	4618      	mov	r0, r3
20000702:	f242 7104 	movw	r1, #9988	; 0x2704
20000706:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000070a:	f04f 0216 	mov.w	r2, #22
2000070e:	f000 fa6d 	bl	20000bec <MSS_UART_polled_tx>
20000712:	e00d      	b.n	20000730 <main+0x1e8>
				}
				else
				{
					MSS_UART_polled_tx ( gp_my_uart, (const uint8_t *)"F", 1 );
20000714:	f242 638c 	movw	r3, #9868	; 0x268c
20000718:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000071c:	681b      	ldr	r3, [r3, #0]
2000071e:	4618      	mov	r0, r3
20000720:	f242 6190 	movw	r1, #9872	; 0x2690
20000724:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000728:	f04f 0201 	mov.w	r2, #1
2000072c:	f000 fa5e 	bl	20000bec <MSS_UART_polled_tx>
				}
				delay(600000);
20000730:	f242 70c0 	movw	r0, #10176	; 0x27c0
20000734:	f2c0 0009 	movt	r0, #9
20000738:	f000 f986 	bl	20000a48 <delay>
				stateWorking = 1;
2000073c:	f242 63f1 	movw	r3, #9969	; 0x26f1
20000740:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000744:	f04f 0201 	mov.w	r2, #1
20000748:	701a      	strb	r2, [r3, #0]
			}
2000074a:	e79d      	b.n	20000688 <main+0x140>
		}
	return 0;
2000074c:	f04f 0300 	mov.w	r3, #0
	}
}
20000750:	4618      	mov	r0, r3
20000752:	f107 0708 	add.w	r7, r7, #8
20000756:	46bd      	mov	sp, r7
20000758:	bd80      	pop	{r7, pc}
2000075a:	bf00      	nop

2000075c <mss_write_transaction>:

/*------------------------------------------------------------------------------
 * MSS I2C Master perform write transaction with parameters gathered from the GUI.
 *-------------------------------------------------------------------------------*/
mss_i2c_status_t mss_write_transaction(uint8_t serial_addr,
		uint8_t * tx_buffer, uint16_t write_length) {
2000075c:	b580      	push	{r7, lr}
2000075e:	b088      	sub	sp, #32
20000760:	af02      	add	r7, sp, #8
20000762:	60b9      	str	r1, [r7, #8]
20000764:	4613      	mov	r3, r2
20000766:	4602      	mov	r2, r0
20000768:	73fa      	strb	r2, [r7, #15]
2000076a:	80fb      	strh	r3, [r7, #6]
	mss_i2c_status_t status;

	MSS_I2C_write(MSS_I2C_MASTER, serial_addr, tx_buffer, write_length,
2000076c:	7bfa      	ldrb	r2, [r7, #15]
2000076e:	88fb      	ldrh	r3, [r7, #6]
20000770:	f04f 0100 	mov.w	r1, #0
20000774:	9100      	str	r1, [sp, #0]
20000776:	f242 70b4 	movw	r0, #10164	; 0x27b4
2000077a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000077e:	4611      	mov	r1, r2
20000780:	68ba      	ldr	r2, [r7, #8]
20000782:	f000 ff75 	bl	20001670 <MSS_I2C_write>
			MSS_I2C_RELEASE_BUS);

	status = MSS_I2C_wait_complete(MSS_I2C_MASTER, DEMO_I2C_TIMEOUT);
20000786:	f242 70b4 	movw	r0, #10164	; 0x27b4
2000078a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000078e:	f640 31b8 	movw	r1, #3000	; 0xbb8
20000792:	f001 f881 	bl	20001898 <MSS_I2C_wait_complete>
20000796:	4603      	mov	r3, r0
20000798:	75fb      	strb	r3, [r7, #23]

	return status;
2000079a:	7dfb      	ldrb	r3, [r7, #23]
}
2000079c:	4618      	mov	r0, r3
2000079e:	f107 0718 	add.w	r7, r7, #24
200007a2:	46bd      	mov	sp, r7
200007a4:	bd80      	pop	{r7, pc}
200007a6:	bf00      	nop

200007a8 <mss_write_read_transaction>:
 * MSS I2C Master perform write-read transaction with parameters gathered from
 * the GUI.
 *------------------------------------------------------------------------------*/
mss_i2c_status_t mss_write_read_transaction(uint8_t serial_addr,
		uint8_t * tx_buffer, uint16_t write_length, uint8_t * rx_buffer,
		uint16_t read_length) {
200007a8:	b580      	push	{r7, lr}
200007aa:	b08a      	sub	sp, #40	; 0x28
200007ac:	af04      	add	r7, sp, #16
200007ae:	60b9      	str	r1, [r7, #8]
200007b0:	603b      	str	r3, [r7, #0]
200007b2:	4603      	mov	r3, r0
200007b4:	73fb      	strb	r3, [r7, #15]
200007b6:	4613      	mov	r3, r2
200007b8:	80fb      	strh	r3, [r7, #6]
	mss_i2c_status_t status;

	MSS_I2C_write_read(MSS_I2C_MASTER, serial_addr, tx_buffer, write_length,
200007ba:	7bfa      	ldrb	r2, [r7, #15]
200007bc:	88fb      	ldrh	r3, [r7, #6]
200007be:	6839      	ldr	r1, [r7, #0]
200007c0:	9100      	str	r1, [sp, #0]
200007c2:	8c39      	ldrh	r1, [r7, #32]
200007c4:	9101      	str	r1, [sp, #4]
200007c6:	f04f 0100 	mov.w	r1, #0
200007ca:	9102      	str	r1, [sp, #8]
200007cc:	f242 70b4 	movw	r0, #10164	; 0x27b4
200007d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007d4:	4611      	mov	r1, r2
200007d6:	68ba      	ldr	r2, [r7, #8]
200007d8:	f000 ffc4 	bl	20001764 <MSS_I2C_write_read>
			rx_buffer, read_length, MSS_I2C_RELEASE_BUS);

	status = MSS_I2C_wait_complete(MSS_I2C_MASTER, DEMO_I2C_TIMEOUT);
200007dc:	f242 70b4 	movw	r0, #10164	; 0x27b4
200007e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200007e4:	f640 31b8 	movw	r1, #3000	; 0xbb8
200007e8:	f001 f856 	bl	20001898 <MSS_I2C_wait_complete>
200007ec:	4603      	mov	r3, r0
200007ee:	75fb      	strb	r3, [r7, #23]

	return status;
200007f0:	7dfb      	ldrb	r3, [r7, #23]
}
200007f2:	4618      	mov	r0, r3
200007f4:	f107 0718 	add.w	r7, r7, #24
200007f8:	46bd      	mov	sp, r7
200007fa:	bd80      	pop	{r7, pc}

200007fc <I2C_writeU>:

mss_i2c_status_t I2C_writeU(uint8_t regAdr, uint8_t vbyte) {
200007fc:	b580      	push	{r7, lr}
200007fe:	b084      	sub	sp, #16
20000800:	af00      	add	r7, sp, #0
20000802:	4602      	mov	r2, r0
20000804:	460b      	mov	r3, r1
20000806:	71fa      	strb	r2, [r7, #7]
20000808:	71bb      	strb	r3, [r7, #6]
	mss_i2c_status_t status;
	uint8_t tx_buf[2];
	tx_buf[0] = regAdr;
2000080a:	79fb      	ldrb	r3, [r7, #7]
2000080c:	733b      	strb	r3, [r7, #12]
	tx_buf[1] = vbyte;
2000080e:	79bb      	ldrb	r3, [r7, #6]
20000810:	737b      	strb	r3, [r7, #13]
	status = mss_write_transaction(slave_address, tx_buf, 2);
20000812:	f242 731c 	movw	r3, #10012	; 0x271c
20000816:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000081a:	781a      	ldrb	r2, [r3, #0]
2000081c:	f107 030c 	add.w	r3, r7, #12
20000820:	4610      	mov	r0, r2
20000822:	4619      	mov	r1, r3
20000824:	f04f 0202 	mov.w	r2, #2
20000828:	f7ff ff98 	bl	2000075c <mss_write_transaction>
2000082c:	4603      	mov	r3, r0
2000082e:	73fb      	strb	r3, [r7, #15]
	return status;
20000830:	7bfb      	ldrb	r3, [r7, #15]
}
20000832:	4618      	mov	r0, r3
20000834:	f107 0710 	add.w	r7, r7, #16
20000838:	46bd      	mov	sp, r7
2000083a:	bd80      	pop	{r7, pc}

2000083c <readcompass>:

mss_i2c_status_t readcompass() {
2000083c:	b580      	push	{r7, lr}
2000083e:	b084      	sub	sp, #16
20000840:	af02      	add	r7, sp, #8
	mss_i2c_status_t status;
	uint8_t tx_buf[2];
	slave_address = 0x0C;
20000842:	f242 731c 	movw	r3, #10012	; 0x271c
20000846:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000084a:	f04f 020c 	mov.w	r2, #12
2000084e:	701a      	strb	r2, [r3, #0]
	tx_buf[0] = 0;
20000850:	f04f 0300 	mov.w	r3, #0
20000854:	713b      	strb	r3, [r7, #4]
	// собственно чтение данных
	status = mss_write_read_transaction(slave_address, tx_buf, 1, Comp_buf, 10);
20000856:	f242 731c 	movw	r3, #10012	; 0x271c
2000085a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000085e:	781a      	ldrb	r2, [r3, #0]
20000860:	f107 0304 	add.w	r3, r7, #4
20000864:	f04f 010a 	mov.w	r1, #10
20000868:	9100      	str	r1, [sp, #0]
2000086a:	4610      	mov	r0, r2
2000086c:	4619      	mov	r1, r3
2000086e:	f04f 0201 	mov.w	r2, #1
20000872:	f242 7320 	movw	r3, #10016	; 0x2720
20000876:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000087a:	f7ff ff95 	bl	200007a8 <mss_write_read_transaction>
2000087e:	4603      	mov	r3, r0
20000880:	71fb      	strb	r3, [r7, #7]
	return status;
20000882:	79fb      	ldrb	r3, [r7, #7]
}
20000884:	4618      	mov	r0, r3
20000886:	f107 0708 	add.w	r7, r7, #8
2000088a:	46bd      	mov	sp, r7
2000088c:	bd80      	pop	{r7, pc}
2000088e:	bf00      	nop

20000890 <fill_uart_tx_buf>:

void fill_uart_tx_buf()
{
20000890:	b480      	push	{r7}
20000892:	af00      	add	r7, sp, #0
	uart_tx_buf[0] = 10;
20000894:	f242 7304 	movw	r3, #9988	; 0x2704
20000898:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000089c:	f04f 020a 	mov.w	r2, #10
200008a0:	701a      	strb	r2, [r3, #0]
	uart_tx_buf[1] = 13;
200008a2:	f242 7304 	movw	r3, #9988	; 0x2704
200008a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008aa:	f04f 020d 	mov.w	r2, #13
200008ae:	705a      	strb	r2, [r3, #1]

	uart_tx_buf[2] =  AG_buf[0];   //AX high
200008b0:	f242 63f4 	movw	r3, #9972	; 0x26f4
200008b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008b8:	781a      	ldrb	r2, [r3, #0]
200008ba:	f242 7304 	movw	r3, #9988	; 0x2704
200008be:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008c2:	709a      	strb	r2, [r3, #2]
	uart_tx_buf[3] =  AG_buf[1];   //AX low
200008c4:	f242 63f4 	movw	r3, #9972	; 0x26f4
200008c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008cc:	785a      	ldrb	r2, [r3, #1]
200008ce:	f242 7304 	movw	r3, #9988	; 0x2704
200008d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008d6:	70da      	strb	r2, [r3, #3]
	uart_tx_buf[4] =  AG_buf[2];   //AY high
200008d8:	f242 63f4 	movw	r3, #9972	; 0x26f4
200008dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008e0:	789a      	ldrb	r2, [r3, #2]
200008e2:	f242 7304 	movw	r3, #9988	; 0x2704
200008e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008ea:	711a      	strb	r2, [r3, #4]
	uart_tx_buf[5] =  AG_buf[3];   //AY low
200008ec:	f242 63f4 	movw	r3, #9972	; 0x26f4
200008f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008f4:	78da      	ldrb	r2, [r3, #3]
200008f6:	f242 7304 	movw	r3, #9988	; 0x2704
200008fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008fe:	715a      	strb	r2, [r3, #5]
	uart_tx_buf[6] =  AG_buf[4];   //AZ high
20000900:	f242 63f4 	movw	r3, #9972	; 0x26f4
20000904:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000908:	791a      	ldrb	r2, [r3, #4]
2000090a:	f242 7304 	movw	r3, #9988	; 0x2704
2000090e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000912:	719a      	strb	r2, [r3, #6]
	uart_tx_buf[7] =  AG_buf[5];   //AZ low
20000914:	f242 63f4 	movw	r3, #9972	; 0x26f4
20000918:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000091c:	795a      	ldrb	r2, [r3, #5]
2000091e:	f242 7304 	movw	r3, #9988	; 0x2704
20000922:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000926:	71da      	strb	r2, [r3, #7]
	uart_tx_buf[8] =  AG_buf[6];   //T high
20000928:	f242 63f4 	movw	r3, #9972	; 0x26f4
2000092c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000930:	799a      	ldrb	r2, [r3, #6]
20000932:	f242 7304 	movw	r3, #9988	; 0x2704
20000936:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000093a:	721a      	strb	r2, [r3, #8]
	uart_tx_buf[9] =  AG_buf[7];   //T low
2000093c:	f242 63f4 	movw	r3, #9972	; 0x26f4
20000940:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000944:	79da      	ldrb	r2, [r3, #7]
20000946:	f242 7304 	movw	r3, #9988	; 0x2704
2000094a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000094e:	725a      	strb	r2, [r3, #9]
	uart_tx_buf[10] = AG_buf[8];   //GX high
20000950:	f242 63f4 	movw	r3, #9972	; 0x26f4
20000954:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000958:	7a1a      	ldrb	r2, [r3, #8]
2000095a:	f242 7304 	movw	r3, #9988	; 0x2704
2000095e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000962:	729a      	strb	r2, [r3, #10]
	uart_tx_buf[11] = AG_buf[9];   //GX low
20000964:	f242 63f4 	movw	r3, #9972	; 0x26f4
20000968:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000096c:	7a5a      	ldrb	r2, [r3, #9]
2000096e:	f242 7304 	movw	r3, #9988	; 0x2704
20000972:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000976:	72da      	strb	r2, [r3, #11]
	uart_tx_buf[12] = AG_buf[10];  //GY high
20000978:	f242 63f4 	movw	r3, #9972	; 0x26f4
2000097c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000980:	7a9a      	ldrb	r2, [r3, #10]
20000982:	f242 7304 	movw	r3, #9988	; 0x2704
20000986:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000098a:	731a      	strb	r2, [r3, #12]
	uart_tx_buf[13] = AG_buf[11];  //GY low
2000098c:	f242 63f4 	movw	r3, #9972	; 0x26f4
20000990:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000994:	7ada      	ldrb	r2, [r3, #11]
20000996:	f242 7304 	movw	r3, #9988	; 0x2704
2000099a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000099e:	735a      	strb	r2, [r3, #13]
	uart_tx_buf[14] = AG_buf[12];  //GZ high
200009a0:	f242 63f4 	movw	r3, #9972	; 0x26f4
200009a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009a8:	7b1a      	ldrb	r2, [r3, #12]
200009aa:	f242 7304 	movw	r3, #9988	; 0x2704
200009ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009b2:	739a      	strb	r2, [r3, #14]
	uart_tx_buf[15] = AG_buf[13];  //GZ low
200009b4:	f242 63f4 	movw	r3, #9972	; 0x26f4
200009b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009bc:	7b5a      	ldrb	r2, [r3, #13]
200009be:	f242 7304 	movw	r3, #9988	; 0x2704
200009c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009c6:	73da      	strb	r2, [r3, #15]

	uart_tx_buf[16] = Comp_buf[3];  //MX low
200009c8:	f242 7320 	movw	r3, #10016	; 0x2720
200009cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009d0:	78da      	ldrb	r2, [r3, #3]
200009d2:	f242 7304 	movw	r3, #9988	; 0x2704
200009d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009da:	741a      	strb	r2, [r3, #16]
	uart_tx_buf[17] = Comp_buf[4];  //MX high
200009dc:	f242 7320 	movw	r3, #10016	; 0x2720
200009e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009e4:	791a      	ldrb	r2, [r3, #4]
200009e6:	f242 7304 	movw	r3, #9988	; 0x2704
200009ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009ee:	745a      	strb	r2, [r3, #17]
	uart_tx_buf[18] = Comp_buf[5];  //MY low
200009f0:	f242 7320 	movw	r3, #10016	; 0x2720
200009f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009f8:	795a      	ldrb	r2, [r3, #5]
200009fa:	f242 7304 	movw	r3, #9988	; 0x2704
200009fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a02:	749a      	strb	r2, [r3, #18]
	uart_tx_buf[19] = Comp_buf[6];  //MY high
20000a04:	f242 7320 	movw	r3, #10016	; 0x2720
20000a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a0c:	799a      	ldrb	r2, [r3, #6]
20000a0e:	f242 7304 	movw	r3, #9988	; 0x2704
20000a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a16:	74da      	strb	r2, [r3, #19]
	uart_tx_buf[20] = Comp_buf[7];  //MZ low
20000a18:	f242 7320 	movw	r3, #10016	; 0x2720
20000a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a20:	79da      	ldrb	r2, [r3, #7]
20000a22:	f242 7304 	movw	r3, #9988	; 0x2704
20000a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a2a:	751a      	strb	r2, [r3, #20]
	uart_tx_buf[21] = Comp_buf[8];  //MZ high
20000a2c:	f242 7320 	movw	r3, #10016	; 0x2720
20000a30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a34:	7a1a      	ldrb	r2, [r3, #8]
20000a36:	f242 7304 	movw	r3, #9988	; 0x2704
20000a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a3e:	755a      	strb	r2, [r3, #21]
}
20000a40:	46bd      	mov	sp, r7
20000a42:	bc80      	pop	{r7}
20000a44:	4770      	bx	lr
20000a46:	bf00      	nop

20000a48 <delay>:

/* Function for delay */
void delay(volatile uint32_t n) {
20000a48:	b480      	push	{r7}
20000a4a:	b083      	sub	sp, #12
20000a4c:	af00      	add	r7, sp, #0
20000a4e:	6078      	str	r0, [r7, #4]
	while (n != 0) {
20000a50:	e003      	b.n	20000a5a <delay+0x12>
		n--;
20000a52:	687b      	ldr	r3, [r7, #4]
20000a54:	f103 33ff 	add.w	r3, r3, #4294967295
20000a58:	607b      	str	r3, [r7, #4]
	uart_tx_buf[21] = Comp_buf[8];  //MZ high
}

/* Function for delay */
void delay(volatile uint32_t n) {
	while (n != 0) {
20000a5a:	687b      	ldr	r3, [r7, #4]
20000a5c:	2b00      	cmp	r3, #0
20000a5e:	d1f8      	bne.n	20000a52 <delay+0xa>
		n--;
	}
}
20000a60:	f107 070c 	add.w	r7, r7, #12
20000a64:	46bd      	mov	sp, r7
20000a66:	bc80      	pop	{r7}
20000a68:	4770      	bx	lr
20000a6a:	bf00      	nop

20000a6c <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20000a6c:	b480      	push	{r7}
20000a6e:	b083      	sub	sp, #12
20000a70:	af00      	add	r7, sp, #0
20000a72:	4603      	mov	r3, r0
20000a74:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20000a76:	f24e 1300 	movw	r3, #57600	; 0xe100
20000a7a:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000a7e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20000a82:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000a86:	79f9      	ldrb	r1, [r7, #7]
20000a88:	f001 011f 	and.w	r1, r1, #31
20000a8c:	f04f 0001 	mov.w	r0, #1
20000a90:	fa00 f101 	lsl.w	r1, r0, r1
20000a94:	f102 0260 	add.w	r2, r2, #96	; 0x60
20000a98:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000a9c:	f107 070c 	add.w	r7, r7, #12
20000aa0:	46bd      	mov	sp, r7
20000aa2:	bc80      	pop	{r7}
20000aa4:	4770      	bx	lr
20000aa6:	bf00      	nop

20000aa8 <set_bit_reg8>:
static __INLINE void set_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20000aa8:	b480      	push	{r7}
20000aaa:	b083      	sub	sp, #12
20000aac:	af00      	add	r7, sp, #0
20000aae:	6078      	str	r0, [r7, #4]
20000ab0:	460b      	mov	r3, r1
20000ab2:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x1;
20000ab4:	687b      	ldr	r3, [r7, #4]
20000ab6:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20000aba:	687b      	ldr	r3, [r7, #4]
20000abc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000ac0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
20000ac4:	ea4f 1343 	mov.w	r3, r3, lsl #5
20000ac8:	441a      	add	r2, r3
20000aca:	78fb      	ldrb	r3, [r7, #3]
20000acc:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000ad0:	4413      	add	r3, r2
20000ad2:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
20000ad6:	f04f 0201 	mov.w	r2, #1
20000ada:	601a      	str	r2, [r3, #0]
}
20000adc:	f107 070c 	add.w	r7, r7, #12
20000ae0:	46bd      	mov	sp, r7
20000ae2:	bc80      	pop	{r7}
20000ae4:	4770      	bx	lr
20000ae6:	bf00      	nop

20000ae8 <clear_bit_reg8>:
static __INLINE void clear_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20000ae8:	b480      	push	{r7}
20000aea:	b083      	sub	sp, #12
20000aec:	af00      	add	r7, sp, #0
20000aee:	6078      	str	r0, [r7, #4]
20000af0:	460b      	mov	r3, r1
20000af2:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x0;
20000af4:	687b      	ldr	r3, [r7, #4]
20000af6:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20000afa:	687b      	ldr	r3, [r7, #4]
20000afc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000b00:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
20000b04:	ea4f 1343 	mov.w	r3, r3, lsl #5
20000b08:	441a      	add	r2, r3
20000b0a:	78fb      	ldrb	r3, [r7, #3]
20000b0c:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000b10:	4413      	add	r3, r2
20000b12:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
20000b16:	f04f 0200 	mov.w	r2, #0
20000b1a:	601a      	str	r2, [r3, #0]
}
20000b1c:	f107 070c 	add.w	r7, r7, #12
20000b20:	46bd      	mov	sp, r7
20000b22:	bc80      	pop	{r7}
20000b24:	4770      	bx	lr
20000b26:	bf00      	nop

20000b28 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20000b28:	b480      	push	{r7}
20000b2a:	b083      	sub	sp, #12
20000b2c:	af00      	add	r7, sp, #0
20000b2e:	6078      	str	r0, [r7, #4]
20000b30:	460b      	mov	r3, r1
20000b32:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
20000b34:	687b      	ldr	r3, [r7, #4]
20000b36:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20000b3a:	687b      	ldr	r3, [r7, #4]
20000b3c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000b40:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
20000b44:	ea4f 1343 	mov.w	r3, r3, lsl #5
20000b48:	441a      	add	r2, r3
20000b4a:	78fb      	ldrb	r3, [r7, #3]
20000b4c:	ea4f 0383 	mov.w	r3, r3, lsl #2
20000b50:	4413      	add	r3, r2
20000b52:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
20000b56:	681b      	ldr	r3, [r3, #0]
20000b58:	b2db      	uxtb	r3, r3
}
20000b5a:	4618      	mov	r0, r3
20000b5c:	f107 070c 	add.w	r7, r7, #12
20000b60:	46bd      	mov	sp, r7
20000b62:	bc80      	pop	{r7}
20000b64:	4770      	bx	lr
20000b66:	bf00      	nop

20000b68 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
20000b68:	b580      	push	{r7, lr}
20000b6a:	b084      	sub	sp, #16
20000b6c:	af00      	add	r7, sp, #0
20000b6e:	60f8      	str	r0, [r7, #12]
20000b70:	60b9      	str	r1, [r7, #8]
20000b72:	4613      	mov	r3, r2
20000b74:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20000b76:	68fa      	ldr	r2, [r7, #12]
20000b78:	f242 7374 	movw	r3, #10100	; 0x2774
20000b7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b80:	429a      	cmp	r2, r3
20000b82:	d007      	beq.n	20000b94 <MSS_UART_init+0x2c>
20000b84:	68fa      	ldr	r2, [r7, #12]
20000b86:	f242 7334 	movw	r3, #10036	; 0x2734
20000b8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b8e:	429a      	cmp	r2, r3
20000b90:	d000      	beq.n	20000b94 <MSS_UART_init+0x2c>
20000b92:	be00      	bkpt	0x0000

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
20000b94:	79fb      	ldrb	r3, [r7, #7]
20000b96:	68f8      	ldr	r0, [r7, #12]
20000b98:	68b9      	ldr	r1, [r7, #8]
20000b9a:	461a      	mov	r2, r3
20000b9c:	f000 f988 	bl	20000eb0 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
20000ba0:	68fb      	ldr	r3, [r7, #12]
20000ba2:	681b      	ldr	r3, [r3, #0]
20000ba4:	f103 0330 	add.w	r3, r3, #48	; 0x30
20000ba8:	4618      	mov	r0, r3
20000baa:	f04f 0103 	mov.w	r1, #3
20000bae:	f7ff ff9b 	bl	20000ae8 <clear_bit_reg8>

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
20000bb2:	68fb      	ldr	r3, [r7, #12]
20000bb4:	681b      	ldr	r3, [r3, #0]
20000bb6:	f103 0334 	add.w	r3, r3, #52	; 0x34
20000bba:	4618      	mov	r0, r3
20000bbc:	f04f 0102 	mov.w	r1, #2
20000bc0:	f7ff ff92 	bl	20000ae8 <clear_bit_reg8>

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
20000bc4:	68fb      	ldr	r3, [r7, #12]
20000bc6:	681b      	ldr	r3, [r3, #0]
20000bc8:	f103 0338 	add.w	r3, r3, #56	; 0x38
20000bcc:	4618      	mov	r0, r3
20000bce:	f04f 0100 	mov.w	r1, #0
20000bd2:	f7ff ff89 	bl	20000ae8 <clear_bit_reg8>

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
20000bd6:	68fa      	ldr	r2, [r7, #12]
20000bd8:	f241 3349 	movw	r3, #4937	; 0x1349
20000bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000be0:	6253      	str	r3, [r2, #36]	; 0x24
}
20000be2:	f107 0710 	add.w	r7, r7, #16
20000be6:	46bd      	mov	sp, r7
20000be8:	bd80      	pop	{r7, pc}
20000bea:	bf00      	nop

20000bec <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
20000bec:	b480      	push	{r7}
20000bee:	b089      	sub	sp, #36	; 0x24
20000bf0:	af00      	add	r7, sp, #0
20000bf2:	60f8      	str	r0, [r7, #12]
20000bf4:	60b9      	str	r1, [r7, #8]
20000bf6:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0u;
20000bf8:	f04f 0300 	mov.w	r3, #0
20000bfc:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20000bfe:	68fa      	ldr	r2, [r7, #12]
20000c00:	f242 7374 	movw	r3, #10100	; 0x2774
20000c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c08:	429a      	cmp	r2, r3
20000c0a:	d007      	beq.n	20000c1c <MSS_UART_polled_tx+0x30>
20000c0c:	68fa      	ldr	r2, [r7, #12]
20000c0e:	f242 7334 	movw	r3, #10036	; 0x2734
20000c12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c16:	429a      	cmp	r2, r3
20000c18:	d000      	beq.n	20000c1c <MSS_UART_polled_tx+0x30>
20000c1a:	be00      	bkpt	0x0000
    ASSERT(pbuff != ( (uint8_t *)0));
20000c1c:	68bb      	ldr	r3, [r7, #8]
20000c1e:	2b00      	cmp	r3, #0
20000c20:	d100      	bne.n	20000c24 <MSS_UART_polled_tx+0x38>
20000c22:	be00      	bkpt	0x0000
    ASSERT(tx_size > 0u);
20000c24:	687b      	ldr	r3, [r7, #4]
20000c26:	2b00      	cmp	r3, #0
20000c28:	d100      	bne.n	20000c2c <MSS_UART_polled_tx+0x40>
20000c2a:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20000c2c:	68fa      	ldr	r2, [r7, #12]
20000c2e:	f242 7374 	movw	r3, #10100	; 0x2774
20000c32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c36:	429a      	cmp	r2, r3
20000c38:	d006      	beq.n	20000c48 <MSS_UART_polled_tx+0x5c>
20000c3a:	68fa      	ldr	r2, [r7, #12]
20000c3c:	f242 7334 	movw	r3, #10036	; 0x2734
20000c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c44:	429a      	cmp	r2, r3
20000c46:	d13d      	bne.n	20000cc4 <MSS_UART_polled_tx+0xd8>
20000c48:	68bb      	ldr	r3, [r7, #8]
20000c4a:	2b00      	cmp	r3, #0
20000c4c:	d03a      	beq.n	20000cc4 <MSS_UART_polled_tx+0xd8>
20000c4e:	687b      	ldr	r3, [r7, #4]
20000c50:	2b00      	cmp	r3, #0
20000c52:	d037      	beq.n	20000cc4 <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
20000c54:	68fb      	ldr	r3, [r7, #12]
20000c56:	681b      	ldr	r3, [r3, #0]
20000c58:	7d1b      	ldrb	r3, [r3, #20]
20000c5a:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
20000c5c:	68fb      	ldr	r3, [r7, #12]
20000c5e:	7b5a      	ldrb	r2, [r3, #13]
20000c60:	7efb      	ldrb	r3, [r7, #27]
20000c62:	ea42 0303 	orr.w	r3, r2, r3
20000c66:	b2da      	uxtb	r2, r3
20000c68:	68fb      	ldr	r3, [r7, #12]
20000c6a:	735a      	strb	r2, [r3, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
20000c6c:	7efb      	ldrb	r3, [r7, #27]
20000c6e:	f003 0320 	and.w	r3, r3, #32
20000c72:	2b00      	cmp	r3, #0
20000c74:	d023      	beq.n	20000cbe <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
20000c76:	f04f 0310 	mov.w	r3, #16
20000c7a:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
20000c7c:	687b      	ldr	r3, [r7, #4]
20000c7e:	2b0f      	cmp	r3, #15
20000c80:	d801      	bhi.n	20000c86 <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
20000c82:	687b      	ldr	r3, [r7, #4]
20000c84:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
20000c86:	f04f 0300 	mov.w	r3, #0
20000c8a:	617b      	str	r3, [r7, #20]
20000c8c:	e00e      	b.n	20000cac <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
20000c8e:	68fb      	ldr	r3, [r7, #12]
20000c90:	681b      	ldr	r3, [r3, #0]
20000c92:	68b9      	ldr	r1, [r7, #8]
20000c94:	693a      	ldr	r2, [r7, #16]
20000c96:	440a      	add	r2, r1
20000c98:	7812      	ldrb	r2, [r2, #0]
20000c9a:	701a      	strb	r2, [r3, #0]
                    char_idx++;
20000c9c:	693b      	ldr	r3, [r7, #16]
20000c9e:	f103 0301 	add.w	r3, r3, #1
20000ca2:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
20000ca4:	697b      	ldr	r3, [r7, #20]
20000ca6:	f103 0301 	add.w	r3, r3, #1
20000caa:	617b      	str	r3, [r7, #20]
20000cac:	697a      	ldr	r2, [r7, #20]
20000cae:	69fb      	ldr	r3, [r7, #28]
20000cb0:	429a      	cmp	r2, r3
20000cb2:	d3ec      	bcc.n	20000c8e <MSS_UART_polled_tx+0xa2>
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
20000cb4:	687a      	ldr	r2, [r7, #4]
20000cb6:	697b      	ldr	r3, [r7, #20]
20000cb8:	ebc3 0302 	rsb	r3, r3, r2
20000cbc:	607b      	str	r3, [r7, #4]
            }
        } while(tx_size);
20000cbe:	687b      	ldr	r3, [r7, #4]
20000cc0:	2b00      	cmp	r3, #0
20000cc2:	d1c7      	bne.n	20000c54 <MSS_UART_polled_tx+0x68>
    }
}
20000cc4:	f107 0724 	add.w	r7, r7, #36	; 0x24
20000cc8:	46bd      	mov	sp, r7
20000cca:	bc80      	pop	{r7}
20000ccc:	4770      	bx	lr
20000cce:	bf00      	nop

20000cd0 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
20000cd0:	4668      	mov	r0, sp
20000cd2:	f020 0107 	bic.w	r1, r0, #7
20000cd6:	468d      	mov	sp, r1
20000cd8:	b589      	push	{r0, r3, r7, lr}
20000cda:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
20000cdc:	f242 7074 	movw	r0, #10100	; 0x2774
20000ce0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ce4:	f000 fa1a 	bl	2000111c <MSS_UART_isr>
}
20000ce8:	46bd      	mov	sp, r7
20000cea:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20000cee:	4685      	mov	sp, r0
20000cf0:	4770      	bx	lr
20000cf2:	bf00      	nop

20000cf4 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
20000cf4:	4668      	mov	r0, sp
20000cf6:	f020 0107 	bic.w	r1, r0, #7
20000cfa:	468d      	mov	sp, r1
20000cfc:	b589      	push	{r0, r3, r7, lr}
20000cfe:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
20000d00:	f242 7034 	movw	r0, #10036	; 0x2734
20000d04:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000d08:	f000 fa08 	bl	2000111c <MSS_UART_isr>
}
20000d0c:	46bd      	mov	sp, r7
20000d0e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20000d12:	4685      	mov	sp, r0
20000d14:	4770      	bx	lr
20000d16:	bf00      	nop

20000d18 <config_baud_divisors>:
config_baud_divisors
(
    mss_uart_instance_t * this_uart,
    uint32_t baudrate    
)
{
20000d18:	b580      	push	{r7, lr}
20000d1a:	b088      	sub	sp, #32
20000d1c:	af00      	add	r7, sp, #0
20000d1e:	6078      	str	r0, [r7, #4]
20000d20:	6039      	str	r1, [r7, #0]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20000d22:	687a      	ldr	r2, [r7, #4]
20000d24:	f242 7374 	movw	r3, #10100	; 0x2774
20000d28:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d2c:	429a      	cmp	r2, r3
20000d2e:	d007      	beq.n	20000d40 <config_baud_divisors+0x28>
20000d30:	687a      	ldr	r2, [r7, #4]
20000d32:	f242 7334 	movw	r3, #10036	; 0x2734
20000d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d3a:	429a      	cmp	r2, r3
20000d3c:	d000      	beq.n	20000d40 <config_baud_divisors+0x28>
20000d3e:	be00      	bkpt	0x0000
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20000d40:	687a      	ldr	r2, [r7, #4]
20000d42:	f242 7374 	movw	r3, #10100	; 0x2774
20000d46:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d4a:	429a      	cmp	r2, r3
20000d4c:	d007      	beq.n	20000d5e <config_baud_divisors+0x46>
20000d4e:	687a      	ldr	r2, [r7, #4]
20000d50:	f242 7334 	movw	r3, #10036	; 0x2734
20000d54:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d58:	429a      	cmp	r2, r3
20000d5a:	f040 80a4 	bne.w	20000ea6 <config_baud_divisors+0x18e>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
20000d5e:	687b      	ldr	r3, [r7, #4]
20000d60:	683a      	ldr	r2, [r7, #0]
20000d62:	609a      	str	r2, [r3, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
20000d64:	f001 faa8 	bl	200022b8 <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
20000d68:	687a      	ldr	r2, [r7, #4]
20000d6a:	f242 7374 	movw	r3, #10100	; 0x2774
20000d6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d72:	429a      	cmp	r2, r3
20000d74:	d106      	bne.n	20000d84 <config_baud_divisors+0x6c>
        {
            pclk_freq = g_FrequencyPCLK0;
20000d76:	f242 63cc 	movw	r3, #9932	; 0x26cc
20000d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d7e:	681b      	ldr	r3, [r3, #0]
20000d80:	61fb      	str	r3, [r7, #28]
20000d82:	e005      	b.n	20000d90 <config_baud_divisors+0x78>
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
20000d84:	f242 63d0 	movw	r3, #9936	; 0x26d0
20000d88:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d8c:	681b      	ldr	r3, [r3, #0]
20000d8e:	61fb      	str	r3, [r7, #28]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
20000d90:	69fb      	ldr	r3, [r7, #28]
20000d92:	ea4f 02c3 	mov.w	r2, r3, lsl #3
20000d96:	683b      	ldr	r3, [r7, #0]
20000d98:	fbb2 f3f3 	udiv	r3, r2, r3
20000d9c:	617b      	str	r3, [r7, #20]
        baud_value_by_64 = baud_value_by_128 / 2u;
20000d9e:	697b      	ldr	r3, [r7, #20]
20000da0:	ea4f 0353 	mov.w	r3, r3, lsr #1
20000da4:	613b      	str	r3, [r7, #16]
        baud_value = baud_value_by_64 / 64u;
20000da6:	693b      	ldr	r3, [r7, #16]
20000da8:	ea4f 1393 	mov.w	r3, r3, lsr #6
20000dac:	60fb      	str	r3, [r7, #12]
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
20000dae:	68fb      	ldr	r3, [r7, #12]
20000db0:	ea4f 1383 	mov.w	r3, r3, lsl #6
20000db4:	693a      	ldr	r2, [r7, #16]
20000db6:	ebc3 0302 	rsb	r3, r3, r2
20000dba:	61bb      	str	r3, [r7, #24]
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
20000dbc:	68fb      	ldr	r3, [r7, #12]
20000dbe:	ea4f 13c3 	mov.w	r3, r3, lsl #7
20000dc2:	697a      	ldr	r2, [r7, #20]
20000dc4:	ebc3 0202 	rsb	r2, r3, r2
20000dc8:	69bb      	ldr	r3, [r7, #24]
20000dca:	ea4f 0343 	mov.w	r3, r3, lsl #1
20000dce:	ebc3 0302 	rsb	r3, r3, r2
20000dd2:	69ba      	ldr	r2, [r7, #24]
20000dd4:	4413      	add	r3, r2
20000dd6:	61bb      	str	r3, [r7, #24]
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
20000dd8:	68fa      	ldr	r2, [r7, #12]
20000dda:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000dde:	429a      	cmp	r2, r3
20000de0:	d900      	bls.n	20000de4 <config_baud_divisors+0xcc>
20000de2:	be00      	bkpt	0x0000
    
        if(baud_value <= (uint32_t)UINT16_MAX)
20000de4:	68fa      	ldr	r2, [r7, #12]
20000de6:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000dea:	429a      	cmp	r2, r3
20000dec:	d85b      	bhi.n	20000ea6 <config_baud_divisors+0x18e>
        {
            if(baud_value > 1u)
20000dee:	68fb      	ldr	r3, [r7, #12]
20000df0:	2b01      	cmp	r3, #1
20000df2:	d931      	bls.n	20000e58 <config_baud_divisors+0x140>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20000df4:	687b      	ldr	r3, [r7, #4]
20000df6:	681b      	ldr	r3, [r3, #0]
20000df8:	f103 030c 	add.w	r3, r3, #12
20000dfc:	4618      	mov	r0, r3
20000dfe:	f04f 0107 	mov.w	r1, #7
20000e02:	f7ff fe51 	bl	20000aa8 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
20000e06:	687b      	ldr	r3, [r7, #4]
20000e08:	681b      	ldr	r3, [r3, #0]
20000e0a:	68fa      	ldr	r2, [r7, #12]
20000e0c:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000e10:	b2d2      	uxtb	r2, r2
20000e12:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
20000e14:	687b      	ldr	r3, [r7, #4]
20000e16:	681b      	ldr	r3, [r3, #0]
20000e18:	68fa      	ldr	r2, [r7, #12]
20000e1a:	b2d2      	uxtb	r2, r2
20000e1c:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20000e1e:	687b      	ldr	r3, [r7, #4]
20000e20:	681b      	ldr	r3, [r3, #0]
20000e22:	f103 030c 	add.w	r3, r3, #12
20000e26:	4618      	mov	r0, r3
20000e28:	f04f 0107 	mov.w	r1, #7
20000e2c:	f7ff fe5c 	bl	20000ae8 <clear_bit_reg8>
        
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
20000e30:	687b      	ldr	r3, [r7, #4]
20000e32:	681b      	ldr	r3, [r3, #0]
20000e34:	f103 0330 	add.w	r3, r3, #48	; 0x30
20000e38:	4618      	mov	r0, r3
20000e3a:	f04f 0107 	mov.w	r1, #7
20000e3e:	f7ff fe33 	bl	20000aa8 <set_bit_reg8>
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
20000e42:	69bb      	ldr	r3, [r7, #24]
20000e44:	2bff      	cmp	r3, #255	; 0xff
20000e46:	d900      	bls.n	20000e4a <config_baud_divisors+0x132>
20000e48:	be00      	bkpt	0x0000
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
20000e4a:	687b      	ldr	r3, [r7, #4]
20000e4c:	681b      	ldr	r3, [r3, #0]
20000e4e:	69ba      	ldr	r2, [r7, #24]
20000e50:	b2d2      	uxtb	r2, r2
20000e52:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
20000e56:	e026      	b.n	20000ea6 <config_baud_divisors+0x18e>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20000e58:	687b      	ldr	r3, [r7, #4]
20000e5a:	681b      	ldr	r3, [r3, #0]
20000e5c:	f103 030c 	add.w	r3, r3, #12
20000e60:	4618      	mov	r0, r3
20000e62:	f04f 0107 	mov.w	r1, #7
20000e66:	f7ff fe1f 	bl	20000aa8 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
20000e6a:	687b      	ldr	r3, [r7, #4]
20000e6c:	681b      	ldr	r3, [r3, #0]
20000e6e:	68fa      	ldr	r2, [r7, #12]
20000e70:	ea4f 2212 	mov.w	r2, r2, lsr #8
20000e74:	b2d2      	uxtb	r2, r2
20000e76:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
20000e78:	687b      	ldr	r3, [r7, #4]
20000e7a:	681b      	ldr	r3, [r3, #0]
20000e7c:	68fa      	ldr	r2, [r7, #12]
20000e7e:	b2d2      	uxtb	r2, r2
20000e80:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20000e82:	687b      	ldr	r3, [r7, #4]
20000e84:	681b      	ldr	r3, [r3, #0]
20000e86:	f103 030c 	add.w	r3, r3, #12
20000e8a:	4618      	mov	r0, r3
20000e8c:	f04f 0107 	mov.w	r1, #7
20000e90:	f7ff fe2a 	bl	20000ae8 <clear_bit_reg8>
                
                /* Disable Fractional baud rate */
                clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
20000e94:	687b      	ldr	r3, [r7, #4]
20000e96:	681b      	ldr	r3, [r3, #0]
20000e98:	f103 0330 	add.w	r3, r3, #48	; 0x30
20000e9c:	4618      	mov	r0, r3
20000e9e:	f04f 0107 	mov.w	r1, #7
20000ea2:	f7ff fe21 	bl	20000ae8 <clear_bit_reg8>
            }
        }
    }
}
20000ea6:	f107 0720 	add.w	r7, r7, #32
20000eaa:	46bd      	mov	sp, r7
20000eac:	bd80      	pop	{r7, pc}
20000eae:	bf00      	nop

20000eb0 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
20000eb0:	b580      	push	{r7, lr}
20000eb2:	b084      	sub	sp, #16
20000eb4:	af00      	add	r7, sp, #0
20000eb6:	60f8      	str	r0, [r7, #12]
20000eb8:	60b9      	str	r1, [r7, #8]
20000eba:	4613      	mov	r3, r2
20000ebc:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20000ebe:	68fa      	ldr	r2, [r7, #12]
20000ec0:	f242 7374 	movw	r3, #10100	; 0x2774
20000ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ec8:	429a      	cmp	r2, r3
20000eca:	d007      	beq.n	20000edc <global_init+0x2c>
20000ecc:	68fa      	ldr	r2, [r7, #12]
20000ece:	f242 7334 	movw	r3, #10036	; 0x2734
20000ed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ed6:	429a      	cmp	r2, r3
20000ed8:	d000      	beq.n	20000edc <global_init+0x2c>
20000eda:	be00      	bkpt	0x0000

    if(this_uart == &g_mss_uart0)
20000edc:	68fa      	ldr	r2, [r7, #12]
20000ede:	f242 7374 	movw	r3, #10100	; 0x2774
20000ee2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ee6:	429a      	cmp	r2, r3
20000ee8:	d124      	bne.n	20000f34 <global_init+0x84>
    {
        this_uart->hw_reg = UART0;
20000eea:	68fb      	ldr	r3, [r7, #12]
20000eec:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
20000ef0:	601a      	str	r2, [r3, #0]
        this_uart->irqn = UART0_IRQn;
20000ef2:	68fb      	ldr	r3, [r7, #12]
20000ef4:	f04f 020a 	mov.w	r2, #10
20000ef8:	711a      	strb	r2, [r3, #4]
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
20000efa:	f248 0300 	movw	r3, #32768	; 0x8000
20000efe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000f02:	f248 0200 	movw	r2, #32768	; 0x8000
20000f06:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000f0a:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000f0c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20000f10:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
20000f12:	f04f 000a 	mov.w	r0, #10
20000f16:	f7ff fda9 	bl	20000a6c <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
20000f1a:	f248 0300 	movw	r3, #32768	; 0x8000
20000f1e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000f22:	f248 0200 	movw	r2, #32768	; 0x8000
20000f26:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000f2a:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000f2c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
20000f30:	649a      	str	r2, [r3, #72]	; 0x48
20000f32:	e025      	b.n	20000f80 <global_init+0xd0>
    }
    else
    {
        this_uart->hw_reg = UART1;
20000f34:	68fa      	ldr	r2, [r7, #12]
20000f36:	f240 0300 	movw	r3, #0
20000f3a:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000f3e:	6013      	str	r3, [r2, #0]
        this_uart->irqn = UART1_IRQn;
20000f40:	68fb      	ldr	r3, [r7, #12]
20000f42:	f04f 020b 	mov.w	r2, #11
20000f46:	711a      	strb	r2, [r3, #4]
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
20000f48:	f248 0300 	movw	r3, #32768	; 0x8000
20000f4c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000f50:	f248 0200 	movw	r2, #32768	; 0x8000
20000f54:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000f58:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000f5a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20000f5e:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
20000f60:	f04f 000b 	mov.w	r0, #11
20000f64:	f7ff fd82 	bl	20000a6c <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
20000f68:	f248 0300 	movw	r3, #32768	; 0x8000
20000f6c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000f70:	f248 0200 	movw	r2, #32768	; 0x8000
20000f74:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000f78:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000f7a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20000f7e:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
20000f80:	68fb      	ldr	r3, [r7, #12]
20000f82:	681b      	ldr	r3, [r3, #0]
20000f84:	f04f 0200 	mov.w	r2, #0
20000f88:	711a      	strb	r2, [r3, #4]

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
20000f8a:	68fb      	ldr	r3, [r7, #12]
20000f8c:	681b      	ldr	r3, [r3, #0]
20000f8e:	f04f 0200 	mov.w	r2, #0
20000f92:	721a      	strb	r2, [r3, #8]
    /* clear receiver FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_RX_FIFO);
20000f94:	68fb      	ldr	r3, [r7, #12]
20000f96:	681b      	ldr	r3, [r3, #0]
20000f98:	f103 0308 	add.w	r3, r3, #8
20000f9c:	4618      	mov	r0, r3
20000f9e:	f04f 0101 	mov.w	r1, #1
20000fa2:	f7ff fd81 	bl	20000aa8 <set_bit_reg8>
    /* clear transmitter FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_TX_FIFO);
20000fa6:	68fb      	ldr	r3, [r7, #12]
20000fa8:	681b      	ldr	r3, [r3, #0]
20000faa:	f103 0308 	add.w	r3, r3, #8
20000fae:	4618      	mov	r0, r3
20000fb0:	f04f 0102 	mov.w	r1, #2
20000fb4:	f7ff fd78 	bl	20000aa8 <set_bit_reg8>

    /* set default READY mode : Mode 0*/
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);
20000fb8:	68fb      	ldr	r3, [r7, #12]
20000fba:	681b      	ldr	r3, [r3, #0]
20000fbc:	f103 0308 	add.w	r3, r3, #8
20000fc0:	4618      	mov	r0, r3
20000fc2:	f04f 0100 	mov.w	r1, #0
20000fc6:	f7ff fd6f 	bl	20000aa8 <set_bit_reg8>

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
20000fca:	68fb      	ldr	r3, [r7, #12]
20000fcc:	681b      	ldr	r3, [r3, #0]
20000fce:	f103 0310 	add.w	r3, r3, #16
20000fd2:	4618      	mov	r0, r3
20000fd4:	f04f 0104 	mov.w	r1, #4
20000fd8:	f7ff fd86 	bl	20000ae8 <clear_bit_reg8>
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);
20000fdc:	68fb      	ldr	r3, [r7, #12]
20000fde:	681b      	ldr	r3, [r3, #0]
20000fe0:	f103 0310 	add.w	r3, r3, #16
20000fe4:	4618      	mov	r0, r3
20000fe6:	f04f 0105 	mov.w	r1, #5
20000fea:	f7ff fd7d 	bl	20000ae8 <clear_bit_reg8>

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
20000fee:	68fb      	ldr	r3, [r7, #12]
20000ff0:	681b      	ldr	r3, [r3, #0]
20000ff2:	f103 0334 	add.w	r3, r3, #52	; 0x34
20000ff6:	4618      	mov	r0, r3
20000ff8:	f04f 0101 	mov.w	r1, #1
20000ffc:	f7ff fd74 	bl	20000ae8 <clear_bit_reg8>
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);
20001000:	68fb      	ldr	r3, [r7, #12]
20001002:	681b      	ldr	r3, [r3, #0]
20001004:	f103 0334 	add.w	r3, r3, #52	; 0x34
20001008:	4618      	mov	r0, r3
2000100a:	f04f 0100 	mov.w	r1, #0
2000100e:	f7ff fd6b 	bl	20000ae8 <clear_bit_reg8>

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
20001012:	68fb      	ldr	r3, [r7, #12]
20001014:	681b      	ldr	r3, [r3, #0]
20001016:	f103 0338 	add.w	r3, r3, #56	; 0x38
2000101a:	4618      	mov	r0, r3
2000101c:	f04f 0101 	mov.w	r1, #1
20001020:	f7ff fd62 	bl	20000ae8 <clear_bit_reg8>

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
20001024:	68fb      	ldr	r3, [r7, #12]
20001026:	681b      	ldr	r3, [r3, #0]
20001028:	f103 0330 	add.w	r3, r3, #48	; 0x30
2000102c:	4618      	mov	r0, r3
2000102e:	f04f 0105 	mov.w	r1, #5
20001032:	f7ff fd59 	bl	20000ae8 <clear_bit_reg8>

    /* set default RX timeout */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO); 
20001036:	68fb      	ldr	r3, [r7, #12]
20001038:	681b      	ldr	r3, [r3, #0]
2000103a:	f103 0330 	add.w	r3, r3, #48	; 0x30
2000103e:	4618      	mov	r0, r3
20001040:	f04f 0106 	mov.w	r1, #6
20001044:	f7ff fd50 	bl	20000ae8 <clear_bit_reg8>

    /* disable fractional baud-rate */
    clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR); 
20001048:	68fb      	ldr	r3, [r7, #12]
2000104a:	681b      	ldr	r3, [r3, #0]
2000104c:	f103 0330 	add.w	r3, r3, #48	; 0x30
20001050:	4618      	mov	r0, r3
20001052:	f04f 0107 	mov.w	r1, #7
20001056:	f7ff fd47 	bl	20000ae8 <clear_bit_reg8>

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
2000105a:	68fb      	ldr	r3, [r7, #12]
2000105c:	681b      	ldr	r3, [r3, #0]
2000105e:	f103 0338 	add.w	r3, r3, #56	; 0x38
20001062:	4618      	mov	r0, r3
20001064:	f04f 0103 	mov.w	r1, #3
20001068:	f7ff fd3e 	bl	20000ae8 <clear_bit_reg8>

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
2000106c:	68fb      	ldr	r3, [r7, #12]
2000106e:	681b      	ldr	r3, [r3, #0]
20001070:	f04f 0200 	mov.w	r2, #0
20001074:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
20001078:	68fb      	ldr	r3, [r7, #12]
2000107a:	681b      	ldr	r3, [r3, #0]
2000107c:	f04f 0200 	mov.w	r2, #0
20001080:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
20001084:	68fb      	ldr	r3, [r7, #12]
20001086:	681b      	ldr	r3, [r3, #0]
20001088:	f04f 0200 	mov.w	r2, #0
2000108c:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    
    /* 
     * Configure baud rate divisors. This uses the frational baud rate divisor
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);
20001090:	68f8      	ldr	r0, [r7, #12]
20001092:	68b9      	ldr	r1, [r7, #8]
20001094:	f7ff fe40 	bl	20000d18 <config_baud_divisors>

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
20001098:	68fb      	ldr	r3, [r7, #12]
2000109a:	681b      	ldr	r3, [r3, #0]
2000109c:	79fa      	ldrb	r2, [r7, #7]
2000109e:	731a      	strb	r2, [r3, #12]

    /* Instance setup */
    this_uart->baudrate = baud_rate;
200010a0:	68fb      	ldr	r3, [r7, #12]
200010a2:	68ba      	ldr	r2, [r7, #8]
200010a4:	609a      	str	r2, [r3, #8]
    this_uart->lineconfig = line_config;
200010a6:	68fb      	ldr	r3, [r7, #12]
200010a8:	79fa      	ldrb	r2, [r7, #7]
200010aa:	731a      	strb	r2, [r3, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
200010ac:	68fb      	ldr	r3, [r7, #12]
200010ae:	f04f 0200 	mov.w	r2, #0
200010b2:	615a      	str	r2, [r3, #20]
    this_uart->tx_buffer = (const uint8_t *)0;
200010b4:	68fb      	ldr	r3, [r7, #12]
200010b6:	f04f 0200 	mov.w	r2, #0
200010ba:	611a      	str	r2, [r3, #16]
    this_uart->tx_idx = 0u;
200010bc:	68fb      	ldr	r3, [r7, #12]
200010be:	f04f 0200 	mov.w	r2, #0
200010c2:	619a      	str	r2, [r3, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
200010c4:	68fb      	ldr	r3, [r7, #12]
200010c6:	f04f 0200 	mov.w	r2, #0
200010ca:	621a      	str	r2, [r3, #32]
    this_uart->tx_handler       = NULL_HANDLER;
200010cc:	68fb      	ldr	r3, [r7, #12]
200010ce:	f04f 0200 	mov.w	r2, #0
200010d2:	625a      	str	r2, [r3, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
200010d4:	68fb      	ldr	r3, [r7, #12]
200010d6:	f04f 0200 	mov.w	r2, #0
200010da:	61da      	str	r2, [r3, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
200010dc:	68fb      	ldr	r3, [r7, #12]
200010de:	f04f 0200 	mov.w	r2, #0
200010e2:	629a      	str	r2, [r3, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
200010e4:	68fb      	ldr	r3, [r7, #12]
200010e6:	f04f 0200 	mov.w	r2, #0
200010ea:	62da      	str	r2, [r3, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
200010ec:	68fb      	ldr	r3, [r7, #12]
200010ee:	f04f 0200 	mov.w	r2, #0
200010f2:	631a      	str	r2, [r3, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
200010f4:	68fb      	ldr	r3, [r7, #12]
200010f6:	f04f 0200 	mov.w	r2, #0
200010fa:	635a      	str	r2, [r3, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
200010fc:	68fb      	ldr	r3, [r7, #12]
200010fe:	f04f 0200 	mov.w	r2, #0
20001102:	639a      	str	r2, [r3, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
20001104:	68fb      	ldr	r3, [r7, #12]
20001106:	f04f 0200 	mov.w	r2, #0
2000110a:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
2000110c:	68fb      	ldr	r3, [r7, #12]
2000110e:	f04f 0200 	mov.w	r2, #0
20001112:	735a      	strb	r2, [r3, #13]
}
20001114:	f107 0710 	add.w	r7, r7, #16
20001118:	46bd      	mov	sp, r7
2000111a:	bd80      	pop	{r7, pc}

2000111c <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
2000111c:	b580      	push	{r7, lr}
2000111e:	b084      	sub	sp, #16
20001120:	af00      	add	r7, sp, #0
20001122:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20001124:	687a      	ldr	r2, [r7, #4]
20001126:	f242 7374 	movw	r3, #10100	; 0x2774
2000112a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000112e:	429a      	cmp	r2, r3
20001130:	d007      	beq.n	20001142 <MSS_UART_isr+0x26>
20001132:	687a      	ldr	r2, [r7, #4]
20001134:	f242 7334 	movw	r3, #10036	; 0x2734
20001138:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000113c:	429a      	cmp	r2, r3
2000113e:	d000      	beq.n	20001142 <MSS_UART_isr+0x26>
20001140:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20001142:	687a      	ldr	r2, [r7, #4]
20001144:	f242 7374 	movw	r3, #10100	; 0x2774
20001148:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000114c:	429a      	cmp	r2, r3
2000114e:	d007      	beq.n	20001160 <MSS_UART_isr+0x44>
20001150:	687a      	ldr	r2, [r7, #4]
20001152:	f242 7334 	movw	r3, #10036	; 0x2734
20001156:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000115a:	429a      	cmp	r2, r3
2000115c:	f040 80ef 	bne.w	2000133e <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
20001160:	687b      	ldr	r3, [r7, #4]
20001162:	681b      	ldr	r3, [r3, #0]
20001164:	7a1b      	ldrb	r3, [r3, #8]
20001166:	b2db      	uxtb	r3, r3
20001168:	f003 030f 	and.w	r3, r3, #15
2000116c:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
2000116e:	7bfb      	ldrb	r3, [r7, #15]
20001170:	2b0c      	cmp	r3, #12
20001172:	f200 80d7 	bhi.w	20001324 <MSS_UART_isr+0x208>
20001176:	a201      	add	r2, pc, #4	; (adr r2, 2000117c <MSS_UART_isr+0x60>)
20001178:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000117c:	200011b1 	.word	0x200011b1
20001180:	20001325 	.word	0x20001325
20001184:	200011cf 	.word	0x200011cf
20001188:	20001229 	.word	0x20001229
2000118c:	200011ed 	.word	0x200011ed
20001190:	20001325 	.word	0x20001325
20001194:	2000120b 	.word	0x2000120b
20001198:	20001325 	.word	0x20001325
2000119c:	20001325 	.word	0x20001325
200011a0:	20001325 	.word	0x20001325
200011a4:	20001325 	.word	0x20001325
200011a8:	20001325 	.word	0x20001325
200011ac:	200011ed 	.word	0x200011ed
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
200011b0:	687b      	ldr	r3, [r7, #4]
200011b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200011b4:	2b00      	cmp	r3, #0
200011b6:	d100      	bne.n	200011ba <MSS_UART_isr+0x9e>
200011b8:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
200011ba:	687b      	ldr	r3, [r7, #4]
200011bc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200011be:	2b00      	cmp	r3, #0
200011c0:	f000 80b2 	beq.w	20001328 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
200011c4:	687b      	ldr	r3, [r7, #4]
200011c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200011c8:	6878      	ldr	r0, [r7, #4]
200011ca:	4798      	blx	r3
                }
            }
            break;
200011cc:	e0b7      	b.n	2000133e <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
200011ce:	687b      	ldr	r3, [r7, #4]
200011d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200011d2:	2b00      	cmp	r3, #0
200011d4:	d100      	bne.n	200011d8 <MSS_UART_isr+0xbc>
200011d6:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
200011d8:	687b      	ldr	r3, [r7, #4]
200011da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200011dc:	2b00      	cmp	r3, #0
200011de:	f000 80a5 	beq.w	2000132c <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
200011e2:	687b      	ldr	r3, [r7, #4]
200011e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200011e6:	6878      	ldr	r0, [r7, #4]
200011e8:	4798      	blx	r3
                }
            }
            break;
200011ea:	e0a8      	b.n	2000133e <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
200011ec:	687b      	ldr	r3, [r7, #4]
200011ee:	6a1b      	ldr	r3, [r3, #32]
200011f0:	2b00      	cmp	r3, #0
200011f2:	d100      	bne.n	200011f6 <MSS_UART_isr+0xda>
200011f4:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
200011f6:	687b      	ldr	r3, [r7, #4]
200011f8:	6a1b      	ldr	r3, [r3, #32]
200011fa:	2b00      	cmp	r3, #0
200011fc:	f000 8098 	beq.w	20001330 <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
20001200:	687b      	ldr	r3, [r7, #4]
20001202:	6a1b      	ldr	r3, [r3, #32]
20001204:	6878      	ldr	r0, [r7, #4]
20001206:	4798      	blx	r3
                }
            }
            break;
20001208:	e099      	b.n	2000133e <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
2000120a:	687b      	ldr	r3, [r7, #4]
2000120c:	69db      	ldr	r3, [r3, #28]
2000120e:	2b00      	cmp	r3, #0
20001210:	d100      	bne.n	20001214 <MSS_UART_isr+0xf8>
20001212:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
20001214:	687b      	ldr	r3, [r7, #4]
20001216:	69db      	ldr	r3, [r3, #28]
20001218:	2b00      	cmp	r3, #0
2000121a:	f000 808b 	beq.w	20001334 <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
2000121e:	687b      	ldr	r3, [r7, #4]
20001220:	69db      	ldr	r3, [r3, #28]
20001222:	6878      	ldr	r0, [r7, #4]
20001224:	4798      	blx	r3
                }
            }
            break;
20001226:	e08a      	b.n	2000133e <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
20001228:	687b      	ldr	r3, [r7, #4]
2000122a:	681b      	ldr	r3, [r3, #0]
2000122c:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001230:	4618      	mov	r0, r3
20001232:	f04f 0100 	mov.w	r1, #0
20001236:	f7ff fc77 	bl	20000b28 <read_bit_reg8>
2000123a:	4603      	mov	r3, r0
2000123c:	2b00      	cmp	r3, #0
2000123e:	d00c      	beq.n	2000125a <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
20001240:	687b      	ldr	r3, [r7, #4]
20001242:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001244:	2b00      	cmp	r3, #0
20001246:	d100      	bne.n	2000124a <MSS_UART_isr+0x12e>
20001248:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
2000124a:	687b      	ldr	r3, [r7, #4]
2000124c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000124e:	2b00      	cmp	r3, #0
20001250:	d003      	beq.n	2000125a <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
20001252:	687b      	ldr	r3, [r7, #4]
20001254:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001256:	6878      	ldr	r0, [r7, #4]
20001258:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
2000125a:	687b      	ldr	r3, [r7, #4]
2000125c:	681b      	ldr	r3, [r3, #0]
2000125e:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001262:	4618      	mov	r0, r3
20001264:	f04f 0101 	mov.w	r1, #1
20001268:	f7ff fc5e 	bl	20000b28 <read_bit_reg8>
2000126c:	4603      	mov	r3, r0
2000126e:	2b00      	cmp	r3, #0
20001270:	d00c      	beq.n	2000128c <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
20001272:	687b      	ldr	r3, [r7, #4]
20001274:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001276:	2b00      	cmp	r3, #0
20001278:	d100      	bne.n	2000127c <MSS_UART_isr+0x160>
2000127a:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
2000127c:	687b      	ldr	r3, [r7, #4]
2000127e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001280:	2b00      	cmp	r3, #0
20001282:	d003      	beq.n	2000128c <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
20001284:	687b      	ldr	r3, [r7, #4]
20001286:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20001288:	6878      	ldr	r0, [r7, #4]
2000128a:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
2000128c:	687b      	ldr	r3, [r7, #4]
2000128e:	681b      	ldr	r3, [r3, #0]
20001290:	f103 0328 	add.w	r3, r3, #40	; 0x28
20001294:	4618      	mov	r0, r3
20001296:	f04f 0102 	mov.w	r1, #2
2000129a:	f7ff fc45 	bl	20000b28 <read_bit_reg8>
2000129e:	4603      	mov	r3, r0
200012a0:	2b00      	cmp	r3, #0
200012a2:	d00c      	beq.n	200012be <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
200012a4:	687b      	ldr	r3, [r7, #4]
200012a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200012a8:	2b00      	cmp	r3, #0
200012aa:	d100      	bne.n	200012ae <MSS_UART_isr+0x192>
200012ac:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
200012ae:	687b      	ldr	r3, [r7, #4]
200012b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200012b2:	2b00      	cmp	r3, #0
200012b4:	d003      	beq.n	200012be <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
200012b6:	687b      	ldr	r3, [r7, #4]
200012b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200012ba:	6878      	ldr	r0, [r7, #4]
200012bc:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
200012be:	687b      	ldr	r3, [r7, #4]
200012c0:	681b      	ldr	r3, [r3, #0]
200012c2:	f103 0328 	add.w	r3, r3, #40	; 0x28
200012c6:	4618      	mov	r0, r3
200012c8:	f04f 0103 	mov.w	r1, #3
200012cc:	f7ff fc2c 	bl	20000b28 <read_bit_reg8>
200012d0:	4603      	mov	r3, r0
200012d2:	2b00      	cmp	r3, #0
200012d4:	d00c      	beq.n	200012f0 <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
200012d6:	687b      	ldr	r3, [r7, #4]
200012d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200012da:	2b00      	cmp	r3, #0
200012dc:	d100      	bne.n	200012e0 <MSS_UART_isr+0x1c4>
200012de:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
200012e0:	687b      	ldr	r3, [r7, #4]
200012e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200012e4:	2b00      	cmp	r3, #0
200012e6:	d003      	beq.n	200012f0 <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
200012e8:	687b      	ldr	r3, [r7, #4]
200012ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200012ec:	6878      	ldr	r0, [r7, #4]
200012ee:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
200012f0:	687b      	ldr	r3, [r7, #4]
200012f2:	681b      	ldr	r3, [r3, #0]
200012f4:	f103 0328 	add.w	r3, r3, #40	; 0x28
200012f8:	4618      	mov	r0, r3
200012fa:	f04f 0104 	mov.w	r1, #4
200012fe:	f7ff fc13 	bl	20000b28 <read_bit_reg8>
20001302:	4603      	mov	r3, r0
20001304:	2b00      	cmp	r3, #0
20001306:	d017      	beq.n	20001338 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
20001308:	687b      	ldr	r3, [r7, #4]
2000130a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000130c:	2b00      	cmp	r3, #0
2000130e:	d100      	bne.n	20001312 <MSS_UART_isr+0x1f6>
20001310:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
20001312:	687b      	ldr	r3, [r7, #4]
20001314:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20001316:	2b00      	cmp	r3, #0
20001318:	d010      	beq.n	2000133c <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
2000131a:	687b      	ldr	r3, [r7, #4]
2000131c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000131e:	6878      	ldr	r0, [r7, #4]
20001320:	4798      	blx	r3
                    }
                }
                break;
20001322:	e00c      	b.n	2000133e <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
20001324:	be00      	bkpt	0x0000
20001326:	e00a      	b.n	2000133e <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
20001328:	bf00      	nop
2000132a:	e008      	b.n	2000133e <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
2000132c:	bf00      	nop
2000132e:	e006      	b.n	2000133e <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
20001330:	bf00      	nop
20001332:	e004      	b.n	2000133e <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
20001334:	bf00      	nop
20001336:	e002      	b.n	2000133e <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
20001338:	bf00      	nop
2000133a:	e000      	b.n	2000133e <MSS_UART_isr+0x222>
2000133c:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
2000133e:	f107 0710 	add.w	r7, r7, #16
20001342:	46bd      	mov	sp, r7
20001344:	bd80      	pop	{r7, pc}
20001346:	bf00      	nop

20001348 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
20001348:	b580      	push	{r7, lr}
2000134a:	b086      	sub	sp, #24
2000134c:	af00      	add	r7, sp, #0
2000134e:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20001350:	687a      	ldr	r2, [r7, #4]
20001352:	f242 7374 	movw	r3, #10100	; 0x2774
20001356:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000135a:	429a      	cmp	r2, r3
2000135c:	d007      	beq.n	2000136e <default_tx_handler+0x26>
2000135e:	687a      	ldr	r2, [r7, #4]
20001360:	f242 7334 	movw	r3, #10036	; 0x2734
20001364:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001368:	429a      	cmp	r2, r3
2000136a:	d000      	beq.n	2000136e <default_tx_handler+0x26>
2000136c:	be00      	bkpt	0x0000
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
2000136e:	687b      	ldr	r3, [r7, #4]
20001370:	691b      	ldr	r3, [r3, #16]
20001372:	2b00      	cmp	r3, #0
20001374:	d100      	bne.n	20001378 <default_tx_handler+0x30>
20001376:	be00      	bkpt	0x0000
    ASSERT(0u < this_uart->tx_buff_size);
20001378:	687b      	ldr	r3, [r7, #4]
2000137a:	695b      	ldr	r3, [r3, #20]
2000137c:	2b00      	cmp	r3, #0
2000137e:	d100      	bne.n	20001382 <default_tx_handler+0x3a>
20001380:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20001382:	687a      	ldr	r2, [r7, #4]
20001384:	f242 7374 	movw	r3, #10100	; 0x2774
20001388:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000138c:	429a      	cmp	r2, r3
2000138e:	d006      	beq.n	2000139e <default_tx_handler+0x56>
20001390:	687a      	ldr	r2, [r7, #4]
20001392:	f242 7334 	movw	r3, #10036	; 0x2734
20001396:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000139a:	429a      	cmp	r2, r3
2000139c:	d155      	bne.n	2000144a <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
2000139e:	687b      	ldr	r3, [r7, #4]
200013a0:	691b      	ldr	r3, [r3, #16]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
200013a2:	2b00      	cmp	r3, #0
200013a4:	d051      	beq.n	2000144a <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
200013a6:	687b      	ldr	r3, [r7, #4]
200013a8:	695b      	ldr	r3, [r3, #20]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
200013aa:	2b00      	cmp	r3, #0
200013ac:	d04d      	beq.n	2000144a <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
200013ae:	687b      	ldr	r3, [r7, #4]
200013b0:	681b      	ldr	r3, [r3, #0]
200013b2:	7d1b      	ldrb	r3, [r3, #20]
200013b4:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
200013b6:	687b      	ldr	r3, [r7, #4]
200013b8:	7b5a      	ldrb	r2, [r3, #13]
200013ba:	7afb      	ldrb	r3, [r7, #11]
200013bc:	ea42 0303 	orr.w	r3, r2, r3
200013c0:	b2da      	uxtb	r2, r3
200013c2:	687b      	ldr	r3, [r7, #4]
200013c4:	735a      	strb	r2, [r3, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
200013c6:	7afb      	ldrb	r3, [r7, #11]
200013c8:	f003 0320 	and.w	r3, r3, #32
200013cc:	2b00      	cmp	r3, #0
200013ce:	d029      	beq.n	20001424 <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
200013d0:	f04f 0310 	mov.w	r3, #16
200013d4:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
200013d6:	687b      	ldr	r3, [r7, #4]
200013d8:	695a      	ldr	r2, [r3, #20]
200013da:	687b      	ldr	r3, [r7, #4]
200013dc:	699b      	ldr	r3, [r3, #24]
200013de:	ebc3 0302 	rsb	r3, r3, r2
200013e2:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
200013e4:	697b      	ldr	r3, [r7, #20]
200013e6:	2b0f      	cmp	r3, #15
200013e8:	d801      	bhi.n	200013ee <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
200013ea:	697b      	ldr	r3, [r7, #20]
200013ec:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
200013ee:	f04f 0300 	mov.w	r3, #0
200013f2:	60fb      	str	r3, [r7, #12]
200013f4:	e012      	b.n	2000141c <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
200013f6:	687b      	ldr	r3, [r7, #4]
200013f8:	681b      	ldr	r3, [r3, #0]
200013fa:	687a      	ldr	r2, [r7, #4]
200013fc:	6911      	ldr	r1, [r2, #16]
200013fe:	687a      	ldr	r2, [r7, #4]
20001400:	6992      	ldr	r2, [r2, #24]
20001402:	440a      	add	r2, r1
20001404:	7812      	ldrb	r2, [r2, #0]
20001406:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
20001408:	687b      	ldr	r3, [r7, #4]
2000140a:	699b      	ldr	r3, [r3, #24]
2000140c:	f103 0201 	add.w	r2, r3, #1
20001410:	687b      	ldr	r3, [r7, #4]
20001412:	619a      	str	r2, [r3, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
20001414:	68fb      	ldr	r3, [r7, #12]
20001416:	f103 0301 	add.w	r3, r3, #1
2000141a:	60fb      	str	r3, [r7, #12]
2000141c:	68fa      	ldr	r2, [r7, #12]
2000141e:	693b      	ldr	r3, [r7, #16]
20001420:	429a      	cmp	r2, r3
20001422:	d3e8      	bcc.n	200013f6 <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
20001424:	687b      	ldr	r3, [r7, #4]
20001426:	699a      	ldr	r2, [r3, #24]
20001428:	687b      	ldr	r3, [r7, #4]
2000142a:	695b      	ldr	r3, [r3, #20]
2000142c:	429a      	cmp	r2, r3
2000142e:	d10c      	bne.n	2000144a <default_tx_handler+0x102>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
20001430:	687b      	ldr	r3, [r7, #4]
20001432:	f04f 0200 	mov.w	r2, #0
20001436:	615a      	str	r2, [r3, #20]
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
20001438:	687b      	ldr	r3, [r7, #4]
2000143a:	681b      	ldr	r3, [r3, #0]
2000143c:	f103 0304 	add.w	r3, r3, #4
20001440:	4618      	mov	r0, r3
20001442:	f04f 0101 	mov.w	r1, #1
20001446:	f7ff fb4f 	bl	20000ae8 <clear_bit_reg8>
        }
    }
}
2000144a:	f107 0718 	add.w	r7, r7, #24
2000144e:	46bd      	mov	sp, r7
20001450:	bd80      	pop	{r7, pc}
20001452:	bf00      	nop

20001454 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20001454:	b480      	push	{r7}
20001456:	b083      	sub	sp, #12
20001458:	af00      	add	r7, sp, #0
2000145a:	4603      	mov	r3, r0
2000145c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000145e:	f24e 1300 	movw	r3, #57600	; 0xe100
20001462:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001466:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000146a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000146e:	79f9      	ldrb	r1, [r7, #7]
20001470:	f001 011f 	and.w	r1, r1, #31
20001474:	f04f 0001 	mov.w	r0, #1
20001478:	fa00 f101 	lsl.w	r1, r0, r1
2000147c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20001480:	f107 070c 	add.w	r7, r7, #12
20001484:	46bd      	mov	sp, r7
20001486:	bc80      	pop	{r7}
20001488:	4770      	bx	lr
2000148a:	bf00      	nop

2000148c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
2000148c:	b480      	push	{r7}
2000148e:	b083      	sub	sp, #12
20001490:	af00      	add	r7, sp, #0
20001492:	4603      	mov	r3, r0
20001494:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20001496:	f24e 1300 	movw	r3, #57600	; 0xe100
2000149a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000149e:	f997 2007 	ldrsb.w	r2, [r7, #7]
200014a2:	ea4f 1252 	mov.w	r2, r2, lsr #5
200014a6:	79f9      	ldrb	r1, [r7, #7]
200014a8:	f001 011f 	and.w	r1, r1, #31
200014ac:	f04f 0001 	mov.w	r0, #1
200014b0:	fa00 f101 	lsl.w	r1, r0, r1
200014b4:	f102 0220 	add.w	r2, r2, #32
200014b8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200014bc:	f107 070c 	add.w	r7, r7, #12
200014c0:	46bd      	mov	sp, r7
200014c2:	bc80      	pop	{r7}
200014c4:	4770      	bx	lr
200014c6:	bf00      	nop

200014c8 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200014c8:	b480      	push	{r7}
200014ca:	b083      	sub	sp, #12
200014cc:	af00      	add	r7, sp, #0
200014ce:	4603      	mov	r3, r0
200014d0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
200014d2:	f24e 1300 	movw	r3, #57600	; 0xe100
200014d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
200014da:	f997 2007 	ldrsb.w	r2, [r7, #7]
200014de:	ea4f 1252 	mov.w	r2, r2, lsr #5
200014e2:	79f9      	ldrb	r1, [r7, #7]
200014e4:	f001 011f 	and.w	r1, r1, #31
200014e8:	f04f 0001 	mov.w	r0, #1
200014ec:	fa00 f101 	lsl.w	r1, r0, r1
200014f0:	f102 0260 	add.w	r2, r2, #96	; 0x60
200014f4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200014f8:	f107 070c 	add.w	r7, r7, #12
200014fc:	46bd      	mov	sp, r7
200014fe:	bc80      	pop	{r7}
20001500:	4770      	bx	lr
20001502:	bf00      	nop

20001504 <MSS_I2C_init>:
(
    mss_i2c_instance_t * this_i2c,
    uint8_t ser_address,
    mss_i2c_clock_divider_t ser_clock_speed
)
{
20001504:	b580      	push	{r7, lr}
20001506:	b084      	sub	sp, #16
20001508:	af00      	add	r7, sp, #0
2000150a:	6078      	str	r0, [r7, #4]
2000150c:	4613      	mov	r3, r2
2000150e:	460a      	mov	r2, r1
20001510:	70fa      	strb	r2, [r7, #3]
20001512:	70bb      	strb	r3, [r7, #2]
    uint32_t primask;
    uint_fast16_t clock_speed = (uint_fast16_t)ser_clock_speed;
20001514:	78bb      	ldrb	r3, [r7, #2]
20001516:	60fb      	str	r3, [r7, #12]
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
20001518:	687a      	ldr	r2, [r7, #4]
2000151a:	f242 73b4 	movw	r3, #10164	; 0x27b4
2000151e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001522:	429a      	cmp	r2, r3
20001524:	d007      	beq.n	20001536 <MSS_I2C_init+0x32>
20001526:	687a      	ldr	r2, [r7, #4]
20001528:	f642 0328 	movw	r3, #10280	; 0x2828
2000152c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001530:	429a      	cmp	r2, r3
20001532:	d000      	beq.n	20001536 <MSS_I2C_init+0x32>
20001534:	be00      	bkpt	0x0000
     * Initialize all items of the this_i2c data structure to zero. This
     * initializes all state variables to their init value. It relies on
     * the fact that NO_TRANSACTION, I2C_SUCCESS and I2C_RELEASE_BUS all
     * have an actual value of zero.
     */
    primask = disable_interrupts();
20001536:	f000 fe63 	bl	20002200 <disable_interrupts>
2000153a:	4603      	mov	r3, r0
2000153c:	60bb      	str	r3, [r7, #8]
    memset(this_i2c, 0, sizeof(mss_i2c_instance_t));
2000153e:	6878      	ldr	r0, [r7, #4]
20001540:	f04f 0100 	mov.w	r1, #0
20001544:	f04f 0274 	mov.w	r2, #116	; 0x74
20001548:	f001 f836 	bl	200025b8 <memset>
    
    if ( this_i2c == &g_mss_i2c0 )
2000154c:	687a      	ldr	r2, [r7, #4]
2000154e:	f242 73b4 	movw	r3, #10164	; 0x27b4
20001552:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001556:	429a      	cmp	r2, r3
20001558:	d12c      	bne.n	200015b4 <MSS_I2C_init+0xb0>
    {
        this_i2c->irqn = I2C0_IRQn;
2000155a:	687b      	ldr	r3, [r7, #4]
2000155c:	f04f 0204 	mov.w	r2, #4
20001560:	745a      	strb	r2, [r3, #17]
        this_i2c->hw_reg = I2C0;
20001562:	687a      	ldr	r2, [r7, #4]
20001564:	f242 0300 	movw	r3, #8192	; 0x2000
20001568:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000156c:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C0_BITBAND;
2000156e:	687a      	ldr	r2, [r7, #4]
20001570:	f240 0300 	movw	r3, #0
20001574:	f2c4 2304 	movt	r3, #16900	; 0x4204
20001578:	6193      	str	r3, [r2, #24]
        
        /* reset I2C0 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C0_SOFTRESET_MASK;
2000157a:	f248 0300 	movw	r3, #32768	; 0x8000
2000157e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001582:	f248 0200 	movw	r2, #32768	; 0x8000
20001586:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000158a:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000158c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
20001590:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended I2C0 interrupt */
        NVIC_ClearPendingIRQ( I2C0_IRQn );
20001592:	f04f 0004 	mov.w	r0, #4
20001596:	f7ff ff97 	bl	200014c8 <NVIC_ClearPendingIRQ>
        /* Take I2C0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C0_SOFTRESET_MASK;
2000159a:	f248 0300 	movw	r3, #32768	; 0x8000
2000159e:	f2c4 0303 	movt	r3, #16387	; 0x4003
200015a2:	f248 0200 	movw	r2, #32768	; 0x8000
200015a6:	f2c4 0203 	movt	r2, #16387	; 0x4003
200015aa:	6c92      	ldr	r2, [r2, #72]	; 0x48
200015ac:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
200015b0:	649a      	str	r2, [r3, #72]	; 0x48
200015b2:	e02b      	b.n	2000160c <MSS_I2C_init+0x108>
    }
    else
    {
        this_i2c->irqn = I2C1_IRQn;
200015b4:	687b      	ldr	r3, [r7, #4]
200015b6:	f04f 0207 	mov.w	r2, #7
200015ba:	745a      	strb	r2, [r3, #17]
        this_i2c->hw_reg = I2C1;
200015bc:	687a      	ldr	r2, [r7, #4]
200015be:	f242 0300 	movw	r3, #8192	; 0x2000
200015c2:	f2c4 0301 	movt	r3, #16385	; 0x4001
200015c6:	6153      	str	r3, [r2, #20]
        this_i2c->hw_reg_bit = I2C1_BITBAND;
200015c8:	687a      	ldr	r2, [r7, #4]
200015ca:	f240 0300 	movw	r3, #0
200015ce:	f2c4 2324 	movt	r3, #16932	; 0x4224
200015d2:	6193      	str	r3, [r2, #24]
        
        /* reset I2C1 */
        SYSREG->SOFT_RST_CR |= SYSREG_I2C1_SOFTRESET_MASK;
200015d4:	f248 0300 	movw	r3, #32768	; 0x8000
200015d8:	f2c4 0303 	movt	r3, #16387	; 0x4003
200015dc:	f248 0200 	movw	r2, #32768	; 0x8000
200015e0:	f2c4 0203 	movt	r2, #16387	; 0x4003
200015e4:	6c92      	ldr	r2, [r2, #72]	; 0x48
200015e6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
200015ea:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended I2C1 interrupt */
        NVIC_ClearPendingIRQ( I2C1_IRQn );
200015ec:	f04f 0007 	mov.w	r0, #7
200015f0:	f7ff ff6a 	bl	200014c8 <NVIC_ClearPendingIRQ>
        /* Take I2C1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_I2C1_SOFTRESET_MASK;
200015f4:	f248 0300 	movw	r3, #32768	; 0x8000
200015f8:	f2c4 0303 	movt	r3, #16387	; 0x4003
200015fc:	f248 0200 	movw	r2, #32768	; 0x8000
20001600:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001604:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001606:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2000160a:	649a      	str	r2, [r3, #72]	; 0x48
    }
    
    /* Use same base address for SMBus bitband access */
    this_i2c->hw_smb_reg_bit = (I2C_SMBus_BitBand_TypeDef *)this_i2c->hw_reg_bit;
2000160c:	687b      	ldr	r3, [r7, #4]
2000160e:	699b      	ldr	r3, [r3, #24]
20001610:	461a      	mov	r2, r3
20001612:	687b      	ldr	r3, [r7, #4]
20001614:	61da      	str	r2, [r3, #28]

    /* Update Serial address of the device */
    this_i2c->ser_address = (uint_fast8_t)ser_address << 1u;
20001616:	78fb      	ldrb	r3, [r7, #3]
20001618:	ea4f 0243 	mov.w	r2, r3, lsl #1
2000161c:	687b      	ldr	r3, [r7, #4]
2000161e:	601a      	str	r2, [r3, #0]

    this_i2c->hw_reg_bit->CTRL_CR2 = (uint32_t)((clock_speed >> 2u) & 0x01u);
20001620:	687b      	ldr	r3, [r7, #4]
20001622:	699b      	ldr	r3, [r3, #24]
20001624:	68fa      	ldr	r2, [r7, #12]
20001626:	ea4f 0292 	mov.w	r2, r2, lsr #2
2000162a:	f002 0201 	and.w	r2, r2, #1
2000162e:	61da      	str	r2, [r3, #28]
    this_i2c->hw_reg_bit->CTRL_CR1 = (uint32_t)((clock_speed >> 1u) & 0x01u);
20001630:	687b      	ldr	r3, [r7, #4]
20001632:	699b      	ldr	r3, [r3, #24]
20001634:	68fa      	ldr	r2, [r7, #12]
20001636:	ea4f 0252 	mov.w	r2, r2, lsr #1
2000163a:	f002 0201 	and.w	r2, r2, #1
2000163e:	605a      	str	r2, [r3, #4]
    this_i2c->hw_reg_bit->CTRL_CR0 = (uint32_t)(clock_speed & 0x01u);
20001640:	687b      	ldr	r3, [r7, #4]
20001642:	699b      	ldr	r3, [r3, #24]
20001644:	68fa      	ldr	r2, [r7, #12]
20001646:	f002 0201 	and.w	r2, r2, #1
2000164a:	601a      	str	r2, [r3, #0]
    this_i2c->hw_reg->ADDR = (uint8_t)this_i2c->ser_address;
2000164c:	687b      	ldr	r3, [r7, #4]
2000164e:	695b      	ldr	r3, [r3, #20]
20001650:	687a      	ldr	r2, [r7, #4]
20001652:	6812      	ldr	r2, [r2, #0]
20001654:	b2d2      	uxtb	r2, r2
20001656:	731a      	strb	r2, [r3, #12]
    this_i2c->hw_reg_bit->CTRL_ENS1 = 0x01u; /* set enable bit */
20001658:	687b      	ldr	r3, [r7, #4]
2000165a:	699b      	ldr	r3, [r3, #24]
2000165c:	f04f 0201 	mov.w	r2, #1
20001660:	619a      	str	r2, [r3, #24]
    restore_interrupts( primask );
20001662:	68b8      	ldr	r0, [r7, #8]
20001664:	f000 fde2 	bl	2000222c <restore_interrupts>
}
20001668:	f107 0710 	add.w	r7, r7, #16
2000166c:	46bd      	mov	sp, r7
2000166e:	bd80      	pop	{r7, pc}

20001670 <MSS_I2C_write>:
    uint8_t serial_addr,
    const uint8_t * write_buffer,
    uint16_t write_size,
    uint8_t options
)
{
20001670:	b580      	push	{r7, lr}
20001672:	b086      	sub	sp, #24
20001674:	af00      	add	r7, sp, #0
20001676:	60f8      	str	r0, [r7, #12]
20001678:	607a      	str	r2, [r7, #4]
2000167a:	460a      	mov	r2, r1
2000167c:	72fa      	strb	r2, [r7, #11]
2000167e:	807b      	strh	r3, [r7, #2]
    uint32_t primask;
    volatile uint8_t stat_ctrl;

    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
20001680:	68fa      	ldr	r2, [r7, #12]
20001682:	f242 73b4 	movw	r3, #10164	; 0x27b4
20001686:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000168a:	429a      	cmp	r2, r3
2000168c:	d007      	beq.n	2000169e <MSS_I2C_write+0x2e>
2000168e:	68fa      	ldr	r2, [r7, #12]
20001690:	f642 0328 	movw	r3, #10280	; 0x2828
20001694:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001698:	429a      	cmp	r2, r3
2000169a:	d000      	beq.n	2000169e <MSS_I2C_write+0x2e>
2000169c:	be00      	bkpt	0x0000

    primask = disable_interrupts();
2000169e:	f000 fdaf 	bl	20002200 <disable_interrupts>
200016a2:	4603      	mov	r3, r0
200016a4:	617b      	str	r3, [r7, #20]

    /* Update the transaction only when there is no transaction going on I2C */
    if( this_i2c->transaction == NO_TRANSACTION)
200016a6:	68fb      	ldr	r3, [r7, #12]
200016a8:	7a1b      	ldrb	r3, [r3, #8]
200016aa:	2b00      	cmp	r3, #0
200016ac:	d103      	bne.n	200016b6 <MSS_I2C_write+0x46>
    {
      this_i2c->transaction = MASTER_WRITE_TRANSACTION;
200016ae:	68fb      	ldr	r3, [r7, #12]
200016b0:	f04f 0201 	mov.w	r2, #1
200016b4:	721a      	strb	r2, [r3, #8]
    }

    /* Update the Pending transaction information so that transaction can restarted */
    this_i2c->pending_transaction = MASTER_WRITE_TRANSACTION ;
200016b6:	68fb      	ldr	r3, [r7, #12]
200016b8:	f04f 0201 	mov.w	r2, #1
200016bc:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

    /* Update target address */
    this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
200016c0:	7afb      	ldrb	r3, [r7, #11]
200016c2:	ea4f 0243 	mov.w	r2, r3, lsl #1
200016c6:	68fb      	ldr	r3, [r7, #12]
200016c8:	605a      	str	r2, [r3, #4]

    this_i2c->dir = WRITE_DIR;
200016ca:	68fb      	ldr	r3, [r7, #12]
200016cc:	f04f 0200 	mov.w	r2, #0
200016d0:	62da      	str	r2, [r3, #44]	; 0x2c

    this_i2c->master_tx_buffer = write_buffer;
200016d2:	68fb      	ldr	r3, [r7, #12]
200016d4:	687a      	ldr	r2, [r7, #4]
200016d6:	621a      	str	r2, [r3, #32]
    this_i2c->master_tx_size = write_size;
200016d8:	887a      	ldrh	r2, [r7, #2]
200016da:	68fb      	ldr	r3, [r7, #12]
200016dc:	625a      	str	r2, [r3, #36]	; 0x24
    this_i2c->master_tx_idx = 0u;
200016de:	68fb      	ldr	r3, [r7, #12]
200016e0:	f04f 0200 	mov.w	r2, #0
200016e4:	629a      	str	r2, [r3, #40]	; 0x28

    /* Set I2C status in progress */
    this_i2c->master_status = MSS_I2C_IN_PROGRESS;
200016e6:	68fb      	ldr	r3, [r7, #12]
200016e8:	f04f 0201 	mov.w	r2, #1
200016ec:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    this_i2c->options = options;
200016f0:	68fb      	ldr	r3, [r7, #12]
200016f2:	f897 2020 	ldrb.w	r2, [r7, #32]
200016f6:	741a      	strb	r2, [r3, #16]

    if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
200016f8:	68fb      	ldr	r3, [r7, #12]
200016fa:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
200016fe:	b2db      	uxtb	r3, r3
20001700:	2b01      	cmp	r3, #1
20001702:	d105      	bne.n	20001710 <MSS_I2C_write+0xa0>
    {
        this_i2c->is_transaction_pending = 1u;
20001704:	68fb      	ldr	r3, [r7, #12]
20001706:	f04f 0201 	mov.w	r2, #1
2000170a:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
2000170e:	e004      	b.n	2000171a <MSS_I2C_write+0xaa>
    }
    else
    {
        this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
20001710:	68fb      	ldr	r3, [r7, #12]
20001712:	699b      	ldr	r3, [r3, #24]
20001714:	f04f 0201 	mov.w	r2, #1
20001718:	615a      	str	r2, [r3, #20]
    /*
     * Clear interrupts if required (depends on repeated starts).
     * Since the Bus is on hold, only then prior status needs to
     * be cleared.
     */
    if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
2000171a:	68fb      	ldr	r3, [r7, #12]
2000171c:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
20001720:	2b01      	cmp	r3, #1
20001722:	d111      	bne.n	20001748 <MSS_I2C_write+0xd8>
    {
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
20001724:	68fb      	ldr	r3, [r7, #12]
20001726:	699b      	ldr	r3, [r3, #24]
20001728:	f04f 0200 	mov.w	r2, #0
2000172c:	60da      	str	r2, [r3, #12]
        stat_ctrl = this_i2c->hw_reg->STATUS;
2000172e:	68fb      	ldr	r3, [r7, #12]
20001730:	695b      	ldr	r3, [r3, #20]
20001732:	791b      	ldrb	r3, [r3, #4]
20001734:	74fb      	strb	r3, [r7, #19]
        stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
20001736:	7cfb      	ldrb	r3, [r7, #19]
20001738:	b2db      	uxtb	r3, r3
2000173a:	74fb      	strb	r3, [r7, #19]
        NVIC_ClearPendingIRQ( this_i2c->irqn );
2000173c:	68fb      	ldr	r3, [r7, #12]
2000173e:	7c5b      	ldrb	r3, [r3, #17]
20001740:	b25b      	sxtb	r3, r3
20001742:	4618      	mov	r0, r3
20001744:	f7ff fec0 	bl	200014c8 <NVIC_ClearPendingIRQ>
    }

    /* Enable the interrupt. ( Re-enable) */
    NVIC_EnableIRQ( this_i2c->irqn );
20001748:	68fb      	ldr	r3, [r7, #12]
2000174a:	7c5b      	ldrb	r3, [r3, #17]
2000174c:	b25b      	sxtb	r3, r3
2000174e:	4618      	mov	r0, r3
20001750:	f7ff fe80 	bl	20001454 <NVIC_EnableIRQ>

    restore_interrupts( primask );
20001754:	6978      	ldr	r0, [r7, #20]
20001756:	f000 fd69 	bl	2000222c <restore_interrupts>
}
2000175a:	f107 0718 	add.w	r7, r7, #24
2000175e:	46bd      	mov	sp, r7
20001760:	bd80      	pop	{r7, pc}
20001762:	bf00      	nop

20001764 <MSS_I2C_write_read>:
    uint16_t offset_size,
    uint8_t * read_buffer,
    uint16_t read_size,
    uint8_t options
)
{
20001764:	b580      	push	{r7, lr}
20001766:	b086      	sub	sp, #24
20001768:	af00      	add	r7, sp, #0
2000176a:	60f8      	str	r0, [r7, #12]
2000176c:	607a      	str	r2, [r7, #4]
2000176e:	460a      	mov	r2, r1
20001770:	72fa      	strb	r2, [r7, #11]
20001772:	807b      	strh	r3, [r7, #2]
    ASSERT((this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1));
20001774:	68fa      	ldr	r2, [r7, #12]
20001776:	f242 73b4 	movw	r3, #10164	; 0x27b4
2000177a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000177e:	429a      	cmp	r2, r3
20001780:	d007      	beq.n	20001792 <MSS_I2C_write_read+0x2e>
20001782:	68fa      	ldr	r2, [r7, #12]
20001784:	f642 0328 	movw	r3, #10280	; 0x2828
20001788:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000178c:	429a      	cmp	r2, r3
2000178e:	d000      	beq.n	20001792 <MSS_I2C_write_read+0x2e>
20001790:	be00      	bkpt	0x0000
    ASSERT(offset_size > 0u);
20001792:	887b      	ldrh	r3, [r7, #2]
20001794:	2b00      	cmp	r3, #0
20001796:	d100      	bne.n	2000179a <MSS_I2C_write_read+0x36>
20001798:	be00      	bkpt	0x0000
    ASSERT(addr_offset != (const uint8_t *)0);
2000179a:	687b      	ldr	r3, [r7, #4]
2000179c:	2b00      	cmp	r3, #0
2000179e:	d100      	bne.n	200017a2 <MSS_I2C_write_read+0x3e>
200017a0:	be00      	bkpt	0x0000
    ASSERT(read_size > 0u);
200017a2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
200017a4:	2b00      	cmp	r3, #0
200017a6:	d100      	bne.n	200017aa <MSS_I2C_write_read+0x46>
200017a8:	be00      	bkpt	0x0000
    ASSERT(read_buffer != (uint8_t *)0);
200017aa:	6a3b      	ldr	r3, [r7, #32]
200017ac:	2b00      	cmp	r3, #0
200017ae:	d100      	bne.n	200017b2 <MSS_I2C_write_read+0x4e>
200017b0:	be00      	bkpt	0x0000

    if((read_size > 0u) && (offset_size > 0u))
200017b2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
200017b4:	2b00      	cmp	r3, #0
200017b6:	d06a      	beq.n	2000188e <MSS_I2C_write_read+0x12a>
200017b8:	887b      	ldrh	r3, [r7, #2]
200017ba:	2b00      	cmp	r3, #0
200017bc:	d067      	beq.n	2000188e <MSS_I2C_write_read+0x12a>
    {
        uint32_t primask;
        volatile uint8_t stat_ctrl;

        primask = disable_interrupts();
200017be:	f000 fd1f 	bl	20002200 <disable_interrupts>
200017c2:	4603      	mov	r3, r0
200017c4:	617b      	str	r3, [r7, #20]

        /* Update the transaction only when there is no transaction going on I2C */
        if( this_i2c->transaction == NO_TRANSACTION)
200017c6:	68fb      	ldr	r3, [r7, #12]
200017c8:	7a1b      	ldrb	r3, [r3, #8]
200017ca:	2b00      	cmp	r3, #0
200017cc:	d103      	bne.n	200017d6 <MSS_I2C_write_read+0x72>
        {
            this_i2c->transaction = MASTER_RANDOM_READ_TRANSACTION;
200017ce:	68fb      	ldr	r3, [r7, #12]
200017d0:	f04f 0203 	mov.w	r2, #3
200017d4:	721a      	strb	r2, [r3, #8]
        }

        /* Update the Pending transaction information so that transaction can restarted */
        this_i2c->pending_transaction = MASTER_RANDOM_READ_TRANSACTION ;
200017d6:	68fb      	ldr	r3, [r7, #12]
200017d8:	f04f 0203 	mov.w	r2, #3
200017dc:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72

        /* Update target address */
        this_i2c->target_addr = (uint_fast8_t)serial_addr << 1u;
200017e0:	7afb      	ldrb	r3, [r7, #11]
200017e2:	ea4f 0243 	mov.w	r2, r3, lsl #1
200017e6:	68fb      	ldr	r3, [r7, #12]
200017e8:	605a      	str	r2, [r3, #4]

        this_i2c->dir = WRITE_DIR;
200017ea:	68fb      	ldr	r3, [r7, #12]
200017ec:	f04f 0200 	mov.w	r2, #0
200017f0:	62da      	str	r2, [r3, #44]	; 0x2c
        this_i2c->master_tx_buffer = addr_offset;
200017f2:	68fb      	ldr	r3, [r7, #12]
200017f4:	687a      	ldr	r2, [r7, #4]
200017f6:	621a      	str	r2, [r3, #32]
        this_i2c->master_tx_size = offset_size;
200017f8:	887a      	ldrh	r2, [r7, #2]
200017fa:	68fb      	ldr	r3, [r7, #12]
200017fc:	625a      	str	r2, [r3, #36]	; 0x24
        this_i2c->master_tx_idx = 0u;
200017fe:	68fb      	ldr	r3, [r7, #12]
20001800:	f04f 0200 	mov.w	r2, #0
20001804:	629a      	str	r2, [r3, #40]	; 0x28

        this_i2c->master_rx_buffer = read_buffer;
20001806:	68fb      	ldr	r3, [r7, #12]
20001808:	6a3a      	ldr	r2, [r7, #32]
2000180a:	631a      	str	r2, [r3, #48]	; 0x30
        this_i2c->master_rx_size = read_size;
2000180c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2000180e:	68fb      	ldr	r3, [r7, #12]
20001810:	635a      	str	r2, [r3, #52]	; 0x34
        this_i2c->master_rx_idx = 0u;
20001812:	68fb      	ldr	r3, [r7, #12]
20001814:	f04f 0200 	mov.w	r2, #0
20001818:	639a      	str	r2, [r3, #56]	; 0x38

        /* Set I2C status in progress */
        this_i2c->master_status = MSS_I2C_IN_PROGRESS;
2000181a:	68fb      	ldr	r3, [r7, #12]
2000181c:	f04f 0201 	mov.w	r2, #1
20001820:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        this_i2c->options = options;
20001824:	68fb      	ldr	r3, [r7, #12]
20001826:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
2000182a:	741a      	strb	r2, [r3, #16]

        if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
2000182c:	68fb      	ldr	r3, [r7, #12]
2000182e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
20001832:	b2db      	uxtb	r3, r3
20001834:	2b01      	cmp	r3, #1
20001836:	d105      	bne.n	20001844 <MSS_I2C_write_read+0xe0>
        {
            this_i2c->is_transaction_pending = 1u;
20001838:	68fb      	ldr	r3, [r7, #12]
2000183a:	f04f 0201 	mov.w	r2, #1
2000183e:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
20001842:	e004      	b.n	2000184e <MSS_I2C_write_read+0xea>
        }
        else
        {
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
20001844:	68fb      	ldr	r3, [r7, #12]
20001846:	699b      	ldr	r3, [r3, #24]
20001848:	f04f 0201 	mov.w	r2, #1
2000184c:	615a      	str	r2, [r3, #20]
        /*
         * Clear interrupts if required (depends on repeated starts).
         * Since the Bus is on hold, only then prior status needs to
         * be cleared.
         */
        if ( MSS_I2C_HOLD_BUS == this_i2c->bus_status )
2000184e:	68fb      	ldr	r3, [r7, #12]
20001850:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
20001854:	2b01      	cmp	r3, #1
20001856:	d111      	bne.n	2000187c <MSS_I2C_write_read+0x118>
        {
            this_i2c->hw_reg_bit->CTRL_SI = 0u;
20001858:	68fb      	ldr	r3, [r7, #12]
2000185a:	699b      	ldr	r3, [r3, #24]
2000185c:	f04f 0200 	mov.w	r2, #0
20001860:	60da      	str	r2, [r3, #12]
            stat_ctrl = this_i2c->hw_reg->STATUS;
20001862:	68fb      	ldr	r3, [r7, #12]
20001864:	695b      	ldr	r3, [r3, #20]
20001866:	791b      	ldrb	r3, [r3, #4]
20001868:	74fb      	strb	r3, [r7, #19]
            stat_ctrl = stat_ctrl;  /* Avoids Lint warning */
2000186a:	7cfb      	ldrb	r3, [r7, #19]
2000186c:	b2db      	uxtb	r3, r3
2000186e:	74fb      	strb	r3, [r7, #19]
            NVIC_ClearPendingIRQ( this_i2c->irqn );
20001870:	68fb      	ldr	r3, [r7, #12]
20001872:	7c5b      	ldrb	r3, [r3, #17]
20001874:	b25b      	sxtb	r3, r3
20001876:	4618      	mov	r0, r3
20001878:	f7ff fe26 	bl	200014c8 <NVIC_ClearPendingIRQ>
        }

        /* Enable the interrupt. ( Re-enable) */
        NVIC_EnableIRQ( this_i2c->irqn );
2000187c:	68fb      	ldr	r3, [r7, #12]
2000187e:	7c5b      	ldrb	r3, [r3, #17]
20001880:	b25b      	sxtb	r3, r3
20001882:	4618      	mov	r0, r3
20001884:	f7ff fde6 	bl	20001454 <NVIC_EnableIRQ>

        restore_interrupts( primask );
20001888:	6978      	ldr	r0, [r7, #20]
2000188a:	f000 fccf 	bl	2000222c <restore_interrupts>
    }
}
2000188e:	f107 0718 	add.w	r7, r7, #24
20001892:	46bd      	mov	sp, r7
20001894:	bd80      	pop	{r7, pc}
20001896:	bf00      	nop

20001898 <MSS_I2C_wait_complete>:
mss_i2c_status_t MSS_I2C_wait_complete
(
    mss_i2c_instance_t * this_i2c,
    uint32_t timeout_ms
)
{
20001898:	b480      	push	{r7}
2000189a:	b085      	sub	sp, #20
2000189c:	af00      	add	r7, sp, #0
2000189e:	6078      	str	r0, [r7, #4]
200018a0:	6039      	str	r1, [r7, #0]
	mss_i2c_status_t i2c_status;
    
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
200018a2:	687a      	ldr	r2, [r7, #4]
200018a4:	f242 73b4 	movw	r3, #10164	; 0x27b4
200018a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200018ac:	429a      	cmp	r2, r3
200018ae:	d007      	beq.n	200018c0 <MSS_I2C_wait_complete+0x28>
200018b0:	687a      	ldr	r2, [r7, #4]
200018b2:	f642 0328 	movw	r3, #10280	; 0x2828
200018b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200018ba:	429a      	cmp	r2, r3
200018bc:	d000      	beq.n	200018c0 <MSS_I2C_wait_complete+0x28>
200018be:	be00      	bkpt	0x0000
    
    this_i2c->master_timeout_ms = timeout_ms;
200018c0:	687b      	ldr	r3, [r7, #4]
200018c2:	683a      	ldr	r2, [r7, #0]
200018c4:	641a      	str	r2, [r3, #64]	; 0x40

    /* Run the loop until state returns I2C_FAILED  or I2C_SUCESS*/
    do {
        i2c_status = this_i2c->master_status;
200018c6:	687b      	ldr	r3, [r7, #4]
200018c8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
200018cc:	73fb      	strb	r3, [r7, #15]
    } while(MSS_I2C_IN_PROGRESS == i2c_status);
200018ce:	7bfb      	ldrb	r3, [r7, #15]
200018d0:	2b01      	cmp	r3, #1
200018d2:	d0f8      	beq.n	200018c6 <MSS_I2C_wait_complete+0x2e>

    return i2c_status;
200018d4:	7bfb      	ldrb	r3, [r7, #15]
}
200018d6:	4618      	mov	r0, r3
200018d8:	f107 0714 	add.w	r7, r7, #20
200018dc:	46bd      	mov	sp, r7
200018de:	bc80      	pop	{r7}
200018e0:	4770      	bx	lr
200018e2:	bf00      	nop

200018e4 <enable_slave_if_required>:
 */
static void enable_slave_if_required
(
    mss_i2c_instance_t * this_i2c
)
{
200018e4:	b480      	push	{r7}
200018e6:	b083      	sub	sp, #12
200018e8:	af00      	add	r7, sp, #0
200018ea:	6078      	str	r0, [r7, #4]
    if( this_i2c->is_slave_enabled )
200018ec:	687b      	ldr	r3, [r7, #4]
200018ee:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
200018f2:	2b00      	cmp	r3, #0
200018f4:	d004      	beq.n	20001900 <enable_slave_if_required+0x1c>
    {
        this_i2c->hw_reg_bit->CTRL_AA = 1u;
200018f6:	687b      	ldr	r3, [r7, #4]
200018f8:	699b      	ldr	r3, [r3, #24]
200018fa:	f04f 0201 	mov.w	r2, #1
200018fe:	609a      	str	r2, [r3, #8]
    }
}
20001900:	f107 070c 	add.w	r7, r7, #12
20001904:	46bd      	mov	sp, r7
20001906:	bc80      	pop	{r7}
20001908:	4770      	bx	lr
2000190a:	bf00      	nop

2000190c <mss_i2c_isr>:
 */
static void mss_i2c_isr
(
    mss_i2c_instance_t * this_i2c
)
{
2000190c:	b580      	push	{r7, lr}
2000190e:	b084      	sub	sp, #16
20001910:	af00      	add	r7, sp, #0
20001912:	6078      	str	r0, [r7, #4]
    volatile uint8_t status;
    uint8_t data;
    uint8_t hold_bus;
    uint8_t clear_irq = 1u;
20001914:	f04f 0301 	mov.w	r3, #1
20001918:	73bb      	strb	r3, [r7, #14]
    ASSERT( (this_i2c == &g_mss_i2c0) || (this_i2c == &g_mss_i2c1) );
2000191a:	687a      	ldr	r2, [r7, #4]
2000191c:	f242 73b4 	movw	r3, #10164	; 0x27b4
20001920:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001924:	429a      	cmp	r2, r3
20001926:	d007      	beq.n	20001938 <mss_i2c_isr+0x2c>
20001928:	687a      	ldr	r2, [r7, #4]
2000192a:	f642 0328 	movw	r3, #10280	; 0x2828
2000192e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001932:	429a      	cmp	r2, r3
20001934:	d000      	beq.n	20001938 <mss_i2c_isr+0x2c>
20001936:	be00      	bkpt	0x0000

    status = this_i2c->hw_reg->STATUS;
20001938:	687b      	ldr	r3, [r7, #4]
2000193a:	695b      	ldr	r3, [r3, #20]
2000193c:	791b      	ldrb	r3, [r3, #4]
2000193e:	72fb      	strb	r3, [r7, #11]

    switch( status )
20001940:	7afb      	ldrb	r3, [r7, #11]
20001942:	b2db      	uxtb	r3, r3
20001944:	f1a3 0308 	sub.w	r3, r3, #8
20001948:	2bd0      	cmp	r3, #208	; 0xd0
2000194a:	f200 841c 	bhi.w	20002186 <mss_i2c_isr+0x87a>
2000194e:	a201      	add	r2, pc, #4	; (adr r2, 20001954 <mss_i2c_isr+0x48>)
20001950:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001954:	20001c99 	.word	0x20001c99
20001958:	20002187 	.word	0x20002187
2000195c:	20002187 	.word	0x20002187
20001960:	20002187 	.word	0x20002187
20001964:	20002187 	.word	0x20002187
20001968:	20002187 	.word	0x20002187
2000196c:	20002187 	.word	0x20002187
20001970:	20002187 	.word	0x20002187
20001974:	20001c99 	.word	0x20001c99
20001978:	20002187 	.word	0x20002187
2000197c:	20002187 	.word	0x20002187
20001980:	20002187 	.word	0x20002187
20001984:	20002187 	.word	0x20002187
20001988:	20002187 	.word	0x20002187
2000198c:	20002187 	.word	0x20002187
20001990:	20002187 	.word	0x20002187
20001994:	20001d3d 	.word	0x20001d3d
20001998:	20002187 	.word	0x20002187
2000199c:	20002187 	.word	0x20002187
200019a0:	20002187 	.word	0x20002187
200019a4:	20002187 	.word	0x20002187
200019a8:	20002187 	.word	0x20002187
200019ac:	20002187 	.word	0x20002187
200019b0:	20002187 	.word	0x20002187
200019b4:	20001d19 	.word	0x20001d19
200019b8:	20002187 	.word	0x20002187
200019bc:	20002187 	.word	0x20002187
200019c0:	20002187 	.word	0x20002187
200019c4:	20002187 	.word	0x20002187
200019c8:	20002187 	.word	0x20002187
200019cc:	20002187 	.word	0x20002187
200019d0:	20002187 	.word	0x20002187
200019d4:	20001d3d 	.word	0x20001d3d
200019d8:	20002187 	.word	0x20002187
200019dc:	20002187 	.word	0x20002187
200019e0:	20002187 	.word	0x20002187
200019e4:	20002187 	.word	0x20002187
200019e8:	20002187 	.word	0x20002187
200019ec:	20002187 	.word	0x20002187
200019f0:	20002187 	.word	0x20002187
200019f4:	20001dd1 	.word	0x20001dd1
200019f8:	20002187 	.word	0x20002187
200019fc:	20002187 	.word	0x20002187
20001a00:	20002187 	.word	0x20002187
20001a04:	20002187 	.word	0x20002187
20001a08:	20002187 	.word	0x20002187
20001a0c:	20002187 	.word	0x20002187
20001a10:	20002187 	.word	0x20002187
20001a14:	20001d0d 	.word	0x20001d0d
20001a18:	20002187 	.word	0x20002187
20001a1c:	20002187 	.word	0x20002187
20001a20:	20002187 	.word	0x20002187
20001a24:	20002187 	.word	0x20002187
20001a28:	20002187 	.word	0x20002187
20001a2c:	20002187 	.word	0x20002187
20001a30:	20002187 	.word	0x20002187
20001a34:	20001df5 	.word	0x20001df5
20001a38:	20002187 	.word	0x20002187
20001a3c:	20002187 	.word	0x20002187
20001a40:	20002187 	.word	0x20002187
20001a44:	20002187 	.word	0x20002187
20001a48:	20002187 	.word	0x20002187
20001a4c:	20002187 	.word	0x20002187
20001a50:	20002187 	.word	0x20002187
20001a54:	20001e45 	.word	0x20001e45
20001a58:	20002187 	.word	0x20002187
20001a5c:	20002187 	.word	0x20002187
20001a60:	20002187 	.word	0x20002187
20001a64:	20002187 	.word	0x20002187
20001a68:	20002187 	.word	0x20002187
20001a6c:	20002187 	.word	0x20002187
20001a70:	20002187 	.word	0x20002187
20001a74:	20001e69 	.word	0x20001e69
20001a78:	20002187 	.word	0x20002187
20001a7c:	20002187 	.word	0x20002187
20001a80:	20002187 	.word	0x20002187
20001a84:	20002187 	.word	0x20002187
20001a88:	20002187 	.word	0x20002187
20001a8c:	20002187 	.word	0x20002187
20001a90:	20002187 	.word	0x20002187
20001a94:	20001ea3 	.word	0x20001ea3
20001a98:	20002187 	.word	0x20002187
20001a9c:	20002187 	.word	0x20002187
20001aa0:	20002187 	.word	0x20002187
20001aa4:	20002187 	.word	0x20002187
20001aa8:	20002187 	.word	0x20002187
20001aac:	20002187 	.word	0x20002187
20001ab0:	20002187 	.word	0x20002187
20001ab4:	20001f45 	.word	0x20001f45
20001ab8:	20002187 	.word	0x20002187
20001abc:	20002187 	.word	0x20002187
20001ac0:	20002187 	.word	0x20002187
20001ac4:	20002187 	.word	0x20002187
20001ac8:	20002187 	.word	0x20002187
20001acc:	20002187 	.word	0x20002187
20001ad0:	20002187 	.word	0x20002187
20001ad4:	20001f3b 	.word	0x20001f3b
20001ad8:	20002187 	.word	0x20002187
20001adc:	20002187 	.word	0x20002187
20001ae0:	20002187 	.word	0x20002187
20001ae4:	20002187 	.word	0x20002187
20001ae8:	20002187 	.word	0x20002187
20001aec:	20002187 	.word	0x20002187
20001af0:	20002187 	.word	0x20002187
20001af4:	20001f45 	.word	0x20001f45
20001af8:	20002187 	.word	0x20002187
20001afc:	20002187 	.word	0x20002187
20001b00:	20002187 	.word	0x20002187
20001b04:	20002187 	.word	0x20002187
20001b08:	20002187 	.word	0x20002187
20001b0c:	20002187 	.word	0x20002187
20001b10:	20002187 	.word	0x20002187
20001b14:	20001f3b 	.word	0x20001f3b
20001b18:	20002187 	.word	0x20002187
20001b1c:	20002187 	.word	0x20002187
20001b20:	20002187 	.word	0x20002187
20001b24:	20002187 	.word	0x20002187
20001b28:	20002187 	.word	0x20002187
20001b2c:	20002187 	.word	0x20002187
20001b30:	20002187 	.word	0x20002187
20001b34:	20001f87 	.word	0x20001f87
20001b38:	20002187 	.word	0x20002187
20001b3c:	20002187 	.word	0x20002187
20001b40:	20002187 	.word	0x20002187
20001b44:	20002187 	.word	0x20002187
20001b48:	20002187 	.word	0x20002187
20001b4c:	20002187 	.word	0x20002187
20001b50:	20002187 	.word	0x20002187
20001b54:	20001f07 	.word	0x20001f07
20001b58:	20002187 	.word	0x20002187
20001b5c:	20002187 	.word	0x20002187
20001b60:	20002187 	.word	0x20002187
20001b64:	20002187 	.word	0x20002187
20001b68:	20002187 	.word	0x20002187
20001b6c:	20002187 	.word	0x20002187
20001b70:	20002187 	.word	0x20002187
20001b74:	20001f87 	.word	0x20001f87
20001b78:	20002187 	.word	0x20002187
20001b7c:	20002187 	.word	0x20002187
20001b80:	20002187 	.word	0x20002187
20001b84:	20002187 	.word	0x20002187
20001b88:	20002187 	.word	0x20002187
20001b8c:	20002187 	.word	0x20002187
20001b90:	20002187 	.word	0x20002187
20001b94:	20001f07 	.word	0x20001f07
20001b98:	20002187 	.word	0x20002187
20001b9c:	20002187 	.word	0x20002187
20001ba0:	20002187 	.word	0x20002187
20001ba4:	20002187 	.word	0x20002187
20001ba8:	20002187 	.word	0x20002187
20001bac:	20002187 	.word	0x20002187
20001bb0:	20002187 	.word	0x20002187
20001bb4:	20001fe3 	.word	0x20001fe3
20001bb8:	20002187 	.word	0x20002187
20001bbc:	20002187 	.word	0x20002187
20001bc0:	20002187 	.word	0x20002187
20001bc4:	20002187 	.word	0x20002187
20001bc8:	20002187 	.word	0x20002187
20001bcc:	20002187 	.word	0x20002187
20001bd0:	20002187 	.word	0x20002187
20001bd4:	200020bb 	.word	0x200020bb
20001bd8:	20002187 	.word	0x20002187
20001bdc:	20002187 	.word	0x20002187
20001be0:	20002187 	.word	0x20002187
20001be4:	20002187 	.word	0x20002187
20001be8:	20002187 	.word	0x20002187
20001bec:	20002187 	.word	0x20002187
20001bf0:	20002187 	.word	0x20002187
20001bf4:	200020bb 	.word	0x200020bb
20001bf8:	20002187 	.word	0x20002187
20001bfc:	20002187 	.word	0x20002187
20001c00:	20002187 	.word	0x20002187
20001c04:	20002187 	.word	0x20002187
20001c08:	20002187 	.word	0x20002187
20001c0c:	20002187 	.word	0x20002187
20001c10:	20002187 	.word	0x20002187
20001c14:	200020bb 	.word	0x200020bb
20001c18:	20002187 	.word	0x20002187
20001c1c:	20002187 	.word	0x20002187
20001c20:	20002187 	.word	0x20002187
20001c24:	20002187 	.word	0x20002187
20001c28:	20002187 	.word	0x20002187
20001c2c:	20002187 	.word	0x20002187
20001c30:	20002187 	.word	0x20002187
20001c34:	2000214d 	.word	0x2000214d
20001c38:	20002187 	.word	0x20002187
20001c3c:	20002187 	.word	0x20002187
20001c40:	20002187 	.word	0x20002187
20001c44:	20002187 	.word	0x20002187
20001c48:	20002187 	.word	0x20002187
20001c4c:	20002187 	.word	0x20002187
20001c50:	20002187 	.word	0x20002187
20001c54:	2000214d 	.word	0x2000214d
20001c58:	20002187 	.word	0x20002187
20001c5c:	20002187 	.word	0x20002187
20001c60:	20002187 	.word	0x20002187
20001c64:	20002187 	.word	0x20002187
20001c68:	20002187 	.word	0x20002187
20001c6c:	20002187 	.word	0x20002187
20001c70:	20002187 	.word	0x20002187
20001c74:	20002187 	.word	0x20002187
20001c78:	20002187 	.word	0x20002187
20001c7c:	20002187 	.word	0x20002187
20001c80:	20002187 	.word	0x20002187
20001c84:	20002187 	.word	0x20002187
20001c88:	20002187 	.word	0x20002187
20001c8c:	20002187 	.word	0x20002187
20001c90:	20002187 	.word	0x20002187
20001c94:	2000208d 	.word	0x2000208d
    {
        /************** MASTER TRANSMITTER / RECEIVER *******************/
      
        case ST_START: /* start has been xmt'd */
        case ST_RESTART: /* repeated start has been xmt'd */
            this_i2c->hw_reg_bit->CTRL_STA = 0u;
20001c98:	687b      	ldr	r3, [r7, #4]
20001c9a:	699b      	ldr	r3, [r3, #24]
20001c9c:	f04f 0200 	mov.w	r2, #0
20001ca0:	615a      	str	r2, [r3, #20]
            this_i2c->hw_reg->DATA = (uint8_t)this_i2c->target_addr;
20001ca2:	687b      	ldr	r3, [r7, #4]
20001ca4:	695b      	ldr	r3, [r3, #20]
20001ca6:	687a      	ldr	r2, [r7, #4]
20001ca8:	6852      	ldr	r2, [r2, #4]
20001caa:	b2d2      	uxtb	r2, r2
20001cac:	721a      	strb	r2, [r3, #8]
            this_i2c->hw_reg_bit->DATA_DIR = this_i2c->dir;
20001cae:	687b      	ldr	r3, [r7, #4]
20001cb0:	699b      	ldr	r3, [r3, #24]
20001cb2:	687a      	ldr	r2, [r7, #4]
20001cb4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20001cb6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
            if ( this_i2c->dir == WRITE_DIR )
20001cba:	687b      	ldr	r3, [r7, #4]
20001cbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001cbe:	2b00      	cmp	r3, #0
20001cc0:	d104      	bne.n	20001ccc <mss_i2c_isr+0x3c0>
            {
                this_i2c->master_tx_idx = 0u;
20001cc2:	687b      	ldr	r3, [r7, #4]
20001cc4:	f04f 0200 	mov.w	r2, #0
20001cc8:	629a      	str	r2, [r3, #40]	; 0x28
20001cca:	e007      	b.n	20001cdc <mss_i2c_isr+0x3d0>
            }
            else if ( this_i2c->dir == READ_DIR)
20001ccc:	687b      	ldr	r3, [r7, #4]
20001cce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20001cd0:	2b01      	cmp	r3, #1
20001cd2:	d103      	bne.n	20001cdc <mss_i2c_isr+0x3d0>
            {
                this_i2c->master_rx_idx = 0u;
20001cd4:	687b      	ldr	r3, [r7, #4]
20001cd6:	f04f 0200 	mov.w	r2, #0
20001cda:	639a      	str	r2, [r3, #56]	; 0x38
            /*
             * Clear the pending transaction. This condition will be true if the slave 
             * has acquired the bus to carry out pending master transaction which 
             * it had received during its slave transmission or reception mode. 
             */
            if(this_i2c->is_transaction_pending)
20001cdc:	687b      	ldr	r3, [r7, #4]
20001cde:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
20001ce2:	2b00      	cmp	r3, #0
20001ce4:	d004      	beq.n	20001cf0 <mss_i2c_isr+0x3e4>
            {
                this_i2c->is_transaction_pending = 0u;
20001ce6:	687b      	ldr	r3, [r7, #4]
20001ce8:	f04f 0200 	mov.w	r2, #0
20001cec:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71

            /*
             * Make sure to update proper transaction after master START
             * or RESTART
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
20001cf0:	687b      	ldr	r3, [r7, #4]
20001cf2:	7a1a      	ldrb	r2, [r3, #8]
20001cf4:	687b      	ldr	r3, [r7, #4]
20001cf6:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
20001cfa:	429a      	cmp	r2, r3
20001cfc:	f000 8267 	beq.w	200021ce <mss_i2c_isr+0x8c2>
            {
                this_i2c->transaction = this_i2c->pending_transaction;
20001d00:	687b      	ldr	r3, [r7, #4]
20001d02:	f893 2072 	ldrb.w	r2, [r3, #114]	; 0x72
20001d06:	687b      	ldr	r3, [r7, #4]
20001d08:	721a      	strb	r2, [r3, #8]
            }
            break;
20001d0a:	e269      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
        case ST_LOST_ARB:
            /* Set start bit.  Let's keep trying!  Don't give up! */
            this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
20001d0c:	687b      	ldr	r3, [r7, #4]
20001d0e:	699b      	ldr	r3, [r3, #24]
20001d10:	f04f 0201 	mov.w	r2, #1
20001d14:	615a      	str	r2, [r3, #20]
            break;
20001d16:	e263      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
        /******************* MASTER TRANSMITTER *************************/
        case ST_SLAW_NACK:
            /* SLA+W has been transmitted; not ACK has been received - let's stop. */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001d18:	687b      	ldr	r3, [r7, #4]
20001d1a:	699b      	ldr	r3, [r3, #24]
20001d1c:	f04f 0201 	mov.w	r2, #1
20001d20:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
20001d22:	687b      	ldr	r3, [r7, #4]
20001d24:	f04f 0202 	mov.w	r2, #2
20001d28:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            this_i2c->transaction = NO_TRANSACTION;
20001d2c:	687b      	ldr	r3, [r7, #4]
20001d2e:	f04f 0200 	mov.w	r2, #0
20001d32:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
20001d34:	6878      	ldr	r0, [r7, #4]
20001d36:	f7ff fdd5 	bl	200018e4 <enable_slave_if_required>
            break;
20001d3a:	e251      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
        case ST_SLAW_ACK:
        case ST_TX_DATA_ACK:
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
20001d3c:	687b      	ldr	r3, [r7, #4]
20001d3e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20001d40:	687b      	ldr	r3, [r7, #4]
20001d42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20001d44:	429a      	cmp	r2, r3
20001d46:	d20d      	bcs.n	20001d64 <mss_i2c_isr+0x458>
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
20001d48:	687b      	ldr	r3, [r7, #4]
20001d4a:	695a      	ldr	r2, [r3, #20]
20001d4c:	687b      	ldr	r3, [r7, #4]
20001d4e:	6a19      	ldr	r1, [r3, #32]
20001d50:	687b      	ldr	r3, [r7, #4]
20001d52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20001d54:	4419      	add	r1, r3
20001d56:	7809      	ldrb	r1, [r1, #0]
20001d58:	7211      	strb	r1, [r2, #8]
20001d5a:	f103 0201 	add.w	r2, r3, #1
20001d5e:	687b      	ldr	r3, [r7, #4]
20001d60:	629a      	str	r2, [r3, #40]	; 0x28
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
20001d62:	e23d      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            /* data byte has been xmt'd with ACK, time to send stop bit or repeated start. */
            if (this_i2c->master_tx_idx < this_i2c->master_tx_size)
            {    
                this_i2c->hw_reg->DATA = this_i2c->master_tx_buffer[this_i2c->master_tx_idx++];
            }
            else if ( this_i2c->transaction == MASTER_RANDOM_READ_TRANSACTION )
20001d64:	687b      	ldr	r3, [r7, #4]
20001d66:	7a1b      	ldrb	r3, [r3, #8]
20001d68:	2b03      	cmp	r3, #3
20001d6a:	d109      	bne.n	20001d80 <mss_i2c_isr+0x474>
            {
                /* We are finished sending the address offset part of a random read transaction.
                 * It is is time to send a restart in order to change direction. */
                 this_i2c->dir = READ_DIR;
20001d6c:	687b      	ldr	r3, [r7, #4]
20001d6e:	f04f 0201 	mov.w	r2, #1
20001d72:	62da      	str	r2, [r3, #44]	; 0x2c
                 this_i2c->hw_reg_bit->CTRL_STA = 0x01u;
20001d74:	687b      	ldr	r3, [r7, #4]
20001d76:	699b      	ldr	r3, [r3, #24]
20001d78:	f04f 0201 	mov.w	r2, #1
20001d7c:	615a      	str	r2, [r3, #20]
                    NVIC_DisableIRQ( this_i2c->irqn );
                    clear_irq = 0u;
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
            }
            break;
20001d7e:	e22f      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            {
                /*
                 * Set the transaction back to NO_TRANSACTION to allow user to do further
                 * transaction
                 */
                this_i2c->transaction = NO_TRANSACTION;
20001d80:	687b      	ldr	r3, [r7, #4]
20001d82:	f04f 0200 	mov.w	r2, #0
20001d86:	721a      	strb	r2, [r3, #8]
                hold_bus = this_i2c->options & MSS_I2C_HOLD_BUS;
20001d88:	687b      	ldr	r3, [r7, #4]
20001d8a:	7c1b      	ldrb	r3, [r3, #16]
20001d8c:	f003 0301 	and.w	r3, r3, #1
20001d90:	737b      	strb	r3, [r7, #13]

                /* Store the information of current I2C bus status in the bus_status*/
                this_i2c->bus_status  = hold_bus;
20001d92:	687b      	ldr	r3, [r7, #4]
20001d94:	7b7a      	ldrb	r2, [r7, #13]
20001d96:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
                if ( hold_bus == 0u )
20001d9a:	7b7b      	ldrb	r3, [r7, #13]
20001d9c:	2b00      	cmp	r3, #0
20001d9e:	d108      	bne.n	20001db2 <mss_i2c_isr+0x4a6>
                { 
                    this_i2c->hw_reg_bit->CTRL_STO = 0x01u; /*xmt stop condition */
20001da0:	687b      	ldr	r3, [r7, #4]
20001da2:	699b      	ldr	r3, [r3, #24]
20001da4:	f04f 0201 	mov.w	r2, #1
20001da8:	611a      	str	r2, [r3, #16]
                    enable_slave_if_required(this_i2c);
20001daa:	6878      	ldr	r0, [r7, #4]
20001dac:	f7ff fd9a 	bl	200018e4 <enable_slave_if_required>
20001db0:	e008      	b.n	20001dc4 <mss_i2c_isr+0x4b8>
                }
                else
                {
                    NVIC_DisableIRQ( this_i2c->irqn );
20001db2:	687b      	ldr	r3, [r7, #4]
20001db4:	7c5b      	ldrb	r3, [r3, #17]
20001db6:	b25b      	sxtb	r3, r3
20001db8:	4618      	mov	r0, r3
20001dba:	f7ff fb67 	bl	2000148c <NVIC_DisableIRQ>
                    clear_irq = 0u;
20001dbe:	f04f 0300 	mov.w	r3, #0
20001dc2:	73bb      	strb	r3, [r7, #14]
                }
                this_i2c->master_status = MSS_I2C_SUCCESS;
20001dc4:	687b      	ldr	r3, [r7, #4]
20001dc6:	f04f 0200 	mov.w	r2, #0
20001dca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }
            break;
20001dce:	e207      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            /* data byte SENT, ACK to be received
             * In fact, this means we've received a NACK (This may not be 
             * obvious, but if we've rec'd an ACK then we would be in state 
             * 0x28!) hence, let's send a stop bit
             */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001dd0:	687b      	ldr	r3, [r7, #4]
20001dd2:	699b      	ldr	r3, [r3, #24]
20001dd4:	f04f 0201 	mov.w	r2, #1
20001dd8:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
20001dda:	687b      	ldr	r3, [r7, #4]
20001ddc:	f04f 0202 	mov.w	r2, #2
20001de0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20001de4:	687b      	ldr	r3, [r7, #4]
20001de6:	f04f 0200 	mov.w	r2, #0
20001dea:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
20001dec:	6878      	ldr	r0, [r7, #4]
20001dee:	f7ff fd79 	bl	200018e4 <enable_slave_if_required>

            break;
20001df2:	e1f5      	b.n	200021e0 <mss_i2c_isr+0x8d4>
      /* STATUS codes 08H, 10H, 38H are all covered in MTX mode */
        case ST_SLAR_ACK: /* SLA+R tx'ed. */
            /* Let's make sure we ACK the first data byte received (set AA bit in CTRL) unless
             * the next byte is the last byte of the read transaction.
             */
            if(this_i2c->master_rx_size > 1u)
20001df4:	687b      	ldr	r3, [r7, #4]
20001df6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001df8:	2b01      	cmp	r3, #1
20001dfa:	d905      	bls.n	20001e08 <mss_i2c_isr+0x4fc>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001dfc:	687b      	ldr	r3, [r7, #4]
20001dfe:	699b      	ldr	r3, [r3, #24]
20001e00:	f04f 0201 	mov.w	r2, #1
20001e04:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
20001e06:	e1eb      	b.n	200021e0 <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->master_rx_size > 1u)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
            }
            else if(1u == this_i2c->master_rx_size)
20001e08:	687b      	ldr	r3, [r7, #4]
20001e0a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001e0c:	2b01      	cmp	r3, #1
20001e0e:	d105      	bne.n	20001e1c <mss_i2c_isr+0x510>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
20001e10:	687b      	ldr	r3, [r7, #4]
20001e12:	699b      	ldr	r3, [r3, #24]
20001e14:	f04f 0200 	mov.w	r2, #0
20001e18:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
                this_i2c->master_status = MSS_I2C_SUCCESS;
                this_i2c->transaction = NO_TRANSACTION;
            }
            break;
20001e1a:	e1e1      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            else /* this_i2c->master_rx_size == 0u */
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001e1c:	687b      	ldr	r3, [r7, #4]
20001e1e:	699b      	ldr	r3, [r3, #24]
20001e20:	f04f 0201 	mov.w	r2, #1
20001e24:	609a      	str	r2, [r3, #8]
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001e26:	687b      	ldr	r3, [r7, #4]
20001e28:	699b      	ldr	r3, [r3, #24]
20001e2a:	f04f 0201 	mov.w	r2, #1
20001e2e:	611a      	str	r2, [r3, #16]
                this_i2c->master_status = MSS_I2C_SUCCESS;
20001e30:	687b      	ldr	r3, [r7, #4]
20001e32:	f04f 0200 	mov.w	r2, #0
20001e36:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                this_i2c->transaction = NO_TRANSACTION;
20001e3a:	687b      	ldr	r3, [r7, #4]
20001e3c:	f04f 0200 	mov.w	r2, #0
20001e40:	721a      	strb	r2, [r3, #8]
            }
            break;
20001e42:	e1cd      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
        case ST_SLAR_NACK: /* SLA+R tx'ed; let's release the bus (send a stop condition) */
            this_i2c->hw_reg_bit->CTRL_STO = 0x01u;
20001e44:	687b      	ldr	r3, [r7, #4]
20001e46:	699b      	ldr	r3, [r3, #24]
20001e48:	f04f 0201 	mov.w	r2, #1
20001e4c:	611a      	str	r2, [r3, #16]
            this_i2c->master_status = MSS_I2C_FAILED;
20001e4e:	687b      	ldr	r3, [r7, #4]
20001e50:	f04f 0202 	mov.w	r2, #2
20001e54:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20001e58:	687b      	ldr	r3, [r7, #4]
20001e5a:	f04f 0200 	mov.w	r2, #0
20001e5e:	721a      	strb	r2, [r3, #8]
            enable_slave_if_required(this_i2c);
20001e60:	6878      	ldr	r0, [r7, #4]
20001e62:	f7ff fd3f 	bl	200018e4 <enable_slave_if_required>
            break;
20001e66:	e1bb      	b.n	200021e0 <mss_i2c_isr+0x8d4>
          
        case ST_RX_DATA_ACK: /* Data byte received, ACK returned */
            /* First, get the data */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx++] = this_i2c->hw_reg->DATA;
20001e68:	687b      	ldr	r3, [r7, #4]
20001e6a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20001e6c:	687b      	ldr	r3, [r7, #4]
20001e6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20001e70:	441a      	add	r2, r3
20001e72:	6879      	ldr	r1, [r7, #4]
20001e74:	6949      	ldr	r1, [r1, #20]
20001e76:	7a09      	ldrb	r1, [r1, #8]
20001e78:	b2c9      	uxtb	r1, r1
20001e7a:	7011      	strb	r1, [r2, #0]
20001e7c:	f103 0201 	add.w	r2, r3, #1
20001e80:	687b      	ldr	r3, [r7, #4]
20001e82:	639a      	str	r2, [r3, #56]	; 0x38

            if( this_i2c->master_rx_idx >= (this_i2c->master_rx_size - 1u))
20001e84:	687b      	ldr	r3, [r7, #4]
20001e86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
20001e88:	687b      	ldr	r3, [r7, #4]
20001e8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20001e8c:	f103 33ff 	add.w	r3, r3, #4294967295
20001e90:	429a      	cmp	r2, r3
20001e92:	f0c0 819e 	bcc.w	200021d2 <mss_i2c_isr+0x8c6>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
20001e96:	687b      	ldr	r3, [r7, #4]
20001e98:	699b      	ldr	r3, [r3, #24]
20001e9a:	f04f 0200 	mov.w	r2, #0
20001e9e:	609a      	str	r2, [r3, #8]
            }
            break;
20001ea0:	e19e      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
        case ST_RX_DATA_NACK: /* Data byte received, NACK returned */
            /* Get the data, then send a stop condition */
            this_i2c->master_rx_buffer[this_i2c->master_rx_idx] = this_i2c->hw_reg->DATA;
20001ea2:	687b      	ldr	r3, [r7, #4]
20001ea4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20001ea6:	687b      	ldr	r3, [r7, #4]
20001ea8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20001eaa:	4413      	add	r3, r2
20001eac:	687a      	ldr	r2, [r7, #4]
20001eae:	6952      	ldr	r2, [r2, #20]
20001eb0:	7a12      	ldrb	r2, [r2, #8]
20001eb2:	b2d2      	uxtb	r2, r2
20001eb4:	701a      	strb	r2, [r3, #0]
          
            hold_bus = this_i2c->options &  MSS_I2C_HOLD_BUS; 
20001eb6:	687b      	ldr	r3, [r7, #4]
20001eb8:	7c1b      	ldrb	r3, [r3, #16]
20001eba:	f003 0301 	and.w	r3, r3, #1
20001ebe:	737b      	strb	r3, [r7, #13]

            /* Store the information of current I2C bus status in the bus_status*/
            this_i2c->bus_status  = hold_bus;
20001ec0:	687b      	ldr	r3, [r7, #4]
20001ec2:	7b7a      	ldrb	r2, [r7, #13]
20001ec4:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
            if ( hold_bus == 0u )
20001ec8:	7b7b      	ldrb	r3, [r7, #13]
20001eca:	2b00      	cmp	r3, #0
20001ecc:	d108      	bne.n	20001ee0 <mss_i2c_isr+0x5d4>
            { 
                this_i2c->hw_reg_bit->CTRL_STO = 0x01u;  /*xmt stop condition */
20001ece:	687b      	ldr	r3, [r7, #4]
20001ed0:	699b      	ldr	r3, [r3, #24]
20001ed2:	f04f 0201 	mov.w	r2, #1
20001ed6:	611a      	str	r2, [r3, #16]

                /* Bus is released, now we can start listening to bus, if it is slave */
                   enable_slave_if_required(this_i2c);
20001ed8:	6878      	ldr	r0, [r7, #4]
20001eda:	f7ff fd03 	bl	200018e4 <enable_slave_if_required>
20001ede:	e008      	b.n	20001ef2 <mss_i2c_isr+0x5e6>
            }
            else
            {
                NVIC_DisableIRQ( this_i2c->irqn );
20001ee0:	687b      	ldr	r3, [r7, #4]
20001ee2:	7c5b      	ldrb	r3, [r3, #17]
20001ee4:	b25b      	sxtb	r3, r3
20001ee6:	4618      	mov	r0, r3
20001ee8:	f7ff fad0 	bl	2000148c <NVIC_DisableIRQ>
                clear_irq = 0u;
20001eec:	f04f 0300 	mov.w	r3, #0
20001ef0:	73bb      	strb	r3, [r7, #14]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20001ef2:	687b      	ldr	r3, [r7, #4]
20001ef4:	f04f 0200 	mov.w	r2, #0
20001ef8:	721a      	strb	r2, [r3, #8]
            this_i2c->master_status = MSS_I2C_SUCCESS;
20001efa:	687b      	ldr	r3, [r7, #4]
20001efc:	f04f 0200 	mov.w	r2, #0
20001f00:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            break;
20001f04:	e16c      	b.n	200021e0 <mss_i2c_isr+0x8d4>
        
        /******************** SLAVE RECEIVER **************************/
        case ST_GCA_NACK: /* NACK after, GCA addressing */
        case ST_SLA_NACK: /* Re-enable AA (assert ack) bit for future transmissions */
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20001f06:	687b      	ldr	r3, [r7, #4]
20001f08:	699b      	ldr	r3, [r3, #24]
20001f0a:	f04f 0201 	mov.w	r2, #1
20001f0e:	609a      	str	r2, [r3, #8]
            
            this_i2c->transaction = NO_TRANSACTION;
20001f10:	687b      	ldr	r3, [r7, #4]
20001f12:	f04f 0200 	mov.w	r2, #0
20001f16:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_status = MSS_I2C_SUCCESS;
20001f18:	687b      	ldr	r3, [r7, #4]
20001f1a:	f04f 0200 	mov.w	r2, #0
20001f1e:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
20001f22:	687b      	ldr	r3, [r7, #4]
20001f24:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
20001f28:	2b00      	cmp	r3, #0
20001f2a:	f000 8154 	beq.w	200021d6 <mss_i2c_isr+0x8ca>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
20001f2e:	687b      	ldr	r3, [r7, #4]
20001f30:	699b      	ldr	r3, [r3, #24]
20001f32:	f04f 0201 	mov.w	r2, #1
20001f36:	615a      	str	r2, [r3, #20]
            }
            break;
20001f38:	e152      	b.n	200021e0 <mss_i2c_isr+0x8d4>
        case ST_SLV_LA: /* Arbitr. lost (SLA rec'd) */
            /*
             *  We lost arbitration and either the GCE or our address was the
             *  one received so pend the master operation we were starting.
             */
            this_i2c->is_transaction_pending = 1u;
20001f3a:	687b      	ldr	r3, [r7, #4]
20001f3c:	f04f 0201 	mov.w	r2, #1
20001f40:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            /* Fall through to normal ST processing as we are now in slave mode */

        case ST_GCA: /* General call address received, ACK returned */
        case ST_SLAVE_SLAW: /* SLA+W received, ACK returned */

            this_i2c->transaction = WRITE_SLAVE_TRANSACTION;
20001f44:	687b      	ldr	r3, [r7, #4]
20001f46:	f04f 0204 	mov.w	r2, #4
20001f4a:	721a      	strb	r2, [r3, #8]
            this_i2c->slave_rx_idx = 0u;
20001f4c:	687b      	ldr	r3, [r7, #4]
20001f4e:	f04f 0200 	mov.w	r2, #0
20001f52:	659a      	str	r2, [r3, #88]	; 0x58
            this_i2c->random_read_addr = 0u;
20001f54:	687b      	ldr	r3, [r7, #4]
20001f56:	f04f 0200 	mov.w	r2, #0
20001f5a:	60da      	str	r2, [r3, #12]

             /* If Start Bit is set, clear it, but store that information since it is because of
              * pending transaction
              */
            if(this_i2c->hw_reg_bit->CTRL_STA)
20001f5c:	687b      	ldr	r3, [r7, #4]
20001f5e:	699b      	ldr	r3, [r3, #24]
20001f60:	695b      	ldr	r3, [r3, #20]
20001f62:	2b00      	cmp	r3, #0
20001f64:	d009      	beq.n	20001f7a <mss_i2c_isr+0x66e>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 0u ;
20001f66:	687b      	ldr	r3, [r7, #4]
20001f68:	699b      	ldr	r3, [r3, #24]
20001f6a:	f04f 0200 	mov.w	r2, #0
20001f6e:	615a      	str	r2, [r3, #20]
                this_i2c->is_transaction_pending = 1u;
20001f70:	687b      	ldr	r3, [r7, #4]
20001f72:	f04f 0201 	mov.w	r2, #1
20001f76:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
            }
            this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
20001f7a:	687b      	ldr	r3, [r7, #4]
20001f7c:	f04f 0201 	mov.w	r2, #1
20001f80:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
            /* Fall through to put address as first byte in payload buffer */
#else
            /* Only break from this case if the slave address must NOT be included at the
             * beginning of the received write data. */
            break;
20001f84:	e12c      	b.n	200021e0 <mss_i2c_isr+0x8d4>
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
20001f86:	687b      	ldr	r3, [r7, #4]
20001f88:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20001f8a:	2b00      	cmp	r3, #0
20001f8c:	d01c      	beq.n	20001fc8 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
20001f8e:	687b      	ldr	r3, [r7, #4]
20001f90:	6d9a      	ldr	r2, [r3, #88]	; 0x58
20001f92:	687b      	ldr	r3, [r7, #4]
20001f94:	6d5b      	ldr	r3, [r3, #84]	; 0x54
             * beginning of the received write data. */
            break;
#endif            
        case ST_GCA_ACK: /* DATA received; ACK sent after GCA */
        case ST_RDATA: /* DATA received; must clear DATA register */
            if((this_i2c->slave_rx_buffer != (uint8_t *)0)
20001f96:	429a      	cmp	r2, r3
20001f98:	d216      	bcs.n	20001fc8 <mss_i2c_isr+0x6bc>
               && (this_i2c->slave_rx_idx < this_i2c->slave_rx_size))
            {
                data = this_i2c->hw_reg->DATA;
20001f9a:	687b      	ldr	r3, [r7, #4]
20001f9c:	695b      	ldr	r3, [r3, #20]
20001f9e:	7a1b      	ldrb	r3, [r3, #8]
20001fa0:	733b      	strb	r3, [r7, #12]
                this_i2c->slave_rx_buffer[this_i2c->slave_rx_idx++] = data;
20001fa2:	687b      	ldr	r3, [r7, #4]
20001fa4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
20001fa6:	687b      	ldr	r3, [r7, #4]
20001fa8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20001faa:	441a      	add	r2, r3
20001fac:	7b39      	ldrb	r1, [r7, #12]
20001fae:	7011      	strb	r1, [r2, #0]
20001fb0:	f103 0201 	add.w	r2, r3, #1
20001fb4:	687b      	ldr	r3, [r7, #4]
20001fb6:	659a      	str	r2, [r3, #88]	; 0x58
                {
                    /* Ignore the slave address byte in the random read address
                       computation in the case where INCLUDE_SLA_IN_RX_PAYLOAD
                       is defined. */
#endif
                    this_i2c->random_read_addr = (this_i2c->random_read_addr << 8) + data;
20001fb8:	687b      	ldr	r3, [r7, #4]
20001fba:	68db      	ldr	r3, [r3, #12]
20001fbc:	ea4f 2203 	mov.w	r2, r3, lsl #8
20001fc0:	7b3b      	ldrb	r3, [r7, #12]
20001fc2:	441a      	add	r2, r3
20001fc4:	687b      	ldr	r3, [r7, #4]
20001fc6:	60da      	str	r2, [r3, #12]
#ifdef MSS_I2C_INCLUDE_SLA_IN_RX_PAYLOAD
                }
#endif
            }
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
20001fc8:	687b      	ldr	r3, [r7, #4]
20001fca:	6d9a      	ldr	r2, [r3, #88]	; 0x58
20001fcc:	687b      	ldr	r3, [r7, #4]
20001fce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20001fd0:	429a      	cmp	r2, r3
20001fd2:	f0c0 8102 	bcc.w	200021da <mss_i2c_isr+0x8ce>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
20001fd6:	687b      	ldr	r3, [r7, #4]
20001fd8:	699b      	ldr	r3, [r3, #24]
20001fda:	f04f 0200 	mov.w	r2, #0
20001fde:	609a      	str	r2, [r3, #8]
            }
            break;
20001fe0:	e0fe      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            /* STOP or repeated START occurred. */
            /* We cannot be sure if the transaction has actually completed as
             * this hardware state reports that either a STOP or repeated START
             * condition has occurred. We assume that this is a repeated START
             * if the transaction was a write from the master to this point.*/
            if ( this_i2c->transaction == WRITE_SLAVE_TRANSACTION )
20001fe2:	687b      	ldr	r3, [r7, #4]
20001fe4:	7a1b      	ldrb	r3, [r3, #8]
20001fe6:	2b04      	cmp	r3, #4
20001fe8:	d135      	bne.n	20002056 <mss_i2c_isr+0x74a>
            {
                if ( this_i2c->slave_rx_idx == this_i2c->slave_mem_offset_length )
20001fea:	687b      	ldr	r3, [r7, #4]
20001fec:	6d9a      	ldr	r2, [r3, #88]	; 0x58
20001fee:	687b      	ldr	r3, [r7, #4]
20001ff0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20001ff2:	429a      	cmp	r2, r3
20001ff4:	d103      	bne.n	20001ffe <mss_i2c_isr+0x6f2>
                {
                    this_i2c->slave_tx_idx = this_i2c->random_read_addr;
20001ff6:	687b      	ldr	r3, [r7, #4]
20001ff8:	68da      	ldr	r2, [r3, #12]
20001ffa:	687b      	ldr	r3, [r7, #4]
20001ffc:	64da      	str	r2, [r3, #76]	; 0x4c
                }
                {
                    /* Call the slave's write transaction handler if it exists. */
                    if ( this_i2c->slave_write_handler != 0u )
20001ffe:	687b      	ldr	r3, [r7, #4]
20002000:	6e5b      	ldr	r3, [r3, #100]	; 0x64
20002002:	2b00      	cmp	r3, #0
20002004:	d021      	beq.n	2000204a <mss_i2c_isr+0x73e>
                    {
                        mss_i2c_slave_handler_ret_t h_ret;
                        h_ret = this_i2c->slave_write_handler( this_i2c, this_i2c->slave_rx_buffer, (uint16_t)this_i2c->slave_rx_idx );
20002006:	687b      	ldr	r3, [r7, #4]
20002008:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2000200a:	687a      	ldr	r2, [r7, #4]
2000200c:	6d11      	ldr	r1, [r2, #80]	; 0x50
2000200e:	687a      	ldr	r2, [r7, #4]
20002010:	6d92      	ldr	r2, [r2, #88]	; 0x58
20002012:	b292      	uxth	r2, r2
20002014:	6878      	ldr	r0, [r7, #4]
20002016:	4798      	blx	r3
20002018:	4603      	mov	r3, r0
2000201a:	73fb      	strb	r3, [r7, #15]
                        if ( MSS_I2C_REENABLE_SLAVE_RX == h_ret )
2000201c:	7bfb      	ldrb	r3, [r7, #15]
2000201e:	2b00      	cmp	r3, #0
20002020:	d108      	bne.n	20002034 <mss_i2c_isr+0x728>
                        {
                            /* There is a small risk that the write handler could
                             * call MSS_I2C_disable_slave() but return
                             * MSS_I2C_REENABLE_SLAVE_RX in error so we only
                             * enable ACKs if still in slave mode. */
                             enable_slave_if_required(this_i2c);
20002022:	6878      	ldr	r0, [r7, #4]
20002024:	f7ff fc5e 	bl	200018e4 <enable_slave_if_required>
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20002028:	687b      	ldr	r3, [r7, #4]
2000202a:	699b      	ldr	r3, [r3, #24]
2000202c:	f04f 0201 	mov.w	r2, #1
20002030:	609a      	str	r2, [r3, #8]
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20002032:	e017      	b.n	20002064 <mss_i2c_isr+0x758>
                             enable_slave_if_required(this_i2c);
                             this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
                        }
                        else
                        {
                            this_i2c->hw_reg_bit->CTRL_AA = 0u;
20002034:	687b      	ldr	r3, [r7, #4]
20002036:	699b      	ldr	r3, [r3, #24]
20002038:	f04f 0200 	mov.w	r2, #0
2000203c:	609a      	str	r2, [r3, #8]
                            /* Clear slave mode flag as well otherwise in mixed
                             * master/slave applications, the AA bit will get set by
                             * subsequent master operations. */
                            this_i2c->is_slave_enabled = 0u;
2000203e:	687b      	ldr	r3, [r7, #4]
20002040:	f04f 0200 	mov.w	r2, #0
20002044:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                        }
                    }
                    else
                    {
                        /* Re-enable address acknowledge in case we were ready to nack the next received byte. */
                        this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20002048:	e00c      	b.n	20002064 <mss_i2c_isr+0x758>
2000204a:	687b      	ldr	r3, [r7, #4]
2000204c:	699b      	ldr	r3, [r3, #24]
2000204e:	f04f 0201 	mov.w	r2, #1
20002052:	609a      	str	r2, [r3, #8]
20002054:	e006      	b.n	20002064 <mss_i2c_isr+0x758>
            {
                /*
                 * Reset slave_tx_idx so that a subsequent read will result in the slave's
                 * transmit buffer being sent from the first byte.
                 */
                this_i2c->slave_tx_idx = 0u;
20002056:	687b      	ldr	r3, [r7, #4]
20002058:	f04f 0200 	mov.w	r2, #0
2000205c:	64da      	str	r2, [r3, #76]	; 0x4c
                /*
                 * See if we need to re-enable acknowledgement as some error conditions, such
                 * as a master prematurely ending a transfer, can see us get here with AA set
                 * to 0 which will disable slave operation if we are not careful.
                 */
                enable_slave_if_required(this_i2c);
2000205e:	6878      	ldr	r0, [r7, #4]
20002060:	f7ff fc40 	bl	200018e4 <enable_slave_if_required>
            }

            /* Mark any previous master write transaction as complete. */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
20002064:	687b      	ldr	r3, [r7, #4]
20002066:	f04f 0200 	mov.w	r2, #0
2000206a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
2000206e:	687b      	ldr	r3, [r7, #4]
20002070:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
20002074:	2b00      	cmp	r3, #0
20002076:	d004      	beq.n	20002082 <mss_i2c_isr+0x776>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
20002078:	687b      	ldr	r3, [r7, #4]
2000207a:	699b      	ldr	r3, [r3, #24]
2000207c:	f04f 0201 	mov.w	r2, #1
20002080:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20002082:	687b      	ldr	r3, [r7, #4]
20002084:	f04f 0200 	mov.w	r2, #0
20002088:	721a      	strb	r2, [r3, #8]
            break;
2000208a:	e0a9      	b.n	200021e0 <mss_i2c_isr+0x8d4>
        case ST_SLV_RST: /* SMBUS ONLY: timeout state. must clear interrupt */
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction.
             */
            this_i2c->transaction = NO_TRANSACTION;
2000208c:	687b      	ldr	r3, [r7, #4]
2000208e:	f04f 0200 	mov.w	r2, #0
20002092:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
20002094:	687b      	ldr	r3, [r7, #4]
20002096:	f04f 0200 	mov.w	r2, #0
2000209a:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear status to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
2000209c:	687b      	ldr	r3, [r7, #4]
2000209e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
200020a2:	b2db      	uxtb	r3, r3
200020a4:	2b01      	cmp	r3, #1
200020a6:	d104      	bne.n	200020b2 <mss_i2c_isr+0x7a6>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
200020a8:	687b      	ldr	r3, [r7, #4]
200020aa:	f04f 0202 	mov.w	r2, #2
200020ae:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            }

            enable_slave_if_required(this_i2c); /* Make sure AA is set correctly */
200020b2:	6878      	ldr	r0, [r7, #4]
200020b4:	f7ff fc16 	bl	200018e4 <enable_slave_if_required>

            break;
200020b8:	e092      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
        /****************** SLAVE TRANSMITTER **************************/
        case ST_SLAVE_SLAR_ACK: /* SLA+R received, ACK returned */
        case ST_SLARW_LA:   /* Arbitration lost, SLA+R received, ACK returned */
        case ST_RACK: /* Data tx'ed, ACK received */
            if ( status == ST_SLAVE_SLAR_ACK )
200020ba:	7afb      	ldrb	r3, [r7, #11]
200020bc:	b2db      	uxtb	r3, r3
200020be:	2ba8      	cmp	r3, #168	; 0xa8
200020c0:	d11b      	bne.n	200020fa <mss_i2c_isr+0x7ee>
            {
                this_i2c->transaction = READ_SLAVE_TRANSACTION;
200020c2:	687b      	ldr	r3, [r7, #4]
200020c4:	f04f 0205 	mov.w	r2, #5
200020c8:	721a      	strb	r2, [r3, #8]
                this_i2c->random_read_addr = 0u;
200020ca:	687b      	ldr	r3, [r7, #4]
200020cc:	f04f 0200 	mov.w	r2, #0
200020d0:	60da      	str	r2, [r3, #12]

                this_i2c->slave_status = MSS_I2C_IN_PROGRESS;
200020d2:	687b      	ldr	r3, [r7, #4]
200020d4:	f04f 0201 	mov.w	r2, #1
200020d8:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

                /* If Start Bit is set, clear it, but store that information since it is because of
                 * pending transaction
                 */
                if(this_i2c->hw_reg_bit->CTRL_STA)
200020dc:	687b      	ldr	r3, [r7, #4]
200020de:	699b      	ldr	r3, [r3, #24]
200020e0:	695b      	ldr	r3, [r3, #20]
200020e2:	2b00      	cmp	r3, #0
200020e4:	d009      	beq.n	200020fa <mss_i2c_isr+0x7ee>
                {
                    this_i2c->hw_reg_bit->CTRL_STA = 0u ;
200020e6:	687b      	ldr	r3, [r7, #4]
200020e8:	699b      	ldr	r3, [r3, #24]
200020ea:	f04f 0200 	mov.w	r2, #0
200020ee:	615a      	str	r2, [r3, #20]
                    this_i2c->is_transaction_pending = 1u;
200020f0:	687b      	ldr	r3, [r7, #4]
200020f2:	f04f 0201 	mov.w	r2, #1
200020f6:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                }
            }
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size)
200020fa:	687b      	ldr	r3, [r7, #4]
200020fc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
200020fe:	687b      	ldr	r3, [r7, #4]
20002100:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002102:	429a      	cmp	r2, r3
20002104:	d305      	bcc.n	20002112 <mss_i2c_isr+0x806>
            {
                /* Ensure 0xFF is returned to the master when the slave specifies
                 * an empty transmit buffer. */
                this_i2c->hw_reg->DATA = 0xFFu;
20002106:	687b      	ldr	r3, [r7, #4]
20002108:	695b      	ldr	r3, [r3, #20]
2000210a:	f04f 32ff 	mov.w	r2, #4294967295
2000210e:	721a      	strb	r2, [r3, #8]
20002110:	e00c      	b.n	2000212c <mss_i2c_isr+0x820>
            }
            else
            {
                /* Load the data the data byte to be sent to the master. */
                this_i2c->hw_reg->DATA = this_i2c->slave_tx_buffer[this_i2c->slave_tx_idx++];
20002112:	687b      	ldr	r3, [r7, #4]
20002114:	695a      	ldr	r2, [r3, #20]
20002116:	687b      	ldr	r3, [r7, #4]
20002118:	6c59      	ldr	r1, [r3, #68]	; 0x44
2000211a:	687b      	ldr	r3, [r7, #4]
2000211c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000211e:	4419      	add	r1, r3
20002120:	7809      	ldrb	r1, [r1, #0]
20002122:	7211      	strb	r1, [r2, #8]
20002124:	f103 0201 	add.w	r2, r3, #1
20002128:	687b      	ldr	r3, [r7, #4]
2000212a:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            /* Determine if this is the last data byte to send to the master. */
            if (this_i2c->slave_tx_idx >= this_i2c->slave_tx_size) /* last byte? */
2000212c:	687b      	ldr	r3, [r7, #4]
2000212e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
20002130:	687b      	ldr	r3, [r7, #4]
20002132:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002134:	429a      	cmp	r2, r3
20002136:	d352      	bcc.n	200021de <mss_i2c_isr+0x8d2>
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
20002138:	687b      	ldr	r3, [r7, #4]
2000213a:	699b      	ldr	r3, [r3, #24]
2000213c:	f04f 0200 	mov.w	r2, #0
20002140:	609a      	str	r2, [r3, #8]
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
20002142:	687b      	ldr	r3, [r7, #4]
20002144:	f04f 0200 	mov.w	r2, #0
20002148:	64da      	str	r2, [r3, #76]	; 0x4c
            }
            break;
2000214a:	e049      	b.n	200021e0 <mss_i2c_isr+0x8d4>
        case ST_SLAVE_RNACK:    /* Data byte has been transmitted; not-ACK has been received. */
        case ST_FINAL: /* Last Data byte tx'ed, ACK received */
            /* We assume that the transaction will be stopped by the master.
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte. */
            this_i2c->slave_tx_idx = 0u;
2000214c:	687b      	ldr	r3, [r7, #4]
2000214e:	f04f 0200 	mov.w	r2, #0
20002152:	64da      	str	r2, [r3, #76]	; 0x4c
            this_i2c->hw_reg_bit->CTRL_AA = 0x01u;
20002154:	687b      	ldr	r3, [r7, #4]
20002156:	699b      	ldr	r3, [r3, #24]
20002158:	f04f 0201 	mov.w	r2, #1
2000215c:	609a      	str	r2, [r3, #8]

            /*  Mark previous state as complete */
            this_i2c->slave_status = MSS_I2C_SUCCESS;
2000215e:	687b      	ldr	r3, [r7, #4]
20002160:	f04f 0200 	mov.w	r2, #0
20002164:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
20002168:	687b      	ldr	r3, [r7, #4]
2000216a:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
2000216e:	2b00      	cmp	r3, #0
20002170:	d004      	beq.n	2000217c <mss_i2c_isr+0x870>
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
20002172:	687b      	ldr	r3, [r7, #4]
20002174:	699b      	ldr	r3, [r3, #24]
20002176:	f04f 0201 	mov.w	r2, #1
2000217a:	615a      	str	r2, [r3, #20]

            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
2000217c:	687b      	ldr	r3, [r7, #4]
2000217e:	f04f 0200 	mov.w	r2, #0
20002182:	721a      	strb	r2, [r3, #8]
            break;
20002184:	e02c      	b.n	200021e0 <mss_i2c_isr+0x8d4>
        case ST_RESET_ACTIVATED:
        case ST_BUS_ERROR: /* Bus error during MST or selected slave modes */
        default:
            /* Some undefined state has encountered. Clear Start bit to make
             * sure, next good transaction happen */
            this_i2c->hw_reg_bit->CTRL_STA = 0x00u;
20002186:	687b      	ldr	r3, [r7, #4]
20002188:	699b      	ldr	r3, [r3, #24]
2000218a:	f04f 0200 	mov.w	r2, #0
2000218e:	615a      	str	r2, [r3, #20]
            /*
             * Set the transaction back to NO_TRANSACTION to allow user to do further
             * transaction
             */
            this_i2c->transaction = NO_TRANSACTION;
20002190:	687b      	ldr	r3, [r7, #4]
20002192:	f04f 0200 	mov.w	r2, #0
20002196:	721a      	strb	r2, [r3, #8]
            /*
             * Reset slave_tx_idx so that a subsequent read will result in the slave's
             * transmit buffer being sent from the first byte.
             */
            this_i2c->slave_tx_idx = 0u;
20002198:	687b      	ldr	r3, [r7, #4]
2000219a:	f04f 0200 	mov.w	r2, #0
2000219e:	64da      	str	r2, [r3, #76]	; 0x4c
            /*
             * Clear statuses to I2C_FAILED only if there was an operation in progress.
             */
            if(MSS_I2C_IN_PROGRESS == this_i2c->master_status)
200021a0:	687b      	ldr	r3, [r7, #4]
200021a2:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
200021a6:	b2db      	uxtb	r3, r3
200021a8:	2b01      	cmp	r3, #1
200021aa:	d104      	bne.n	200021b6 <mss_i2c_isr+0x8aa>
            {
                this_i2c->master_status = MSS_I2C_FAILED;
200021ac:	687b      	ldr	r3, [r7, #4]
200021ae:	f04f 0202 	mov.w	r2, #2
200021b2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            }

            if(MSS_I2C_IN_PROGRESS == this_i2c->slave_status)
200021b6:	687b      	ldr	r3, [r7, #4]
200021b8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
200021bc:	b2db      	uxtb	r3, r3
200021be:	2b01      	cmp	r3, #1
200021c0:	d10e      	bne.n	200021e0 <mss_i2c_isr+0x8d4>
            {
                this_i2c->slave_status = MSS_I2C_FAILED;
200021c2:	687b      	ldr	r3, [r7, #4]
200021c4:	f04f 0202 	mov.w	r2, #2
200021c8:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
200021cc:	e008      	b.n	200021e0 <mss_i2c_isr+0x8d4>
             */
            if(this_i2c->transaction != this_i2c->pending_transaction)
            {
                this_i2c->transaction = this_i2c->pending_transaction;
            }
            break;
200021ce:	bf00      	nop
200021d0:	e006      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            {
                /* If we're at the second last byte, let's set AA to 0 so
                 * we return a NACK at the last byte. */
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
            }
            break;
200021d2:	bf00      	nop
200021d4:	e004      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            /* Check if transaction was pending. If yes, set the START bit */
            if(this_i2c->is_transaction_pending)
            {
                this_i2c->hw_reg_bit->CTRL_STA = 1u ;
            }
            break;
200021d6:	bf00      	nop
200021d8:	e002      	b.n	200021e0 <mss_i2c_isr+0x8d4>
            
            if (this_i2c->slave_rx_idx >= this_i2c->slave_rx_size)
            {
                this_i2c->hw_reg_bit->CTRL_AA = 0u;   /* send a NACK when done (next reception) */
            }
            break;
200021da:	bf00      	nop
200021dc:	e000      	b.n	200021e0 <mss_i2c_isr+0x8d4>
                this_i2c->hw_reg_bit->CTRL_AA = 0u;
                /* Next read transaction will result in slave's transmit buffer
                 * being sent from the first byte. */
                this_i2c->slave_tx_idx = 0u;
            }
            break;
200021de:	bf00      	nop


            break;
    }
    
    if ( clear_irq )
200021e0:	7bbb      	ldrb	r3, [r7, #14]
200021e2:	2b00      	cmp	r3, #0
200021e4:	d004      	beq.n	200021f0 <mss_i2c_isr+0x8e4>
    {
        /* clear interrupt. */
        this_i2c->hw_reg_bit->CTRL_SI = 0u;
200021e6:	687b      	ldr	r3, [r7, #4]
200021e8:	699b      	ldr	r3, [r3, #24]
200021ea:	f04f 0200 	mov.w	r2, #0
200021ee:	60da      	str	r2, [r3, #12]
    }
    
    /* Read the status register to ensure the last I2C registers write took place
     * in a system built around a bus making use of posted writes. */
    status = this_i2c->hw_reg->STATUS;
200021f0:	687b      	ldr	r3, [r7, #4]
200021f2:	695b      	ldr	r3, [r3, #20]
200021f4:	791b      	ldrb	r3, [r3, #4]
200021f6:	72fb      	strb	r3, [r7, #11]
}
200021f8:	f107 0710 	add.w	r7, r7, #16
200021fc:	46bd      	mov	sp, r7
200021fe:	bd80      	pop	{r7, pc}

20002200 <disable_interrupts>:
}
/*------------------------------------------------------------------------------
 *
 */
static uint32_t disable_interrupts( void )
{
20002200:	b480      	push	{r7}
20002202:	b085      	sub	sp, #20
20002204:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
20002206:	f3ef 8310 	mrs	r3, PRIMASK
2000220a:	60bb      	str	r3, [r7, #8]
  return(result);
2000220c:	68bb      	ldr	r3, [r7, #8]
    uint32_t primask;
    primask = __get_PRIMASK();
2000220e:	607b      	str	r3, [r7, #4]
20002210:	f04f 0301 	mov.w	r3, #1
20002214:	60fb      	str	r3, [r7, #12]

    \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
20002216:	68fb      	ldr	r3, [r7, #12]
20002218:	f383 8810 	msr	PRIMASK, r3
    __set_PRIMASK(1u);
    return primask;
2000221c:	687b      	ldr	r3, [r7, #4]
}
2000221e:	4618      	mov	r0, r3
20002220:	f107 0714 	add.w	r7, r7, #20
20002224:	46bd      	mov	sp, r7
20002226:	bc80      	pop	{r7}
20002228:	4770      	bx	lr
2000222a:	bf00      	nop

2000222c <restore_interrupts>:

/*------------------------------------------------------------------------------
 *
 */
static void restore_interrupts( uint32_t primask )
{
2000222c:	b480      	push	{r7}
2000222e:	b085      	sub	sp, #20
20002230:	af00      	add	r7, sp, #0
20002232:	6078      	str	r0, [r7, #4]
20002234:	687b      	ldr	r3, [r7, #4]
20002236:	60fb      	str	r3, [r7, #12]
20002238:	68fb      	ldr	r3, [r7, #12]
2000223a:	f383 8810 	msr	PRIMASK, r3
    __set_PRIMASK( primask );
}
2000223e:	f107 0714 	add.w	r7, r7, #20
20002242:	46bd      	mov	sp, r7
20002244:	bc80      	pop	{r7}
20002246:	4770      	bx	lr

20002248 <I2C0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C0_IRQHandler( void )
#else
void I2C0_IRQHandler( void )
#endif
{
20002248:	4668      	mov	r0, sp
2000224a:	f020 0107 	bic.w	r1, r0, #7
2000224e:	468d      	mov	sp, r1
20002250:	b589      	push	{r0, r3, r7, lr}
20002252:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c0 );
20002254:	f242 70b4 	movw	r0, #10164	; 0x27b4
20002258:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000225c:	f7ff fb56 	bl	2000190c <mss_i2c_isr>
}
20002260:	46bd      	mov	sp, r7
20002262:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20002266:	4685      	mov	sp, r0
20002268:	4770      	bx	lr
2000226a:	bf00      	nop

2000226c <I2C1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void I2C1_IRQHandler( void )
#else
void I2C1_IRQHandler( void )
#endif
{
2000226c:	4668      	mov	r0, sp
2000226e:	f020 0107 	bic.w	r1, r0, #7
20002272:	468d      	mov	sp, r1
20002274:	b589      	push	{r0, r3, r7, lr}
20002276:	af00      	add	r7, sp, #0
    mss_i2c_isr( &g_mss_i2c1 );
20002278:	f642 0028 	movw	r0, #10280	; 0x2828
2000227c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002280:	f7ff fb44 	bl	2000190c <mss_i2c_isr>
}
20002284:	46bd      	mov	sp, r7
20002286:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
2000228a:	4685      	mov	sp, r0
2000228c:	4770      	bx	lr
2000228e:	bf00      	nop

20002290 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
20002290:	b580      	push	{r7, lr}
20002292:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
20002294:	f000 f936 	bl	20002504 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
20002298:	f64e 5300 	movw	r3, #60672	; 0xed00
2000229c:	f2ce 0300 	movt	r3, #57344	; 0xe000
200022a0:	f64e 5200 	movw	r2, #60672	; 0xed00
200022a4:	f2ce 0200 	movt	r2, #57344	; 0xe000
200022a8:	6952      	ldr	r2, [r2, #20]
200022aa:	f442 7200 	orr.w	r2, r2, #512	; 0x200
200022ae:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
200022b0:	f7fe f8c0 	bl	20000434 <mscc_post_hw_cfg_init>
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
    } while (0u == init_done);
#endif
}
200022b4:	bd80      	pop	{r7, pc}
200022b6:	bf00      	nop

200022b8 <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
200022b8:	b580      	push	{r7, lr}
200022ba:	b088      	sub	sp, #32
200022bc:	af00      	add	r7, sp, #0
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
200022be:	f248 0300 	movw	r3, #32768	; 0x8000
200022c2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200022c6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200022ca:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
200022ce:	60fb      	str	r3, [r7, #12]

    if(0u == controller_pll_init)
200022d0:	68fb      	ldr	r3, [r7, #12]
200022d2:	2b00      	cmp	r3, #0
200022d4:	f040 808b 	bne.w	200023ee <SystemCoreClockUpdate+0x136>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
200022d8:	f248 0300 	movw	r3, #32768	; 0x8000
200022dc:	f2c4 0303 	movt	r3, #16387	; 0x4003
200022e0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200022e4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
200022e8:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
200022ea:	697b      	ldr	r3, [r7, #20]
200022ec:	2b00      	cmp	r3, #0
200022ee:	d13f      	bne.n	20002370 <SystemCoreClockUpdate+0xb8>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
200022f0:	f242 63c8 	movw	r3, #9928	; 0x26c8
200022f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200022f8:	f24e 62c0 	movw	r2, #59072	; 0xe6c0
200022fc:	f2c0 72ce 	movt	r2, #1998	; 0x7ce
20002300:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
20002302:	f242 63cc 	movw	r3, #9932	; 0x26cc
20002306:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000230a:	f247 3260 	movw	r2, #29536	; 0x7360
2000230e:	f2c0 32e7 	movt	r2, #999	; 0x3e7
20002312:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
20002314:	f242 63d0 	movw	r3, #9936	; 0x26d0
20002318:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000231c:	f247 3260 	movw	r2, #29536	; 0x7360
20002320:	f2c0 32e7 	movt	r2, #999	; 0x3e7
20002324:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20002326:	f242 63d4 	movw	r3, #9940	; 0x26d4
2000232a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000232e:	f64b 12b0 	movw	r2, #47536	; 0xb9b0
20002332:	f2c0 12f3 	movt	r2, #499	; 0x1f3
20002336:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
20002338:	f242 63d8 	movw	r3, #9944	; 0x26d8
2000233c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002340:	f24e 62c0 	movw	r2, #59072	; 0xe6c0
20002344:	f2c0 72ce 	movt	r2, #1998	; 0x7ce
20002348:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
2000234a:	f242 63dc 	movw	r3, #9948	; 0x26dc
2000234e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002352:	f24e 62c0 	movw	r2, #59072	; 0xe6c0
20002356:	f2c0 72ce 	movt	r2, #1998	; 0x7ce
2000235a:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
2000235c:	f242 63e0 	movw	r3, #9952	; 0x26e0
20002360:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002364:	f24e 62c0 	movw	r2, #59072	; 0xe6c0
20002368:	f2c0 72ce 	movt	r2, #1998	; 0x7ce
2000236c:	601a      	str	r2, [r3, #0]
                break;

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
2000236e:	e045      	b.n	200023fc <SystemCoreClockUpdate+0x144>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
20002370:	f242 6394 	movw	r3, #9876	; 0x2694
20002374:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002378:	f107 0204 	add.w	r2, r7, #4
2000237c:	e893 0003 	ldmia.w	r3, {r0, r1}
20002380:	e882 0003 	stmia.w	r2, {r0, r1}

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
20002384:	f248 0300 	movw	r3, #32768	; 0x8000
20002388:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000238c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20002390:	ea4f 1393 	mov.w	r3, r3, lsr #6
20002394:	f003 0307 	and.w	r3, r3, #7
20002398:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
2000239a:	69bb      	ldr	r3, [r7, #24]
2000239c:	f107 0220 	add.w	r2, r7, #32
200023a0:	4413      	add	r3, r2
200023a2:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
200023a6:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
200023a8:	7ffb      	ldrb	r3, [r7, #31]
200023aa:	2b01      	cmp	r3, #1
200023ac:	d00b      	beq.n	200023c6 <SystemCoreClockUpdate+0x10e>
200023ae:	2b02      	cmp	r3, #2
200023b0:	d00e      	beq.n	200023d0 <SystemCoreClockUpdate+0x118>
200023b2:	2b00      	cmp	r3, #0
200023b4:	d114      	bne.n	200023e0 <SystemCoreClockUpdate+0x128>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
200023b6:	f000 f825 	bl	20002404 <get_rcosc_25_50mhz_frequency>
200023ba:	4603      	mov	r3, r0
200023bc:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
200023be:	6938      	ldr	r0, [r7, #16]
200023c0:	f000 f842 	bl	20002448 <set_clock_frequency_globals>
                break;
200023c4:	e01a      	b.n	200023fc <SystemCoreClockUpdate+0x144>

                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
200023c6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
200023ca:	f000 f83d 	bl	20002448 <set_clock_frequency_globals>
                break;
200023ce:	e015      	b.n	200023fc <SystemCoreClockUpdate+0x144>

                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
200023d0:	f244 2040 	movw	r0, #16960	; 0x4240
200023d4:	f2c0 000f 	movt	r0, #15
200023d8:	f000 f836 	bl	20002448 <set_clock_frequency_globals>
                break;
200023dc:	bf00      	nop
200023de:	e00d      	b.n	200023fc <SystemCoreClockUpdate+0x144>

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
200023e0:	f244 2040 	movw	r0, #16960	; 0x4240
200023e4:	f2c0 000f 	movt	r0, #15
200023e8:	f000 f82e 	bl	20002448 <set_clock_frequency_globals>
200023ec:	e006      	b.n	200023fc <SystemCoreClockUpdate+0x144>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
200023ee:	f000 f809 	bl	20002404 <get_rcosc_25_50mhz_frequency>
200023f2:	4603      	mov	r3, r0
200023f4:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
200023f6:	6938      	ldr	r0, [r7, #16]
200023f8:	f000 f826 	bl	20002448 <set_clock_frequency_globals>
    }
}
200023fc:	f107 0720 	add.w	r7, r7, #32
20002400:	46bd      	mov	sp, r7
20002402:	bd80      	pop	{r7, pc}

20002404 <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
20002404:	b480      	push	{r7}
20002406:	b083      	sub	sp, #12
20002408:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
2000240a:	f248 0300 	movw	r3, #32768	; 0x8000
2000240e:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002412:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
20002416:	f003 0304 	and.w	r3, r3, #4
2000241a:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
2000241c:	683b      	ldr	r3, [r7, #0]
2000241e:	2b00      	cmp	r3, #0
20002420:	d105      	bne.n	2000242e <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
20002422:	f647 0340 	movw	r3, #30784	; 0x7840
20002426:	f2c0 137d 	movt	r3, #381	; 0x17d
2000242a:	607b      	str	r3, [r7, #4]
2000242c:	e004      	b.n	20002438 <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
2000242e:	f24f 0380 	movw	r3, #61568	; 0xf080
20002432:	f2c0 23fa 	movt	r3, #762	; 0x2fa
20002436:	607b      	str	r3, [r7, #4]
    }

    return rcosc_frequency;
20002438:	687b      	ldr	r3, [r7, #4]
}
2000243a:	4618      	mov	r0, r3
2000243c:	f107 070c 	add.w	r7, r7, #12
20002440:	46bd      	mov	sp, r7
20002442:	bc80      	pop	{r7}
20002444:	4770      	bx	lr
20002446:	bf00      	nop

20002448 <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
20002448:	b480      	push	{r7}
2000244a:	b083      	sub	sp, #12
2000244c:	af00      	add	r7, sp, #0
2000244e:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
20002450:	f242 63c8 	movw	r3, #9928	; 0x26c8
20002454:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002458:	687a      	ldr	r2, [r7, #4]
2000245a:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
2000245c:	f242 63cc 	movw	r3, #9932	; 0x26cc
20002460:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002464:	687a      	ldr	r2, [r7, #4]
20002466:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
20002468:	f242 63d0 	movw	r3, #9936	; 0x26d0
2000246c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002470:	687a      	ldr	r2, [r7, #4]
20002472:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20002474:	f242 63d4 	movw	r3, #9940	; 0x26d4
20002478:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000247c:	f64b 12b0 	movw	r2, #47536	; 0xb9b0
20002480:	f2c0 12f3 	movt	r2, #499	; 0x1f3
20002484:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
20002486:	f242 63d8 	movw	r3, #9944	; 0x26d8
2000248a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000248e:	687a      	ldr	r2, [r7, #4]
20002490:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
20002492:	f242 63dc 	movw	r3, #9948	; 0x26dc
20002496:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000249a:	687a      	ldr	r2, [r7, #4]
2000249c:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
2000249e:	f242 63e0 	movw	r3, #9952	; 0x26e0
200024a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024a6:	687a      	ldr	r2, [r7, #4]
200024a8:	601a      	str	r2, [r3, #0]
}
200024aa:	f107 070c 	add.w	r7, r7, #12
200024ae:	46bd      	mov	sp, r7
200024b0:	bc80      	pop	{r7}
200024b2:	4770      	bx	lr

200024b4 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
200024b4:	b480      	push	{r7}
200024b6:	b083      	sub	sp, #12
200024b8:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
200024ba:	f248 0300 	movw	r3, #32768	; 0x8000
200024be:	f2c4 0303 	movt	r3, #16387	; 0x4003
200024c2:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
200024c6:	607b      	str	r3, [r7, #4]
    switch(device_version)
200024c8:	687a      	ldr	r2, [r7, #4]
200024ca:	f64f 0302 	movw	r3, #63490	; 0xf802
200024ce:	429a      	cmp	r2, r3
200024d0:	d006      	beq.n	200024e0 <get_silicon_revision+0x2c>
200024d2:	f64f 0302 	movw	r3, #63490	; 0xf802
200024d6:	f2c0 0301 	movt	r3, #1
200024da:	429a      	cmp	r2, r3
200024dc:	d004      	beq.n	200024e8 <get_silicon_revision+0x34>
200024de:	e007      	b.n	200024f0 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
200024e0:	f04f 0301 	mov.w	r3, #1
200024e4:	603b      	str	r3, [r7, #0]
            break;
200024e6:	e006      	b.n	200024f6 <get_silicon_revision+0x42>

        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
200024e8:	f04f 0302 	mov.w	r3, #2
200024ec:	603b      	str	r3, [r7, #0]
            break;
200024ee:	e002      	b.n	200024f6 <get_silicon_revision+0x42>

        default:
            silicon_revision = UNKNOWN_SILICON_REV;
200024f0:	f04f 0300 	mov.w	r3, #0
200024f4:	603b      	str	r3, [r7, #0]
            break;
    }

    return silicon_revision;
200024f6:	683b      	ldr	r3, [r7, #0]
}
200024f8:	4618      	mov	r0, r3
200024fa:	f107 070c 	add.w	r7, r7, #12
200024fe:	46bd      	mov	sp, r7
20002500:	bc80      	pop	{r7}
20002502:	4770      	bx	lr

20002504 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
20002504:	b580      	push	{r7, lr}
20002506:	b082      	sub	sp, #8
20002508:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;

    silicon_revision = get_silicon_revision();
2000250a:	f7ff ffd3 	bl	200024b4 <get_silicon_revision>
2000250e:	4603      	mov	r3, r0
20002510:	607b      	str	r3, [r7, #4]

    switch(silicon_revision)
20002512:	687b      	ldr	r3, [r7, #4]
20002514:	2b01      	cmp	r3, #1
20002516:	d101      	bne.n	2000251c <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
20002518:	f000 f804 	bl	20002524 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
2000251c:	f107 0708 	add.w	r7, r7, #8
20002520:	46bd      	mov	sp, r7
20002522:	bd80      	pop	{r7, pc}

20002524 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
20002524:	b480      	push	{r7}
20002526:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
20002528:	f248 0300 	movw	r3, #32768	; 0x8000
2000252c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002530:	f248 0200 	movw	r2, #32768	; 0x8000
20002534:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002538:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
2000253c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002540:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
20002544:	f248 0300 	movw	r3, #32768	; 0x8000
20002548:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000254c:	f248 0200 	movw	r2, #32768	; 0x8000
20002550:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002554:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20002558:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
2000255c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
20002560:	46bd      	mov	sp, r7
20002562:	bc80      	pop	{r7}
20002564:	4770      	bx	lr
20002566:	bf00      	nop

20002568 <__libc_init_array>:
20002568:	b570      	push	{r4, r5, r6, lr}
2000256a:	f242 66b4 	movw	r6, #9908	; 0x26b4
2000256e:	f242 65b4 	movw	r5, #9908	; 0x26b4
20002572:	f2c2 0600 	movt	r6, #8192	; 0x2000
20002576:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000257a:	1b76      	subs	r6, r6, r5
2000257c:	10b6      	asrs	r6, r6, #2
2000257e:	d006      	beq.n	2000258e <__libc_init_array+0x26>
20002580:	2400      	movs	r4, #0
20002582:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20002586:	3401      	adds	r4, #1
20002588:	4798      	blx	r3
2000258a:	42a6      	cmp	r6, r4
2000258c:	d8f9      	bhi.n	20002582 <__libc_init_array+0x1a>
2000258e:	f242 65b4 	movw	r5, #9908	; 0x26b4
20002592:	f242 66b8 	movw	r6, #9912	; 0x26b8
20002596:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000259a:	f2c2 0600 	movt	r6, #8192	; 0x2000
2000259e:	1b76      	subs	r6, r6, r5
200025a0:	f000 f87c 	bl	2000269c <_init>
200025a4:	10b6      	asrs	r6, r6, #2
200025a6:	d006      	beq.n	200025b6 <__libc_init_array+0x4e>
200025a8:	2400      	movs	r4, #0
200025aa:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
200025ae:	3401      	adds	r4, #1
200025b0:	4798      	blx	r3
200025b2:	42a6      	cmp	r6, r4
200025b4:	d8f9      	bhi.n	200025aa <__libc_init_array+0x42>
200025b6:	bd70      	pop	{r4, r5, r6, pc}

200025b8 <memset>:
200025b8:	2a03      	cmp	r2, #3
200025ba:	b2c9      	uxtb	r1, r1
200025bc:	b430      	push	{r4, r5}
200025be:	d807      	bhi.n	200025d0 <memset+0x18>
200025c0:	b122      	cbz	r2, 200025cc <memset+0x14>
200025c2:	2300      	movs	r3, #0
200025c4:	54c1      	strb	r1, [r0, r3]
200025c6:	3301      	adds	r3, #1
200025c8:	4293      	cmp	r3, r2
200025ca:	d1fb      	bne.n	200025c4 <memset+0xc>
200025cc:	bc30      	pop	{r4, r5}
200025ce:	4770      	bx	lr
200025d0:	eb00 0c02 	add.w	ip, r0, r2
200025d4:	4603      	mov	r3, r0
200025d6:	e001      	b.n	200025dc <memset+0x24>
200025d8:	f803 1c01 	strb.w	r1, [r3, #-1]
200025dc:	f003 0403 	and.w	r4, r3, #3
200025e0:	461a      	mov	r2, r3
200025e2:	3301      	adds	r3, #1
200025e4:	2c00      	cmp	r4, #0
200025e6:	d1f7      	bne.n	200025d8 <memset+0x20>
200025e8:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
200025ec:	ebc2 040c 	rsb	r4, r2, ip
200025f0:	fb03 f301 	mul.w	r3, r3, r1
200025f4:	e01f      	b.n	20002636 <memset+0x7e>
200025f6:	f842 3c40 	str.w	r3, [r2, #-64]
200025fa:	f842 3c3c 	str.w	r3, [r2, #-60]
200025fe:	f842 3c38 	str.w	r3, [r2, #-56]
20002602:	f842 3c34 	str.w	r3, [r2, #-52]
20002606:	f842 3c30 	str.w	r3, [r2, #-48]
2000260a:	f842 3c2c 	str.w	r3, [r2, #-44]
2000260e:	f842 3c28 	str.w	r3, [r2, #-40]
20002612:	f842 3c24 	str.w	r3, [r2, #-36]
20002616:	f842 3c20 	str.w	r3, [r2, #-32]
2000261a:	f842 3c1c 	str.w	r3, [r2, #-28]
2000261e:	f842 3c18 	str.w	r3, [r2, #-24]
20002622:	f842 3c14 	str.w	r3, [r2, #-20]
20002626:	f842 3c10 	str.w	r3, [r2, #-16]
2000262a:	f842 3c0c 	str.w	r3, [r2, #-12]
2000262e:	f842 3c08 	str.w	r3, [r2, #-8]
20002632:	f842 3c04 	str.w	r3, [r2, #-4]
20002636:	4615      	mov	r5, r2
20002638:	3240      	adds	r2, #64	; 0x40
2000263a:	2c3f      	cmp	r4, #63	; 0x3f
2000263c:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
20002640:	dcd9      	bgt.n	200025f6 <memset+0x3e>
20002642:	462a      	mov	r2, r5
20002644:	ebc5 040c 	rsb	r4, r5, ip
20002648:	e007      	b.n	2000265a <memset+0xa2>
2000264a:	f842 3c10 	str.w	r3, [r2, #-16]
2000264e:	f842 3c0c 	str.w	r3, [r2, #-12]
20002652:	f842 3c08 	str.w	r3, [r2, #-8]
20002656:	f842 3c04 	str.w	r3, [r2, #-4]
2000265a:	4615      	mov	r5, r2
2000265c:	3210      	adds	r2, #16
2000265e:	2c0f      	cmp	r4, #15
20002660:	f1a4 0410 	sub.w	r4, r4, #16
20002664:	dcf1      	bgt.n	2000264a <memset+0x92>
20002666:	462a      	mov	r2, r5
20002668:	ebc5 050c 	rsb	r5, r5, ip
2000266c:	e001      	b.n	20002672 <memset+0xba>
2000266e:	f842 3c04 	str.w	r3, [r2, #-4]
20002672:	4614      	mov	r4, r2
20002674:	3204      	adds	r2, #4
20002676:	2d03      	cmp	r5, #3
20002678:	f1a5 0504 	sub.w	r5, r5, #4
2000267c:	dcf7      	bgt.n	2000266e <memset+0xb6>
2000267e:	e001      	b.n	20002684 <memset+0xcc>
20002680:	f804 1b01 	strb.w	r1, [r4], #1
20002684:	4564      	cmp	r4, ip
20002686:	d3fb      	bcc.n	20002680 <memset+0xc8>
20002688:	e7a0      	b.n	200025cc <memset+0x14>
2000268a:	bf00      	nop

2000268c <gp_my_uart>:
2000268c:	2774 2000 0046 0000                         t'. F...

20002694 <C.18.3527>:
20002694:	0100 0100 0202 0303                         ........

2000269c <_init>:
2000269c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000269e:	bf00      	nop
200026a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
200026a2:	bc08      	pop	{r3}
200026a4:	469e      	mov	lr, r3
200026a6:	4770      	bx	lr

200026a8 <_fini>:
200026a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
200026aa:	bf00      	nop
200026ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
200026ae:	bc08      	pop	{r3}
200026b0:	469e      	mov	lr, r3
200026b2:	4770      	bx	lr

200026b4 <__frame_dummy_init_array_entry>:
200026b4:	04d5 2000                                   ... 

200026b8 <__do_global_dtors_aux_fini_array_entry>:
200026b8:	04c1 2000 0000 0000                         ... ....
